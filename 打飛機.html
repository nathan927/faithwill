```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airplane Bullet Dodging Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            touch-action: none;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #000;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #gameInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 30px;
        }

        #timer {
            color: white;
            font-size: 24px;
            font-weight: bold;
        }

        #lives {
            display: flex;
            gap: 10px;
        }

        .lifeIcon {
            width: 25px;
            height: 25px;
            background-color: #ff4040;
            border-radius: 50%;
            position: relative;
        }

        .lifeIcon::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            width: 15px;
            height: 15px;
            background-color: #ff8080;
            border-radius: 50%;
        }

        #score {
            color: white;
            font-size: 24px;
            font-weight: bold;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            pointer-events: auto;
        }

        #startTitle {
            color: white;
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 100px;
            text-shadow: 0 0 20px #ff4040;
            text-align: center;
        }

        #pressStart {
            color: white;
            font-size: 36px;
            font-weight: bold;
            animation: flash 1.5s infinite;
            cursor: pointer;
        }

        @keyframes flash {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        #difficultySelect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            gap: 20px;
            pointer-events: auto;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 64, 64, 0.5);
            border: 2px solid #ff4040;
        }

        #colorSelect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            gap: 20px;
            pointer-events: auto;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 64, 64, 0.5);
            border: 2px solid #ff4040;
            min-width: 300px;
        }

        #colorSelectTitle {
            color: white;
            font-size: 24px;
            text-align: center;
            margin-bottom: 20px;
        }

        .colorOptions {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .colorOption {
            width: 80px;
            height: 80px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid transparent;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
        }

        .colorOption:hover {
            transform: scale(1.1);
            border-color: white;
            box-shadow: 0 0 15px white;
        }

        .planePreview {
            width: 70px;
            height: 70px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .difficultyBtn {
            padding: 15px 30px;
            font-size: 20px;
            background-color: #802020;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .difficultyBtn:hover {
            background-color: #ff4040;
            transform: scale(1.05);
        }

        #countdownOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 100px;
            font-weight: bold;
            color: white;
            display: none;
        }

        #resultOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 60px;
            font-weight: bold;
            color: white;
            display: none;
        }

        .resultBtns {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }

        .gameButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #802020;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
        }

        .gameButton:hover {
            background-color: #ff4040;
            transform: scale(1.05);
        }

        #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            color: gold;
            font-size: 60px;
            font-weight: bold;
            display: none;
            z-index: 20;
            pointer-events: auto;
            overflow: hidden;
        }

        #victoryTitle {
            font-size: 80px;
            color: gold;
            text-shadow: 0 0 20px #ff8800;
            animation: victoryPulse 2s infinite;
            margin-bottom: 20px;
            text-align: center;
        }

        @keyframes victoryPulse {
            0% { transform: scale(1); text-shadow: 0 0 20px #ff8800; }
            50% { transform: scale(1.05); text-shadow: 0 0 30px #ff8800, 0 0 50px #ff4400; }
            100% { transform: scale(1); text-shadow: 0 0 20px #ff8800; }
        }

        #trophyIcon {
            font-size: 120px;
            color: gold;
            margin: 20px 0;
            animation: trophySpin 10s infinite linear;
            text-shadow: 0 0 30px #ffcc00;
        }

        @keyframes trophySpin {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(360deg); }
        }

        #victoryMessage {
            font-size: 36px;
            color: white;
            margin: 15px 0;
            text-align: center;
            max-width: 80%;
        }

        #finalScore {
            font-size: 48px;
            color: #ffcc00;
            margin: 15px 0;
            text-shadow: 0 0 15px #ff8800;
        }

        .firework {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            pointer-events: none;
        }

        .medal {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, #ffd700 0%, #ffa500 70%, #ff8c00 100%);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 15px auto;
            position: relative;
            box-shadow: 0 0 30px #ffcc00;
            animation: medalSpin 5s infinite ease-in-out;
        }

        @keyframes medalSpin {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
            100% { transform: rotateY(360deg); }
        }

        .medal::before {
            content: '★';
            font-size: 60px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        .victoryStats {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid gold;
            max-width: 80%;
            margin: 15px 0;
        }

        .statItem {
            font-size: 24px;
            color: white;
            margin: 10px 0;
        }

        .confetti {
            position: absolute;
            width: 15px;
            height: 15px;
            pointer-events: none;
        }

        #invincibleEffect {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        .powerup {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        #levelDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
        }

        #pointsPopup {
            position: absolute;
            color: gold;
            font-weight: bold;
            pointer-events: none;
            animation: fadeUp 1s forwards;
        }

        @keyframes fadeUp {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-50px); }
        }

        .bulletAlert {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: rgba(255, 0, 0, 0.7);
            border-radius: 50%;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        #helpButton {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: rgba(80, 80, 80, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 100;
        }

        #helpButton:hover {
            background-color: rgba(120, 120, 120, 0.9);
            transform: scale(1.1);
        }

        #instructionsModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #ff4040;
            width: 80%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            pointer-events: auto;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.3);
        }

        #instructionsTitle {
            color: white;
            font-size: 36px;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff4040;
        }

        .instructionSection {
            margin-bottom: 25px;
        }

        .instructionHeading {
            color: #ff4040;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .instructionText {
            color: white;
            font-size: 18px;
            line-height: 1.6;
        }

        .powerupDescription {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        .powerupIcon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #closeInstructions {
            background-color: #802020;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
            transition: all 0.2s;
        }

        #closeInstructions:hover {
            background-color: #ff4040;
            transform: scale(1.05);
        }

        #demoModeText {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
            pointer-events: none;
            animation: demoPulse 2s infinite ease-in-out;
            display: none;
            z-index: 100;
        }

        @keyframes demoPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        @media (max-width: 768px) {
            #startTitle {
                font-size: 32px;
            }

            .difficultyBtn {
                font-size: 16px;
                padding: 12px 24px;
            }

            #gameInfo {
                gap: 15px;
            }

            #timer, #score {
                font-size: 20px;
            }

            .lifeIcon {
                width: 20px;
                height: 20px;
            }

            .lifeIcon::before {
                top: 4px;
                left: 4px;
                width: 12px;
                height: 12px;
            }

            #instructionsTitle {
                font-size: 28px;
            }

            .instructionHeading {
                font-size: 20px;
            }

            .instructionText {
                font-size: 16px;
            }

            #victoryTitle {
                font-size: 50px;
            }

            #trophyIcon {
                font-size: 80px;
            }

            #finalScore {
                font-size: 36px;
            }

            .medal {
                width: 100px;
                height: 100px;
            }

            .medal::before {
                font-size: 50px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="gameInfo">
                <div id="timer">30.0</div>
                <div id="lives">
                    <div class="lifeIcon"></div>
                    <div class="lifeIcon"></div>
                </div>
                <div id="score">SCORE: 0</div>
            </div>

            <div id="levelDisplay"></div>

            <div id="startScreen">
                <div id="startTitle">飛機避子彈遊戲 - BULLET STORM</div>
                <div id="pressStart">PRESS START</div>
                <div id="helpButton">?</div>
            </div>

            <div id="colorSelect">
                <div id="colorSelectTitle">選擇飛機顏色</div>
                <div class="colorOptions">
                    <div class="colorOption" data-color="blue" style="background-color: rgba(64, 128, 255, 0.3);">
                        <div class="planePreview" id="bluePlane"></div>
                    </div>
                    <div class="colorOption" data-color="red" style="background-color: rgba(255, 64, 64, 0.3);">
                        <div class="planePreview" id="redPlane"></div>
                    </div>
                    <div class="colorOption" data-color="purple" style="background-color: rgba(128, 64, 255, 0.3);">
                        <div class="planePreview" id="purplePlane"></div>
                    </div>
                    <div class="colorOption" data-color="green" style="background-color: rgba(64, 255, 64, 0.3);">
                        <div class="planePreview" id="greenPlane"></div>
                    </div>
                    <div class="colorOption" data-color="yellow" style="background-color: rgba(255, 255, 64, 0.3);">
                        <div class="planePreview" id="yellowPlane"></div>
                    </div>
                    <div class="colorOption" data-color="cyan" style="background-color: rgba(64, 255, 255, 0.3);">
                        <div class="planePreview" id="cyanPlane"></div>
                    </div>
                </div>
            </div>

            <div id="difficultySelect">
                <div class="difficultyBtn" data-difficulty="easy">簡單: 子彈速度慢，數量少</div>
                <div class="difficultyBtn" data-difficulty="medium">中等: 子彈速度和數量適中</div>
                <div class="difficultyBtn" data-difficulty="hard">困難: 子彈速度快，數量多</div>
                <div class="difficultyBtn" data-difficulty="insane">瘋狂: 子彈速度非常快，數量非常多</div>
                <div class="difficultyBtn" data-difficulty="ultimate">終極: 極限挑戰，各種彈幕襲來</div>
                <div class="difficultyBtn aiDemoBtn" data-difficulty="aiDemo" style="background-color: #4080C0; margin-top: 20px;">AI示範模式 (終極難度)</div>
            </div>

            <div id="countdownOverlay">3</div>

            <div id="resultOverlay">
                <div id="resultText">過關！</div>
                <div class="resultBtns">
                    <div id="resultBtn" class="gameButton">挑戰下一關 !</div>
                    <div id="restartFromFailBtn" class="gameButton">重新開始</div>
                </div>
            </div>

            <div id="victoryScreen">
                <div id="victoryTitle">恭喜通關全部難度!</div>
                <div class="medal"></div>
                <div id="victoryMessage">你成功征服了所有難度，成為了頂尖的飛行員！</div>
                <div id="finalScore">最終得分: 0</div>
                <div class="victoryStats">
                    <div class="statItem">完成難度: <span id="completedLevelsStats">5/5</span></div>
                    <div class="statItem">生存時間: <span id="survivalTimeStats">0</span> 秒</div>
                    <div class="statItem">躲避子彈: <span id="bulletsDodgedStats">0</span></div>
                </div>
                <div id="restartBtn" class="gameButton">重新挑戰</div>
            </div>

            <div id="instructionsModal">
                <div id="instructionsTitle">遊戲說明</div>

                <div class="instructionSection">
                    <div class="instructionHeading">遊戲目標</div>
                    <div class="instructionText">
                        在每個關卡中生存 30 秒，躲避不同類型的子彈。通過所有難度級別以贏得遊戲！
                    </div>
                </div>

                <div class="instructionSection">
                    <div class="instructionHeading">生命系統</div>
                    <div class="instructionText">
                        你有 2 條生命。每次被子彈擊中會失去一條生命。當你失去所有生命時，遊戲將結束，你需要重新嘗試當前難度。
                    </div>
                </div>

                <div class="instructionSection">
                    <div class="instructionHeading">時間規則</div>
                    <div class="instructionText">
                        每個關卡持續 30 秒。屏幕左上角的計時器會顯示剩餘時間。堅持到計時器歸零以通過當前難度！
                    </div>
                </div>

                <div class="instructionSection">
                    <div class="instructionHeading">獎勵道具</div>
                    <div class="instructionText">
                        遊戲中會隨機出現道具。迅速移動到它們的位置以獲得特殊能力：
                    </div>

                    <div class="powerupDescription">
                        <div class="powerupIcon" style="background-color: #4080ff;"></div>
                        <div>無敵護盾：短時間內無敵，可以免疫子彈傷害</div>
                    </div>

                    <div class="powerupDescription">
                        <div class="powerupIcon" style="background-color: #ff4040;"></div>
                        <div>額外生命：增加一條生命（最多 3 條）</div>
                    </div>

                    <div class="powerupDescription">
                        <div class="powerupIcon" style="background-color: #40ff40;"></div>
                        <div>時間減速：減慢所有子彈的速度</div>
                    </div>

                    <div class="powerupDescription">
                        <div class="powerupIcon" style="background-color: #ffff40;"></div>
                        <div>清場：移除所有子彈並獲得額外分數</div>
                    </div>
                </div>

                <div class="instructionSection">
                    <div class="instructionHeading">控制方式</div>
                    <div class="instructionText">
                        使用鼠標或觸摸屏移動飛機。保持移動以避開子彈！
                    </div>
                </div>

                <button id="closeInstructions">關閉</button>
            </div>

            <div id="demoModeText">DEMO MODE</div>

            <div id="invincibleEffect"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const pressStart = document.getElementById('pressStart');
        const difficultySelect = document.getElementById('difficultySelect');
        const colorSelect = document.getElementById('colorSelect');
        const timerDisplay = document.getElementById('timer');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('levelDisplay');
        const countdownOverlay = document.getElementById('countdownOverlay');
        const resultOverlay = document.getElementById('resultOverlay');
        const resultText = document.getElementById('resultText');
        const resultBtn = document.getElementById('resultBtn');
        const restartFromFailBtn = document.getElementById('restartFromFailBtn');
        const victoryScreen = document.getElementById('victoryScreen');
        const finalScore = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const invincibleEffect = document.getElementById('invincibleEffect');
        const livesContainer = document.getElementById('lives');
        const helpButton = document.getElementById('helpButton');
        const instructionsModal = document.getElementById('instructionsModal');
        const closeInstructions = document.getElementById('closeInstructions');
        const completedLevelsStats = document.getElementById('completedLevelsStats');
        const survivalTimeStats = document.getElementById('survivalTimeStats');
        const bulletsDodgedStats = document.getElementById('bulletsDodgedStats');

        // Game state
        let gameActive = false;
        let currentLevel = 0;
        let completedLevels = 0;
        let gameTime = 30;
        let timeRemaining = gameTime;
        let lastTime = 0;
        let playerX = 0;
        let playerY = 0;
        let bullets = [];
        let particles = [];
        let stars = [];
        let powerups = [];
        let bulletAlerts = [];
        let score = 0;
        let lives = 2;
        let playerColor = 'blue'; // Default color
        let totalSurvivalTime = 0;
        let bulletsDodged = 0;
        let confettiColors = ['#ff4040', '#4080ff', '#40ff40', '#ffff40', '#ff40ff', '#40ffff', '#ffffff'];
        let lastFrameTime = 0;
        let isAiDemo = false; // Flag for AI demonstration mode
        let aiDemoEnded = false;
        let demoModeTextElement = null;
        let playerColorSchemes = {
            blue: {
                primary: '#4080ff',
                secondary: '#80c0ff',
                accent: '#6090ff',
                cockpit: '#d0e8ff',
                pilot: '#333333',
                helmet: '#2060d0'
            },
            red: {
                primary: '#ff4040',
                secondary: '#ff8080',
                accent: '#ff6060',
                cockpit: '#ffe0e0',
                pilot: '#333333',
                helmet: '#d02020'
            },
            purple: {
                primary: '#8040ff',
                secondary: '#c080ff',
                accent: '#a060ff',
                cockpit: '#e8d0ff',
                pilot: '#333333',
                helmet: '#6020d0'
            },
            green: {
                primary: '#40ff40',
                secondary: '#80ff80',
                accent: '#60ff60',
                cockpit: '#e0ffe0',
                pilot: '#333333',
                helmet: '#20d020'
            },
            yellow: {
                primary: '#ffff40',
                secondary: '#ffff80',
                accent: '#ffff60',
                cockpit: '#fffff0',
                pilot: '#333333',
                helmet: '#d0d020'
            },
            cyan: {
                primary: '#40ffff',
                secondary: '#80ffff',
                accent: '#60ffff',
                cockpit: '#e0ffff',
                pilot: '#333333',
                helmet: '#20d0d0'
            }
        };
        let difficultySettings = {
            easy: {
                bulletSpeed: 150,
                bulletRate: 1200,
                bulletPatterns: ['simple', 'spread', 'bouncer'],
                powerupRate: 8000,
                name: "簡單"
            },
            medium: {
                bulletSpeed: 220,
                bulletRate: 800,
                bulletPatterns: ['simple', 'spread', 'wave', 'bouncer', 'zigzag'],
                powerupRate: 10000,
                name: "中等"
            },
            hard: {
                bulletSpeed: 280,
                bulletRate: 600,
                bulletPatterns: ['simple', 'spread', 'wave', 'circle', 'zigzag', 'homing'],
                powerupRate: 12000,
                name: "困難"
            },
            insane: {
                bulletSpeed: 350,
                bulletRate: 400,
                bulletPatterns: ['simple', 'spread', 'wave', 'circle', 'spiral', 'homing', 'zigzag'],
                powerupRate: 15000,
                name: "瘋狂"
            },
            ultimate: {
                bulletSpeed: 450,
                bulletRate: 300,
                bulletPatterns: ['simple', 'spread', 'wave', 'circle', 'spiral', 'homing', 'zigzag'],
                bossMode: true,
                powerupRate: 20000,
                name: "終極"
            }
        };
        let currentDifficulty = null;
        let lastBulletTime = 0;
        let lastPowerupTime = 0;
        let playerSize = 30;
        let bulletSize = 8;
        let playerHit = false;
        let playerInvincible = false;
        let invincibleTime = 0;
        let invincibleDuration = 2; // seconds
        let difficultyOrder = ['easy', 'medium', 'hard', 'insane', 'ultimate'];
        let bulletPatterns = {
            simple: function(x, y, angle, speed) {
                return [{
                    x: x,
                    y: y,
                    angle: angle,
                    speed: speed,
                    size: bulletSize,
                    color: '#ff3030',
                    type: 'simple'
                }];
            },
            spread: function(x, y, angle, speed) {
                const bullets = [];
                const count = 3;
                const spread = Math.PI / 8;

                for (let i = 0; i < count; i++) {
                    const bulletAngle = angle - spread + (spread * 2 / (count - 1)) * i;
                    bullets.push({
                        x: x,
                        y: y,
                        angle: bulletAngle,
                        speed: speed * 0.9,
                        size: bulletSize * 0.8,
                        color: '#ffff30',
                        type: 'spread'
                    });
                }

                return bullets;
            },
            wave: function(x, y, angle, speed) {
                return [{
                    x: x,
                    y: y,
                    angle: angle,
                    speed: speed * 0.8,
                    size: bulletSize * 0.9,
                    color: '#30ff30',
                    waveAmplitude: 50,
                    waveLength: 200,
                    waveOffset: 0,
                    type: 'wave'
                }];
            },
            circle: function(x, y, angle, speed) {
                const bullets = [];
                const count = 8;

                for (let i = 0; i < count; i++) {
                    const bulletAngle = (Math.PI * 2 / count) * i;
                    bullets.push({
                        x: x,
                        y: y,
                        angle: bulletAngle,
                        speed: speed * 0.7,
                        size: bulletSize * 0.7,
                        color: '#3030ff',
                        type: 'circle'
                    });
                }

                return bullets;
            },
            spiral: function(x, y, angle, speed) {
                const bullets = [];
                const count = 5;

                for (let i = 0; i < count; i++) {
                    const bulletAngle = angle + (Math.PI * 2 / count) * i;
                    bullets.push({
                        x: x,
                        y: y,
                        angle: bulletAngle,
                        speed: speed * 0.6,
                        size: bulletSize * 0.65,
                        rotationSpeed: 2, // radians per second
                        originX: x,
                        originY: y,
                        radius: 0,
                        maxRadius: 100,
                        radiusGrowthRate: 100, // pixels per second
                        color: '#ff30ff',
                        type: 'spiral'
                    });
                }

                return bullets;
            },
            homing: function(x, y, angle, speed) {
                return [{
                    x: x,
                    y: y,
                    angle: angle,
                    speed: speed * 0.75,
                    size: bulletSize * 0.9,
                    color: '#ff8000',
                    type: 'homing',
                    homingStrength: 2, // turning rate
                    homingDelay: 1, // seconds before homing activates
                    timeAlive: 0
                }];
            },
            zigzag: function(x, y, angle, speed) {
                return [{
                    x: x,
                    y: y,
                    angle: angle,
                    speed: speed * 0.85,
                    size: bulletSize * 0.85,
                    color: '#00ffff',
                    type: 'zigzag',
                    zigzagTime: 0,
                    zigzagPeriod: 0.8, // seconds per zigzag
                    zigzagAngle: Math.PI / 3 // angle of zigzag
                }];
            },
            bouncer: function(x, y, angle, speed) {
                return [{
                    x: x,
                    y: y,
                    angle: angle,
                    speed: speed * 0.8,
                    size: bulletSize * 1.1,
                    color: '#ffaa00',
                    type: 'bouncer',
                    bounceCount: 0,
                    maxBounces: 2
                }];
            }
        };

        let powerupTypes = [
            {
                type: 'shield',
                color: '#4080ff',
                effect: function() {
                    playerInvincible = true;
                    invincibleTime = 5; // 5 seconds shield
                    pulseInvincibilityEffect('#4080ff');
                    createPointsPopup('無敵護盾!', playerX, playerY - 30, '#4080ff');
                }
            },
            {
                type: 'extraLife',
                color: '#ff4040',
                effect: function() {
                    if (lives < 3) {
                        lives++;
                        updateLivesDisplay();
                        createPointsPopup('+1 命!', playerX, playerY - 30, '#ff4040');
                    } else {
                        score += 2000;
                        createPointsPopup('+2000 分!', playerX, playerY - 30, '#ff4040');
                    }
                }
            },
            {
                type: 'slowTime',
                color: '#40ff40',
                effect: function() {
                    // Slow down all bullets
                    for (let bullet of bullets) {
                        bullet.speed *= 0.6;
                    }
                    createPointsPopup('時間減速!', playerX, playerY - 30, '#40ff40');
                }
            },
            {
                type: 'clearScreen',
                color: '#ffff40',
                effect: function() {
                    // Remove all bullets and award points
                    const pointsPerBullet = 200;
                    const totalPoints = bullets.length * pointsPerBullet;

                    // Create an explosion effect for each bullet
                    for (let bullet of bullets) {
                        createSmallExplosionParticles(bullet.x, bullet.y, bullet.color);
                    }

                    bulletsDodged += bullets.length;
                    bullets = [];
                    score += totalPoints;
                    createPointsPopup(`清場! +${totalPoints} 分`, playerX, playerY - 30, '#ffff40');
                }
            }
        ];

        // Initialize game
        function init() {
            resizeCanvas();
            createStars();
            setupEventListeners();
            setupPlanePreviews();
            gameLoop(0);
        }

        // Setup plane previews for color selection
        function setupPlanePreviews() {
            const previewFunctions = {
                'bluePlane': drawPlanePreview.bind(null, 'blue'),
                'redPlane': drawPlanePreview.bind(null, 'red'),
                'purplePlane': drawPlanePreview.bind(null, 'purple'),
                'greenPlane': drawPlanePreview.bind(null, 'green'),
                'yellowPlane': drawPlanePreview.bind(null, 'yellow'),
                'cyanPlane': drawPlanePreview.bind(null, 'cyan')
            };

            for (const [id, func] of Object.entries(previewFunctions)) {
                const canvas = document.createElement('canvas');
                canvas.width = 70;
                canvas.height = 70;
                const ctx = canvas.getContext('2d');
                func(ctx, 35, 35, 30);
                document.getElementById(id).appendChild(canvas);
            }
        }

        // Draw plane preview for color selection
        function drawPlanePreview(color, ctx, x, y, size) {
            const colors = playerColorSchemes[color];

            ctx.save();
            ctx.translate(x, y);

            // Main body
            ctx.fillStyle = colors.primary;
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(size * 0.6, size * 0.2);
            ctx.lineTo(size * 0.4, size * 0.7);
            ctx.lineTo(0, size * 0.4);
            ctx.lineTo(-size * 0.4, size * 0.7);
            ctx.lineTo(-size * 0.6, size * 0.2);
            ctx.closePath();
            ctx.fill();

            // Cockpit
            ctx.fillStyle = colors.secondary;
            ctx.beginPath();
            ctx.moveTo(0, -size * 0.5);
            ctx.lineTo(size * 0.3, -size * 0.1);
            ctx.lineTo(0, size * 0.2);
            ctx.lineTo(-size * 0.3, -size * 0.1);
            ctx.closePath();
            ctx.fill();

            // Pilot
            ctx.fillStyle = colors.pilot;
            ctx.beginPath();
            ctx.arc(0, -size * 0.15, size * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Helmet/Visor
            ctx.fillStyle = colors.helmet;
            ctx.beginPath();
            ctx.arc(0, -size * 0.15, size * 0.09, 0, Math.PI * 2);
            ctx.fill();

            // Face details
            ctx.fillStyle = colors.cockpit;
            ctx.beginPath();
            ctx.arc(0, -size * 0.15, size * 0.05, 0, Math.PI, false);
            ctx.fill();

            // Wings
            ctx.fillStyle = colors.accent;

            // Right wing
            ctx.beginPath();
            ctx.moveTo(size * 0.2, 0);
            ctx.lineTo(size * 0.8, size * 0.1);
            ctx.lineTo(size * 0.7, size * 0.5);
            ctx.lineTo(size * 0.4, size * 0.3);
            ctx.closePath();
            ctx.fill();

            // Left wing
            ctx.beginPath();
            ctx.moveTo(-size * 0.2, 0);
            ctx.lineTo(-size * 0.8, size * 0.1);
            ctx.lineTo(-size * 0.7, size * 0.5);
            ctx.lineTo(-size * 0.4, size * 0.3);
            ctx.closePath();
            ctx.fill();

            // Wing details (stripes)
            ctx.strokeStyle = colors.secondary;
            ctx.lineWidth = size * 0.05;

            // Right wing stripe
            ctx.beginPath();
            ctx.moveTo(size * 0.3, size * 0.1);
            ctx.lineTo(size * 0.6, size * 0.2);
            ctx.stroke();

            // Left wing stripe
            ctx.beginPath();
            ctx.moveTo(-size * 0.3, size * 0.1);
            ctx.lineTo(-size * 0.6, size * 0.2);
            ctx.stroke();

            // Engines/thrusters
            ctx.fillStyle = 'rgba(255, 150, 50, 0.8)';

            // Center thruster
            ctx.beginPath();
            ctx.moveTo(-size * 0.1, size * 0.4);
            ctx.lineTo(0, size * 0.7);
            ctx.lineTo(size * 0.1, size * 0.4);
            ctx.closePath();
            ctx.fill();

            // Engine glow
            ctx.fillStyle = 'rgba(255, 200, 100, 0.5)';
            ctx.beginPath();
            ctx.arc(0, size * 0.7, size * 0.15, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Resize canvas to fit window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            playerX = canvas.width / 2;
            playerY = canvas.height - 100;
        }

        // Create stars for background
        function createStars() {
            stars = [];
            const starCount = 200;
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 30 + 10
                });
            }
        }

        // Update lives display
        function updateLivesDisplay() {
            livesContainer.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const lifeIcon = document.createElement('div');
                lifeIcon.className = 'lifeIcon';
                livesContainer.appendChild(lifeIcon);
            }
        }

        // Create a points popup
        function createPointsPopup(text, x, y, color) {
            const popup = document.createElement('div');
            popup.id = 'pointsPopup';
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            popup.style.color = color || 'gold';
            popup.style.fontSize = '24px';
            popup.textContent = text;

            document.getElementById('ui').appendChild(popup);

            setTimeout(() => {
                popup.remove();
            }, 1000);
        }

        // Create bullet alert indicator
        function createBulletAlert(edge, position) {
            const alert = document.createElement('div');
            alert.className = 'bulletAlert';

            switch(edge) {
                case 0: // Top
                    alert.style.top = '5px';
                    alert.style.left = `${position}px`;
                    break;
                case 1: // Right
                    alert.style.right = '5px';
                    alert.style.top = `${position}px`;
                    break;
                case 3: // Left
                    alert.style.left = '5px';
                    alert.style.top = `${position}px`;
                    break;
            }

            document.getElementById('ui').appendChild(alert);
            bulletAlerts.push(alert);

            setTimeout(() => {
                alert.remove();
                bulletAlerts = bulletAlerts.filter(a => a !== alert);
            }, 500);
        }

        // Set up event listeners
        function setupEventListeners() {
            window.addEventListener('resize', resizeCanvas);

            // Mouse/touch controls
            canvas.addEventListener('mousemove', handlePlayerMove);
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });

            // Start Screen
            startScreen.addEventListener('click', () => {
                startScreen.style.display = 'none';
                colorSelect.style.display = 'flex';
            });

            window.addEventListener('keydown', () => {
                if (startScreen.style.display !== 'none') {
                    startScreen.style.display = 'none';
                    colorSelect.style.display = 'flex';
                }
            });

            // Help button and instructions
            helpButton.addEventListener('click', (event) => {
                event.stopPropagation();
                instructionsModal.style.display = 'block';
            });

            closeInstructions.addEventListener('click', () => {
                instructionsModal.style.display = 'none';
            });

            // Color selection
            const colorOptions = document.querySelectorAll('.colorOption');
            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    playerColor = this.getAttribute('data-color');
                    colorSelect.style.display = 'none';
                    difficultySelect.style.display = 'flex';
                });
            });

            // Difficulty selection
            const difficultyBtns = document.querySelectorAll('.difficultyBtn');
            difficultyBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    const difficulty = this.getAttribute('data-difficulty');

                    if (difficulty === 'aiDemo') {
                        isAiDemo = true;
                        currentDifficulty = 'ultimate';
                        currentLevel = difficultyOrder.indexOf('ultimate');
                    } else {
                        isAiDemo = false;
                        currentDifficulty = difficulty;
                        currentLevel = difficultyOrder.indexOf(difficulty);
                    }

                    difficultySelect.style.display = 'none';
                    // Update level display immediately
                    updateLevelDisplay();
                    startCountdown();
                });
            });

            // Continue button after level
            resultBtn.addEventListener('click', () => {
                // Check if this button has a specific reload action assigned (AI demo end)
                if (resultBtn.hasAttribute('data-action') && resultBtn.getAttribute('data-action') === 'reload') {
                    window.location.reload();
                    return;
                }

                resultOverlay.style.display = 'none';
                if (resultText.textContent.includes('過關')) {
                    startNextLevel();
                } else {
                    // Failed the level - restart the same level
                    startCountdown();
                }
            });

            // Restart from fail screen
            restartFromFailBtn.addEventListener('click', () => {
                 // --- MODIFICATION START ---
                 window.location.reload();
                 // --- MODIFICATION END ---
            });

            // Restart button after victory
            restartBtn.addEventListener('click', () => {
                // --- MODIFICATION START ---
                window.location.reload();
                // --- MODIFICATION END ---
            });
        }


        // Handle player movement with mouse
        function handlePlayerMove(e) {
            if (gameActive && !isAiDemo) {
                playerX = e.clientX;
                playerY = e.clientY;

                // Keep player within screen bounds
                playerX = Math.max(playerSize, Math.min(canvas.width - playerSize, playerX));
                playerY = Math.max(playerSize, Math.min(canvas.height - playerSize, playerY));
            }
        }

        // Handle player movement with touch
        function handleTouchMove(e) {
            e.preventDefault();
            if (gameActive && !isAiDemo && e.touches[0]) {
                playerX = e.touches[0].clientX;
                playerY = e.touches[0].clientY;

                // Keep player within screen bounds
                playerX = Math.max(playerSize, Math.min(canvas.width - playerSize, playerX));
                playerY = Math.max(playerSize, Math.min(canvas.height - playerSize, playerY));
            }
        }

        // AI movement function for demo mode - completely redesigned for perfect bullet avoidance
        function updateAiMovement() {
            if (!isAiDemo || !gameActive) return;

            // Advanced bullet avoidance with increased safety margins
            const safetyMargin = 30; // Extra distance to keep from bullets
            const predictionTime = 1.2; // Look ahead time in seconds for bullet trajectories

            // Create a danger map for the entire screen
            const gridSize = 15;
            const gridWidth = Math.ceil(canvas.width / gridSize);
            const gridHeight = Math.ceil(canvas.height / gridSize);
            let dangerMap = Array(gridWidth).fill().map(() => Array(gridHeight).fill(0));

            // Process all bullets and mark danger zones on the map
            for (let bullet of bullets) {
                // Current position and properties
                let bx = bullet.x;
                let by = bullet.y;
                let bangle = bullet.angle;
                let bspeed = bullet.speed;
                let bsize = bullet.size + safetyMargin; // Add safety margin to bullet size

                // Mark the current bullet position as dangerous
                markDangerZone(bx, by, bsize * 2);

                // Calculate and mark future positions for this bullet
                for (let step = 1; step <= 20; step++) {
                    const timeStep = step * predictionTime / 20;
                    let futureX = bx;
                    let futureY = by;

                    // Predict position based on bullet type
                    switch (bullet.type) {
                        case 'simple':
                        case 'spread':
                        case 'circle':
                            futureX = bx + Math.cos(bangle) * bspeed * timeStep;
                            futureY = by + Math.sin(bangle) * bspeed * timeStep;
                            break;

                        case 'wave':
                            // Estimate wave motion
                            const waveOffset = (bullet.waveOffset || 0) + bspeed * timeStep;
                            futureX = bx + Math.cos(bangle) * bspeed * timeStep;
                            futureY = by + Math.sin(bangle) * bspeed * timeStep;

                            // Add wave motion perpendicular to movement
                            if (bullet.waveAmplitude && bullet.waveLength) {
                                const perpAngle = bangle + Math.PI / 2;
                                const waveAmplitude = bullet.waveAmplitude || 50;
                                const waveLength = bullet.waveLength || 200;

                                futureX += Math.cos(perpAngle) * Math.sin(waveOffset / waveLength * Math.PI * 2) * waveAmplitude * timeStep * 1.5;
                                futureY += Math.sin(perpAngle) * Math.sin(waveOffset / waveLength * Math.PI * 2) * waveAmplitude * timeStep * 1.5;
                            }
                            break;

                        case 'homing':
                            // For homing bullets, use a wider danger area and assume worst-case tracking
                            if (bullet.timeAlive + timeStep > (bullet.homingDelay || 1)) {
                                // After homing delay, assume it tracks the player perfectly
                                const homingFactor = Math.min(timeStep * (bullet.homingStrength || 2), 1);
                                const targetAngle = Math.atan2(playerY - by, playerX - bx);

                                // Blend current angle with target angle based on homing factor
                                bangle = bangle * (1 - homingFactor) + targetAngle * homingFactor;
                            }

                            futureX = bx + Math.cos(bangle) * bspeed * timeStep;
                            futureY = by + Math.sin(bangle) * bspeed * timeStep;

                            // Mark extra danger around homing bullets
                            markDangerZone(futureX, futureY, bsize * 3);
                            break;

                        case 'spiral':
                            // Approximate spiral motion
                            let radius = (bullet.radius || 0) + (bullet.radiusGrowthRate || 100) * timeStep;
                            radius = Math.min(radius, bullet.maxRadius || 100);

                            const rotatedAngle = bangle + (bullet.rotationSpeed || 2) * timeStep;
                            futureX = (bullet.originX || bx) + Math.cos(rotatedAngle) * radius;
                            futureY = (bullet.originY || by) + Math.sin(rotatedAngle) * radius;

                            // Mark a wider danger zone around spiral bullets
                            markDangerZone(futureX, futureY, bsize * 1.5);
                            break;

                        case 'zigzag':
                            // Approximate zigzag motion
                            const zigzagTime = (bullet.zigzagTime || 0) + timeStep;
                            const zigzagPeriod = bullet.zigzagPeriod || 0.8;
                            const zigzagPhase = (zigzagTime / zigzagPeriod) % 1;
                            const zigDirection = zigzagPhase < 0.5 ? 1 : -1;
                            const zigzagAngle = bullet.zigzagAngle || (Math.PI / 3);
                            const currentAngle = bangle + zigDirection * zigzagAngle;

                            futureX = bx + Math.cos(currentAngle) * bspeed * timeStep;
                            futureY = by + Math.sin(currentAngle) * bspeed * timeStep;

                            // Mark a wider area to account for zigzag unpredictability
                            markDangerZone(futureX, futureY, bsize * 2);
                            break;

                        case 'bouncer':
                            // Calculate bouncer trajectory with potential bounces
                            futureX = bx + Math.cos(bangle) * bspeed * timeStep;
                            futureY = by + Math.sin(bangle) * bspeed * timeStep;

                            // Check for potential bounces and update angle for next step
                            if (futureX < bsize || futureX > canvas.width - bsize) {
                                bangle = Math.PI - bangle; // Horizontal bounce
                                // Mark extended danger zone at bounce points
                                markDangerZone(futureX, futureY, bsize * 2.5);
                            }
                            if (futureY < bsize) {
                                bangle = -bangle; // Vertical bounce (top only)
                                // Mark extended danger zone at bounce points
                                markDangerZone(futureX, futureY, bsize * 2.5);
                            }
                            break;
                    }

                    // Mark standard danger zone for this future position
                    markDangerZone(futureX, futureY, bsize * 1.2);

                    // Update bullet position for next prediction step
                    bx = futureX;
                    by = futureY;
                }
            }

            // Function to mark danger zones in the grid
            function markDangerZone(x, y, radius) {
                // Skip if position is out of screen
                if (x < -radius || x > canvas.width + radius || y < -radius || y > canvas.height + radius) {
                    return;
                }

                // Determine grid cells affected by this danger zone
                const startGridX = Math.max(0, Math.floor((x - radius) / gridSize));
                const endGridX = Math.min(gridWidth - 1, Math.floor((x + radius) / gridSize));
                const startGridY = Math.max(0, Math.floor((y - radius) / gridSize));
                const endGridY = Math.min(gridHeight - 1, Math.floor((y + radius) / gridSize));

                // Mark all affected cells with danger value
                for (let gx = startGridX; gx <= endGridX; gx++) {
                    for (let gy = startGridY; gy <= endGridY; gy++) {
                        // Calculate cell center
                        const cellCenterX = (gx + 0.5) * gridSize;
                        const cellCenterY = (gy + 0.5) * gridSize;

                        // Calculate distance from danger center to cell center
                        const distSq = Math.pow(x - cellCenterX, 2) + Math.pow(y - cellCenterY, 2);

                        // Add danger value inversely proportional to distance squared
                        const dangerValue = 1000 / (distSq + 1);
                        dangerMap[gx][gy] += dangerValue;
                    }
                }
            }

            // Find current player grid position
            const playerGridX = Math.floor(playerX / gridSize);
            const playerGridY = Math.floor(playerY / gridSize);

            // Check if player is in danger and needs to move
            let currentDanger = 0;
            if (playerGridX >= 0 && playerGridX < gridWidth && playerGridY >= 0 && playerGridY < gridHeight) {
                currentDanger = dangerMap[playerGridX][playerGridY];
            }

            // Find the safest location to move to
            let bestMoveX = playerX;
            let bestMoveY = playerY;
            let minDanger = currentDanger;

            // Check potential movement directions
            const moveRadius = 120; // Maximum distance to consider moving
            const directions = 24; // Number of directions to check

            for (let dir = 0; dir < directions; dir++) {
                const angle = (dir / directions) * Math.PI * 2;

                // Check various distances in this direction
                for (let dist = gridSize; dist <= moveRadius; dist += gridSize) {
                    const testX = playerX + Math.cos(angle) * dist;
                    const testY = playerY + Math.sin(angle) * dist;

                    // Skip if out of bounds
                    if (testX < playerSize || testX > canvas.width - playerSize ||
                        testY < playerSize || testY > canvas.height - playerSize) {
                        continue;
                    }

                    // Convert to grid coordinates
                    const testGridX = Math.floor(testX / gridSize);
                    const testGridY = Math.floor(testY / gridSize);

                    // Skip if grid coordinates are invalid
                    if (testGridX < 0 || testGridX >= gridWidth || testGridY < 0 || testGridY >= gridHeight) {
                        continue;
                    }

                    // Get danger value at this position
                    let testDanger = dangerMap[testGridX][testGridY];

                    // Add penalty for being near screen edges
                    const edgeMargin = 120;
                    if (testX < edgeMargin || testX > canvas.width - edgeMargin ||
                        testY < edgeMargin || testY > canvas.height - edgeMargin) {
                        testDanger += 200;
                    }

                    // Check if this is a safer position
                    if (testDanger < minDanger) {
                        minDanger = testDanger;
                        bestMoveX = testX;
                        bestMoveY = testY;
                    }
                }
            }

            // Move toward the safest location
            const moveSpeed = 20; // Maximum move speed
            let moveX = bestMoveX - playerX;
            let moveY = bestMoveY - playerY;
            const moveDist = Math.sqrt(moveX * moveX + moveY * moveY);

            if (moveDist > 0) {
                // Normalize and scale movement
                moveX = moveX / moveDist * Math.min(moveDist, moveSpeed);
                moveY = moveY / moveDist * Math.min(moveDist, moveSpeed);

                // Apply movement
                playerX += moveX;
                playerY += moveY;
            }

            // Check for powerups and collect them if safe
            let closestPowerup = null;
            let minPowerupDist = 150;

            for (let powerup of powerups) {
                const dx = powerup.x - playerX;
                const dy = powerup.y - playerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < minPowerupDist) {
                    // Check if path to powerup is safe
                    const powerupGridX = Math.floor(powerup.x / gridSize);
                    const powerupGridY = Math.floor(powerup.y / gridSize);

                    let pathDanger = 0;
                    if (powerupGridX >= 0 && powerupGridX < gridWidth &&
                        powerupGridY >= 0 && powerupGridY < gridHeight) {
                        pathDanger = dangerMap[powerupGridX][powerupGridY];
                    }

                    // If path is relatively safe, go for the powerup
                    if (pathDanger < 10) {
                        closestPowerup = powerup;
                        minPowerupDist = distance;
                    }
                }
            }

            // Move toward closest safe powerup if found
            if (closestPowerup) {
                const powerupDirX = closestPowerup.x - playerX;
                const powerupDirY = closestPowerup.y - playerY;
                const powerupDist = Math.sqrt(powerupDirX * powerupDirX + powerupDirY * powerupDirY);

                playerX += (powerupDirX / powerupDist) * moveSpeed * 0.7;
                playerY += (powerupDirY / powerupDist) * moveSpeed * 0.7;
            }

            // Stay within bounds
            playerX = Math.max(playerSize, Math.min(canvas.width - playerSize, playerX));
            playerY = Math.max(playerSize, Math.min(canvas.height - playerSize, playerY));
        }

        // Start countdown before level begins
        function startCountdown() {
            let count = 3;
            countdownOverlay.textContent = count;
            countdownOverlay.style.display = 'flex';

            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownOverlay.textContent = count;
                } else {
                    clearInterval(countInterval);
                    countdownOverlay.style.display = 'none';
                    startLevel();
                }
            }, 1000);
        }

        // Start the current level
        function startLevel() {
            gameActive = true;
            timeRemaining = gameTime;
            bullets = [];
            powerups = [];
            playerHit = false;
            playerInvincible = false;
            lastBulletTime = 0;
            lastPowerupTime = 0;
            lives = 2;
            updateLivesDisplay();
            updateLevelDisplay();

            // Reset result button attributes/text if needed
            resultBtn.textContent = "挑戰下一關 !";
            resultBtn.removeAttribute('data-action');
            if (restartFromFailBtn) {
                restartFromFailBtn.style.display = 'block'; // Ensure restart is visible for normal play
            }


            // Show DEMO MODE text if in AI demo mode
            if (isAiDemo) {
                demoModeTextElement = document.getElementById('demoModeText');
                demoModeTextElement.style.display = 'block';
            } else {
                if (demoModeTextElement) {
                    demoModeTextElement.style.display = 'none';
                }
            }
        }

        // Update level display
        function updateLevelDisplay() {
            const difficulty = difficultySettings[currentDifficulty];
            levelDisplay.textContent = `難度: ${difficulty.name}`;
        }

        // Start the next level
        function startNextLevel() {
            currentLevel++;
            if (currentLevel >= difficultyOrder.length) {
                // All levels completed - show victory screen
                showVictoryScreen();
            } else {
                currentDifficulty = difficultyOrder[currentLevel];
                // Update level display immediately
                updateLevelDisplay();
                startCountdown();
            }
        }

        // Show level result screen
        function showLevelResult(success) {
            gameActive = false;

            // Hide DEMO MODE text
            const demoModeText = document.getElementById('demoModeText');
            if (demoModeText) {
                demoModeText.style.display = 'none';
            }

            if (isAiDemo && success) {
                // AI demo completed - setup demo end screen
                resultText.textContent = "AI 示範完成";
                resultBtn.textContent = "結束示範";

                // --- MODIFICATION START ---
                // Set a data attribute to trigger reload on click
                resultBtn.setAttribute('data-action', 'reload');
                // --- MODIFICATION END ---

                // Hide the standard restart button
                if (restartFromFailBtn) {
                    restartFromFailBtn.style.display = 'none';
                }

                // Remove any old onclick handler if it exists
                resultBtn.onclick = null;
                 // Add the listener again to ensure it uses the new attribute
                 resultBtn.addEventListener('click', () => {
                    if (resultBtn.hasAttribute('data-action') && resultBtn.getAttribute('data-action') === 'reload') {
                        window.location.reload();
                    }
                 });


                setTimeout(() => {
                    resultOverlay.style.display = 'flex';
                }, 1000);
                return; // Exit early for AI demo end
            }

            // Handle normal player success/failure
             if (success) {
                resultText.textContent = "過關！";

                // If at the ultimate level, change the button text
                if (currentLevel === difficultyOrder.indexOf('ultimate')) {
                    resultBtn.textContent = "繼續";
                } else {
                    resultBtn.textContent = "挑戰下一關 !";
                }

                // Make sure restart button is visible for player mode
                if (restartFromFailBtn) {
                    restartFromFailBtn.style.display = 'block';
                }

                // Assign points for level completion
                score += Math.floor(5000 * (currentLevel + 1) * (lives + 1)); // Bonus for completion
                scoreDisplay.textContent = 'SCORE: ' + score;
                completedLevels++;
                totalSurvivalTime += gameTime;
                createCelebrationParticles();
            } else {
                resultText.textContent = "失敗！請再試一次";
                resultBtn.textContent = "繼續";
                if (restartFromFailBtn) {
                    restartFromFailBtn.style.display = 'block';
                }
            }

            // Reset the action attribute for normal play
            resultBtn.removeAttribute('data-action');

            // Remove any old onclick handler specific to AI demo
            resultBtn.onclick = null;
            // Re-add the standard listener
            resultBtn.addEventListener('click', () => {
                if (resultBtn.hasAttribute('data-action') && resultBtn.getAttribute('data-action') === 'reload') {
                    // This case should now only be handled by the AI demo logic above
                    return;
                }
                resultOverlay.style.display = 'none';
                if (resultText.textContent.includes('過關')) {
                    startNextLevel();
                } else {
                    startCountdown(); // Restart current level on fail
                }
            });

            setTimeout(() => {
                resultOverlay.style.display = 'flex';
            }, 1000);
        }


        // Show enhanced victory screen
        function showVictoryScreen() {
            // Update victory statistics
            finalScore.textContent = `最終得分: ${score}`;
            completedLevelsStats.textContent = `${completedLevels}/5`;
            survivalTimeStats.textContent = totalSurvivalTime.toFixed(1);
            bulletsDodgedStats.textContent = bulletsDodged;

            // Show the victory screen
            victoryScreen.style.display = 'flex';

            // Create celebratory effects
            createVictoryFireworks();
            createConfetti();

            // Create victory audio effect (if desired)
            // playVictorySound();
        }

        // Create victory fireworks
        function createVictoryFireworks() {
            // Create multiple fireworks with different colors and timings
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const x = Math.random() * canvas.width;
                    const y = canvas.height - Math.random() * canvas.height * 0.7;
                    createFirework(x, y);
                }, i * 300);
            }
        }

        // Create a single firework
        function createFirework(x, y) {
            // Create particles for the firework
            const color = `hsl(${Math.random() * 360}, 100%, 60%)`;
            const particleCount = 100;

            // First, create the launching effect
            const launchDuration = 1000;
            const startY = canvas.height;

            const firework = document.createElement('div');
            firework.className = 'firework';
            firework.style.left = `${x}px`;
            firework.style.top = `${startY}px`;
            firework.style.backgroundColor = color;
            document.getElementById('ui').appendChild(firework);

            // Animate the launch
            let startTime = performance.now();

            function animateLaunch(timestamp) {
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / launchDuration, 1);
                const currentY = startY - (startY - y) * progress;

                firework.style.top = `${currentY}px`;

                if (progress < 1) {
                    requestAnimationFrame(animateLaunch);
                } else {
                    // Explosion
                    firework.remove();

                    // Create explosion particles
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const velocity = 2 + Math.random() * 3;
                        const particleSize = Math.random() * 4 + 2;
                        const lifetime = 1000 + Math.random() * 1000;

                        const particle = document.createElement('div');
                        particle.className = 'firework';
                        particle.style.width = `${particleSize}px`;
                        particle.style.height = `${particleSize}px`;
                        particle.style.backgroundColor = color;
                        particle.style.left = `${x}px`;
                        particle.style.top = `${y}px`;
                        document.getElementById('ui').appendChild(particle);

                        // Animate each particle
                        let particleStartTime = performance.now();

                        function animateParticle(timestamp) {
                            const elapsed = timestamp - particleStartTime;
                            const progress = elapsed / lifetime;

                            if (progress < 1) {
                                const distance = velocity * elapsed / 20;
                                const gravity = 0.05 * elapsed / 20;

                                const particleX = x + Math.cos(angle) * distance;
                                const particleY = y + Math.sin(angle) * distance + gravity * elapsed / 20;

                                particle.style.left = `${particleX}px`;
                                particle.style.top = `${particleY}px`;
                                particle.style.opacity = 1 - progress;

                                requestAnimationFrame(animateParticle);
                            } else {
                                particle.remove();
                            }
                        }

                        requestAnimationFrame(animateParticle);
                    }
                }
            }

            requestAnimationFrame(animateLaunch);
        }

        // Create confetti
        function createConfetti() {
            const confettiCount = 200;

            for (let i = 0; i < confettiCount; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                    confetti.style.left = `${Math.random() * canvas.width}px`;
                    confetti.style.top = '-20px';

                    // Random shape: square or rectangle
                    if (Math.random() > 0.5) {
                        confetti.style.width = `${5 + Math.random() * 10}px`;
                        confetti.style.height = confetti.style.width;
                    } else {
                        confetti.style.width = `${5 + Math.random() * 10}px`;
                        confetti.style.height = `${5 + Math.random() * 10}px`;
                    }

                    // Random rotation
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;

                    document.getElementById('ui').appendChild(confetti);

                    // Animate the confetti
                    const duration = 3000 + Math.random() * 2000;
                    const horizontalMovement = -30 + Math.random() * 60;
                    const rotationSpeed = -5 + Math.random() * 10;

                    let startTime = performance.now();

                    function animateConfetti(timestamp) {
                        const elapsed = timestamp - startTime;
                        const progress = elapsed / duration;

                        if (progress < 1) {
                            const verticalProgress = Math.min(1, elapsed / (duration * 0.7));

                            // Calculate position with some oscillation
                            const posX = parseFloat(confetti.style.left) + Math.sin(elapsed / 200) * horizontalMovement / 20;
                            const posY = -20 + canvas.height * verticalProgress;

                            confetti.style.left = `${posX}px`;
                            confetti.style.top = `${posY}px`;

                            // Rotate
                            const rotation = parseFloat(confetti.style.transform.replace('rotate(', '').replace('deg)', '')) + rotationSpeed;
                            confetti.style.transform = `rotate(${rotation}deg)`;

                            // Fade out near the end
                            if (progress > 0.7) {
                                confetti.style.opacity = 1 - ((progress - 0.7) / 0.3);
                            }

                            requestAnimationFrame(animateConfetti);
                        } else {
                            confetti.remove();
                        }
                    }

                    requestAnimationFrame(animateConfetti);
                }, i * 20);
            }
        }

        // Handle player hit
        function handlePlayerHit() {
            lives--;
            updateLivesDisplay();
            createSmallExplosionParticles(playerX, playerY);

            if (lives <= 0) {
                playerHit = true;
                createExplosionParticles(playerX, playerY);
                showLevelResult(false);
            } else {
                // Make player temporarily invincible
                playerInvincible = true;
                invincibleTime = invincibleDuration;
                pulseInvincibilityEffect();
            }
        }

        // Create pulsing effect for invincibility
        function pulseInvincibilityEffect(color) {
            invincibleEffect.style.display = 'block';
            invincibleEffect.style.boxShadow = `0 0 100px 50px ${color || playerColorSchemes[playerColor].primary}`;

            let fadeIn = true;
            let opacity = 0;

            const pulseInterval = setInterval(() => {
                if (!playerInvincible) {
                    clearInterval(pulseInterval);
                    invincibleEffect.style.display = 'none';
                    return;
                }

                if (fadeIn) {
                    opacity += 0.1;
                    if (opacity >= 0.3) fadeIn = false;
                } else {
                    opacity -= 0.1;
                    if (opacity <= 0) fadeIn = true;
                }

                invincibleEffect.style.backgroundColor = `rgba(255, 255, 255, ${opacity})`;
            }, 50);
        }

        // Create celebration particles (no white flash)
        function createCelebrationParticles() {
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 10 + 5,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                    life: 100
                });
            }
        }

        // Create small explosion particles when player is hit but has lives
        function createSmallExplosionParticles(x, y, baseColor) {
            const color = baseColor || '#ff6030';
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 5 + 2,
                    color: color,
                    life: 40
                });
            }
        }

        // Create explosion particles when player is destroyed
        function createExplosionParticles(x, y) {
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    size: Math.random() * 8 + 2,
                    color: `hsl(${Math.random() * 30 + 10}, 100%, 50%)`,
                    life: 60
                });
            }
        }

        // Update game state
        function update(deltaTime) {
            // Update stars
            updateStars(deltaTime);

            // Update particles
            updateParticles(deltaTime);

            if (gameActive) {
                // Update AI movement for demo mode
                if (isAiDemo) {
                    updateAiMovement();
                }

                // Update invincibility
                if (playerInvincible) {
                    invincibleTime -= deltaTime;
                    if (invincibleTime <= 0) {
                        playerInvincible = false;
                        invincibleEffect.style.display = 'none';
                    }
                }

                // Update timer
                timeRemaining -= deltaTime;
                timerDisplay.textContent = Math.max(0, timeRemaining).toFixed(1); // Ensure timer doesn't go below 0

                 // --- MODIFICATION START ---
                // Award points rapidly based on milliseconds survived
                // Base points per millisecond, scaled by difficulty level
                const pointsPerMillisecond = 1.0; // Adjust this value for desired speed
                score += Math.floor(deltaTime * 1000 * pointsPerMillisecond * (currentLevel + 1));
                scoreDisplay.textContent = 'SCORE: ' + score;
                 // --- MODIFICATION END ---


                if (timeRemaining <= 0) {
                    // Level completed
                    timeRemaining = 0; // Clamp timer at 0
                    showLevelResult(true);
                    return;
                }

                // Spawn bullets
                spawnBullets(deltaTime);

                // Spawn powerups
                spawnPowerups(deltaTime);

                // Update bullets
                updateBullets(deltaTime);

                // Update powerups
                updatePowerups(deltaTime);

                // Check collisions - AI is invincible
                if (!playerInvincible && !playerHit && !isAiDemo) {
                    checkCollisions();
                }

                // Check powerup collisions
                checkPowerupCollisions();
            }
        }


        // Update star positions
        function updateStars(deltaTime) {
            for (let star of stars) {
                star.y += star.speed * deltaTime;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            }
        }

        // Update particle positions and lifetimes
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;

                // Optional: Add gravity or fade effect
                particle.vy += 0.1; // Gentle gravity

                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Spawn bullets from edges of the screen
        function spawnBullets(deltaTime) {
            const settings = difficultySettings[currentDifficulty];
            const currentTime = performance.now();

            if (currentTime - lastBulletTime > settings.bulletRate) {
                lastBulletTime = currentTime;

                // Choose a random pattern from available patterns for this difficulty
                const patternType = settings.bulletPatterns[Math.floor(Math.random() * settings.bulletPatterns.length)];

                // Choose a random edge (0: top, 1: right, 3: left) - no bullets from bottom
                const edges = [0, 1, 3];
                const edge = edges[Math.floor(Math.random() * edges.length)];
                let startX, startY;

                // Position bullet on chosen edge
                switch (edge) {
                    case 0: // Top edge
                        startX = Math.random() * canvas.width;
                        startY = -bulletSize;
                        break;
                    case 1: // Right edge
                        startX = canvas.width + bulletSize;
                        startY = Math.random() * (canvas.height * 0.7); // Only spawn in top 70% of right edge
                        break;
                    case 3: // Left edge
                        startX = -bulletSize;
                        startY = Math.random() * (canvas.height * 0.7); // Only spawn in top 70% of left edge
                        break;
                }

                // Calculate angle towards player
                const angle = Math.atan2(playerY - startY, playerX - startX);

                // Generate bullets based on pattern
                const newBullets = bulletPatterns[patternType](startX, startY, angle, settings.bulletSpeed);
                bullets.push(...newBullets);

                // Create bullet alert
                let alertPosition;
                if (edge === 0) alertPosition = startX;
                else alertPosition = startY;
                createBulletAlert(edge, alertPosition);

                // Ultimate level: Special patterns
                if (settings.bossMode) {
                    // In Ultimate, sometimes add a second bullet pattern
                    if (Math.random() < 0.3) {
                        // Another pattern from a different position
                        const secondEdge = edges[Math.floor(Math.random() * edges.length)];
                        let secondX, secondY;

                        switch (secondEdge) {
                            case 0:
                                secondX = Math.random() * canvas.width;
                                secondY = -bulletSize;
                                break;
                            case 1:
                                secondX = canvas.width + bulletSize;
                                secondY = Math.random() * (canvas.height * 0.7);
                                break;
                            case 3:
                                secondX = -bulletSize;
                                secondY = Math.random() * (canvas.height * 0.7);
                                break;
                        }

                        const secondAngle = Math.atan2(playerY - secondY, playerX - secondX);
                        const secondPattern = settings.bulletPatterns[Math.floor(Math.random() * settings.bulletPatterns.length)];
                        const secondBullets = bulletPatterns[secondPattern](secondX, secondY, secondAngle, settings.bulletSpeed);
                        bullets.push(...secondBullets);

                        let secondAlertPosition;
                        if (secondEdge === 0) secondAlertPosition = secondX;
                        else secondAlertPosition = secondY;
                        createBulletAlert(secondEdge, secondAlertPosition);
                    }
                }
            }
        }

        // Spawn powerups
        function spawnPowerups(deltaTime) {
            const settings = difficultySettings[currentDifficulty];
            const currentTime = performance.now();

            if (settings.powerupRate && currentTime - lastPowerupTime > settings.powerupRate) {
                lastPowerupTime = currentTime;

                if (Math.random() < 0.5) { // 50% chance to spawn a powerup
                    // Choose a random powerup type
                    const powerupType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];

                    // Spawn at a random position (not too close to edges)
                    const margin = 50;
                    const x = margin + Math.random() * (canvas.width - margin * 2);
                    const y = margin + Math.random() * (canvas.height * 0.5); // Upper half of screen

                    powerups.push({
                        x: x,
                        y: y,
                        type: powerupType.type,
                        color: powerupType.color,
                        effect: powerupType.effect,
                        size: 20,
                        lifetime: 8, // seconds
                        pulsePhase: 0
                    });
                }
            }
        }

        // Update bullet positions
        function updateBullets(deltaTime) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                // Handle different bullet types
                switch (bullet.type) {
                    case 'simple':
                    case 'spread':
                    case 'circle':
                    case 'bouncer':
                        bullet.x += Math.cos(bullet.angle) * bullet.speed * deltaTime;
                        bullet.y += Math.sin(bullet.angle) * bullet.speed * deltaTime;

                        // Bouncer bullets can bounce off walls
                        if (bullet.type === 'bouncer') {
                            const bounceMargin = bullet.size;

                            // Bounce horizontally
                            if ((bullet.x < bounceMargin || bullet.x > canvas.width - bounceMargin) && bullet.bounceCount < bullet.maxBounces) {
                                bullet.angle = Math.PI - bullet.angle;
                                bullet.bounceCount++;
                                bullet.x = Math.max(bounceMargin, Math.min(canvas.width - bounceMargin, bullet.x)); // Prevent sticking

                                // Create bounce effect
                                createSmallExplosionParticles(bullet.x, bullet.y, '#ffaa00');
                            }

                            // Bounce vertically (only from top)
                            if (bullet.y < bounceMargin && bullet.bounceCount < bullet.maxBounces) {
                                bullet.angle = -bullet.angle;
                                bullet.bounceCount++;
                                bullet.y = bounceMargin; // Prevent sticking

                                // Create bounce effect
                                createSmallExplosionParticles(bullet.x, bullet.y, '#ffaa00');
                            }

                            // Remove after max bounces
                            if (bullet.bounceCount >= bullet.maxBounces) {
                                 // Let it fly off screen instead of removing immediately after last bounce
                                // bullets.splice(i, 1);
                                // continue;
                            }
                        }
                        break;

                    case 'wave':
                        bullet.waveOffset += bullet.speed * deltaTime;
                        bullet.x += Math.cos(bullet.angle) * bullet.speed * deltaTime;
                        bullet.y += Math.sin(bullet.angle) * bullet.speed * deltaTime;
                        // Add wave motion perpendicular to movement
                        const perpAngle = bullet.angle + Math.PI / 2;
                        bullet.x += Math.cos(perpAngle) * Math.sin(bullet.waveOffset / bullet.waveLength * Math.PI * 2) * bullet.waveAmplitude * deltaTime;
                        bullet.y += Math.sin(perpAngle) * Math.sin(bullet.waveOffset / bullet.waveLength * Math.PI * 2) * bullet.waveAmplitude * deltaTime;
                        break;

                    case 'spiral':
                        // Update spiral movement
                        bullet.angle += bullet.rotationSpeed * deltaTime;
                        bullet.radius += bullet.radiusGrowthRate * deltaTime;
                        if (bullet.radius > bullet.maxRadius) {
                            bullet.radius = bullet.maxRadius;
                            // Once max radius is reached, start moving outward
                            bullet.originX += Math.cos(bullet.angle) * bullet.speed * 0.5 * deltaTime;
                            bullet.originY += Math.sin(bullet.angle) * bullet.speed * 0.5 * deltaTime;
                        }
                        // Calculate position based on origin and angle
                        bullet.x = bullet.originX + Math.cos(bullet.angle) * bullet.radius;
                        bullet.y = bullet.originY + Math.sin(bullet.angle) * bullet.radius;
                        break;

                    case 'homing':
                        // Update homing bullet
                        bullet.timeAlive += deltaTime;

                        // Move forward
                        bullet.x += Math.cos(bullet.angle) * bullet.speed * deltaTime;
                        bullet.y += Math.sin(bullet.angle) * bullet.speed * deltaTime;

                        // Start homing after delay
                        if (bullet.timeAlive > bullet.homingDelay) {
                            // Calculate angle to player
                            const targetAngle = Math.atan2(playerY - bullet.y, playerX - bullet.x);

                            // Gradually turn towards player
                            let angleDiff = targetAngle - bullet.angle;

                            // Handle angle wrapping
                            if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                            // Turn towards player at limited rate
                            bullet.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), bullet.homingStrength * deltaTime);
                        }
                        break;

                    case 'zigzag':
                        // Update zigzag time
                        bullet.zigzagTime += deltaTime;

                        // Calculate zigzag direction
                        const zigzagPhase = (bullet.zigzagTime / bullet.zigzagPeriod) % 1;
                        const zigDirection = zigzagPhase < 0.5 ? 1 : -1;

                        // Move in zigzag pattern
                        const baseAngle = bullet.angle;
                        const currentAngle = baseAngle + zigDirection * bullet.zigzagAngle;

                        bullet.x += Math.cos(currentAngle) * bullet.speed * deltaTime;
                        bullet.y += Math.sin(currentAngle) * bullet.speed * deltaTime;
                        break;
                }

                // Count bullets dodged when they go off screen
                const margin = 100; // A bit more than bullet size to account for trails
                if (bullet.x < -margin || bullet.x > canvas.width + margin ||
                    bullet.y < -margin || bullet.y > canvas.height + margin) {
                    bullets.splice(i, 1);
                    if (gameActive) bulletsDodged++; // Only count dodged bullets while game is active
                }
            }
        }


        // Update powerups
        function updatePowerups(deltaTime) {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];

                // Update pulse animation
                powerup.pulsePhase += deltaTime * 4;

                // Update lifetime
                powerup.lifetime -= deltaTime;

                if (powerup.lifetime <= 0) {
                    // Create fade-out effect
                    createSmallExplosionParticles(powerup.x, powerup.y, powerup.color);
                    powerups.splice(i, 1);
                }
            }
        }

        // Check powerup collisions
        function checkPowerupCollisions() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                const dx = playerX - powerup.x;
                const dy = playerY - powerup.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < playerSize + powerup.size) {
                    // Collect powerup
                    powerup.effect();

                    // Create effect
                    createSmallExplosionParticles(powerup.x, powerup.y, powerup.color);

                    // Remove powerup
                    powerups.splice(i, 1);
                }
            }
        }

        // Check for collisions between player and bullets
        function checkCollisions() {
            const hitboxSize = playerSize * 0.6; // Smaller hitbox for better gameplay

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                const dx = playerX - bullet.x;
                const dy = playerY - bullet.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < hitboxSize + bullet.size) {
                    bullets.splice(i, 1); // Remove bullet
                    handlePlayerHit();
                    break; // Only process one hit per frame
                }
            }
        }


        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            drawStars();

            // Draw bullets
            drawBullets();

            // Draw powerups
            drawPowerups();

            // Draw player
            if (!playerHit) {
                drawPlayer();
            }

            // Draw particles
            drawParticles();
        }

        // Draw stars
        function drawStars() {
            ctx.fillStyle = 'white';
            for (let star of stars) {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw bullets
        function drawBullets() {
            for (let bullet of bullets) {
                ctx.fillStyle = bullet.color;

                // Draw different bullet shapes based on type
                switch (bullet.type) {
                    case 'simple':
                        // Draw oval bullet
                        ctx.save();
                        ctx.translate(bullet.x, bullet.y);
                        ctx.rotate(bullet.angle);
                        ctx.beginPath();
                        ctx.ellipse(0, 0, bullet.size * 1.5, bullet.size * 0.8, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        // Bullet trail
                        ctx.beginPath();
                        ctx.moveTo(bullet.x, bullet.y);
                        ctx.lineTo(
                            bullet.x - Math.cos(bullet.angle) * bullet.size * 3,
                            bullet.y - Math.sin(bullet.angle) * bullet.size * 3
                        );
                        ctx.strokeStyle = 'rgba(255, 100, 50, 0.5)';
                        ctx.lineWidth = bullet.size;
                        ctx.stroke();
                        break;

                    case 'spread':
                        // Draw diamond bullet
                        ctx.save();
                        ctx.translate(bullet.x, bullet.y);
                        ctx.rotate(bullet.angle + Math.PI / 4); // Rotate for diamond shape
                        ctx.fillRect(-bullet.size * 1.1, -bullet.size * 1.1, bullet.size * 2.2, bullet.size * 2.2);
                        ctx.restore();
                        break;

                    case 'wave':
                        // Draw square bullet with rotation
                        ctx.save();
                        ctx.translate(bullet.x, bullet.y);
                        ctx.rotate(bullet.waveOffset / 20);
                        ctx.fillRect(-bullet.size, -bullet.size, bullet.size * 2, bullet.size * 2);
                        ctx.restore();
                        break;

                    case 'circle':
                        // Draw circular bullet with inner circle
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                        ctx.fill();

                        // Inner circle
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, bullet.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'spiral':
                        // Draw star-shaped bullet
                        ctx.save();
                        ctx.translate(bullet.x, bullet.y);
                        ctx.rotate(bullet.angle * 2);

                        ctx.beginPath();
                        const points = 5;
                        const innerRadius = bullet.size * 0.5;
                        const outerRadius = bullet.size;

                        for (let i = 0; i < points * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / points - Math.PI/2; // Adjust starting angle
                            if (i === 0) {
                                ctx.moveTo(radius * Math.cos(angle), radius * Math.sin(angle));
                            } else {
                                ctx.lineTo(radius * Math.cos(angle), radius * Math.sin(angle));
                            }
                        }

                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                        break;

                    case 'homing':
                        // Draw missile-like bullet
                        ctx.save();
                        ctx.translate(bullet.x, bullet.y);
                        ctx.rotate(bullet.angle);

                        // Bullet body
                        ctx.fillStyle = bullet.color;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, bullet.size * 1.5, bullet.size * 0.8, 0, 0, Math.PI * 2);
                        ctx.fill();


                        // Thruster effect
                        if (bullet.timeAlive > bullet.homingDelay) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.beginPath();
                             ctx.arc(-bullet.size * 1.2, 0, bullet.size * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Engine flame
                        ctx.fillStyle = 'rgba(255, 150, 50, 0.8)';
                        ctx.beginPath();
                        ctx.moveTo(-bullet.size * 1.5, -bullet.size * 0.5);
                        ctx.lineTo(-bullet.size * 2.5, 0);
                        ctx.lineTo(-bullet.size * 1.5, bullet.size * 0.5);
                        ctx.closePath();
                        ctx.fill();

                        ctx.restore();
                        break;

                    case 'zigzag':
                        // Draw triangular bullet
                        ctx.save();
                        ctx.translate(bullet.x, bullet.y);

                        // Rotate based on overall direction
                         ctx.rotate(bullet.angle);

                        // Draw triangle
                        ctx.beginPath();
                        ctx.moveTo(bullet.size * 1.5, 0);
                        ctx.lineTo(-bullet.size, bullet.size);
                        ctx.lineTo(-bullet.size, -bullet.size);
                        ctx.closePath();
                        ctx.fill();

                        // Lightning effect (subtle flicker)
                         if(Math.random() > 0.7) {
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(-bullet.size * 0.8, -bullet.size * 0.5);
                            ctx.lineTo(bullet.size * 0.8, bullet.size * 0.5);
                             ctx.moveTo(-bullet.size * 0.8, bullet.size * 0.5);
                            ctx.lineTo(bullet.size * 0.8, -bullet.size * 0.5);
                            ctx.stroke();
                         }


                        ctx.restore();
                        break;

                    case 'bouncer':
                        // Draw bouncing ball
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw bounce indicators/energy effect
                        ctx.strokeStyle = 'rgba(255, 200, 0, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, bullet.size * (1.2 + Math.sin(Date.now()/100 + bullet.x) * 0.2), 0, Math.PI * 2);
                        ctx.stroke();

                        break;
                }
            }
        }

        // Draw powerups
        function drawPowerups() {
            for (let powerup of powerups) {
                // Pulse effect
                const pulseSize = powerup.size * (1 + Math.sin(powerup.pulsePhase) * 0.2);

                // Draw powerup glow
                ctx.beginPath();
                const gradient = ctx.createRadialGradient(
                    powerup.x, powerup.y, pulseSize * 0.5,
                    powerup.x, powerup.y, pulseSize * 1.5
                );
                gradient.addColorStop(0, powerup.color);
                gradient.addColorStop(0.5, powerup.color + '80'); // Add some transparency
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.arc(powerup.x, powerup.y, pulseSize * 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Draw powerup core - smaller and brighter
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(powerup.x, powerup.y, pulseSize * 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Draw icon based on type (simpler icons)
                 ctx.fillStyle = powerup.color; // Use solid color for icon
                 ctx.font = `${pulseSize * 0.7}px Arial Black`;
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';


                switch (powerup.type) {
                    case 'shield':
                        ctx.fillText('S', powerup.x, powerup.y);
                        break;

                    case 'extraLife':
                         ctx.fillText('♥', powerup.x, powerup.y + pulseSize * 0.1); // Heart symbol
                        break;

                    case 'slowTime':
                         ctx.fillText('T', powerup.x, powerup.y);
                        break;

                    case 'clearScreen':
                         ctx.fillText('!', powerup.x, powerup.y);
                        break;
                }

                // Add blinking effect for expiring powerups
                 let alpha = 1;
                if (powerup.lifetime < 2) {
                    alpha = 0.5 + Math.sin(Date.now() / 100) * 0.5; // Faster blink
                }
                 ctx.globalAlpha = alpha;


                // Reset global alpha after drawing this powerup
                 ctx.globalAlpha = 1;
            }
        }


        // Draw player (airplane) with selected color and pilot
        function drawPlayer() {
            const colors = playerColorSchemes[playerColor];

            ctx.save();
            ctx.translate(playerX, playerY);

            // Draw player ship
            if (!playerInvincible || Math.floor(Date.now() / 100) % 2 === 0) { // Blinking effect when invincible
                // Main body
                ctx.fillStyle = colors.primary;
                ctx.beginPath();
                ctx.moveTo(0, -playerSize);
                ctx.lineTo(playerSize * 0.6, playerSize * 0.2);
                ctx.lineTo(playerSize * 0.4, playerSize * 0.7);
                ctx.lineTo(0, playerSize * 0.4);
                ctx.lineTo(-playerSize * 0.4, playerSize * 0.7);
                ctx.lineTo(-playerSize * 0.6, playerSize * 0.2);
                ctx.closePath();
                ctx.fill();

                // Cockpit
                ctx.fillStyle = colors.secondary;
                ctx.beginPath();
                ctx.moveTo(0, -playerSize * 0.5);
                ctx.lineTo(playerSize * 0.3, -playerSize * 0.1);
                ctx.lineTo(0, playerSize * 0.2);
                ctx.lineTo(-playerSize * 0.3, -playerSize * 0.1);
                ctx.closePath();
                ctx.fill();

                // Draw canopy glass reflection
                ctx.fillStyle = colors.cockpit;
                ctx.beginPath();
                ctx.moveTo(0, -playerSize * 0.4);
                ctx.lineTo(playerSize * 0.15, -playerSize * 0.2);
                ctx.lineTo(0, -playerSize * 0.1);
                ctx.lineTo(-playerSize * 0.15, -playerSize * 0.2);
                ctx.closePath();
                ctx.fill();

                // Draw pilot head
                ctx.fillStyle = colors.pilot;
                ctx.beginPath();
                ctx.arc(0, -playerSize * 0.15, playerSize * 0.12, 0, Math.PI * 2);
                ctx.fill();

                // Draw pilot helmet/visor
                ctx.fillStyle = colors.helmet;
                ctx.beginPath();
                ctx.arc(0, -playerSize * 0.15, playerSize * 0.09, 0, Math.PI * 2);
                ctx.fill();

                // Draw face details - visor/goggles
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.ellipse(0, -playerSize * 0.15, playerSize * 0.06, playerSize * 0.03, 0, 0, Math.PI);
                ctx.fill();

                // Wings
                ctx.fillStyle = colors.accent;

                // Right wing
                ctx.beginPath();
                ctx.moveTo(playerSize * 0.2, 0);
                ctx.lineTo(playerSize * 0.8, playerSize * 0.1);
                ctx.lineTo(playerSize * 0.7, playerSize * 0.5);
                ctx.lineTo(playerSize * 0.4, playerSize * 0.3);
                ctx.closePath();
                ctx.fill();

                // Left wing
                ctx.beginPath();
                ctx.moveTo(-playerSize * 0.2, 0);
                ctx.lineTo(-playerSize * 0.8, playerSize * 0.1);
                ctx.lineTo(-playerSize * 0.7, playerSize * 0.5);
                ctx.lineTo(-playerSize * 0.4, playerSize * 0.3);
                ctx.closePath();
                ctx.fill();

                // Wing details - stripes and patterns
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = playerSize * 0.05;

                // Right wing stripe
                ctx.beginPath();
                ctx.moveTo(playerSize * 0.3, playerSize * 0.1);
                ctx.lineTo(playerSize * 0.6, playerSize * 0.2);
                ctx.stroke();

                // Left wing stripe
                ctx.beginPath();
                ctx.moveTo(-playerSize * 0.3, playerSize * 0.1);
                ctx.lineTo(-playerSize * 0.6, playerSize * 0.2);
                ctx.stroke();

                // Engines/thrusters
                ctx.fillStyle = 'rgba(255, 150, 50, 0.8)';

                // Center thruster
                ctx.beginPath();
                ctx.moveTo(-playerSize * 0.1, playerSize * 0.4);
                ctx.lineTo(0, playerSize * 0.7);
                ctx.lineTo(playerSize * 0.1, playerSize * 0.4);
                ctx.closePath();
                ctx.fill();

                // Right thruster
                ctx.beginPath();
                ctx.moveTo(playerSize * 0.3, playerSize * 0.3);
                ctx.lineTo(playerSize * 0.4, playerSize * 0.6);
                ctx.lineTo(playerSize * 0.5, playerSize * 0.3);
                ctx.closePath();
                ctx.fill();

                // Left thruster
                ctx.beginPath();
                ctx.moveTo(-playerSize * 0.3, playerSize * 0.3);
                ctx.lineTo(-playerSize * 0.4, playerSize * 0.6);
                ctx.lineTo(-playerSize * 0.5, playerSize * 0.3);
                ctx.closePath();
                ctx.fill();

                // Add engine glow effect
                ctx.fillStyle = 'rgba(255, 200, 100, 0.5)';
                ctx.beginPath();
                ctx.arc(0, playerSize * 0.7, playerSize * 0.15, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(playerSize * 0.4, playerSize * 0.6, playerSize * 0.1, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(-playerSize * 0.4, playerSize * 0.6, playerSize * 0.1, 0, Math.PI * 2);
                ctx.fill();

                // Add trail based on movement
                if (gameActive) {
                    // Calculate trail length based on speed
                    const trailOpacity = 0.7;
                    const trailLength = 20 + Math.random() * 5; // Add slight variation

                    // Draw engine trails
                    const trailGradient = ctx.createLinearGradient(0, playerSize * 0.6, 0, playerSize * 0.7 + trailLength);
                    trailGradient.addColorStop(0, `rgba(255, 100, 50, ${trailOpacity})`);
                    trailGradient.addColorStop(1, 'rgba(255, 200, 100, 0)'); // Fade out
                    ctx.fillStyle = trailGradient;

                    // Center trail
                    ctx.beginPath();
                    ctx.moveTo(-playerSize * 0.1, playerSize * 0.7);
                    ctx.lineTo(0, playerSize * 0.7 + trailLength);
                    ctx.lineTo(playerSize * 0.1, playerSize * 0.7);
                    ctx.closePath();
                    ctx.fill();

                    // Side trails
                    ctx.beginPath();
                    ctx.moveTo(playerSize * 0.35, playerSize * 0.6);
                    ctx.lineTo(playerSize * 0.4, playerSize * 0.6 + trailLength * 0.8);
                    ctx.lineTo(playerSize * 0.45, playerSize * 0.6);
                    ctx.closePath();
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-playerSize * 0.35, playerSize * 0.6);
                    ctx.lineTo(-playerSize * 0.4, playerSize * 0.6 + trailLength * 0.8);
                    ctx.lineTo(-playerSize * 0.45, playerSize * 0.6);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Draw shield effect if invincible (different visualization)
            if (playerInvincible) {
                const pulseSize = playerSize * (1.2 + Math.sin(Date.now() / 100) * 0.1);
                 const shieldGradient = ctx.createRadialGradient(0, 0, pulseSize * 0.8, 0, 0, pulseSize * 1.1);
                 shieldGradient.addColorStop(0, 'rgba(64, 128, 255, 0)'); // Transparent center
                 shieldGradient.addColorStop(0.8, 'rgba(64, 128, 255, 0.5)'); // Blue shield color
                 shieldGradient.addColorStop(1, 'rgba(200, 220, 255, 0.7)'); // Bright edge

                ctx.fillStyle = shieldGradient;
                ctx.beginPath();
                ctx.arc(0, 0, pulseSize * 1.1, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }


        // Draw particles
        function drawParticles() {
            for (let particle of particles) {
                 // Fade out based on life
                ctx.globalAlpha = Math.max(0, particle.life / 60); // Use original life max if explosion/small explosion use different life values
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size * (particle.life / 60), 0, Math.PI * 2); // Shrink effect
                ctx.fill();
            }
            ctx.globalAlpha = 1; // Reset global alpha
        }


        // Game loop
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp; // Initialize lastTime on first frame
            const deltaTime = Math.min((timestamp - lastTime) / 1000, 0.1); // Cap delta time to prevent large jumps
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Initialize game when page loads
        window.onload = init;
    </script>
</body>
</html>
```