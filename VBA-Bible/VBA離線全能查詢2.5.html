<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VBA全能查詢工具 (離線版)</title>
    <style>
        /* --- 基本重置與全局樣式 --- */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        html {
            -webkit-text-size-adjust: 100%;
            height: 100%;
            scroll-behavior: smooth;
        }    "name": "Range.Row",

        body {
            font-family: Arial, 'Microsoft JhengHei', sans-serif; /* 考慮繁體中文顯示 */
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            font-size: 16px;
            min-height: 100%;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            -webkit-tap-highlight-color: transparent;
            color: #333;
        }
        h1 {
            color: #333;
            text-align: center;
            font-size: 2em;
            margin-bottom: 15px; /* 減少與下方元素的間距 */
        }

        /* --- 搜索與導航按鈕區域 --- */
        #searchHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap; /* 允許在小屏幕上換行 */
        }
        #searchBox {
            flex-grow: 1;
            padding: 10px;
            font-size: 1em;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-right: 15px; /* 與右側按鈕組的間距 */
            min-width: 200px; /* 避免搜索框過窄 */
        }
        #navigationButtons {
            display: flex; /* 讓按鈕水平排列 */
            gap: 8px; /* 按鈕之間的間距 */
            flex-shrink: 0; /* 防止按鈕組被壓縮 */
        }
        .nav-button {
            display: inline-block;
            padding: 9px 15px;
            background-color: #005a9e;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-size: 0.95em;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: none;
            cursor: pointer;
            white-space: nowrap; /* 防止按鈕文字換行 */
        }
        .nav-button:hover {
            background-color: #004085;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        }
        .nav-button:active {
            transform: translateY(0px);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* --- 主查詢界面元素 --- */
        #commandStats {
            text-align: center;
            margin-bottom: 15px;
            color: #555;
            font-size: 0.9em;
        }
        #searchResultsContainer {
            margin-bottom: 20px;
        }
        #results {
            margin-top: 15px;
        }
        .result-item {
            padding: 8px 10px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            display: block;
        }
        .result-item:hover {
            background-color: #e0e0e0;
        }
        #details {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            display: none;
            position: relative;
        }
        #details h2 {
            margin-top: 0;
            margin-right: 30px;
            font-size: 1.5em;
        }
        .close-details-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            font-weight: bold;
            color: #777;
            cursor: pointer;
            line-height: 1;
            padding: 5px;
            user-select: none;
        }
        .close-details-btn:hover {
            color: #333;
        }
        #directory {
            margin-top: 15px;
            padding: 8px;
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }
        .directory-category h3 {
            margin-top: 8px;
            margin-bottom: 0;
            color: #004085;
            border-bottom: 1px solid #eee;
            padding: 5px 5px;
            cursor: pointer;
            position: relative;
            font-size: 0.95em;
        }
        .directory-category h3:hover {
            background-color: #f0f0f0;
        }
        .toggle-icon {
            float: right;
            font-weight: bold;
            margin-right: 3px;
            user-select: none;
            font-size: 0.9em;
        }
        .directory-category ul {
            list-style-type: none;
            padding-left: 0;
            margin-top: 1px;
            margin-bottom: 3px;
        }
        .directory-category li {
            margin: 0;
            padding: 0;
        }
        .directory-item {
            padding: 5px 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: block;
        }
        .directory-item:hover {
            background-color: #e0e0e0;
        }
        .directory-item-name-main {
            font-size: 0.95em;
            font-weight: bold;
            color: #337ab7;
            display: block;
            margin-bottom: 2px;
        }
        .directory-item-description {
            font-size: 0.8em;
            color: #555;
            display: block;
            line-height: 1.25;
            padding-left: 10px;
        }
        pre {
            background-color: #f0f0f0;
            padding: 8px;
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9em;
            color: #333; /* 确保 pre 内文字颜色 */
        }
        .example-explanation {
            font-size: 0.85em;
            font-style: italic;
            color: #555;
            margin-top: -2px;
            margin-bottom: 8px;
            padding-left: 5px;
        }
        .highlight {
            background-color: yellow;
            font-weight: bold;
        }

        /* --- 新內容頁面通用樣式 --- */
        .content-page {
            display: none; /* Initially hidden */
            padding-top: 20px;
        }
        .content-page-inner-container { /* 用于包裹从独立HTML复制过来的 .container 内容 */
            max-width: 900px; /* 与原页面一致或按需调整 */
            margin: 0 auto; /* 居中 */
            padding: 25px;
            background-color: #fff; /* 默认背景，会被特定页面样式覆盖 */
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .content-page-inner-container .button-link,
        .page-specific-footer .button-link { /* 确保返回按钮样式统一或特定 */
            display: inline-block;
            padding: 10px 18px;
            background-color: #6c757d; /* 返回按钮用灰色 */
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            margin-top: 20px;
            font-size: 1em;
            cursor: pointer; /* 改为pointer */
            border: none;
        }
        .content-page-inner-container .button-link:hover,
        .page-specific-footer .button-link:hover {
            background-color: #5a6268;
        }

        /* --- “使用方法”頁面特定樣式 --- */
        #pageUsageGuide .content-page-inner-container {
            font-family: 'Arial', 'Microsoft JhengHei', sans-serif;
            line-height: 1.8;
            background-color: #fff; /* 主体白色背景 */
            color: #333;
            border-left: 5px solid #007bff; /* 蓝色左边框 */
        }
        #pageUsageGuide h1, #pageUsageGuide h2, #pageUsageGuide h3 {
            color: #005a9e;
        }
        #pageUsageGuide h1 {
            text-align: center;
            border-bottom: 2px solid #005a9e;
            padding-bottom: 10px;
            margin-bottom: 25px;
            font-size: 1.8em; /* 调整大小以适应内容页 */
        }
        #pageUsageGuide h2 {
            margin-top: 30px;
            border-bottom: 1px solid #cce0f0;
            padding-bottom: 8px;
            font-size: 1.5em;
        }
        #pageUsageGuide p, #pageUsageGuide li { font-size: 16px; margin-bottom: 12px; }
        #pageUsageGuide ul { padding-left: 25px; }
        #pageUsageGuide code {
            background-color: #e9ecef;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.95em;
            color: #005a9e;
        }
        #pageUsageGuide table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 0.95em; }
        #pageUsageGuide th, #pageUsageGuide td { border: 1px solid #ddd; padding: 10px; text-align: left; }
        #pageUsageGuide th { background-color: #f0f8ff; color: #005a9e; font-weight: bold; } /* 淡藍色表頭 */
        #pageUsageGuide tr:nth-child(even) { background-color: #f9f9f9; }
        #pageUsageGuide .note { background-color: #fff3cd; border-left: 5px solid #ffeeba; padding: 15px; margin: 20px 0; border-radius: 4px;}
        #pageUsageGuide .footer { text-align: center; margin-top: 30px; padding-top: 15px; border-top: 1px solid #ddd; font-size: 0.9em; color: #777;}

        /* --- “新手進階”頁面特定樣式 --- */
        #pageNoviceToAdvanced .content-page-inner-container {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            line-height: 1.7;
            background-color: #ffffff;
            color: #4a4a4a;
            border-left: 5px solid #ff8c00; /* 橙色左邊框 */
            padding: 30px;
        }
        #pageNoviceToAdvanced h1, #pageNoviceToAdvanced h2, #pageNoviceToAdvanced h3 {
            color: #d9534f; /* 暖紅色調標題 */
        }
        #pageNoviceToAdvanced h1 { text-align: center; padding-bottom: 15px; margin-bottom: 30px; font-size: 1.8em; }
        #pageNoviceToAdvanced h2 { margin-top: 35px; padding-bottom: 10px; border-bottom: 1px dashed #f0ad4e; font-size: 1.6em; }
        #pageNoviceToAdvanced h3 { font-size: 1.3em; color: #5cb85c; } /* 綠色小標題 */
        #pageNoviceToAdvanced p, #pageNoviceToAdvanced li { font-size: 16px; margin-bottom: 14px; color: #555; }
        #pageNoviceToAdvanced ul { padding-left: 30px; list-style-type: square; }
        #pageNoviceToAdvanced code {
            background-color: #f9f2f4; /* 淡粉色代碼背景 */
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', monospace;
            color: #c7254e; /* 深紅色代碼文字 */
            font-size: 0.95em;
        }
        #pageNoviceToAdvanced .tip { background-color: #dff0d8; border-left: 5px solid #5cb85c; padding: 18px; margin: 25px 0; border-radius: 5px;}
        #pageNoviceToAdvanced .tip strong { color: #3c763d; }
        #pageNoviceToAdvanced .challenge { background-color: #fcf8e3; border-left: 5px solid #f0ad4e; padding: 18px; margin: 25px 0; border-radius: 5px;}
        #pageNoviceToAdvanced .challenge strong { color: #8a6d3b; }
        #pageNoviceToAdvanced .footer { text-align: center; margin-top: 35px; padding-top: 20px; border-top: 1px solid #eee; font-size: 0.9em; color: #888;}

        /* --- “邁向頂尖”頁面特定樣式 --- */
        #pagePathToMastery .content-page-inner-container {
            font-family: 'Georgia', 'Times New Roman', serif;
            line-height: 1.9;
            background-color: #34495e; /* 稍淺的藍灰色塊 */
            color: #e0e0e0; /* 淺灰色文字 */
            padding: 35px;
            border-radius: 0; /* 保持直角 */
        }
        #pagePathToMastery h1, #pagePathToMastery h2, #pagePathToMastery h3 {
            color: #f1c40f; /* 金色標題 */
            font-family: 'Tahoma', 'Geneva', sans-serif;
        }
        #pagePathToMastery h1 { text-align: center; padding-bottom: 18px; margin-bottom: 35px; font-size: 2em; border-bottom: 3px solid #f1c40f; letter-spacing: 1px; }
        #pagePathToMastery h2 { margin-top: 40px; padding-bottom: 12px; border-bottom: 1px solid #7f8c8d; font-size: 1.7em; }
        #pagePathToMastery h3 { font-size: 1.4em; color: #1abc9c; } /* 綠松石色小標題 */
        #pagePathToMastery p, #pagePathToMastery li { font-size: 17px; margin-bottom: 15px; color: #bdc3c7; }
        #pagePathToMastery ul { padding-left: 30px; list-style-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 10 10"><polygon points="0,0 10,5 0,10" fill="%23f1c40f" /></svg>'); }
        #pagePathToMastery code {
            background-color: #2c3e50;
            border: 1px solid #4a6075;
            padding: 4px 7px;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', monospace;
            color: #c1d700;
            font-size: 1em;
        }
        #pagePathToMastery .vision { background-color: rgba(241, 196, 15, 0.1); border-left: 6px solid #f1c40f; padding: 20px; margin: 30px 0; border-radius: 4px;}
        #pagePathToMastery .vision strong { color: #f1c40f; }
        #pagePathToMastery .highlight-box { background-color: #000000; color: #ecf0f1; padding: 15px; margin: 20px 0; border-radius: 5px;}
        #pagePathToMastery .highlight-box h3 { color: #ffffff; margin-top: 0; font-size: 1.3em; }
        #pagePathToMastery .footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #7f8c8d; font-size: 0.95em; color: #95a5a6;}


        /* --- 響應式設計調整 --- */
        @media (max-width: 700px) { /* 調整斷點 */
            body {
                padding: 10px;
                font-size: 15px;
            }
            h1 {
                font-size: 1.6em;
            }
            #searchHeader {
                flex-direction: column; /* 搜索框和按鈕垂直堆疊 */
                align-items: stretch; /* 使元素填滿寬度 */
            }
            #searchBox {
                margin-right: 0; /* 移除右邊距 */
                margin-bottom: 10px; /* 與下方按鈕組的間距 */
                width: 100%; /* 確保填滿 */
            }
            #navigationButtons {
                justify-content: center; /* 按鈕居中 */
                flex-wrap: wrap; /* 允許按鈕換行 */
                width: 100%; /* 確保填滿 */
            }
            .nav-button {
                padding: 8px 12px;
                font-size: 0.9em;
                margin: 5px; /* 按鈕之間的間距 */
                flex-grow: 1; /* 讓按鈕在空間允許時平均分配寬度 */
                text-align: center;
            }

            #details h2 { font-size: 1.3em; margin-right: 45px; }
            .close-details-btn { top: 8px; right: 8px; font-size: 28px; padding: 8px; }
            #details { padding: 10px; }
            .result-item { padding: 12px 8px; }
            .directory-category h3 { font-size: 0.9em; padding: 10px 5px; }
            .directory-item { padding: 8px 8px; }
            .directory-item-name-main { font-size: 0.9em; }
            .directory-item-description { font-size: 0.75em; line-height: 1.3; padding-left: 5px; }
            pre { font-size: 0.85em; padding: 6px; }
            .example-explanation { font-size: 0.8em; }

            /* 響應式調整新頁面 */
            .content-page-inner-container { padding: 15px; }
            #pageUsageGuide h1, #pageNoviceToAdvanced h1, #pagePathToMastery h1 { font-size: 1.5em; margin-bottom:20px; }
            #pageUsageGuide h2, #pageNoviceToAdvanced h2, #pagePathToMastery h2 { font-size: 1.3em; margin-top:25px;}
            #pageUsageGuide h3, #pageNoviceToAdvanced h3, #pagePathToMastery h3 { font-size: 1.1em; }
            #pagePathToMastery .highlight-box h3 { font-size: 1.2em; }

        }
        /* --- Footer Styles --- */
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            padding-bottom: 20px;
            border-top: 1px solid #ddd;
            font-size: 0.9em;
            color: #555;
        }
    </style>
    <script>
    // <!-- START OF FUSE.MIN.JS CODE -->
    (function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Fuse = factory());
})(this, (function () { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  function isArray(value) {
    return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);
  }

  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
  var INFINITY = 1 / 0;
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }
  function isString(value) {
    return typeof value === 'string';
  }
  function isNumber(value) {
    return typeof value === 'number';
  }

  // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';
  }
  function isObject(value) {
    return _typeof(value) === 'object';
  }

  // Checks if `value` is object-like.
  function isObjectLike(value) {
    return isObject(value) && value !== null;
  }
  function isDefined(value) {
    return value !== undefined && value !== null;
  }
  function isBlank(value) {
    return !value.trim().length;
  }

  // Gets the `toStringTag` of `value`.
  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
  function getTag(value) {
    return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);
  }

  var EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';
  var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
  var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key) {
    return "Invalid value for key ".concat(key);
  };
  var PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE(max) {
    return "Pattern length exceeds max of ".concat(max, ".");
  };
  var MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY(name) {
    return "Missing ".concat(name, " property in key");
  };
  var INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE(key) {
    return "Property 'weight' in key '".concat(key, "' must be a positive integer");
  };

  var hasOwn = Object.prototype.hasOwnProperty;
  var KeyStore = /*#__PURE__*/function () {
    function KeyStore(keys) {
      var _this = this;
      _classCallCheck(this, KeyStore);
      this._keys = [];
      this._keyMap = {};
      var totalWeight = 0;
      keys.forEach(function (key) {
        var obj = createKey(key);
        _this._keys.push(obj);
        _this._keyMap[obj.id] = obj;
        totalWeight += obj.weight;
      });

      // Normalize weights so that their sum is equal to 1
      this._keys.forEach(function (key) {
        key.weight /= totalWeight;
      });
    }
    _createClass(KeyStore, [{
      key: "get",
      value: function get(keyId) {
        return this._keyMap[keyId];
      }
    }, {
      key: "keys",
      value: function keys() {
        return this._keys;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return JSON.stringify(this._keys);
      }
    }]);
    return KeyStore;
  }();
  function createKey(key) {
    var path = null;
    var id = null;
    var src = null;
    var weight = 1;
    var getFn = null;
    if (isString(key) || isArray(key)) {
      src = key;
      path = createKeyPath(key);
      id = createKeyId(key);
    } else {
      if (!hasOwn.call(key, 'name')) {
        throw new Error(MISSING_KEY_PROPERTY('name'));
      }
      var name = key.name;
      src = name;
      if (hasOwn.call(key, 'weight')) {
        weight = key.weight;
        if (weight <= 0) {
          throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
        }
      }
      path = createKeyPath(name);
      id = createKeyId(name);
      getFn = key.getFn;
    }
    return {
      path: path,
      id: id,
      weight: weight,
      src: src,
      getFn: getFn
    };
  }
  function createKeyPath(key) {
    return isArray(key) ? key : key.split('.');
  }
  function createKeyId(key) {
    return isArray(key) ? key.join('.') : key;
  }

  function get(obj, path) {
    var list = [];
    var arr = false;
    var deepGet = function deepGet(obj, path, index) {
      if (!isDefined(obj)) {
        return;
      }
      if (!path[index]) {
        // If there's no path left, we've arrived at the object we care about.
        list.push(obj);
      } else {
        var key = path[index];
        var value = obj[key];
        if (!isDefined(value)) {
          return;
        }

        // If we're at the last value in the path, and if it's a string/number/bool,
        // add it to the list
        if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
          list.push(toString(value));
        } else if (isArray(value)) {
          arr = true;
          // Search each item in the array.
          for (var i = 0, len = value.length; i < len; i += 1) {
            deepGet(value[i], path, index + 1);
          }
        } else if (path.length) {
          // An object. Recurse further.
          deepGet(value, path, index + 1);
        }
      }
    };

    // Backwards compatibility (since path used to be a string)
    deepGet(obj, isString(path) ? path.split('.') : path, 0);
    return arr ? list : list[0];
  }

  var MatchOptions = {
    // Whether the matches should be included in the result set. When `true`, each record in the result
    // set will include the indices of the matched characters.
    // These can consequently be used for highlighting purposes.
    includeMatches: false,
    // When `true`, the matching function will continue to the end of a search pattern even if
    // a perfect match has already been located in the string.
    findAllMatches: false,
    // Minimum number of characters that must be matched before a result is considered a match
    minMatchCharLength: 1
  };
  var BasicOptions = {
    // When `true`, the algorithm continues searching to the end of the input even if a perfect
    // match is found before the end of the same input.
    isCaseSensitive: false,
    // When `true`, the algorithm will ignore diacritics (accents) in comparisons
    ignoreDiacritics: false,
    // When true, the matching function will continue to the end of a search pattern even if
    includeScore: false,
    // List of properties that will be searched. This also supports nested properties.
    keys: [],
    // Whether to sort the result list, by score
    shouldSort: true,
    // Default sort function: sort by ascending score, ascending index
    sortFn: function sortFn(a, b) {
      return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;
    }
  };
  var FuzzyOptions = {
    // Approximately where in the text is the pattern expected to be found?
    location: 0,
    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    // (of both letters and location), a threshold of '1.0' would match anything.
    threshold: 0.6,
    // Determines how close the match must be to the fuzzy location (specified above).
    // An exact letter match which is 'distance' characters away from the fuzzy location
    // would score as a complete mismatch. A distance of '0' requires the match be at
    // the exact location specified, a threshold of '1000' would require a perfect match
    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    distance: 100
  };
  var AdvancedOptions = {
    // When `true`, it enables the use of unix-like search commands
    useExtendedSearch: false,
    // The get function to use when fetching an object's properties.
    // The default will search nested paths *ie foo.bar.baz*
    getFn: get,
    // When `true`, search will ignore `location` and `distance`, so it won't matter
    // where in the string the pattern appears.
    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
    ignoreLocation: false,
    // When `true`, the calculation for the relevance score (used for sorting) will
    // ignore the field-length norm.
    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
    ignoreFieldNorm: false,
    // The weight to determine how much field length norm effects scoring.
    fieldNormWeight: 1
  };
  var Config = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);

  var SPACE = /[^ ]+/g;

  // Field-length norm: the shorter the field, the higher the weight.
  // Set to 3 decimals to reduce index size.
  function norm() {
    var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var mantissa = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    var cache = new Map();
    var m = Math.pow(10, mantissa);
    return {
      get: function get(value) {
        var numTokens = value.match(SPACE).length;
        if (cache.has(numTokens)) {
          return cache.get(numTokens);
        }

        // Default function is 1/sqrt(x), weight makes that variable
        var norm = 1 / Math.pow(numTokens, 0.5 * weight);

        // In place of `toFixed(mantissa)`, for faster computation
        var n = parseFloat(Math.round(norm * m) / m);
        cache.set(numTokens, n);
        return n;
      },
      clear: function clear() {
        cache.clear();
      }
    };
  }

  var FuseIndex = /*#__PURE__*/function () {
    function FuseIndex() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$getFn = _ref.getFn,
        getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn,
        _ref$fieldNormWeight = _ref.fieldNormWeight,
        fieldNormWeight = _ref$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref$fieldNormWeight;
      _classCallCheck(this, FuseIndex);
      this.norm = norm(fieldNormWeight, 3);
      this.getFn = getFn;
      this.isCreated = false;
      this.setIndexRecords();
    }
    _createClass(FuseIndex, [{
      key: "setSources",
      value: function setSources() {
        var docs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.docs = docs;
      }
    }, {
      key: "setIndexRecords",
      value: function setIndexRecords() {
        var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.records = records;
      }
    }, {
      key: "setKeys",
      value: function setKeys() {
        var _this = this;
        var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.keys = keys;
        this._keysMap = {};
        keys.forEach(function (key, idx) {
          _this._keysMap[key.id] = idx;
        });
      }
    }, {
      key: "create",
      value: function create() {
        var _this2 = this;
        if (this.isCreated || !this.docs.length) {
          return;
        }
        this.isCreated = true;

        // List is Array<String>
        if (isString(this.docs[0])) {
          this.docs.forEach(function (doc, docIndex) {
            _this2._addString(doc, docIndex);
          });
        } else {
          // List is Array<Object>
          this.docs.forEach(function (doc, docIndex) {
            _this2._addObject(doc, docIndex);
          });
        }
        this.norm.clear();
      }
      // Adds a doc to the end of the index
    }, {
      key: "add",
      value: function add(doc) {
        var idx = this.size();
        if (isString(doc)) {
          this._addString(doc, idx);
        } else {
          this._addObject(doc, idx);
        }
      }
      // Removes the doc at the specified index of the index
    }, {
      key: "removeAt",
      value: function removeAt(idx) {
        this.records.splice(idx, 1);

        // Change ref index of every subsquent doc
        for (var i = idx, len = this.size(); i < len; i += 1) {
          this.records[i].i -= 1;
        }
      }
    }, {
      key: "getValueForItemAtKeyId",
      value: function getValueForItemAtKeyId(item, keyId) {
        return item[this._keysMap[keyId]];
      }
    }, {
      key: "size",
      value: function size() {
        return this.records.length;
      }
    }, {
      key: "_addString",
      value: function _addString(doc, docIndex) {
        if (!isDefined(doc) || isBlank(doc)) {
          return;
        }
        var record = {
          v: doc,
          i: docIndex,
          n: this.norm.get(doc)
        };
        this.records.push(record);
      }
    }, {
      key: "_addObject",
      value: function _addObject(doc, docIndex) {
        var _this3 = this;
        var record = {
          i: docIndex,
          $: {}
        };

        // Iterate over every key (i.e, path), and fetch the value at that key
        this.keys.forEach(function (key, keyIndex) {
          var value = key.getFn ? key.getFn(doc) : _this3.getFn(doc, key.path);
          if (!isDefined(value)) {
            return;
          }
          if (isArray(value)) {
            var subRecords = [];
            var stack = [{
              nestedArrIndex: -1,
              value: value
            }];
            while (stack.length) {
              var _stack$pop = stack.pop(),
                nestedArrIndex = _stack$pop.nestedArrIndex,
                _value = _stack$pop.value;
              if (!isDefined(_value)) {
                continue;
              }
              if (isString(_value) && !isBlank(_value)) {
                var subRecord = {
                  v: _value,
                  i: nestedArrIndex,
                  n: _this3.norm.get(_value)
                };
                subRecords.push(subRecord);
              } else if (isArray(_value)) {
                _value.forEach(function (item, k) {
                  stack.push({
                    nestedArrIndex: k,
                    value: item
                  });
                });
              } else ;
            }
            record.$[keyIndex] = subRecords;
          } else if (isString(value) && !isBlank(value)) {
            var _subRecord = {
              v: value,
              n: _this3.norm.get(value)
            };
            record.$[keyIndex] = _subRecord;
          }
        });
        this.records.push(record);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          keys: this.keys,
          records: this.records
        };
      }
    }]);
    return FuseIndex;
  }();
  function createIndex(keys, docs) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$getFn = _ref2.getFn,
      getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn,
      _ref2$fieldNormWeight = _ref2.fieldNormWeight,
      fieldNormWeight = _ref2$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref2$fieldNormWeight;
    var myIndex = new FuseIndex({
      getFn: getFn,
      fieldNormWeight: fieldNormWeight
    });
    myIndex.setKeys(keys.map(createKey));
    myIndex.setSources(docs);
    myIndex.create();
    return myIndex;
  }
  function parseIndex(data) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$getFn = _ref3.getFn,
      getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn,
      _ref3$fieldNormWeight = _ref3.fieldNormWeight,
      fieldNormWeight = _ref3$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref3$fieldNormWeight;
    var keys = data.keys,
      records = data.records;
    var myIndex = new FuseIndex({
      getFn: getFn,
      fieldNormWeight: fieldNormWeight
    });
    myIndex.setKeys(keys);
    myIndex.setIndexRecords(records);
    return myIndex;
  }

  function computeScore$1(pattern) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$errors = _ref.errors,
      errors = _ref$errors === void 0 ? 0 : _ref$errors,
      _ref$currentLocation = _ref.currentLocation,
      currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,
      _ref$expectedLocation = _ref.expectedLocation,
      expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
      _ref$ignoreLocation = _ref.ignoreLocation,
      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
    var accuracy = errors / pattern.length;
    if (ignoreLocation) {
      return accuracy;
    }
    var proximity = Math.abs(expectedLocation - currentLocation);
    if (!distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + proximity / distance;
  }

  function convertMaskToIndices() {
    var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Config.minMatchCharLength;
    var indices = [];
    var start = -1;
    var end = -1;
    var i = 0;
    for (var len = matchmask.length; i < len; i += 1) {
      var match = matchmask[i];
      if (match && start === -1) {
        start = i;
      } else if (!match && start !== -1) {
        end = i - 1;
        if (end - start + 1 >= minMatchCharLength) {
          indices.push([start, end]);
        }
        start = -1;
      }
    }

    // (i-1 - start) + 1 => i - start
    if (matchmask[i - 1] && i - start >= minMatchCharLength) {
      indices.push([start, i - 1]);
    }
    return indices;
  }

  // Machine word size
  var MAX_BITS = 32;

  function search(text, pattern, patternAlphabet) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref$location = _ref.location,
      location = _ref$location === void 0 ? Config.location : _ref$location,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
      _ref$threshold = _ref.threshold,
      threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
      _ref$findAllMatches = _ref.findAllMatches,
      findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
      _ref$minMatchCharLeng = _ref.minMatchCharLength,
      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
      _ref$includeMatches = _ref.includeMatches,
      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
      _ref$ignoreLocation = _ref.ignoreLocation,
      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
    if (pattern.length > MAX_BITS) {
      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
    }
    var patternLen = pattern.length;
    // Set starting location at beginning text and initialize the alphabet.
    var textLen = text.length;
    // Handle the case when location > text.length
    var expectedLocation = Math.max(0, Math.min(location, textLen));
    // Highest score beyond which we give up.
    var currentThreshold = threshold;
    // Is there a nearby exact match? (speedup)
    var bestLocation = expectedLocation;

    // Performance: only computer matches when the minMatchCharLength > 1
    // OR if `includeMatches` is true.
    var computeMatches = minMatchCharLength > 1 || includeMatches;
    // A mask of the matches, used for building the indices
    var matchMask = computeMatches ? Array(textLen) : [];
    var index;

    // Get all exact matches, here for speed up
    while ((index = text.indexOf(pattern, bestLocation)) > -1) {
      var score = computeScore$1(pattern, {
        currentLocation: index,
        expectedLocation: expectedLocation,
        distance: distance,
        ignoreLocation: ignoreLocation
      });
      currentThreshold = Math.min(score, currentThreshold);
      bestLocation = index + patternLen;
      if (computeMatches) {
        var i = 0;
        while (i < patternLen) {
          matchMask[index + i] = 1;
          i += 1;
        }
      }
    }

    // Reset the best location
    bestLocation = -1;
    var lastBitArr = [];
    var finalScore = 1;
    var binMax = patternLen + textLen;
    var mask = 1 << patternLen - 1;
    for (var _i = 0; _i < patternLen; _i += 1) {
      // Scan for the best match; each iteration allows for one more error.
      // Run a binary search to determine how far from the match location we can stray
      // at this error level.
      var binMin = 0;
      var binMid = binMax;
      while (binMin < binMid) {
        var _score = computeScore$1(pattern, {
          errors: _i,
          currentLocation: expectedLocation + binMid,
          expectedLocation: expectedLocation,
          distance: distance,
          ignoreLocation: ignoreLocation
        });
        if (_score <= currentThreshold) {
          binMin = binMid;
        } else {
          binMax = binMid;
        }
        binMid = Math.floor((binMax - binMin) / 2 + binMin);
      }

      // Use the result from this iteration as the maximum for the next.
      binMax = binMid;
      var start = Math.max(1, expectedLocation - binMid + 1);
      var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;

      // Initialize the bit array
      var bitArr = Array(finish + 2);
      bitArr[finish + 1] = (1 << _i) - 1;
      for (var j = finish; j >= start; j -= 1) {
        var currentLocation = j - 1;
        var charMatch = patternAlphabet[text.charAt(currentLocation)];
        if (computeMatches) {
          // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
          matchMask[currentLocation] = +!!charMatch;
        }

        // First pass: exact match
        bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;

        // Subsequent passes: fuzzy match
        if (_i) {
          bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
        }
        if (bitArr[j] & mask) {
          finalScore = computeScore$1(pattern, {
            errors: _i,
            currentLocation: currentLocation,
            expectedLocation: expectedLocation,
            distance: distance,
            ignoreLocation: ignoreLocation
          });

          // This match will almost certainly be better than any existing match.
          // But check anyway.
          if (finalScore <= currentThreshold) {
            // Indeed it is
            currentThreshold = finalScore;
            bestLocation = currentLocation;

            // Already passed `loc`, downhill from here on in.
            if (bestLocation <= expectedLocation) {
              break;
            }

            // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
            start = Math.max(1, 2 * expectedLocation - bestLocation);
          }
        }
      }

      // No hope for a (better) match at greater error levels.
      var _score2 = computeScore$1(pattern, {
        errors: _i + 1,
        currentLocation: expectedLocation,
        expectedLocation: expectedLocation,
        distance: distance,
        ignoreLocation: ignoreLocation
      });
      if (_score2 > currentThreshold) {
        break;
      }
      lastBitArr = bitArr;
    }
    var result = {
      isMatch: bestLocation >= 0,
      // Count exact matches (those with a score of 0) to be "almost" exact
      score: Math.max(0.001, finalScore)
    };
    if (computeMatches) {
      var indices = convertMaskToIndices(matchMask, minMatchCharLength);
      if (!indices.length) {
        result.isMatch = false;
      } else if (includeMatches) {
        result.indices = indices;
      }
    }
    return result;
  }

  function createPatternAlphabet(pattern) {
    var mask = {};
    for (var i = 0, len = pattern.length; i < len; i += 1) {
      var _char = pattern.charAt(i);
      mask[_char] = (mask[_char] || 0) | 1 << len - i - 1;
    }
    return mask;
  }

  var stripDiacritics = String.prototype.normalize ? function (str) {
    return str.normalize('NFD').replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g, '');
  } : function (str) {
    return str;
  };

  var BitapSearch = /*#__PURE__*/function () {
    function BitapSearch(pattern) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$ignoreDiacritics = _ref.ignoreDiacritics,
        ignoreDiacritics = _ref$ignoreDiacritics === void 0 ? Config.ignoreDiacritics : _ref$ignoreDiacritics,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      _classCallCheck(this, BitapSearch);
      this.options = {
        location: location,
        threshold: threshold,
        distance: distance,
        includeMatches: includeMatches,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength,
        isCaseSensitive: isCaseSensitive,
        ignoreDiacritics: ignoreDiacritics,
        ignoreLocation: ignoreLocation
      };
      pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
      this.pattern = pattern;
      this.chunks = [];
      if (!this.pattern.length) {
        return;
      }
      var addChunk = function addChunk(pattern, startIndex) {
        _this.chunks.push({
          pattern: pattern,
          alphabet: createPatternAlphabet(pattern),
          startIndex: startIndex
        });
      };
      var len = this.pattern.length;
      if (len > MAX_BITS) {
        var i = 0;
        var remainder = len % MAX_BITS;
        var end = len - remainder;
        while (i < end) {
          addChunk(this.pattern.substr(i, MAX_BITS), i);
          i += MAX_BITS;
        }
        if (remainder) {
          var startIndex = len - MAX_BITS;
          addChunk(this.pattern.substr(startIndex), startIndex);
        }
      } else {
        addChunk(this.pattern, 0);
      }
    }
    _createClass(BitapSearch, [{
      key: "searchIn",
      value: function searchIn(text) {
        var _this$options = this.options,
          isCaseSensitive = _this$options.isCaseSensitive,
          ignoreDiacritics = _this$options.ignoreDiacritics,
          includeMatches = _this$options.includeMatches;
        text = isCaseSensitive ? text : text.toLowerCase();
        text = ignoreDiacritics ? stripDiacritics(text) : text;

        // Exact match
        if (this.pattern === text) {
          var _result = {
            isMatch: true,
            score: 0
          };
          if (includeMatches) {
            _result.indices = [[0, text.length - 1]];
          }
          return _result;
        }

        // Otherwise, use Bitap algorithm
        var _this$options2 = this.options,
          location = _this$options2.location,
          distance = _this$options2.distance,
          threshold = _this$options2.threshold,
          findAllMatches = _this$options2.findAllMatches,
          minMatchCharLength = _this$options2.minMatchCharLength,
          ignoreLocation = _this$options2.ignoreLocation;
        var allIndices = [];
        var totalScore = 0;
        var hasMatches = false;
        this.chunks.forEach(function (_ref2) {
          var pattern = _ref2.pattern,
            alphabet = _ref2.alphabet,
            startIndex = _ref2.startIndex;
          var _search = search(text, pattern, alphabet, {
              location: location + startIndex,
              distance: distance,
              threshold: threshold,
              findAllMatches: findAllMatches,
              minMatchCharLength: minMatchCharLength,
              includeMatches: includeMatches,
              ignoreLocation: ignoreLocation
            }),
            isMatch = _search.isMatch,
            score = _search.score,
            indices = _search.indices;
          if (isMatch) {
            hasMatches = true;
          }
          totalScore += score;
          if (isMatch && indices) {
            allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
          }
        });
        var result = {
          isMatch: hasMatches,
          score: hasMatches ? totalScore / this.chunks.length : 1
        };
        if (hasMatches && includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }]);
    return BitapSearch;
  }();

  var BaseMatch = /*#__PURE__*/function () {
    function BaseMatch(pattern) {
      _classCallCheck(this, BaseMatch);
      this.pattern = pattern;
    }
    _createClass(BaseMatch, [{
      key: "search",
      value: function search( /*text*/) {}
    }], [{
      key: "isMultiMatch",
      value: function isMultiMatch(pattern) {
        return getMatch(pattern, this.multiRegex);
      }
    }, {
      key: "isSingleMatch",
      value: function isSingleMatch(pattern) {
        return getMatch(pattern, this.singleRegex);
      }
    }]);
    return BaseMatch;
  }();
  function getMatch(pattern, exp) {
    var matches = pattern.match(exp);
    return matches ? matches[1] : null;
  }

  var ExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(ExactMatch, _BaseMatch);
    var _super = _createSuper(ExactMatch);
    function ExactMatch(pattern) {
      _classCallCheck(this, ExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(ExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text === this.pattern;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^="(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^=(.*)$/;
      }
    }]);
    return ExactMatch;
  }(BaseMatch);

  var InverseExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(InverseExactMatch, _BaseMatch);
    var _super = _createSuper(InverseExactMatch);
    function InverseExactMatch(pattern) {
      _classCallCheck(this, InverseExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(InverseExactMatch, [{
      key: "search",
      value: function search(text) {
        var index = text.indexOf(this.pattern);
        var isMatch = index === -1;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!(.*)$/;
      }
    }]);
    return InverseExactMatch;
  }(BaseMatch);

  var PrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(PrefixExactMatch, _BaseMatch);
    var _super = _createSuper(PrefixExactMatch);
    function PrefixExactMatch(pattern) {
      _classCallCheck(this, PrefixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(PrefixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text.startsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'prefix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^\^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^\^(.*)$/;
      }
    }]);
    return PrefixExactMatch;
  }(BaseMatch);

  var InversePrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(InversePrefixExactMatch, _BaseMatch);
    var _super = _createSuper(InversePrefixExactMatch);
    function InversePrefixExactMatch(pattern) {
      _classCallCheck(this, InversePrefixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(InversePrefixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = !text.startsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-prefix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!\^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!\^(.*)$/;
      }
    }]);
    return InversePrefixExactMatch;
  }(BaseMatch);

  var SuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(SuffixExactMatch, _BaseMatch);
    var _super = _createSuper(SuffixExactMatch);
    function SuffixExactMatch(pattern) {
      _classCallCheck(this, SuffixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(SuffixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text.endsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [text.length - this.pattern.length, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'suffix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^"(.*)"\$$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^(.*)\$$/;
      }
    }]);
    return SuffixExactMatch;
  }(BaseMatch);

  var InverseSuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(InverseSuffixExactMatch, _BaseMatch);
    var _super = _createSuper(InverseSuffixExactMatch);
    function InverseSuffixExactMatch(pattern) {
      _classCallCheck(this, InverseSuffixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(InverseSuffixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = !text.endsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-suffix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!"(.*)"\$$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!(.*)\$$/;
      }
    }]);
    return InverseSuffixExactMatch;
  }(BaseMatch);

  var FuzzyMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(FuzzyMatch, _BaseMatch);
    var _super = _createSuper(FuzzyMatch);
    function FuzzyMatch(pattern) {
      var _this;
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$ignoreDiacritics = _ref.ignoreDiacritics,
        ignoreDiacritics = _ref$ignoreDiacritics === void 0 ? Config.ignoreDiacritics : _ref$ignoreDiacritics,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      _classCallCheck(this, FuzzyMatch);
      _this = _super.call(this, pattern);
      _this._bitapSearch = new BitapSearch(pattern, {
        location: location,
        threshold: threshold,
        distance: distance,
        includeMatches: includeMatches,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength,
        isCaseSensitive: isCaseSensitive,
        ignoreDiacritics: ignoreDiacritics,
        ignoreLocation: ignoreLocation
      });
      return _this;
    }
    _createClass(FuzzyMatch, [{
      key: "search",
      value: function search(text) {
        return this._bitapSearch.searchIn(text);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'fuzzy';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^(.*)$/;
      }
    }]);
    return FuzzyMatch;
  }(BaseMatch);

  var IncludeMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(IncludeMatch, _BaseMatch);
    var _super = _createSuper(IncludeMatch);
    function IncludeMatch(pattern) {
      _classCallCheck(this, IncludeMatch);
      return _super.call(this, pattern);
    }
    _createClass(IncludeMatch, [{
      key: "search",
      value: function search(text) {
        var location = 0;
        var index;
        var indices = [];
        var patternLen = this.pattern.length;

        // Get all exact matches
        while ((index = text.indexOf(this.pattern, location)) > -1) {
          location = index + patternLen;
          indices.push([index, location - 1]);
        }
        var isMatch = !!indices.length;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: indices
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'include';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^'"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^'(.*)$/;
      }
    }]);
    return IncludeMatch;
  }(BaseMatch);

  // ❗Order is important. DO NOT CHANGE.
  var searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
  var searchersLen = searchers.length;

  // Regex to split by spaces, but keep anything in quotes together
  var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
  var OR_TOKEN = '|';

  // Return a 2D array representation of the query, for simpler parsing.
  // Example:
  // "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
  function parseQuery(pattern) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return pattern.split(OR_TOKEN).map(function (item) {
      var query = item.trim().split(SPACE_RE).filter(function (item) {
        return item && !!item.trim();
      });
      var results = [];
      for (var i = 0, len = query.length; i < len; i += 1) {
        var queryItem = query[i];

        // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
        var found = false;
        var idx = -1;
        while (!found && ++idx < searchersLen) {
          var searcher = searchers[idx];
          var token = searcher.isMultiMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options));
            found = true;
          }
        }
        if (found) {
          continue;
        }

        // 2. Handle single query matches (i.e, once that are *not* quoted)
        idx = -1;
        while (++idx < searchersLen) {
          var _searcher = searchers[idx];
          var _token = _searcher.isSingleMatch(queryItem);
          if (_token) {
            results.push(new _searcher(_token, options));
            break;
          }
        }
      }
      return results;
    });
  }

  // These extended matchers can return an array of matches, as opposed
  // to a singl match
  var MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

  /**
   * Command-like searching
   * ======================
   *
   * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
   * search in a given text.
   *
   * Search syntax:
   *
   * | Token       | Match type                 | Description                            |
   * | ----------- | -------------------------- | -------------------------------------- |
   * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
   * | `=scheme`   | exact-match                | Items that are `scheme`                |
   * | `'python`   | include-match              | Items that include `python`            |
   * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
   * | `^java`     | prefix-exact-match         | Items that start with `java`           |
   * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
   * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
   * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
   *
   * A single pipe character acts as an OR operator. For example, the following
   * query matches entries that start with `core` and end with either`go`, `rb`,
   * or`py`.
   *
   * ```
   * ^core go$ | rb$ | py$
   * ```
   */
    var ExtendedSearch = /*#__PURE__*/function () {
        function ExtendedSearch(pattern) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$isCaseSensitive = _ref.isCaseSensitive,
            isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
            _ref$ignoreDiacritics = _ref.ignoreDiacritics,
            ignoreDiacritics = _ref$ignoreDiacritics === void 0 ? Config.ignoreDiacritics : _ref$ignoreDiacritics,
            _ref$includeMatches = _ref.includeMatches,
            includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
            _ref$minMatchCharLeng = _ref.minMatchCharLength,
            minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
            _ref$ignoreLocation = _ref.ignoreLocation,
            ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation,
            _ref$findAllMatches = _ref.findAllMatches,
            findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
            _ref$location = _ref.location,
            location = _ref$location === void 0 ? Config.location : _ref$location,
            _ref$threshold = _ref.threshold,
            threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
            _ref$distance = _ref.distance,
            distance = _ref$distance === void 0 ? Config.distance : _ref$distance;
        _classCallCheck(this, ExtendedSearch);
        this.query = null;
        this.options = {
            isCaseSensitive: isCaseSensitive,
            ignoreDiacritics: ignoreDiacritics,
            includeMatches: includeMatches,
            minMatchCharLength: minMatchCharLength,
            findAllMatches: findAllMatches,
            ignoreLocation: ignoreLocation,
            location: location,
            threshold: threshold,
            distance: distance
        };
        pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
        pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
        this.pattern = pattern;
        this.query = parseQuery(this.pattern, this.options);
        }
        _createClass(ExtendedSearch, [{
        key: "searchIn",
        value: function searchIn(text) {
            var query = this.query;
            if (!query) {
            return {
                isMatch: false,
                score: 1
            };
            }
            var _this$options = this.options,
            includeMatches = _this$options.includeMatches,
            isCaseSensitive = _this$options.isCaseSensitive,
            ignoreDiacritics = _this$options.ignoreDiacritics;
            text = isCaseSensitive ? text : text.toLowerCase();
            text = ignoreDiacritics ? stripDiacritics(text) : text;
            var numMatches = 0;
            var allIndices = [];
            var totalScore = 0;

            // ORs
            for (var i = 0, qLen = query.length; i < qLen; i += 1) {
            var searchers = query[i];

            // Reset indices
            allIndices.length = 0;
            numMatches = 0;

            // ANDs
            for (var j = 0, pLen = searchers.length; j < pLen; j += 1) {
                var searcher = searchers[j];
                var _searcher$search = searcher.search(text),
                isMatch = _searcher$search.isMatch,
                indices = _searcher$search.indices,
                score = _searcher$search.score;
                if (isMatch) {
                numMatches += 1;
                totalScore += score;
                if (includeMatches) {
                    var type = searcher.constructor.type;
                    if (MultiMatchSet.has(type)) {
                    allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
                    } else {
                    allIndices.push(indices);
                    }
                }
                } else {
                totalScore = 0;
                numMatches = 0;
                allIndices.length = 0;
                break;
                }
            }

            // OR condition, so if TRUE, return
            if (numMatches) {
                var result = {
                isMatch: true,
                score: totalScore / numMatches
                };
                if (includeMatches) {
                result.indices = allIndices;
                }
                return result;
            }
            }

            // Nothing was matched
            return {
            isMatch: false,
            score: 1
            };
        }
        }], [{
        key: "condition",
        value: function condition(_, options) {
            return options.useExtendedSearch;
        }
        }]);
        return ExtendedSearch;
    }();

    var registeredSearchers = [];
    function register() {
        registeredSearchers.push.apply(registeredSearchers, arguments);
    }
    function createSearcher(pattern, options) {
        for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {
        var searcherClass = registeredSearchers[i];
        if (searcherClass.condition(pattern, options)) {
            return new searcherClass(pattern, options);
        }
        }
        return new BitapSearch(pattern, options);
    }

    var LogicalOperator = {
        AND: '$and',
        OR: '$or'
    };
    var KeyType = {
        PATH: '$path',
        PATTERN: '$val'
    };
    var isExpression = function isExpression(query) {
        return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
    };
    var isPath = function isPath(query) {
        return !!query[KeyType.PATH];
    };
    var isLeaf = function isLeaf(query) {
        return !isArray(query) && isObject(query) && !isExpression(query);
    };
    var convertToExplicit = function convertToExplicit(query) {
        return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function (key) {
        return _defineProperty({}, key, query[key]);
        }));
    };

    // When `auto` is `true`, the parse function will infer and initialize and add
    // the appropriate `Searcher` instance
    function parse(query, options) {
        var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref3$auto = _ref3.auto,
        auto = _ref3$auto === void 0 ? true : _ref3$auto;
        var next = function next(query) {
        var keys = Object.keys(query);
        var isQueryPath = isPath(query);
        if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
            return next(convertToExplicit(query));
        }
        if (isLeaf(query)) {
            var key = isQueryPath ? query[KeyType.PATH] : keys[0];
            var pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];
            if (!isString(pattern)) {
            throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
            }
            var obj = {
            keyId: createKeyId(key),
            pattern: pattern
            };
            if (auto) {
            obj.searcher = createSearcher(pattern, options);
            }
            return obj;
        }
        var node = {
            children: [],
            operator: keys[0]
        };
        keys.forEach(function (key) {
            var value = query[key];
            if (isArray(value)) {
            value.forEach(function (item) {
                node.children.push(next(item));
            });
            }
        });
        return node;
        };
        if (!isExpression(query)) {
        query = convertToExplicit(query);
        }
        return next(query);
    }

    // Practical scoring function
    function computeScore(results, _ref) {
        var _ref$ignoreFieldNorm = _ref.ignoreFieldNorm,
        ignoreFieldNorm = _ref$ignoreFieldNorm === void 0 ? Config.ignoreFieldNorm : _ref$ignoreFieldNorm;
        results.forEach(function (result) {
        var totalScore = 1;
        result.matches.forEach(function (_ref2) {
            var key = _ref2.key,
            norm = _ref2.norm,
            score = _ref2.score;
            var weight = key ? key.weight : null;
            totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));
        });
        result.score = totalScore;
        });
    }

    function transformMatches(result, data) {
        var matches = result.matches;
        data.matches = [];
        if (!isDefined(matches)) {
        return;
        }
        matches.forEach(function (match) {
        if (!isDefined(match.indices) || !match.indices.length) {
            return;
        }
        var indices = match.indices,
            value = match.value;
        var obj = {
            indices: indices,
            value: value
        };
        if (match.key) {
            obj.key = match.key.src;
        }
        if (match.idx > -1) {
            obj.refIndex = match.idx;
        }
        data.matches.push(obj);
        });
    }

    function transformScore(result, data) {
        data.score = result.score;
    }

    function format(results, docs) {
        var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$includeScore = _ref.includeScore,
        includeScore = _ref$includeScore === void 0 ? Config.includeScore : _ref$includeScore;
        var transformers = [];
        if (includeMatches) transformers.push(transformMatches);
        if (includeScore) transformers.push(transformScore);
        return results.map(function (result) {
        var idx = result.idx;
        var data = {
            item: docs[idx],
            refIndex: idx
        };
        if (transformers.length) {
            transformers.forEach(function (transformer) {
            transformer(result, data);
            });
        }
        return data;
        });
    }

    var Fuse$1 = /*#__PURE__*/function () {
        function Fuse(docs) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var index = arguments.length > 2 ? arguments[2] : undefined;
        _classCallCheck(this, Fuse);
        this.options = _objectSpread2(_objectSpread2({}, Config), options);
        if (this.options.useExtendedSearch && !true) {
            throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
        }
        this._keyStore = new KeyStore(this.options.keys);
        this.setCollection(docs, index);
        }
        _createClass(Fuse, [{
        key: "setCollection",
        value: function setCollection(docs, index) {
            this._docs = docs;
            if (index && !(index instanceof FuseIndex)) {
            throw new Error(INCORRECT_INDEX_TYPE);
            }
            this._myIndex = index || createIndex(this.options.keys, this._docs, {
            getFn: this.options.getFn,
            fieldNormWeight: this.options.fieldNormWeight
            });
        }
        }, {
        key: "add",
        value: function add(doc) {
            if (!isDefined(doc)) {
            return;
            }
            this._docs.push(doc);
            this._myIndex.add(doc);
        }
        }, {
        key: "remove",
        value: function remove() {
            var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function /* doc, idx */ () {
            return false;
            };
            var results = [];
            for (var i = 0, len = this._docs.length; i < len; i += 1) {
            var doc = this._docs[i];
            if (predicate(doc, i)) {
                this.removeAt(i);
                i -= 1;
                len -= 1;
                results.push(doc);
            }
            }
            return results;
        }
        }, {
        key: "removeAt",
        value: function removeAt(idx) {
            this._docs.splice(idx, 1);
            this._myIndex.removeAt(idx);
        }
        }, {
        key: "getIndex",
        value: function getIndex() {
            return this._myIndex;
        }
        }, {
        key: "search",
        value: function search(query) {
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$limit = _ref.limit,
            limit = _ref$limit === void 0 ? -1 : _ref$limit;
            var _this$options = this.options,
            includeMatches = _this$options.includeMatches,
            includeScore = _this$options.includeScore,
            shouldSort = _this$options.shouldSort,
            sortFn = _this$options.sortFn,
            ignoreFieldNorm = _this$options.ignoreFieldNorm;
            var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
            computeScore(results, {
            ignoreFieldNorm: ignoreFieldNorm
            });
            if (shouldSort) {
            results.sort(sortFn);
            }
            if (isNumber(limit) && limit > -1) {
            results = results.slice(0, limit);
            }
            return format(results, this._docs, {
            includeMatches: includeMatches,
            includeScore: includeScore
            });
        }
        }, {
        key: "_searchStringList",
        value: function _searchStringList(query) {
            var searcher = createSearcher(query, this.options);
            var records = this._myIndex.records;
            var results = [];

            // Iterate over every string in the index
            records.forEach(function (_ref2) {
            var text = _ref2.v,
                idx = _ref2.i,
                norm = _ref2.n;
            if (!isDefined(text)) {
                return;
            }
            var _searcher$searchIn = searcher.searchIn(text),
                isMatch = _searcher$searchIn.isMatch,
                score = _searcher$searchIn.score,
                indices = _searcher$searchIn.indices;
            if (isMatch) {
                results.push({
                item: text,
                idx: idx,
                matches: [{
                    score: score,
                    value: text,
                    norm: norm,
                    indices: indices
                }]
                });
            }
            });
            return results;
        }
        }, {
        key: "_searchLogical",
        value: function _searchLogical(query) {
            var _this = this;
            var expression = parse(query, this.options);
            var evaluate = function evaluate(node, item, idx) {
            if (!node.children) {
                var keyId = node.keyId,
                searcher = node.searcher;
                var matches = _this._findMatches({
                key: _this._keyStore.get(keyId),
                value: _this._myIndex.getValueForItemAtKeyId(item, keyId),
                searcher: searcher
                });
                if (matches && matches.length) {
                return [{
                    idx: idx,
                    item: item,
                    matches: matches
                }];
                }
                return [];
            }
            var res = [];
            for (var i = 0, len = node.children.length; i < len; i += 1) {
                var child = node.children[i];
                var result = evaluate(child, item, idx);
                if (result.length) {
                res.push.apply(res, _toConsumableArray(result));
                } else if (node.operator === LogicalOperator.AND) {
                return [];
                }
            }
            return res;
            };
            var records = this._myIndex.records;
            var resultMap = {};
            var results = [];
            records.forEach(function (_ref3) {
            var item = _ref3.$,
                idx = _ref3.i;
            if (isDefined(item)) {
                var expResults = evaluate(expression, item, idx);
                if (expResults.length) {
                // Dedupe when adding
                if (!resultMap[idx]) {
                    resultMap[idx] = {
                    idx: idx,
                    item: item,
                    matches: []
                    };
                    results.push(resultMap[idx]);
                }
                expResults.forEach(function (_ref4) {
                    var _resultMap$idx$matche;
                    var matches = _ref4.matches;
                    (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));
                });
                }
            }
            });
            return results;
        }
        }, {
        key: "_searchObjectList",
        value: function _searchObjectList(query) {
            var _this2 = this;
            var searcher = createSearcher(query, this.options);
            var _this$_myIndex = this._myIndex,
            keys = _this$_myIndex.keys,
            records = _this$_myIndex.records;
            var results = [];

            // List is Array<Object>
            records.forEach(function (_ref5) {
            var item = _ref5.$,
                idx = _ref5.i;
            if (!isDefined(item)) {
                return;
            }
            var matches = [];

            // Iterate over every key (i.e, path), and fetch the value at that key
            keys.forEach(function (key, keyIndex) {
                matches.push.apply(matches, _toConsumableArray(_this2._findMatches({
                key: key,
                value: item[keyIndex],
                searcher: searcher
                })));
            });
            if (matches.length) {
                results.push({
                idx: idx,
                item: item,
                matches: matches
                });
            }
            });
            return results;
        }
        }, {
        key: "_findMatches",
        value: function _findMatches(_ref6) {
            var key = _ref6.key,
            value = _ref6.value,
            searcher = _ref6.searcher;
            if (!isDefined(value)) {
            return [];
            }
            var matches = [];
            if (isArray(value)) {
            value.forEach(function (_ref7) {
                var text = _ref7.v,
                idx = _ref7.i,
                norm = _ref7.n;
                if (!isDefined(text)) {
                return;
                }
                var _searcher$searchIn2 = searcher.searchIn(text),
                isMatch = _searcher$searchIn2.isMatch,
                score = _searcher$searchIn2.score,
                indices = _searcher$searchIn2.indices;
                if (isMatch) {
                matches.push({
                    score: score,
                    key: key,
                    value: text,
                    idx: idx,
                    norm: norm,
                    indices: indices
                });
                }
            });
            } else {
            var text = value.v,
                norm = value.n;
            var _searcher$searchIn3 = searcher.searchIn(text),
                isMatch = _searcher$searchIn3.isMatch,
                score = _searcher$searchIn3.score,
                indices = _searcher$searchIn3.indices;
            if (isMatch) {
                matches.push({
                score: score,
                key: key,
                value: text,
                norm: norm,
                indices: indices
                });
            }
            }
            return matches;
        }
        }]);
        return Fuse;
    }();

    Fuse$1.version = '7.1.0';
    Fuse$1.createIndex = createIndex;
    Fuse$1.parseIndex = parseIndex;
    Fuse$1.config = Config;
    {
        Fuse$1.parseQuery = parse;
    }
    {
        register(ExtendedSearch);
    }
    var Fuse = Fuse$1;

    return Fuse;

    }));
    // <!-- END OF FUSE.MIN.JS CODE -->
    </script>
</head>
<body>
    <h1>VBA 全能查詢工具 (離線版)</h1>

    <div id="searchHeader">
        <input type="text" id="searchBox" placeholder="輸入查詢詞（例如：cell, 儲存格, mail, automation）" onkeyup="handleSearch()">
        <div id="navigationButtons">
            <a href="javascript:void(0);" onclick="showContentPage('pageUsageGuide')" class="nav-button">使用方法</a>
            <a href="javascript:void(0);" onclick="showContentPage('pageNoviceToAdvanced')" class="nav-button">新手進階</a>
            <a href="javascript:void(0);" onclick="showContentPage('pagePathToMastery')" class="nav-button">邁向頂尖</a>
        </div>
    </div>

    <div id="commandStats"></div>

    <!-- 主查詢界面容器 -->
    <div id="mainQueryInterface">
        <div id="searchResultsContainer">
            <div id="results"></div>
            <div id="details"></div>
        </div>
        <div id="directory"></div>
    </div>

    <!-- 新增內容頁面容器 START -->
    <div id="pageUsageGuide" class="content-page">
        <div class="content-page-inner-container">
            <h1>VBA全能查詢工具 - 使用方法指南</h1>
            <p>您好！我是 Nathan。從一個 VBA 新手，一路摸索到今天，總算積累了一些心得。制作此工具的目標是要成為世界上最好用的VBA查詢工具，希望您也喜歡。本指南將引導你如何有效地使用這個工具，以及一些 VBA 的基礎操作。</p>
            <h2>如何使用本查詢工具</h2>
            <p>本工具旨在提供一個快速、離線的 VBA 指令查詢方式。</p>
            <ul>
                <li><strong>關鍵詞搜索</strong>：在頁面上方的搜索框輸入你想要查詢的 VBA 指令、功能描述或相關關鍵詞（例如：<code>cell</code>, <code>儲存格</code>, <code>mail</code>, <code>automation</code>）。系統會實時顯示匹配的結果。</li>
                <li><strong>指令目錄瀏覽</strong>：在搜索框清空時，頁面會展示按功能分類的 VBA 指令目錄。你可以點擊分類標題展開或收起該分類下的指令列表。</li>
                <li><strong>查看指令詳情</strong>：點擊搜索結果中的任一指令，或目錄中的指令，頁面下方會展示該指令的詳細說明，包括：
                    <ul>
                        <li><strong>分類</strong>：指令所屬的功能類別。</li>
                        <li><strong>語法 (Syntax)</strong>：指令的標準寫法。</li>
                        <li><strong>說明 (Description)</strong>：對指令功能的簡要解釋。</li>
                        <li><strong>參數 (Parameters)</strong>：指令所需的各個參數及其說明（如果適用）。</li>
                        <li><strong>範例 (Examples)</strong>：一至多個實際代碼範例及其解釋，助你理解如何使用。</li>
                        <li><strong>關鍵詞 (Keywords)</strong>：與該指令相關的搜索關鍵詞。</li>
                    </ul>
                </li>
                <li><strong>關閉詳情視圖</strong>：在指令詳情區域的右上角，點擊 "×" 按鈕即可關閉詳情視圖，返回搜索結果或目錄。</li>
                <li><strong>快速清空搜索</strong>：在搜索框中按 <code>Esc</code> 鍵可以快速清空搜索內容，並返回目錄視圖。</li>
            </ul>
            <h2>VBA基礎：添加與運行代碼</h2>
            <p>要在 Excel (或其他 Office 應用程式) 中使用 VBA，你需要通過 VBA 編輯器 (VBE) 添加和運行代碼。</p>
            <h3>1. 打開 VBA 編輯器 (VBE)</h3>
            <ul>
                <li>在 Excel 中，最快的方式是按快捷鍵 <code>Alt + F11</code>。</li>
                <li>或者，如果你的 Excel 功能區顯示了「開發工具」選項卡，可以點擊該選項卡，然後點擊「Visual Basic」按鈕。
                    <br>(如果沒有「開發工具」選項卡，請到「檔案」>「選項」>「自訂功能區」，在右側勾選「開發工具」。)</li>
            </ul>
            <h3>2. 插入模塊 (Module)</h3>
            <p>VBA 代碼通常寫在模塊中。</p>
            <ul>
                <li>在 VBE 中，查看左上方的「專案總管」窗口。如果看不到，可以按 <code>Ctrl + R</code> 或點擊「檢視」>「專案總管」。</li>
                <li>在你的活頁簿專案上（例如 `VBAProject (你的文件名.xlsx)`）點擊右鍵。</li>
                <li>選擇「插入」>「模塊」。一個新的模塊（例如 `Module1`）會出現在「模塊」資料夾下，並在右側打開一個空白的代碼窗口。</li>
            </ul>
            <h3>3. 粘貼或編寫代碼</h3>
            <p>將你從本手冊或其他地方獲取的 VBA 代碼，複製並粘貼到打開的模塊代碼窗口中。或者，你也可以直接在此窗口編寫自己的代碼。</p>
            <p>一個典型的 VBA 過程以 <code>Sub 過程名稱()</code> 開始，以 <code>End Sub</code> 結束；或者以 <code>Function 函數名稱() As 返回類型</code> 開始，以 <code>End Function</code> 結束。</p>
            <h3>4. 運行 VBA 宏 (Sub 過程)</h3>
            <p>有多種方式可以運行一個 <code>Sub</code> 過程（通常稱為宏）：</p>
            <ul>
                <li><strong>從 VBE 運行</strong>：
                    <ol>
                        <li>將光標置於你想要運行的 <code>Sub</code> 過程內的任何位置。</li>
                        <li>按 <code>F5</code> 鍵，或點擊工具欄上的「運行」按鈕（綠色箭頭圖標），或點擊「運行」>「運行 Sub/使用者表單」。</li>
                    </ol>
                </li>
                <li><strong>從 Excel 界面運行</strong>：
                    <ol>
                        <li>回到 Excel 主界面。</li>
                        <li>點擊「開發工具」選項卡中的「宏」按鈕。</li>
                        <li>在彈出的「宏」對話框中，選擇你想要運行的宏的名稱，然後點擊「執行」。</li>
                    </ol>
                </li>
                <li><strong>分配給按鈕或圖形</strong>：
                    <ol>
                        <li>在 Excel 工作表上插入一個按鈕（「開發工具」>「插入」>「按鈕 (表單控制項)」）或任何圖形。</li>
                        <li>如果是表單按鈕，繪製後會自動弹出「指定宏」對話框；如果是圖形，則在圖形上點擊右鍵，選擇「指定宏」。</li>
                        <li>選擇要分配給此按鈕/圖形的宏，然後點擊「確定」。之後點擊此按鈕/圖形即可運行宏。</li>
                    </ol>
                </li>
                <li><strong>使用快捷鍵</strong>：
                    <ol>
                        <li>在「宏」對話框中，選中一個宏，點擊「選項」。</li>
                        <li>在「快速鍵」框中輸入一個字母（例如 `q`），則快捷鍵變為 <code>Ctrl + q</code> (小寫) 或 <code>Ctrl + Shift + Q</code> (大寫)。注意避免與系統或其他常用快捷鍵衝突。</li>
                    </ol>
                </li>
            </ul>
            <p class="note"><strong>注意</strong>：包含 VBA 代碼的 Excel 文件通常需要另存為啟用宏的活頁簿 (<code>.xlsm</code> 格式)。打開這類文件時，Excel 可能會出於安全原因禁用宏，你需要點擊訊息列上的「啟用內容」按鈕才能運行宏。</p>
            <h2>VBA基礎：錄製宏</h2>
            <p>錄製宏是學習 VBA 語法和探索 Office 對象模型的一個好方法，尤其對於初學者。</p>
            <h3>如何錄製宏：</h3>
            <ol>
                <li>在 Excel 中，點擊「開發工具」選項卡上的「錄製宏」按鈕。</li>
                <li>(可選) 在「錄製宏」對話框中，為你的宏命名（不能有空格或特殊字符），分配快捷鍵，選擇保存位置，並添加描述。然後點擊「確定」。</li>
                <li>此時，Excel 會開始記錄你在界面上執行的幾乎所有操作。執行你想要自動化的步驟。</li>
                <li>完成操作後，點擊「開發工具」選項卡上的「停止錄製」按鈕。</li>
            </ol>
            <h3>查看和修改錄製的代碼：</h3>
            <ul>
                <li>按 <code>Alt + F11</code> 打開 VBE。</li>
                <li>在「專案總管」中找到一個新創建的模塊（通常是 `Module1`, `Module2` 等），雙擊打開它。</li>
                <li>你將看到錄製的 VBA 代碼。</li>
            </ul>
            <h3>錄製宏的優點和局限性：</h3>
            <ul>
                <li><strong>優點</strong>：
                    <ul>
                        <li>快速生成執行特定界面操作的代碼。</li>
                        <li>幫助發現完成某任務所需的 VBA 對象、屬性和方法。</li>
                        <li>是學習語法的好起點。</li>
                    </ul>
                </li>
                <li><strong>局限性</strong>：
                    <ul>
                        <li>錄製的代碼通常效率不高，包含很多不必要的選擇 (<code>.Select</code>, <code>ActiveCell</code>) 和屏幕滾動操作。</li>
                        <li>無法錄製循環、條件判斷、變量操作、錯誤處理等邏輯控制。</li>
                        <li>對於複雜或動態的任務，錄製的代碼往往缺乏靈活性。</li>
                    </ul>
                </li>
            </ul>
            <p>因此，建議將錄製宏作為一種學習工具，然後手動修改和優化錄製的代碼，或者作為理解如何與特定對象互動的參考，再編寫更高效、更健壯的自訂代碼。</p>
            <h2>常見 VBA 運行時錯誤代碼、說明及解決建議</h2>
            <p>在編寫和運行 VBA 代碼時，遇到運行時錯誤是家常便飯。理解這些錯誤的含義並知道如何解決它們，是 VBA 開發的關鍵技能。以下是一些常見的 VBA 運行時錯誤及其處理建議：</p>
            <table>
                <thead>
                    <tr>
                        <th>錯誤代碼</th>
                        <th>錯誤訊息 (英文/中文參考)</th>
                        <th>可能原因與說明</th>
                        <th>具體解決建議</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>5</td>
                        <td>Invalid procedure call or argument<br>無效的過程呼叫或參數</td>
                        <td>試圖呼叫一個不存在的過程，或者傳遞給過程的參數數量、類型不正確，或參數值超出有效範圍。</td>
                        <td>檢查過程名稱拼寫是否正確；核對傳遞的參數數量、順序和數據類型是否與過程定義相符；確保參數值在允許範圍內（例如，<code>Mid</code>函數的起始位置不能為0或負數）。</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>Overflow<br>溢位</td>
                        <td>試圖將一個超出其數據類型所能容納範圍的值賦給變量。例如，將一個大於 32,767 的數賦給 <code>Integer</code> 類型變量。</td>
                        <td>為變量選擇一個能容納更大數據範圍的數據類型，例如將 <code>Integer</code> 改為 <code>Long</code>，或將 <code>Single</code> 改為 <code>Double</code>。檢查計算過程中是否有中間結果超出預期。</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>Out of memory<br>記憶體不足</td>
                        <td>VBA 或應用程式耗盡了可用的內存。通常發生在處理非常大的數據集、創建過多對象或無限循環時。</td>
                        <td>優化代碼以減少內存使用：及時釋放不再需要的對象 (<code>Set obj = Nothing</code>)；分批處理大數據；避免在循環中創建大量字符串或對象；檢查是否有無限循環。增加系統可用內存或關閉其他耗內存的程式。</td>
                    </tr>
                    <tr>
                        <td>9</td>
                        <td>Subscript out of range<br>下標超出範圍</td>
                        <td>試圖訪問數組中一個不存在的索引（下標），或者試圖訪問集合中一個不存在的成員（使用索引或鍵名）。</td>
                        <td>檢查數組索引是否在 <code>LBound</code> 和 <code>UBound</code> 之間；確保集合的鍵名拼寫正確，或者索引在 1 到 <code>Collection.Count</code> (或 0 到 <code>Dictionary.Count - 1</code>) 之間。使用調試器查看數組或集合的實際大小和內容。</td>
                    </tr>
                    <tr>
                        <td>11</td>
                        <td>Division by zero<br>除以零</td>
                        <td>在表達式中執行了除以零的運算。</td>
                        <td>在執行除法運算前，檢查除數是否為零。例如：<code>If divisor <> 0 Then result = dividend / divisor Else result = 0 ' 或其他錯誤處理</code>。</td>
                    </tr>
                    <tr>
                        <td>13</td>
                        <td>Type mismatch<br>類型不符</td>
                        <td>試圖對不同數據類型的變量或值執行不兼容的操作，或者將不兼容類型的值賦給變量。例如，試圖將文本字符串與數字相加，或將文本賦給日期型變量而未正確轉換。</td>
                        <td>確保操作數的數據類型兼容；使用轉換函數（如 <code>CInt</code>, <code>CStr</code>, <code>CDate</code>, <code>CDbl</code>, <code>Val</code>）將數據轉換為正確的類型後再進行操作或賦值；檢查函數參數是否傳遞了正確的數據類型。</td>
                    </tr>
                    <tr>
                        <td>48</td>
                        <td>Error in loading DLL<br>載入 DLL 時發生錯誤</td>
                        <td>VBA 嘗試載入一個動態連結程式庫 (DLL) 失敗，可能是因為 DLL 文件丟失、損壞、版本不兼容，或者 (在64位Office中) <code>Declare</code> 語句未使用 <code>PtrSafe</code> 關鍵字。</td>
                        <td>確認 DLL 文件存在於指定路徑或系統路徑中；確保 DLL 是為當前操作系統和 Office 位數 (32位/64位) 設計的；如果是自訂的 DLL，可能需要重新註冊；在64位 Office 中，確保 API 的 <code>Declare</code> 語句使用了 <code>PtrSafe</code> 關鍵字，並且指針類型使用了 <code>LongPtr</code>。</td>
                    </tr>
                    <tr>
                        <td>53</td>
                        <td>File not found<br>找不到檔案</td>
                        <td>試圖訪問一個不存在的文件，或者路徑不正確。</td>
                        <td>檢查文件路徑和文件名是否拼寫正確；確認文件確實存在於指定位置；如果使用相對路徑，確認當前目錄 (<code>CurDir</code>) 是否正確。可以使用 <code>Dir()</code> 函數或 <code>FileSystemObject.FileExists()</code> 檢查文件是否存在。</td>
                    </tr>
                    <tr>
                        <td>58</td>
                        <td>File already exists<br>檔案已存在</td>
                        <td>試圖使用一個已存在的名稱來創建或重命名文件 (例如使用 <code>Name</code> 語句或 <code>FileSystemObject.CreateTextFile</code> 而未指定覆蓋)。</td>
                        <td>在創建或重命名前，先檢查目標文件名是否已存在；如果允許覆蓋，則在操作前刪除舊文件 (使用 <code>Kill</code> 或 <code>FSO.DeleteFile</code>) 或使用允許覆蓋的選項 (如 <code>FSO.CreateTextFile(path, True)</code>)。</td>
                    </tr>
                    <tr>
                        <td>62</td>
                        <td>Input past end of file<br>讀取超過檔案結尾</td>
                        <td>使用 <code>Input #</code> 或 <code>Line Input #</code> 等語句試圖從一個已經到達文件結尾 (EOF) 的循序檔案中讀取數據。</td>
                        <td>在讀取循環中使用 <code>EOF(fileNumber)</code> 函數來判斷是否已到達文件結尾。例如：<code>Do While Not EOF(1) ... Loop</code>。</td>
                    </tr>
                    <tr>
                        <td>70</td>
                        <td>Permission denied<br>權限不足</td>
                        <td>試圖執行的操作因權限不足而失敗。例如，試圖寫入一個唯讀文件，或訪問一個沒有權限的文件夾或註冊表項。</td>
                        <td>檢查文件或文件夾的屬性，確保沒有設定唯讀；確認當前用戶具有執行該操作所需的權限；如果操作涉及網絡資源，檢查網絡權限。</td>
                    </tr>
                    <tr>
                        <td>75</td>
                        <td>Path/File access error<br>路徑/檔案存取錯誤</td>
                        <td>路徑無效，或者試圖訪問一個正在被其他程序使用的文件，或者文件名/路徑名格式不正確。</td>
                        <td>檢查路徑是否有效，文件名是否包含非法字符；確保文件沒有被其他應用程式鎖定；嘗試關閉可能正在使用該文件的其他程序。</td>
                    </tr>
                    <tr>
                        <td>76</td>
                        <td>Path not found<br>找不到路徑</td>
                        <td>指定的文件夾路徑不存在。</td>
                        <td>檢查路徑是否拼寫正確；確認路徑中的所有文件夾都實際存在。可以使用 <code>FileSystemObject.FolderExists()</code> 檢查路徑。</td>
                    </tr>
                    <tr>
                        <td>91</td>
                        <td>Object variable or With block variable not set<br>物件變數或 With 區塊變數未設定</td>
                        <td>試圖使用一個尚未被賦予有效對象引用的對象變量。即該變量的值是 <code>Nothing</code>。</td>
                        <td>在使用對象變量之前，確保已使用 <code>Set</code> 語句將其賦值給一個有效的對象實例 (例如，<code>Set ws = ThisWorkbook.Sheets(1)</code> 或 <code>Set fso = CreateObject("Scripting.FileSystemObject")</code>)。檢查 <code>Set</code> 語句是否成功執行。</td>
                    </tr>
                    <tr>
                        <td>94</td>
                        <td>Invalid use of Null<br>無效使用 Null</td>
                        <td>試圖在不允許使用 <code>Null</code> 值的表達式或操作中使用 <code>Null</code>。常見於從資料庫讀取數據時，某些字段可能包含 <code>Null</code>。</td>
                        <td>在使用可能為 <code>Null</code> 的變量前，使用 <code>IsNull()</code> 函數進行檢查。例如：<code>If Not IsNull(myVar) Then ...</code>。如果需要將 <code>Null</code> 轉換為其他值，可以使用 <code>Nz(myVar, defaultValue)</code> (Access VBA 中) 或類似的邏輯。</td>
                    </tr>
                    <tr>
                        <td>1004</td>
                        <td>Application-defined or object-defined error<br>應用程式定義或物件定義的錯誤</td>
                        <td>這是 Excel (或其他 Office 應用程式) 特有的一個通用錯誤代碼，通常表示你試圖執行一個對象不支持的操作，或者操作的上下文不正確。錯誤消息本身會更有指示性。</td>
                        <td>仔細閱讀伴隨此錯誤代碼的具體錯誤消息。檢查你正在操作的對象 (例如 <code>Range</code>, <code>Worksheet</code>, <code>Workbook</code>) 是否正確，以及你嘗試的方法或屬性對於該對象和當前狀態是否有效。例如，試圖在一個受保護的工作表上修改儲存格而未先解除保護。</td>
                    </tr>
                     <tr>
                        <td>3265</td>
                        <td>Item not found in this collection<br>項目在此集合中找不到</td>
                        <td>試圖通過一個不存在的鍵名或索引訪問集合中的項目 (通常用於 ADODB.Recordset.Fields 或其他集合)。</td>
                        <td>檢查鍵名或索引是否正確。對於 ADODB Recordset Fields，確保查詢返回了該欄位，且欄位名拼寫無誤。遍歷集合的鍵或檢查 Count 屬性以確認項目是否存在。</td>
                    </tr>
                    <tr>
                        <td>424</td>
                        <td>Object required<br>需要物件</td>
                        <td>試圖調用一個需要對象引用的方法或屬性，但提供的值不是對象，或者該對象是 <code>Nothing</code>。</td>
                        <td>與錯誤 91 類似。確保你操作的是一個已正確實例化的對象變量。檢查是否有遺漏的 <code>Set</code> 語句。</td>
                    </tr>
                    <tr>
                        <td>429</td>
                        <td>ActiveX component can't create object or return reference to this object<br>ActiveX 元件無法建立物件或傳回此物件的參照</td>
                        <td>試圖使用 <code>CreateObject</code> 或 <code>GetObject</code> 創建一個 COM 對象失敗。可能是因為該組件未正確註冊到系統，或者所需的應用程式 (如 Word, Outlook) 未安裝或損壞。</td>
                        <td>確認相關的應用程式已安裝且能正常運行；嘗試修復 Office 安裝；確保 VBA 專案中對所需類型庫的引用是正確的 (「工具」>「設定引用項目」)；在某些情況下，以管理員身份運行 Office 可能有助於註冊組件。</td>
                    </tr>
                    <tr>
                        <td>438</td>
                        <td>Object doesn't support this property or method<br>物件不支援此屬性或方法</td>
                        <td>你試圖訪問一個對象上不存在的屬性或方法。</td>
                        <td>檢查屬性或方法名稱的拼寫是否正確；確認你操作的對象類型確實擁有該屬性/方法（例如，Worksheet 對象沒有 <code>Save</code> 方法，Workbook 對象才有）；查閱相關對象的文檔。</td>
                    </tr>
                    <tr>
                        <td>440</td>
                        <td>Automation error<br>自動化錯誤</td>
                        <td>一個通用的自動化 (OLE Automation) 錯誤，通常發生在與其他應用程式 (如 Word, Outlook, IE) 進行交互時。具體原因可能多種多样。</td>
                        <td>檢查與之交互的應用程式是否響應正常；嘗試逐步執行代碼以定位問題點；確保所有對象都已正確初始化和釋放；檢查是否有權限問題。有時，更詳細的錯誤信息可能記錄在事件查看器中。</td>
                    </tr>
                    <tr>
                        <td>457</td>
                        <td>This key is already associated with an element of this collection<br>此鍵已與此集合的元素關聯</td>
                        <td>在使用 <code>Scripting.Dictionary</code> 或 <code>Collection</code> 並指定鍵 (key) 添加項目時，試圖添加一個已存在的鍵。</td>
                        <td>在添加新項目到 Dictionary 或 Collection 之前，先使用 <code>Dictionary.Exists(key)</code> 或遍歷 Collection 檢查鍵是否已存在。</td>
                    </tr>
                    <tr>
                        <td>462</td>
                        <td>The remote server machine does not exist or is unavailable<br>遠端伺服器電腦不存在或無法使用</td>
                        <td>通常發生在試圖通過自動化與另一個應用程式 (如 Excel 控制 Word) 交互時，如果該應用程式實例意外關閉或無響應。</td>
                        <td>確保被控制的應用程式保持打開和響應狀態；在長時間操作中適當使用 <code>DoEvents</code>；在訪問遠程對象前檢查其有效性 (例如 <code>If Not wdApp Is Nothing Then ...</code>)。避免在對象變量超出作用域後仍嘗試使用它。</td>
                    </tr>
                </tbody>
            </table>
            <p class="note"><strong>調試技巧</strong>：當遇到錯誤時，VBA 編輯器通常會高亮顯示出錯的代碼行。使用調試工具，如設置斷點 (<code>F9</code>)、單步執行 (<code>F8</code>)、查看變量值 (將鼠標懸停在變量上或使用「區域變數」窗口、「監看式」窗口)，可以幫助你更快地定位問題的根源。</p>
            <div class="page-specific-footer">
                <a href="javascript:void(0);" onclick="showMainQueryInterface()" class="button-link">返回主查詢頁面</a>
            </div>
        </div>
    </div>

    <div id="pageNoviceToAdvanced" class="content-page">
        <div class="content-page-inner-container">
            <h1>VBA 征途：從新手到進階</h1>
            <p>各位好學的VBA愛好者，我是 Nathan。回想當初學習 VBA，從一知半解到能夠靈活應用，中間確實經歷了不少挑戰。尤其是當我們開始接觸並嘗試修改他人編寫的較複雜代碼時，往往會感到困惑。這個階段，正是從新手邁向進階的關鍵。別擔心，這條路雖然有挑戰，但每一步的突破都會帶來巨大的成就感。</p>
            <div class="challenge">
                <strong>最大的挑戰：理解與修改他人代碼</strong>
                <p>很多時候，我們在網上找到一段看起來能解決問題的代碼，或者同事分享了一段實用腳本。但直接套用時，往往因為數據結構、工作表名稱、或具體目標的細微差異而無法正常運行，甚至出現錯誤。這時，單純的複製粘貼是行不通的。你需要學會：</p>
                <ul>
                    <li><strong>讀懂代碼</strong>：理解每一行代碼的作用，變量的含義，以及整個程序的邏輯流程。</li>
                    <li><strong>調整參數</strong>：識別出代碼中需要根據你的實際情況修改的部分，例如文件路徑、工作表名、儲存格範圍、循環次數等。</li>
                    <li><strong>舉一反三</strong>：明白代碼的核心原理後，思考如何將其應用到類似但不完全相同的問題上。</li>
                    <li><strong>反覆測試與糾正</strong>：修改代碼後，通過運行和調試來驗證結果，並根據錯誤提示或非預期結果不斷修正，直至達到目標。</li>
                </ul>
            </div>
            <h2>讀懂他人代碼的竅門</h2>
            <p>要有效修改和利用他人代碼，首先必須理解它。以下是一些實用技巧：</p>
            <ul>
                <li><strong>利用VBA編輯器的調試工具</strong>：
                    <ul>
                        <li><strong>逐步執行 (<code>F8</code>鍵)</strong>：逐行運行代碼，觀察每一步的執行情況和變量變化。這是理解代碼流程最直接的方法。</li>
                        <li><strong>設置斷點 (<code>F9</code>鍵)</strong>：在關鍵代碼行設置斷點，程序運行到此處會暫停，方便你檢查當前狀態。</li>
                        <li><strong>區域變數窗口 (Locals Window)</strong>：顯示當前過程中所有變量及其值，隨代碼執行實時更新。</li>
                        <li><strong>監看式窗口 (Watch Window)</strong>：可以添加對特定變量或表達式的監看，當其值改變或滿足特定條件時程序會暫停。</li>
                        <li><strong>即時運算窗口 (Immediate Window) (<code>Ctrl+G</code>)</strong>：可以輸入 <code>? VariableName</code> 來查看變量當前值，或者執行單行測試代碼。</li>
                    </ul>
                </li>
                <li><strong>理解變量和對象</strong>：留意變量的命名（好的命名本身就有說明性）和數據類型。理解每個對象變量（如 <code>Worksheet</code>, <code>Range</code>, <code>Workbook</code>）指向的是什麼。</li>
                <li><strong>注意註釋</strong>：如果原代碼有註釋，仔細閱讀。如果沒有，在你理解某段代碼後，自己加上註釋，方便日後回顧。</li>
                <li><strong>分解複雜代碼</strong>：將長過程或複雜邏輯分解成小塊來理解。可以暫時註釋掉部分代碼，專注於理解某個核心部分。</li>
                <li><strong>查閱手冊和文檔</strong>：遇到不熟悉的指令、屬性或方法，及時使用本手冊或官方文檔查詢其用法和參數。</li>
            </ul>
            <h2>修改與調整代碼的策略</h2>
            <p>在理解的基礎上，修改代碼需要細心和系統的方法：</p>
            <ul>
                <li><strong>備份原始代碼</strong>：在做任何修改前，務必複製一份原始代碼作為備份，以防改錯後無法恢復。</li>
                <li><strong>從小處着手，逐步修改</strong>：不要一次性修改太多地方。針對一個小目標進行修改，測試成功後再進行下一步。</li>
                <li><strong>明確你的目標與差異</strong>：清晰地列出原始代碼的功能與你期望的功能之間的差異點，針對這些差異點進行修改。</li>
                <li><strong>參數化硬編碼值</strong>：如果代碼中有很多寫死的值（如文件名、工作表名、路徑），考慮將它們定義為變量或常數放在過程開頭，方便統一修改和日後維護。</li>
                <li><strong>添加錯誤處理</strong>：考慮到你的數據或環境可能與原作者不同，適當添加錯誤處理機制 (<code>On Error GoTo ...</code>, <code>On Error Resume Next</code>) 可以讓你的宏更健壯。但要小心使用 <code>Resume Next</code>，確保你理解其後果。</li>
                <li><strong>測試，測試，再測試</strong>：每次修改後都要運行測試，確保結果符合預期，並且沒有引入新的錯誤。使用不同的測試數據（包括邊界情況和可能的錯誤數據）來驗證代碼的穩健性。</li>
            </ul>
            <div class="tip">
                <strong>實戰演練：一個常見的修改場景</strong>
                <p>假設你找到一段從A列複製數據到B列的代碼：</p>
                <code>Sub CopyColumnAtoB()<br>  Dim lastRow As Long<br>  lastRow = Cells(Rows.Count, "A").End(xlUp).Row<br>  Range("A1:A" & lastRow).Copy Destination:=Range("B1")<br>End Sub</code>
                <p>你需要將其修改為：從名為 "SourceData" 的工作表的C列複製數據，粘貼到名為 "Report" 的工作表的D列，並且只複製數據值，不複製格式。</p>
                <p><strong>你的思考和修改步驟可能如下：</strong></p>
                <ol>
                    <li><strong>理解原代碼</strong>：<code>lastRow</code> 找到A列最後一行；<code>Range.Copy Destination</code> 完成複製粘貼。</li>
                    <li><strong>識別差異</strong>：
                        <ul>
                            <li>源工作表和目標工作表不同。</li>
                            <li>源列和目標列不同。</li>
                            <li>需要只粘貼值。</li>
                        </ul>
                    </li>
                    <li><strong>逐步修改</strong>：
                        <ol>
                            <li>定義工作表對象：<code>Dim wsSource As Worksheet, wsTarget As Worksheet</code><br><code>Set wsSource = ThisWorkbook.Sheets("SourceData")</code><br><code>Set wsTarget = ThisWorkbook.Sheets("Report")</code></li>
                            <li>修改<code>lastRow</code>的計算以基於源工作表的C列：<code>lastRow = wsSource.Cells(Rows.Count, "C").End(xlUp).Row</code></li>
                            <li>修改複製範圍和目標範圍：<code>wsSource.Range("C1:C" & lastRow)</code> 和 <code>wsTarget.Range("D1")</code></li>
                            <li>修改粘貼方式為只粘貼值：使用 <code>PasteSpecial xlPasteValues</code>。這需要先 <code>Copy</code>，然後在目標位置 <code>PasteSpecial</code>。</li>
                        </ol>
                    </li>
                    <li><strong>最終代碼可能看起來像</strong>：<br>
                    <code>Sub CopySourceCtoReportD_ValuesOnly()<br>  Dim lastRow As Long<br>  Dim wsSource As Worksheet, wsTarget As Worksheet<br><br>  Set wsSource = ThisWorkbook.Sheets("SourceData")<br>  Set wsTarget = ThisWorkbook.Sheets("Report")<br><br>  lastRow = wsSource.Cells(Rows.Count, "C").End(xlUp).Row<br><br>  If lastRow >= 1 Then<br>    wsSource.Range("C1:C" & lastRow).Copy<br>    wsTarget.Range("D1").PasteSpecial Paste:=xlPasteValues<br>    Application.CutCopyMode = False ' 清除剪貼板<br>  End If<br><br>  Set wsSource = Nothing<br>  Set wsTarget = Nothing<br>End Sub</code></li>
                    <li><strong>測試</strong>：準備好 "SourceData" 和 "Report" 工作表，放入測試數據，運行宏，檢查結果是否正確。</li>
                </ol>
            </div>
            <h2>其他進階知識點滴</h2>
            <ul>
                <li><strong>理解物件模型 (Object Model)</strong>：深入理解 Excel (或其他Office應用) 的物件層次結構，例如 <code>Application</code> > <code>Workbooks</code> > <code>Worksheets</code> > <code>Range</code> > <code>Cells</code> 等，以及它們各自的屬性和方法，是編寫高效VBA的基礎。</li>
                <li><strong>善用循環與條件判斷</strong>：<code>For...Next</code>, <code>For Each...Next</code>, <code>Do...Loop</code> 循環和 <code>If...Then...ElseIf...Else...End If</code>, <code>Select Case</code> 條件結構是實現複雜邏輯的核心。</li>
                <li><strong>模塊化編程</strong>：將大的任務分解成若干個小的、可重用的 <code>Sub</code> 或 <code>Function</code> 過程，可以使代碼更易於管理、調試和理解。</li>
                <li><strong>學習使用數組 (Arrays)、集合 (Collections) 與字典 (Dictionaries)</strong>：對於在內存中高效處理大量數據，這些數據結構非常有用，可以顯著提升宏的性能，尤其是在避免頻繁讀寫工作表時。</li>
                <li><strong>用戶表單 (UserForms)</strong>：學習創建自定義對話框和用戶界面，可以使你的工具更加友好和專業。</li>
                <li><strong>與其他應用程式交互</strong>：探索如何通過VBA控制Word、Outlook、PowerPoint等其他Office應用程式，甚至與數據庫或網頁進行交互（在允許的環境下）。</li>
            </ul>
            <p>從新手到進階，最重要的是<strong>多練習、多思考、多嘗試</strong>。不要怕犯錯，錯誤是學習的最好機會。善用調試工具，遇到問題時嘗試將問題分解，逐步解決。祝你在VBA的學習道路上不斷精進，體會到自動化帶來的便利與樂趣！</p>
            <div class="page-specific-footer">
                <a href="javascript:void(0);" onclick="showMainQueryInterface()" class="button-link">返回主查詢頁面</a>
            </div>
        </div>
    </div>

    <div id="pagePathToMastery" class="content-page">
        <div class="content-page-inner-container">
            <h1>VBA 之巔：臻於化境的自動化藝術</h1>
            <p>各位志在千里、追求卓越的同事，我是 Nathan。當你熟練掌握 VBA 的基礎與進階技巧後，或許會開始思考：VBA 的極限在哪裡？它還能為我們帶來怎樣的驚喜？這便是「邁向頂尖」的境界——不僅僅是技術的堆砌，更是<strong>思想的昇華與創造力的迸發</strong>。</p>
            <div class="vision">
                <strong>頂尖的願景：化繁為簡，釋放潛能</strong>
                <p>達到 VBA 的頂尖水平，意味著你擁有了將幾乎一切重複、繁瑣、耗時的辦公室工作流程自動化的能力和視野。你不再將 VBA 僅僅視為一個腳本語言，而是將其看作一把解鎖效率、釋放人力、創造價值的萬能鑰匙。你的目標是：<strong>凡是重複的，皆可自動化；凡是人為易錯的，皆可程序化。</strong></p>
            </div>
            <h2>突破「不可能」的辦公自動化實例</h2>
            <p>許多初看起來似乎「無法自動化」或「過於複雜」的工作，其實在頂尖高手眼中，都可能找到自動化的突破口。關鍵在於<strong>分解問題、識別模式、巧妙組合工具</strong>。以下是一些曾被認為難以自動化，但已被 VBA (或結合其他工具) 成功攻克的辦公場景：</p>
            <ul>
                <li><strong>動態合同/提案智能組裝</strong>：根據客戶需求（可能通過 UserForm 輸入），從龐大的條款庫（Excel或結構化Word文檔）中智能抽取適用條款，自動生成包含客戶特定信息的、格式規範的合同初稿。<em>（本手冊中亦有此案例的詳細指令說明）</em></li>
                <li><strong>企業客戶貸後監控與預警</strong>：整合客戶財務數據、經營信息、外部評級等多維度數據，通過 VBA 設定複雜的預警模型和觸發規則，自動生成貸後監控報告，高亮風險點，甚至起草初步的風險提示郵件。<em>（本手冊中亦有此案例的詳細指令說明）</em></li>
                <li><strong>跨應用數據無縫流轉與報告生成</strong>：自動從 Outlook 指定郵件中提取附件（如各分部提交的Excel報表），彙整數據到主 Excel 分析表，進行運算和圖表生成，然後將結果和圖表嵌入到 Word 報告模板，最後將生成的 Word 和 Excel 報告作為附件，起草 Outlook 通知郵件給管理層。<em>（本手冊中亦有此案例的詳細指令說明）</em></li>
                <li><strong>複雜Excel表格數據的智能校驗與清理</strong>：不僅是簡單的格式或空值檢查，還能根據業務邏輯進行交叉驗證（例如，A列+B列應等於C列；若D列為「特定產品」，則E列必須在某範圍內），自動標記不一致數據，並生成校驗報告。</li>
                <li><strong>基於Excel指令，自動處理Outlook郵件並觸發不同回覆</strong>：監控特定郵件夾，根據郵件主旨、發件人、正文關鍵詞，匹配Excel規則表中的指令，自動執行分類、轉發、存檔，甚至根據預設模板生成個性化回覆郵件。<em>（本手冊中亦有此案例的詳細指令說明）</em></li>
            </ul>
            <p>這些案例的共同點是：它們都超越了簡單的腳本錄製，需要對業務流程有深刻理解，並能靈活運用 VBA 的各項功能，甚至結合外部對象庫（如 <code>FileSystemObject</code>, <code>ADODB</code>, <code>MSXML2.XMLHTTP</code>）來實現。</p>
            <h2>頂尖之路：想象力與規律洞察</h2>
            <p>技術是基礎，但要達到頂尖，更重要的是思維模式的轉變：</p>
            <ul>
                <li><strong>打破定勢，擁抱想象</strong>：不要輕易給一個任務貼上「無法自動化」的標籤。多問自己：「這個任務的核心是什麼？它的輸入、處理過程、輸出是什麼？哪些環節是重複的、有規律可循的？」</li>
                <li><strong>洞察規律，抽象建模</strong>：很多看似非標準化的工作，仔細分析後往往能發現其內在的規律或可以簡化的共同模式。將這些規律抽象出來，轉換成 VBA 可以理解和執行的邏輯模型。</li>
                <li><strong>化整為零，逐個擊破</strong>：面對龐大複雜的自動化需求，將其分解為若干個獨立的小模塊，每個模塊實現一個特定功能。當所有小模塊都穩定運行後，再將它們整合起來。</li>
                <li><strong>數據驅動，靈活配置</strong>：盡量避免將固定參數（如文件路徑、閾值、郵件模板）硬編碼在 VBA 代碼中。將它們存儲在 Excel 配置表或外部配置文件中，讓 VBA 動態讀取。這樣，當業務規則變化時，只需修改配置文件，而無需改動 VBA 代碼，大大提高系統的靈活性和可維護性。</li>
            </ul>
            <h2>頂尖 VBA 技巧與功能精要</h2>
            <p>除了本手冊已涵蓋的眾多指令外，以下是一些邁向頂尖常用的VBA技術和概念：</p>
            <div class="highlight-box">
                <h3>1. 高級數據結構與算法思想</h3>
                <p>熟練運用 <code>Collection</code> 和 <code>Scripting.Dictionary</code> 來高效管理和查詢內存中的數據。理解何時使用數組比頻繁操作單元格更優。對於複雜的數據匹配和處理，引入基礎的算法思想（如排序、查找、遞歸）能顯著提升效率和代碼質量。</p>
            </div>
            <div class="highlight-box">
                <h3>2. 類模塊 (Class Modules) 的應用</h3>
                <p>通過創建自定義類，你可以將數據和操作這些數據的過程封裝在一起，實現更面向對象的編程。這對於構建複雜的業務邏輯、提高代碼的可重用性和可維護性非常有幫助。例如，你可以為「客戶」、「訂單」、「報告」等業務實體創建類。</p>
            </div>
            <div class="highlight-box">
                <h3>3. 錯誤處理與日誌記錄的藝術</h3>
                <p>頂尖的VBA程序不僅功能強大，而且非常穩健。這需要完善的錯誤處理機制 (<code>On Error GoTo Handler</code>, <code>Err</code> 對象的詳細使用，自定義錯誤拋出 <code>Err.Raise</code>) 和詳細的日誌記錄功能。日誌不僅記錄錯誤，也記錄關鍵操作的執行情況，便於追蹤和調試。</p>
            </div>
            <div class="highlight-box">
                <h3>4. 與外部世界深度互動</h3>
                <ul>
                    <li><strong>文件系統操作 (<code>FileSystemObject</code>)</strong>：不僅是創建、刪除文件夾，還包括讀寫文本文件、獲取文件屬性、遍歷文件夾結構等高級操作。</li>
                    <li><strong>數據庫連接 (<code>ADODB</code>)</strong>：直接讀寫 Access 數據庫、SQL Server，甚至將 Excel 工作表作為數據庫進行 SQL 查詢和操作。</li>
                    <li><strong>Web數據交互 (<code>MSXML2.XMLHTTP</code> / <code>WinHttp.WinHttpRequest.5.1</code>)</strong>：在銀行內部網絡允許的情況下，可以與內部Web服務進行數據交換 (GET/POST請求)，處理JSON或XML格式的數據。解析JSON通常需要輔助庫或自訂函數。</li>
                    <li><strong>XML文檔處理 (<code>MSXML2.DOMDocument</code>)</strong>：加載、解析、查詢 (XPath) 和創建 XML 文檔，常用於處理配置文件或外部系統的數據接口。</li>
                    <li><strong>Windows API 調用 (<code>Declare</code> 語句)</strong>：通過調用 Windows 操作系統底層的 API 函數，可以實現 VBA 本身不直接提供的功能，例如更精細的窗口控制、系統信息獲取等。但需謹慎使用，並注意32位與64位的兼容性 (<code>PtrSafe</code>, <code>LongPtr</code>)。</li>
                    <li><strong>PowerShell 自動化調用</strong>: VBA可以通過 <code>WScript.Shell</code> 對象執行PowerShell腳本，利用PowerShell在系統管理、與.NET框架交互方面的強大能力。</li>
                </ul>
            </div>
            <div class="highlight-box">
                <h3>5. 用戶界面 (UserForms) 的精雕細琢</h3>
                <p>不僅是創建基礎的輸入表單，更要追求用戶體驗：控件的合理佈局、數據驗證的即時反饋、進度條的顯示、多頁面控件 (MultiPage) 的使用、動態加載控件內容等，使你的VBA工具更像一個專業的應用程序。</p>
            </div>
            <h2>VBA的潛力與局限 (銀行離線環境視角)</h2>
            <p>在銀行這樣高度重視數據安全、通常禁止連接外網的特殊工作環境中，VBA 的價值尤為突出：</p>
            <h3>VBA 的強大潛力 (離線優勢)：</h3>
            <ul>
                <li><strong>Office全家桶無縫集成</strong>：Excel 的數據處理與分析、Word 的文檔生成與排版、Outlook 的郵件管理與自動化、PowerPoint 的簡報製作，VBA 能夠在這幾大核心辦公軟件之間建立強大的聯動，實現數據流轉和任務自動化，而這一切都可以在完全離線的環境中完成。</li>
                <li><strong>強大的數據處理能力</strong>：對於Excel中的數據，VBA可以進行複雜的篩選、排序、計算、匯總、圖表生成、數據透視表操作等，處理速度遠超手動。</li>
                <li><strong>文件與文件夾管理</strong>：通過 <code>FileSystemObject</code>，VBA能夠批量創建、移動、複製、刪除文件和文件夾，整理報告，管理項目文檔結構。</li>
                <li><strong>定制化用戶界面</strong>：UserForm 使得非技術用戶也能方便地與複雜的VBA程序交互，執行特定任務，填寫表單，而無需直接修改代碼或數據表。</li>
                <li><strong>無需額外安裝與高權限</strong>：VBA是Office內建功能，只要Office安裝正確，VBA即可使用，通常不需要系統管理員額外安裝組件或賦予特殊權限（除非調用特定外部DLL或API）。這在權限管控嚴格的銀行內部非常重要。</li>
                <li><strong>快速原型開發與部署</strong>：對於一些緊急的、小型的自動化需求，VBA能夠快速開發出原型並投入使用，解決燃眉之急。</li>
            </ul>
            <h3>VBA 客觀存在的局限：</h3>
            <ul>
                <li><strong>單線程執行</strong>：VBA 是單線程的，執行耗時任務時，應用程式界面可能會暫時無響應 (除非巧妙使用 <code>DoEvents</code>，但<code>DoEvents</code>也需謹慎)。</li>
                <li><strong>性能瓶頸</strong>：對於超大規模數據集（例如數百萬行Excel數據的複雜運算）或極高強度的計算任務，VBA 的性能可能不如 Python、R 或專業數據庫。</li>
                <li><strong>現代Web技術交互困難</strong>：在離線環境下，VBA無法直接與現代的、需要複雜JavaScript渲染的外部網站進行交互。即使在允許網絡的環境，IE自動化也已過時且不可靠。</li>
                <li><strong>UI界面相對傳統</strong>：UserForm雖然實用，但其界面美觀度和交互體驗無法與現代Web應用或桌面應用相比。</li>
                <li><strong>代碼管理與協作</strong>：對於大型複雜的VBA項目，代碼的版本控制、多人協作和模塊化管理不如現代IDE和Git等工具方便。</li>
                <li><strong>安全性考量</strong>：宏病毒的歷史使得啟用宏的文件帶有一定的安全風險，因此銀行內部通常有嚴格的宏安全設置和審批流程。</li>
                <li><strong>對非Office文件的處理能力有限</strong>：雖然可以通過API或Shell調用外部程序間接處理，但VBA本身對PDF、特定格式圖片等非Office原生文件的深度操作能力較弱。</li>
            </ul>
            <p>理解VBA的潛力和局限，揚長避短，將其應用在最能發揮其價值的領域，例如Office套件內的深度自動化、數據整理與報告生成、以及在離線環境下的流程優化，這才是頂尖VBA專家應有的智慧。</p>
            <p>願你在VBA的世界裡，不斷探索，不斷創新，將自動化的力量發揮到極致！</p>
            <div class="page-specific-footer">
                <a href="javascript:void(0);" onclick="showMainQueryInterface()" class="button-link">返回主查詢頁面</a>
            </div>
        </div>
    </div>
    <!-- 新增內容頁面容器 END -->


    <script>
        // VBA 指令資料
        const vbaCommands = [
            // --- 數學、日期與時間 (Math, Date & Time) ---
            {
                "name": "Abs", "category": "數學、日期與時間", "syntax": "Abs(number)",
                "description": "返回數字的絕對值。",
                "parameters": [{"name": "number", "description": "任何有效的數字表達式。"}],
                "examples": [
                    {"code": "Abs(50.3)  ' 返回 50.3", "explanation": "計算正數 50.3 的絕對值，結果為 50.3。"},
                    {"code": "Abs(-50.3) ' 返回 50.3", "explanation": "計算負數 -50.3 的絕對值，結果為 50.3。"}
                ],
                "keywords": ["絕對值", "數字", "計算", "math", "absolute value"]
            },
            {
                "name": "Sin", "category": "數學、日期與時間", "syntax": "Sin(number)",
                "description": "返回角度的正弦值。",
                "parameters": [{"name": "number", "description": "以弧度為單位的角度。"}],
                "examples": [
                    {"code": "Sin(1.3)  ' 返回 0.963558185417193", "explanation": "計算弧度為 1.3 的角度的正弦值。"}
                ],
                "keywords": ["正弦", "角度", "三角函數", "math", "trigonometry", "sine"]
            },
            {
                "name": "Cos", "category": "數學、日期與時間", "syntax": "Cos(number)",
                "description": "返回角度的餘弦值。",
                "parameters": [{"name": "number", "description": "必需。以弧度為單位的角度。"}],
                "examples": [
                    {"code": "Dim MyAngle As Double\nMyAngle = 1.3 ' 弧度\nMsgBox Cos(MyAngle) ' 返回 0.26749882862", "explanation": "計算變數 MyAngle (弧度為1.3) 的餘弦值並顯示。"}
                ],
                "keywords": ["餘弦", "三角函數", "math", "trigonometry", "cosine"]
            },
            {
                "name": "Tan", "category": "數學、日期與時間", "syntax": "Tan(number)",
                "description": "返回角度的正切值。",
                "parameters": [{"name": "number", "description": "必需。以弧度為單位的角度。"}],
                "examples": [
                    {"code": "Dim MyAngle As Double\nMyAngle = 0.785 ' 約 45 度 (弧度)\nMsgBox Tan(MyAngle) ' 返回約 1", "explanation": "計算弧度約為 0.785 (45度) 的角度的正切值。"}
                ],
                "keywords": ["正切", "三角函數", "math", "trigonometry", "tangent"]
            },
            {
                "name": "Atn", "category": "數學、日期與時間", "syntax": "Atn(number)",
                "description": "返回數字的反正切值 (以弧度為單位)。",
                "parameters": [{"name": "number", "description": "必需。任何有效的數值表達式。"}],
                "examples": [
                    {"code": "Dim MyRatio As Double\nMyRatio = 1 ' 正切值為 1\nMsgBox Atn(MyRatio) ' 返回約 0.785 (45度的弧度值)", "explanation": "計算正切值為 1 的角度的反正切值 (弧度)。"}
                ],
                "keywords": ["反正切", "三角函數", "math", "trigonometry", "arctangent", "atan"]
            },
            {
                "name": "Exp", "category": "數學、日期與時間", "syntax": "Exp(number)",
                "description": "返回 e (自然對數的底) 的指定次冪。",
                "parameters": [{"name": "number", "description": "必需。任何有效的數值表達式。"}],
                "examples": [
                    {"code": "MsgBox Exp(1) ' 返回 e 的 1 次冪 (約 2.71828)", "explanation": "計算自然對數的底 e 的 1 次方。"},
                    {"code": "MsgBox Exp(2) ' 返回 e 的 2 次冪 (約 7.38905)", "explanation": "計算自然對數的底 e 的 2 次方。"}
                ],
                "keywords": ["指數", "e的冪", "math", "exponential", "power"]
            },
            {
                "name": "Log", "category": "數學、日期與時間", "syntax": "Log(number)",
                "description": "返回數字的自然對數。",
                "parameters": [{"name": "number", "description": "必需。任何大於零的有效數值表達式。"}],
                "examples": [
                    {"code": "Dim MyValue As Double\nMyValue = Exp(2) ' e 的平方\nMsgBox Log(MyValue) ' 返回 2", "explanation": "計算 e平方 的自然對數，結果為 2。"}
                ],
                "keywords": ["自然對數", "對數", "math", "logarithm", "natural log"]
            },
            {
                "name": "Sqr", "category": "數學、日期與時間", "syntax": "Sqr(number)",
                "description": "返回數字的平方根。",
                "parameters": [{"name": "number", "description": "必需。任何大於或等於零的有效數值表達式。"}],
                "examples": [
                    {"code": "MsgBox Sqr(16) ' 返回 4", "explanation": "計算數字 16 的平方根。"},
                    {"code": "MsgBox Sqr(0)  ' 返回 0", "explanation": "計算數字 0 的平方根。"}
                ],
                "keywords": ["平方根", "開方", "math", "square root"]
            },
            {
                "name": "Rnd", "category": "數學、日期與時間", "syntax": "Rnd[(number)]",
                "description": "返回一個包含隨機數的 Single 值。",
                "parameters": [{"name": "number", "description": "可選。一個 Single 或任何有效的數值表達式。"}],
                "examples": [
                    {"code": "Randomize ' 初始化隨機數生成器\nMsgBox Rnd() ' 生成一個 0 到 1 之間的隨機數", "explanation": "初始化隨機數種子並生成一個0到1之間的隨機小數。"},
                    {"code": "Randomize\nMsgBox Int((6 * Rnd) + 1) ' 生成一個 1 到 6 之間的隨機整數", "explanation": "生成一個1到6之間的隨機整數，常用於模擬骰子。"}
                ],
                "keywords": ["隨機數", "亂數", "數字", "math", "random", "number", "randomize"]
            },
            {
                "name": "Round", "category": "數學、日期與時間", "syntax": "Round(expression[, numdecimalplaces])",
                "description": "返回四捨五入到指定小數位數的數字。",
                "parameters": [{"name": "expression", "description": "必需。要四捨五入的數值表達式。"}, {"name": "numdecimalplaces", "description": "可選。指示小數點右邊應保留多少位。"}],
                "examples": [
                    {"code": "Debug.Print Round(123.456, 2) ' 返回 123.46", "explanation": "將數字 123.456 四捨五入到小數點後兩位。"},
                    {"code": "Debug.Print Round(123.789)    ' 返回 124", "explanation": "將數字 123.789 四捨五入到最接近的整數。"}
                ],
                "keywords": ["四捨五入", "數字", "math", "rounding"]
            },
            {
                "name": "Int", "category": "數學、日期與時間", "syntax": "Int(number)",
                "description": "返回數字的整數部分 (向下取整，對於負數是遠離零的方向)。",
                "parameters": [{"name": "number", "description": "必需。任何有效的數值表達式。"}],
                "examples": [
                    {"code": "Debug.Print Int(99.8)   ' 返回 99", "explanation": "返回 99.8 的整數部分，結果為 99。"},
                    {"code": "Debug.Print Int(-99.8)  ' 返回 -100", "explanation": "返回 -99.8 的整數部分（向下取整），結果為 -100。"}
                ],
                "keywords": ["取整", "整數部分", "向下取整", "math", "integer part", "floor"]
            },
            {
                "name": "Fix", "category": "數學、日期與時間", "syntax": "Fix(number)",
                "description": "返回數字的整數部分 (直接截斷小數部分，向零取整)。",
                "parameters": [{"name": "number", "description": "必需。任何有效的數值表達式。"}],
                "examples": [
                    {"code": "Debug.Print Fix(99.8)   ' 返回 99", "explanation": "返回 99.8 的整數部分（直接截斷），結果為 99。"},
                    {"code": "Debug.Print Fix(-99.8)  ' 返回 -99", "explanation": "返回 -99.8 的整數部分（向零取整），結果為 -99。"}
                ],
                "keywords": ["取整", "整數部分", "截斷", "math", "integer part", "truncate"]
            },
            {
                "name": "Now", "category": "數學、日期與時間", "syntax": "Now",
                "description": "返回表示當前日期和時間的 Date 值。",
                "parameters": [],
                "examples": [
                    {"code": "Dim TodayTime As Date\nTodayTime = Now\nMsgBox \"Current date and time: \" & TodayTime", "explanation": "獲取當前系統的日期和時間。"}
                ],
                "keywords": ["現在", "日期", "時間", "當前", "date", "time", "current"]
            },
            {
                "name": "Date", "category": "數學、日期與時間", "syntax": "Date",
                "description": "返回當前系統日期。",
                "parameters": [],
                "examples": [
                    {"code": "Dim TodayDate As Date\nTodayDate = Date\nMsgBox \"Today's date: \" & TodayDate", "explanation": "獲取當前系統的日期。"}
                ],
                "keywords": ["日期", "當前日期", "系統日期", "date", "current date"]
            },
            {
                "name": "Time", "category": "數學、日期與時間", "syntax": "Time",
                "description": "返回表示當前系統時間的 Variant (Date)。",
                "parameters": [],
                "examples": [
                    {"code": "Dim CurrentSysTime As Date\nCurrentSysTime = Time\nMsgBox \"Current time: \" & CurrentSysTime", "explanation": "獲取當前系統的時間。"}
                ],
                "keywords": ["時間", "當前時間", "系統時間", "time", "current time"]
            },
            {
                "name": "Timer", "category": "數學、日期與時間", "syntax": "Timer",
                "description": "返回自午夜以來經過的秒數（Single）。",
                "parameters": [],
                "examples": [
                    {"code": "Dim SecondsPastMidnight As Single\nSecondsPastMidnight = Timer\nMsgBox \"Seconds since midnight: \" & SecondsPastMidnight", "explanation": "獲取從當天午夜到現在所經過的秒數。"}
                ],
                "keywords": ["計時器", "秒數", "時間", "elapsed time", "seconds"]
            },
            {
                "name": "Year", "category": "數學、日期與時間", "syntax": "Year(date)",
                "description": "返回表示年份的整數。",
                "parameters": [{"name": "date", "description": "必需。任何可以表示日期的 Variant、數值表達式、字串表達式或這些的組合。"}],
                "examples": [
                    {"code": "Dim MyDate As Date, MyYear As Integer\nMyDate = #October 19, 2023#\nMyYear = Year(MyDate)\nMsgBox \"Year: \" & MyYear ' MyYear 返回 2023", "explanation": "從指定日期中提取年份。"}
                ],
                "keywords": ["年", "年份", "日期", "date", "year"]
            },
            {
                "name": "Month", "category": "數學、日期與時間", "syntax": "Month(date)",
                "description": "返回一個介於 1 和 12 之間的整數，表示月份。",
                "parameters": [{"name": "date", "description": "必需。任何可以表示日期的 Variant、數值表達式、字串表達式或這些的組合。"}],
                "examples": [
                    {"code": "Dim MyDate As Date, MyMonth As Integer\nMyDate = #October 19, 2023#\nMyMonth = Month(MyDate)\nMsgBox \"Month: \" & MyMonth ' MyMonth 返回 10", "explanation": "從指定日期中提取月份。"}
                ],
                "keywords": ["月", "月份", "日期", "date", "month"]
            },
            {
                "name": "Day", "category": "數學、日期與時間", "syntax": "Day(date)",
                "description": "返回一個介於 1 和 31 之間的整數，表示月份中的某一天。",
                "parameters": [{"name": "date", "description": "必需。任何可以表示日期的 Variant、數值表達式、字串表達式或這些的組合。"}],
                "examples": [
                    {"code": "Dim MyDate As Date, MyDay As Integer\nMyDate = #October 19, 2023#\nMyDay = Day(MyDate)\nMsgBox \"Day: \" & MyDay ' MyDay 返回 19", "explanation": "從指定日期中提取日。"}
                ],
                "keywords": ["日", "日期", "date", "day"]
            },
            {
                "name": "Hour", "category": "數學、日期與時間", "syntax": "Hour(time)",
                "description": "返回一個介於 0 和 23 之間的整數，表示小時。",
                "parameters": [{"name": "time", "description": "必需。任何可以表示時間的 Variant、數值表達式、字串表達式或這些的組合。"}],
                "examples": [
                    {"code": "Dim MyTime As Date, MyHour As Integer\nMyTime = #4:35:17 PM#\nMyHour = Hour(MyTime)\nMsgBox \"Hour: \" & MyHour ' MyHour 返回 16", "explanation": "從指定時間中提取小時部分（24小時制）。"}
                ],
                "keywords": ["小時", "時間", "time", "hour"]
            },
            {
                "name": "Minute", "category": "數學、日期與時間", "syntax": "Minute(time)",
                "description": "返回一個介於 0 和 59 之間的整數，表示分鐘。",
                "parameters": [{"name": "time", "description": "必需。任何可以表示時間的 Variant、數值表達式、字串表達式或這些的組合。"}],
                "examples": [
                    {"code": "Dim MyTime As Date, MyMinute As Integer\nMyTime = #4:35:17 PM#\nMyMinute = Minute(MyTime)\nMsgBox \"Minute: \" & MyMinute ' MyMinute 返回 35", "explanation": "從指定時間中提取分鐘部分。"}
                ],
                "keywords": ["分鐘", "時間", "time", "minute"]
            },
            {
                "name": "Second", "category": "數學、日期與時間", "syntax": "Second(time)",
                "description": "返回一個介於 0 和 59 之間的整數，表示秒。",
                "parameters": [{"name": "time", "description": "必需。任何可以表示時間的 Variant、數值表達式、字串表達式或這些的組合。"}],
                "examples": [
                    {"code": "Dim MyTime As Date, MySecond As Integer\nMyTime = #4:35:17 PM#\nMySecond = Second(MyTime)\nMsgBox \"Second: \" & MySecond ' MySecond 返回 17", "explanation": "從指定時間中提取秒部分。"}
                ],
                "keywords": ["秒", "時間", "time", "second"]
            },
            {
                "name": "Weekday", "category": "數學、日期與時間", "syntax": "Weekday(date, [firstdayofweek As VbDayOfWeek = vbSunday])",
                "description": "返回一個表示星期幾的整數。",
                "parameters": [{"name": "date", "description": "必需。任何可以表示日期的 Variant。"}, {"name": "firstdayofweek", "description": "可選。一個常數，指定一周的第一天。"}],
                "examples": [
                    {"code": "Dim MyDate As Date, MyWeekDayNum As Integer\nMyDate = #October 19, 2023# ' 假設這天是星期四\nMyWeekDayNum = Weekday(MyDate, vbMonday) ' 以星期一為每周第一天\nMsgBox \"Weekday number (Monday=1): \" & MyWeekDayNum ' 返回 4", "explanation": "獲取指定日期是星期幾（以星期一為每周的第一天計算）。"}
                ],
                "keywords": ["星期幾", "日期", "date", "weekday"]
            },
            {
                "name": "DateAdd", "category": "數學、日期與時間", "syntax": "DateAdd(interval, number, date)",
                "description": "返回一個 Date 值，其中已添加指定的時間間隔。",
                "parameters": [{"name": "interval", "description": "必需。要添加的時間間隔（如 \"yyyy\", \"m\", \"d\"）。"}, {"name": "number", "description": "必需。要添加的時間間隔數。"}, {"name": "date", "description": "必需。要向其添加間隔的日期。"}],
                "examples": [
                    {"code": "Dim MyDate As Date, NewDate As Date\nMyDate = #10/19/2023#\nNewDate = DateAdd(\"m\", 1, MyDate)\nMsgBox \"One month later: \" & NewDate ' NewDate 返回 2023年11月19日", "explanation": "將指定日期增加一個月。"},
                    {"code": "Dim FutureDate As Date\nFutureDate = DateAdd(\"d\", 10, Date)\nMsgBox \"10 days from today: \" & FutureDate", "explanation": "計算從今天起10天後的日期。"}
                ],
                "keywords": ["日期增加", "增加時間", "時間計算", "date", "add", "time", "interval"]
            },
            {
                "name": "DateDiff", "category": "數學、日期與時間", "syntax": "DateDiff(interval, date1, date2[, firstdayofweek[, firstweekofyear]])",
                "description": "返回兩個日期之間指定的時間間隔數。",
                "parameters": [{"name": "interval", "description": "必需。用於計算差異的時間間隔。"}, {"name": "date1, date2", "description": "必需。用於計算的兩個日期。"}, {"name": "firstdayofweek", "description": "可選。指定一周中第一天的常數。"}, {"name": "firstweekofyear", "description": "可選。指定一年中第一周的常數。"}],
                "examples": [
                    {"code": "Dim StartDate As Date, EndDate As Date, DaysDiff As Long\nStartDate = #01/01/2023#\nEndDate = #01/10/2023#\nDaysDiff = DateDiff(\"d\", StartDate, EndDate)\nMsgBox \"Difference in days: \" & DaysDiff ' DaysDiff 返回 9", "explanation": "計算兩個日期之間相差的天數。"},
                    {"code": "Dim MonthsPassed As Long\nMonthsPassed = DateDiff(\"m\", #01/15/2023#, #08/10/2023#)\nMsgBox \"Months passed: \" & MonthsPassed ' 返回 6 (不足一個月的部分不計)", "explanation": "計算兩個日期之間相差的完整月份數。"}
                ],
                "keywords": ["日期差異", "時間間隔", "計算天數", "date", "difference", "interval"]
            },
            {
                "name": "DateSerial", "category": "數學、日期與時間", "syntax": "DateSerial(year, month, day)",
                "description": "返回指定年、月、日的 Date 值。",
                "parameters": [{"name": "year", "description": "必需。年份數字。"}, {"name": "month", "description": "必需。月份數字。"}, {"name": "day", "description": "必需。日期數字。"}],
                "examples": [
                    {"code": "Dim MyCustomDate As Date\nMyCustomDate = DateSerial(2024, 5, 15)\nMsgBox \"Custom date: \" & MyCustomDate ' 返回 2024年5月15日的日期", "explanation": "根據指定的年、月、日創建一個日期值。"}
                ],
                "keywords": ["創建日期", "日期", "date", "serial", "make date"]
            },
            {
                "name": "TimeSerial", "category": "數學、日期與時間", "syntax": "TimeSerial(hour, minute, second)",
                "description": "返回指定時、分、秒的 Date 值 (時間部分)。",
                "parameters": [{"name": "hour", "description": "必需。小時數字。"}, {"name": "minute", "description": "必需。分鐘數字。"}, {"name": "second", "description": "必需。秒數字。"}],
                "examples": [
                    {"code": "Dim MyCustomTime As Date\nMyCustomTime = TimeSerial(14, 30, 0)\nMsgBox \"Custom time: \" & MyCustomTime ' 返回下午 2:30:00 的時間", "explanation": "根據指定的時、分、秒創建一個時間值。"}
                ],
                "keywords": ["創建時間", "時間", "time", "serial", "make time"]
            },
            {
                "name": "DateValue", "category": "數學、日期與時間", "syntax": "DateValue(date)",
                "description": "返回 Date 資料類型。",
                "parameters": [{"name": "date", "description": "必需。通常是一個字串表達式，表示日期。"}],
                "examples": [
                    {"code": "Dim MyDateVal As Date\nMyDateVal = DateValue(\"October 19, 2023\")\nMsgBox \"Date value: \" & MyDateVal", "explanation": "將表示日期的字串轉換為實際的日期類型值。"}
                ],
                "keywords": ["日期值", "轉換日期", "date", "value", "string to date"]
            },
            {
                "name": "TimeValue", "category": "數學、日期與時間", "syntax": "TimeValue(time)",
                "description": "返回包含時間的 Date 資料類型。",
                "parameters": [{"name": "time", "description": "必需。通常是一個字串表達式，表示時間。"}],
                "examples": [
                    {"code": "Dim MyTimeVal As Date\nMyTimeVal = TimeValue(\"4:30 PM\")\nMsgBox \"Time value: \" & MyTimeVal", "explanation": "將表示時間的字串轉換為實際的時間類型值。"}
                ],
                "keywords": ["時間值", "轉換時間", "time", "value", "string to time"]
            },
             {
                "name": "MonthName", "category": "數學、日期與時間", "syntax": "MonthName(month[, abbreviate])",
                "description": "返回表示指定月份名稱的字串。",
                "parameters": [
                    {"name": "month", "description": "必需。1 到 12 之間的數字，代表月份。"},
                    {"name": "abbreviate", "description": "可選。Boolean 值，如果為 True，則返回縮寫月份名稱 (例如 Jan)。預設為 False。"}
                ],
                "examples": [
                    {"code": "MsgBox MonthName(1) ' 返回 \"January\" (根據系統設定可能為本地化名稱，如「一月」)", "explanation": "獲取月份 1 的完整名稱。"},
                    {"code": "MsgBox MonthName(3, True) ' 返回 \"Mar\" (或本地化縮寫)", "explanation": "獲取月份 3 的縮寫名稱。"}
                ],
                "keywords": ["月份名稱", "日期", "格式化", "month name", "date format"]
            },
            {
                "name": "WeekdayName", "category": "數學、日期與時間", "syntax": "WeekdayName(weekday, [abbreviate As Boolean = False], [firstdayofweek As VbDayOfWeek = vbSunday])",
                "description": "返回表示指定星期幾名稱的字串。",
                "parameters": [
                    {"name": "weekday", "description": "必需。代表星期幾的數字 (1 到 7)。"},
                    {"name": "abbreviate", "description": "可選。Boolean 值，如果為 True，則返回縮寫名稱 (例如 Mon)。預設為 False。"},
                    {"name": "firstdayofweek", "description": "可選。指定一周第一天的常數。"}
                ],
                "examples": [
                    {"code": "MsgBox WeekdayName(1, False, vbMonday) ' 返回 \"Monday\" (根據系統設定，以週一為第一天，1代表週一)", "explanation": "獲取星期一的完整名稱。"},
                    {"code": "MsgBox WeekdayName(7, True, vbSunday) ' 返回 \"Sat\" (預設週日為第一天，7代表週六)", "explanation": "獲取星期六的縮寫名稱。"}
                ],
                "keywords": ["星期名稱", "日期", "格式化", "weekday name", "day name", "date format"]
            },
            {
                "name": "Sgn", "category": "數學、日期與時間", "syntax": "Sgn(number)",
                "description": "返回一個表示數字符號的整數。返回 1 (正數)、0 (零)、-1 (負數)。",
                "parameters": [{"name": "number", "description": "任何有效的數值表達式。"}],
                "examples": [
                    {"code": "Debug.Print Sgn(100)  ' 返回 1", "explanation": "獲取正數100的符號。"},
                    {"code": "Debug.Print Sgn(0)    ' 返回 0", "explanation": "獲取0的符號。"},
                    {"code": "Debug.Print Sgn(-5.5) ' 返回 -1", "explanation": "獲取負數-5.5的符號。"}
                ],
                "keywords": ["符號", "正負號", "sign", "math"]
            },
            {
                "name": "Hex", "category": "數學、日期與時間", "syntax": "Hex(number)",
                "description": "返回表示數字十六進制值的字串。",
                "parameters": [{"name": "number", "description": "任何有效的數值表達式或字串表達式。"}],
                "examples": [
                    {"code": "Debug.Print Hex(10)   ' 返回 \"A\"", "explanation": "將數字10轉換為十六進制表示。"},
                    {"code": "Debug.Print Hex(255)  ' 返回 \"FF\"", "explanation": "將數字255轉換為十六進制表示。"}
                ],
                "keywords": ["十六進制", "轉換", "hexadecimal", "conversion"]
            },
            {
                "name": "Oct", "category": "數學、日期與時間", "syntax": "Oct(number)",
                "description": "返回表示數字八進制值的字串。",
                "parameters": [{"name": "number", "description": "任何有效的數值表達式或字串表達式。"}],
                "examples": [
                    {"code": "Debug.Print Oct(8)    ' 返回 \"10\"", "explanation": "將數字8轉換為八進制表示。"},
                    {"code": "Debug.Print Oct(10)   ' 返回 \"12\"", "explanation": "將數字10轉換為八進制表示。"}
                ],
                "keywords": ["八進制", "轉換", "octal", "conversion"]
            },

            // --- 字串與文本操作 (String & Text Manipulation) ---
            {
                "name": "Len", "category": "字串與文本操作", "syntax": "Len(string | varname)",
                "description": "返回字串中的字元數，或儲存變數所需的位元組數。",
                "parameters": [{"name": "string", "description": "任何有效的字串表達式。"}, {"name": "varname", "description": "任何有效的變數名稱。"}],
                "examples": [
                    {"code": "Dim MyString As String, MyLen As Integer\nMyString = \"Hello World\"\nMyLen = Len(MyString)\nMsgBox MyLen ' MyLen 返回 11", "explanation": "計算字串 \"Hello World\" 的長度（字元數）。"}
                ],
                "keywords": ["長度", "字串", "字元數", "length", "string"]
            },
            {
                "name": "Mid", "category": "字串與文本操作", "syntax": "Mid(string, start, [length])",
                "description": "從字串中返回指定數量的字元。",
                "parameters": [{"name": "string", "description": "必需。字串表達式。"}, {"name": "start", "description": "必需。開始提取的位置。"}, {"name": "length", "description": "可選。要返回的字元數。"}],
                "examples": [
                    {"code": "Dim MyString As String, FirstWord As String\nMyString = \"Mid Function Demo\"\nFirstWord = Mid(MyString, 1, 3)\nMsgBox FirstWord ' FirstWord 返回 \"Mid\"", "explanation": "從字串 \"Mid Function Demo\" 的第1個字元開始提取3個字元。"},
                    {"code": "Dim MyString As String, LastPart As String\nMyString = \"Hello VBA\"\nLastPart = Mid(MyString, 7)\nMsgBox LastPart ' LastPart 返回 \"VBA\"", "explanation": "從字串的第7個字元開始提取到字串結尾。"}
                ],
                "keywords": ["子字串", "字串", "提取", "部分", "substring", "string"]
            },
            {
                "name": "Left", "category": "字串與文本操作", "syntax": "Left(string, length)",
                "description": "從字串的左邊返回指定數量的字元。",
                "parameters": [{"name": "string", "description": "必需。字串表達式。"}, {"name": "length", "description": "必需。要返回的字元數。"}],
                "examples": [
                    {"code": "Dim MyString As String, LeftChars As String\nMyString = \"Hello World\"\nLeftChars = Left(MyString, 5)\nMsgBox LeftChars ' LeftChars 返回 \"Hello\"", "explanation": "從字串 \"Hello World\" 的左邊提取5個字元。"}
                ],
                "keywords": ["左側字串", "字串", "提取", "string", "left"]
            },
            {
                "name": "Right", "category": "字串與文本操作", "syntax": "Right(string, length)",
                "description": "從字串的右邊返回指定數量的字元。",
                "parameters": [{"name": "string", "description": "必需。字串表達式。"}, {"name": "length", "description": "必需。要返回的字元數。"}],
                "examples": [
                    {"code": "Dim MyString As String, RightChars As String\nMyString = \"Hello World\"\nRightChars = Right(MyString, 5)\nMsgBox RightChars ' RightChars 返回 \"World\"", "explanation": "從字串 \"Hello World\" 的右邊提取5個字元。"}
                ],
                "keywords": ["右側字串", "字串", "提取", "string", "right"]
            },
            {
                "name": "InStr", "category": "字串與文本操作", "syntax": "InStr([start, ]string1, string2[, compare])",
                "description": "返回一個字串在另一個字串中首次出現的位置。",
                "parameters": [{"name": "start", "description": "可選。搜尋的起始位置。"}, {"name": "string1", "description": "必需。被搜尋的字串。"}, {"name": "string2", "description": "必需。要搜尋的字串。"}, {"name": "compare", "description": "可選。比較類型。"}],
                "examples": [
                    {"code": "Dim SearchString As String, SearchChar As String, MyPos As Integer\nSearchString =\"XXpXXpXXPXXP\"\nSearchChar = \"p\"\nMyPos = InStr(SearchString, SearchChar)\nMsgBox MyPos ' MyPos 返回 3 (預設二進制比較，區分大小寫)", "explanation": "在字串中查找子字串 \"p\" 首次出現的位置（區分大小寫）。"},
                     {"code": "Dim MyPos As Integer\nMyPos = InStr(1, \"Hello World\", \"o\", vbTextCompare)\nMsgBox MyPos ' MyPos 返回 5", "explanation": "從第一個字符開始，在 \"Hello World\" 中不區分大小寫地查找 \"o\"。"}
                ],
                "keywords": ["查找字串", "字串位置", "搜尋", "string", "find", "position", "search"]
            },
            {
                "name": "InStrRev", "category": "字串與文本操作", "syntax": "InStrRev(stringcheck, stringmatch, [start, [compare]])",
                "description": "返回一個字串在另一個字串中從結尾開始出現的位置。",
                "parameters": [{"name": "stringcheck", "description": "必需。被搜尋的字串。"}, {"name": "stringmatch", "description": "必需。要搜尋的字串。"}, {"name": "start", "description": "可選。搜尋的起始位置 (從結尾算起)。"}, {"name": "compare", "description": "可選。比較類型。"}],
                "examples": [
                    {"code": "Dim MyString As String, SearchChar As String, MyPos As Integer\nMyString = \"Hello World World\"\nSearchChar = \"World\"\nMyPos = InStrRev(MyString, SearchChar)\nMsgBox MyPos ' MyPos 返回 13", "explanation": "從字串尾部開始查找子字串 \"World\" 最後一次出現的位置。"}
                ],
                "keywords": ["反向查找", "字串位置", "搜尋", "string", "find", "position", "search", "reverse"]
            },
            {
                "name": "UCase", "category": "字串與文本操作", "syntax": "UCase(string)",
                "description": "返回轉換為大寫的字串。",
                "parameters": [{"name": "string", "description": "必需。任何有效的字串表達式。"}],
                "examples": [
                    {"code": "Dim LowerCaseStr As String, UpperCaseStr As String\nLowerCaseStr = \"hello world\"\nUpperCaseStr = UCase(LowerCaseStr)\nMsgBox UpperCaseStr ' UpperCaseStr 返回 \"HELLO WORLD\"", "explanation": "將字串 \"hello world\" 轉換為大寫。"}
                ],
                "keywords": ["大寫", "轉換", "字串", "uppercase", "string", "case"]
            },
            {
                "name": "LCase", "category": "字串與文本操作", "syntax": "LCase(string)",
                "description": "返回轉換為小寫的字串。",
                "parameters": [{"name": "string", "description": "必需。任何有效的字串表達式。"}],
                "examples": [
                    {"code": "Dim UpperCaseStr As String, LowerCaseStr As String\nUpperCaseStr = \"HELLO WORLD\"\nLowerCaseStr = LCase(UpperCaseStr)\nMsgBox LowerCaseStr ' LowerCaseStr 返回 \"hello world\"", "explanation": "將字串 \"HELLO WORLD\" 轉換為小寫。"}
                ],
                "keywords": ["小寫", "轉換", "字串", "lowercase", "string", "case"]
            },
            {
                "name": "Replace", "category": "字串與文本操作", "syntax": "Replace(expression, find, replace, [start, [count, [compare]]])",
                "description": "返回一個字串，其中指定的子字串已被替換為另一個子字串指定次數。",
                "parameters": [{"name": "expression", "description": "必需。包含要替換的子字串的字串表達式。"}, {"name": "find", "description": "必需。要搜索的子字串。"}, {"name": "replace", "description": "必需。替換子字串。"}, {"name": "start", "description": "可選。開始搜索的位置。"}, {"name": "count", "description": "可選。要執行替換的次數。"}, {"name": "compare", "description": "可選。指示在評估子字串時使用的比較類型。"}],
                "examples": [
                    {"code": "Dim txt As String\ntxt = \"This is a beautiful day! This is great.\"\ntxt = Replace(txt, \"is\", \"XX\")\nMsgBox txt ' txt 變為 \"ThXX XX a beautiful day! ThXX XX great.\"", "explanation": "將字串中所有出現的 \"is\" 替換為 \"XX\"（預設區分大小寫）。"},
                    {"code": "Dim txt As String\ntxt = \"apple Apple APPLE\"\ntxt = Replace(txt, \"apple\", \"orange\", 1, 2, vbTextCompare)\nMsgBox txt ' txt 變為 \"orange orange APPLE\" ", "explanation": "從第一個字符開始，不區分大小寫地將前兩次出現的 \"apple\" 替換為 \"orange\"。"}
                ],
                "keywords": ["替換", "字串", "查找", "修改", "string", "find", "substitute"]
            },
            {
                "name": "Trim", "category": "字串與文本操作", "syntax": "Trim(string)",
                "description": "返回一個字串，其中移除了前導和尾隨空格。",
                "parameters": [{"name": "string", "description": "必需。任何有效的字串表達式。"}],
                "examples": [
                    {"code": "Dim MyString As String, TrimmedString As String\nMyString = \"  Hello World  \"\nTrimmedString = Trim(MyString)\nMsgBox \"'\" & TrimmedString & \"'\" ' TrimmedString 返回 \"Hello World\"", "explanation": "移除字串前後的空格。"}
                ],
                "keywords": ["去除空格", "空格", "字串", "清理", "string", "space", "remove"]
            },
            {
                "name": "LTrim", "category": "字串與文本操作", "syntax": "LTrim(string)",
                "description": "返回一個字串，其中移除了前導空格。",
                "parameters": [{"name": "string", "description": "必需。任何有效的字串表達式。"}],
                "examples": [
                    {"code": "Dim MyString As String, TrimmedString As String\nMyString = \"  Hello World  \"\nTrimmedString = LTrim(MyString)\nMsgBox \"'\" & TrimmedString & \"'\" ' TrimmedString 返回 \"Hello World  \"", "explanation": "移除字串左側（前導）的空格。"}
                ],
                "keywords": ["去除左側空格", "空格", "字串", "清理", "string", "space", "remove", "left trim"]
            },
            {
                "name": "RTrim", "category": "字串與文本操作", "syntax": "RTrim(string)",
                "description": "返回一個字串，其中移除了尾隨空格。",
                "parameters": [{"name": "string", "description": "必需。任何有效的字串表達式。"}],
                "examples": [
                    {"code": "Dim MyString As String, TrimmedString As String\nMyString = \"  Hello World  \"\nTrimmedString = RTrim(MyString)\nMsgBox \"'\" & TrimmedString & \"'\" ' TrimmedString 返回 \"  Hello World\"", "explanation": "移除字串右側（尾隨）的空格。"}
                ],
                "keywords": ["去除右側空格", "空格", "字串", "清理", "string", "space", "remove", "right trim"]
            },
            {
                "name": "Space", "category": "字串與文本操作", "syntax": "Space(number)",
                "description": "返回由指定數量空格組成的字串。",
                "parameters": [{"name": "number", "description": "必需。要包含在字串中的空格數。"}],
                "examples": [
                    {"code": "Dim MyString As String\nMyString = \"Hello\" & Space(5) & \"World\"\nMsgBox MyString ' 返回 \"Hello     World\"", "explanation": "生成一個包含5個空格的字串，並將其插入到 \"Hello\" 和 \"World\" 之間。"}
                ],
                "keywords": ["空格字串", "字串", "string", "spaces"]
            },
            {
                "name": "String", "category": "字串與文本操作", "syntax": "String(number, character)",
                "description": "返回由重複字元組成的字串。",
                "parameters": [{"name": "number", "description": "必需。要返回的字串的長度。"}, {"name": "character", "description": "必需。用於構成字串的字元的字元碼或字串表達式的第一個字元。"}],
                "examples": [
                    {"code": "Dim MyString1 As String\nMyString1 = String(5, \"*\")\nMsgBox MyString1 ' 返回 \"*****\"", "explanation": "生成一個由5個星號組成的字串。"},
                    {"code": "Dim MyString2 As String\nMyString2 = String(3, 65) ' 65 是 'A' 的 ASCII 碼\nMsgBox MyString2 ' 返回 \"AAA\"", "explanation": "生成一個由3個字元 'A' 組成的字串（使用ASCII碼）。"}
                ],
                "keywords": ["重複字串", "字串", "string", "repeating characters", "char"]
            },
            {
                "name": "StrReverse", "category": "字串與文本操作", "syntax": "StrReverse(Expression)",
                "description": "返回反轉了字元順序的字串。",
                "parameters": [{"name": "Expression", "description": "必需。要反轉的字串表達式。"}],
                "examples": [
                    {"code": "Dim MyStr As String\nMyStr = StrReverse(\"VBA Rocks\")\nMsgBox MyStr ' 返回 \"skcoR ABV\"", "explanation": "將字串 \"VBA Rocks\" 的字元順序反轉。"}
                ],
                "keywords": ["反轉字串", "字串", "string", "reverse"]
            },
            {
                "name": "StrComp", "category": "字串與文本操作", "syntax": "StrComp(string1, string2[, compare])",
                "description": "返回一個 Variant (Integer)，指示字串比較的結果。",
                "parameters": [{"name": "string1", "description": "必需。字串表達式。"}, {"name": "string2", "description": "必需。字串表達式。"}, {"name": "compare", "description": "可選。比較類型 (vbBinaryCompare, vbTextCompare)。"}],
                "examples": [
                    {"code": "Debug.Print StrComp(\"ABC\", \"abc\", vbTextCompare) ' 返回 0 (相等)", "explanation": "不區分大小寫地比較 \"ABC\" 和 \"abc\"，結果為相等(0)。"},
                    {"code": "Debug.Print StrComp(\"ABC\", \"abc\", vbBinaryCompare) ' 返回 -1 (string1 < string2)", "explanation": "區分大小寫地比較 \"ABC\" 和 \"abc\"，結果為 \"ABC\" 小於 \"abc\" (-1)。"}
                ],
                "keywords": ["字串比較", "比較", "string", "compare", "text", "binary"]
            },
            {
                "name": "Format", "category": "字串與文本操作", "syntax": "Format(Expression, [Format], [FirstDayOfWeek], [FirstWeekOfYear])",
                "description": "根據格式指令返回格式化的 Variant (String)。",
                "parameters": [{"name": "Expression", "description": "必需。任何有效的表達式。"}, {"name": "Format", "description": "可選。有效的命名或用戶定義的格式表達式。"}, {"name": "FirstDayOfWeek", "description": "可選。指定一周中第一天的常數。"}, {"name": "FirstWeekOfYear", "description": "可選。指定一年中第一周的常數。"}],
                "examples": [
                    {"code": "Dim MyDate As Date, FormattedDate As String\nMyDate = Now\nFormattedDate = Format(MyDate, \"yyyy-mm-dd hh:nn:ss\")\nMsgBox FormattedDate", "explanation": "將當前日期和時間格式化為 \"年-月-日 時:分:秒\" 的形式。"},
                    {"code": "MsgBox Format(5459.4, \"##,##0.00\") ' 返回 \"5,459.40\"", "explanation": "將數字 5459.4 格式化為帶千位分隔符且保留兩位小數的字串。"},
                    {"code": "MsgBox Format(0.75, \"Percent\") ' 返回 \"75.00%\"", "explanation": "將數字 0.75 格式化為百分比形式。"}
                ],
                "keywords": ["格式化", "字串", "日期", "數字", "顯示", "string", "date", "number", "display"]
            },
             {
                "name": "Asc", "category": "字串與文本操作", "syntax": "Asc(string)",
                "description": "返回字串第一個字元的 ANSI 字元碼 (Integer)。",
                "parameters": [{"name": "string", "description": "必需。任何有效的字串表達式。"}],
                "examples": [
                    {"code": "MsgBox Asc(\"A\")  ' 返回 65", "explanation": "獲取字元 'A' 的 ANSI 碼。"},
                    {"code": "MsgBox Asc(\"Apple\") ' 返回 65 (只看第一個字元 'A')", "explanation": "獲取字串 \"Apple\" 中第一個字元 'A' 的 ANSI 碼。"}
                ],
                "keywords": ["ANSI碼", "字元碼", "ASCII", "character code"]
            },
            {
                "name": "Chr", "category": "字串與文本操作", "syntax": "Chr(charcode)",
                "description": "返回與指定 ANSI 字元碼相關聯的字元 (String)。",
                "parameters": [{"name": "charcode", "description": "必需。識別字元的 ANSI 字元碼。"}],
                "examples": [
                    {"code": "MsgBox Chr(65) ' 返回 \"A\"", "explanation": "根據 ANSI 碼 65 獲取對應字元。"},
                    {"code": "MsgBox Chr(34) ' 返回 \\\" (雙引號)", "explanation": "獲取雙引號字元。常用於在字串中嵌入引號。"}
                ],
                "keywords": ["字元", "ANSI碼轉換", "ASCII", "character from code"]
            },
            {
                "name": "vbCrLf", "category": "字串與文本操作", "syntax": "vbCrLf",
                "description": "一個內建常數，代表換行符 (回車符後接換行符)。用於在字串中創建新行。",
                "parameters": [],
                "examples": [
                    {"code": "MsgBox \"第一行\" & vbCrLf & \"第二行\"", "explanation": "在訊息框中顯示兩行文字。"},
                    {"code": "Dim multiLineText As String\nmultiLineText = \"報告標題\" & vbCrLf & String(20, \"-\") & vbCrLf & \"內容...\"\nRange(\"A1\").Value = multiLineText", "explanation": "創建一個多行字串並將其寫入 Excel 儲存格。"}
                ],
                "keywords": ["換行", "新行", "回車換行", "newline", "carriage return line feed", "constant", "vbCr", "vbLf", "vbNewLine"]
            },
            {
                "name": "FormatCurrency", "category": "字串與文本操作", "syntax": "FormatCurrency(Expression[, NumDigitsAfterDecimal[, IncludeLeadingDigit[, UseParensForNegativeNumbers[, GroupDigits]]]])",
                "description": "返回一個格式化為貨幣值的表達式，使用系統控制面板中定義的貨幣符號。",
                "parameters": [
                    {"name": "Expression", "description": "必需。要格式化的表達式。"},
                    {"name": "NumDigitsAfterDecimal", "description": "可選。數值，指示顯示小數點右側多少位。"}
                ],
                "examples": [
                    {"code": "Dim myAmount As Double: myAmount = 1234.567\nMsgBox FormatCurrency(myAmount) ' 顯示如 \"$1,234.57\" (根據系統設定)", "explanation": "將數字格式化為系統預設的貨幣格式。"},
                    {"code": "MsgBox FormatCurrency(1234.5, 0) ' 顯示如 \"$1,235\"", "explanation": "將數字格式化為貨幣，不顯示小數位。"}
                ],
                "keywords": ["格式化貨幣", "貨幣顯示", "format currency", "currency string"]
            },
            {
                "name": "FormatDateTime", "category": "字串與文本操作", "syntax": "FormatDateTime(Date[, NamedFormat])",
                "description": "返回一個格式化為日期或時間的表達式。",
                "parameters": [
                    {"name": "Date", "description": "必需。要格式化的日期表達式。"},
                    {"name": "NamedFormat", "description": "可選。指示所用日期/時間格式的數值 (vbGeneralDate, vbLongDate, vbShortDate, vbLongTime, vbShortTime)。"}
                ],
                "examples": [
                    {"code": "MsgBox FormatDateTime(Now, vbLongDate) ' 顯示長日期格式，如 \"2023年10月27日\"", "explanation": "以長日期格式顯示當前日期。"},
                    {"code": "MsgBox FormatDateTime(Now, vbShortTime) ' 顯示短時間格式，如 \"14:30\"", "explanation": "以短時間格式顯示當前時間。"}
                ],
                "keywords": ["格式化日期時間", "日期顯示", "時間顯示", "format date time", "date string", "time string"]
            },
            {
                "name": "FormatNumber", "category": "字串與文本操作", "syntax": "FormatNumber(Expression[, NumDigitsAfterDecimal[, IncludeLeadingDigit[, UseParensForNegativeNumbers[, GroupDigits]]]])",
                "description": "返回一個格式化為數字的表達式。",
                "parameters": [
                    {"name": "Expression", "description": "必需。要格式化的表達式。"},
                    {"name": "NumDigitsAfterDecimal", "description": "可選。指示顯示多少位小數。"}
                ],
                "examples": [
                    {"code": "MsgBox FormatNumber(12345.6789, 2) ' 顯示 \"12,345.68\"", "explanation": "將數字格式化，保留兩位小數並使用千位分隔符。"}
                ],
                "keywords": ["格式化數字", "數字顯示", "format number", "number string"]
            },
            {
                "name": "FormatPercent", "category": "字串與文本操作", "syntax": "FormatPercent(Expression[, NumDigitsAfterDecimal[, IncludeLeadingDigit[, UseParensForNegativeNumbers[, GroupDigits]]]])",
                "description": "返回一個格式化為百分比 (乘以 100) 並帶有尾隨 % 字符的表達式。",
                "parameters": [
                    {"name": "Expression", "description": "必需。要格式化的表達式。"},
                    {"name": "NumDigitsAfterDecimal", "description": "可選。指示顯示多少位小數。"}
                ],
                "examples": [
                    {"code": "MsgBox FormatPercent(0.7525, 2) ' 顯示 \"75.25%\"", "explanation": "將數字0.7525格式化為百分比，保留兩位小數。"}
                ],
                "keywords": ["格式化百分比", "百分比顯示", "format percent", "percent string"]
            },

            // --- 陣列、集合與字典 (Arrays, Collections & Dictionaries) ---
            {
                "name": "Array", "category": "陣列、集合與字典", "syntax": "Array(arglist)",
                "description": "返回一個包含數組的 Variant。",
                "parameters": [{"name": "arglist", "description": "必需。賦值給數組元素的參數列表，以逗號分隔。"}],
                "examples": [
                    {"code": "Dim MyWeekDays As Variant\nMyWeekDays = Array(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\")\nMsgBox MyWeekDays(0) ' 顯示 \"Sun\"", "explanation": "快速創建一個包含星期名稱的 Variant 數組。"}
                ],
                "keywords": ["創建數組", "數組", "初始化", "array", "initialize", "variant array", "make array"]
            },
            {
                "name": "Split", "category": "陣列、集合與字典", "syntax": "Split(expression, [delimiter], [limit], [compare])",
                "description": "返回一個基於零的一維數組，其中包含指定數量的子字串。",
                "parameters": [{"name": "expression", "description": "必需。包含子字串和分隔符的字串表達式。"}, {"name": "delimiter", "description": "可選。用於標識子字串限制的字串字符。"}, {"name": "limit", "description": "可選。要返回的子字串數。"}, {"name": "compare", "description": "可選。數值，指示在評估子字串時使用的比較類型。"}],
                "examples": [
                    {"code": "Dim Text As String, MyArray As Variant\nText = \"apple,banana,orange\"\nMyArray = Split(Text, \",\")\nMsgBox MyArray(1) ' MyArray(1) 為 \"banana\"", "explanation": "將逗號分隔的字串分割成一個字串數組。"}
                ],
                "keywords": ["分割", "字串", "數組", "分隔符", "array", "string", "delimiter", "string to array"]
            },
            {
                "name": "Join", "category": "陣列、集合與字典", "syntax": "Join(sourcearray, [delimiter])",
                "description": "返回通過連接數組中包含的子字串而創建的字串。",
                "parameters": [{"name": "sourcearray", "description": "必需。包含要連接的子字串的一維數組。"}, {"name": "delimiter", "description": "可選。用於分隔返回字串中子字串的字串字符。"}],
                "examples": [
                    {"code": "Dim MyArr(0 To 2) As String, Result As String\nMyArr(0) = \"Red\"\nMyArr(1) = \"Green\"\nMyArr(2) = \"Blue\"\nResult = Join(MyArr, \"-\")\nMsgBox Result ' Result 為 \"Red-Green-Blue\"", "explanation": "將數組中的元素用連字號 \"-\" 連接成一個單一字串。"}
                ],
                "keywords": ["合併", "字串", "數組", "連接", "array", "string", "concatenate", "array to string"]
            },
            {
                "name": "UBound", "category": "陣列、集合與字典", "syntax": "UBound(arrayname[, dimension])",
                "description": "返回一個 Long，其中包含指定數組維度的最大可用下標。",
                "parameters": [{"name": "arrayname", "description": "必需。數組變數的名稱。"}, {"name": "dimension", "description": "可選。指示返回哪個維度的上限。"}],
                "examples": [
                    {"code": "Dim MyArray(1 To 10, 0 To 3) As Integer\nMsgBox UBound(MyArray, 1)  ' 返回 10", "explanation": "獲取二維數組 MyArray 第一個維度的上限索引。"},
                    {"code": "Dim SimpleArray(5) As String\nMsgBox UBound(SimpleArray) ' 返回 5 (預設第一維)", "explanation": "獲取一維數組 SimpleArray 的上限索引。"}
                ],
                "keywords": ["數組上限", "數組", "維度", "邊界", "array", "upper bound", "dimension", "size"]
            },
            {
                "name": "LBound", "category": "陣列、集合與字典", "syntax": "LBound(arrayname[, dimension])",
                "description": "返回一個 Long，其中包含指定數組維度的最小可用下標。",
                "parameters": [{"name": "arrayname", "description": "必需。數組變數的名稱。"}, {"name": "dimension", "description": "可選。指示返回哪個維度的下限。"}],
                "examples": [
                    {"code": "Dim MyArray(1 To 10, 0 To 3) As Integer\nMsgBox LBound(MyArray, 2)  ' 返回 0", "explanation": "獲取二維數組 MyArray 第二個維度的下限索引。"},
                    {"code": "Dim AnotherArray(3 To 7) As Integer\nMsgBox LBound(AnotherArray) ' 返回 3", "explanation": "獲取自訂下限索引的數組的下限。"}
                ],
                "keywords": ["數組下限", "數組", "維度", "邊界", "array", "lower bound", "dimension", "size"]
            },
            {
                "name": "Erase", "category": "陣列、集合與字典", "syntax": "Erase arraylist",
                "description": "重新初始化固定大小數組的元素，並釋放動態數組的存儲空間。",
                "parameters": [{"name": "arraylist", "description": "必需。一個或多個以逗號分隔的數組變數的列表。"}],
                "examples": [
                    {"code": "Dim NumArray(10) As Integer ' 固定大小數組\nNumArray(5) = 100\nErase NumArray\nMsgBox NumArray(5) ' 元素重置為0", "explanation": "對於固定大小數組，Erase 將所有元素重置為其資料類型的預設初始值。"},
                    {"code": "Dim StrDynArray() As String\nReDim StrDynArray(5)\nStrDynArray(0) = \"Test\"\nErase StrDynArray\n' MsgBox UBound(StrDynArray) ' 這會產生錯誤，因為數組已取消分配", "explanation": "對於動態數組，Erase 會釋放其內存，數組變為未分配狀態。"}
                ],
                "keywords": ["清除數組", "重置數組", "釋放內存", "array", "clear", "reset", "deallocate"]
            },
            {
                "name": "Filter", "category": "陣列、集合與字典", "syntax": "Filter(sourcearray, match[, include[, compare]])",
                "description": "返回一個基於零的數組，其中包含基於指定篩選條件的字串數組的子集。",
                "parameters": [{"name": "sourcearray", "description": "必需。要搜索的一維字串數組。"}, {"name": "match", "description": "必需。要搜索的字串。"}, {"name": "include", "description": "可選。Boolean 值，指示是否返回包含或不包含 match 的子字串。"}, {"name": "compare", "description": "可選。指示要使用的字串比較類型。"}],
                "examples": [
                    {"code": "Dim MyArr As Variant, FilteredArr As Variant\nMyArr = Array(\"Apple Pie\", \"Banana Bread\", \"Cherry Cake\", \"Apple Juice\")\nFilteredArr = Filter(MyArr, \"Apple\")\n' FilteredArr 將包含 \"Apple Pie\", \"Apple Juice\"", "explanation": "從數組中篩選出所有包含子字串 \"Apple\" 的元素。"},
                    {"code": "Dim MyArr As Variant, ExcludedArr As Variant\nMyArr = Array(\"Apple Pie\", \"Banana Bread\", \"Cherry Cake\")\nExcludedArr = Filter(MyArr, \"Apple\", False)\n' ExcludedArr 將包含 \"Banana Bread\", \"Cherry Cake\"", "explanation": "從數組中篩選出所有不包含子字串 \"Apple\" 的元素。"}
                ],
                "keywords": ["篩選數組", "數組", "查找", "string array", "search", "subset", "array filter"]
            },
            {
                "name": "Scripting.Dictionary", "category": "陣列、集合與字典", "syntax": "Set dict = CreateObject(\"Scripting.Dictionary\")",
                "description": "創建一個字典物件，用於儲存鍵值對集合。鍵必須是唯一的。",
                "parameters": [
                    {"name": "Add key, item", "description": "方法：將指定的鍵和項目添加到字典中。"},
                    {"name": "Exists(key)", "description": "方法：如果指定的鍵存在於字典中，則返回 True。"},
                    {"name": "Item(key)", "description": "屬性/方法：設置或返回與指定鍵關聯的項目。"},
                    {"name": "Keys()", "description": "方法：返回一個包含字典中所有鍵的陣列。"},
                    {"name": "Items()", "description": "方法：返回一個包含字典中所有項目的陣列。"},
                    {"name": "Remove(key)", "description": "方法：從字典中刪除指定的鍵值對。"},
                    {"name": "RemoveAll", "description": "方法：從字典中刪除所有鍵值對。"},
                    {"name": "Count", "description": "屬性：返回字典中的鍵值對數量。"},
                    {"name": "CompareMode", "description": "屬性：設置或返回鍵的比較模式 (vbBinaryCompare, vbTextCompare)。"}
                ],
                "examples": [
                    {"code": "Dim myDict As Object\nSet myDict = CreateObject(\"Scripting.Dictionary\")\n' 添加項目\nmydict.Add \"Name\", \"John Doe\"\nmydict.Add \"Age\", 30\n' 檢查鍵是否存在\nIf myDict.Exists(\"Age\") Then\n  MsgBox \"Age: \" & myDict.Item(\"Age\")\nEnd If\n' 遍歷所有鍵\nDim k As Variant\nFor Each k In myDict.Keys\n  Debug.Print k & \": \" & myDict(k)\nNext k\n' 刪除項目\nmydict.Remove \"Age\"\nSet myDict = Nothing", "explanation": "演示如何創建字典、添加、檢查、讀取和刪除項目。"}
                ],
                "keywords": ["字典", "集合", "鍵值對", "dictionary", "collection", "key-value pair", "hash map", "associative array"]
            },
            {
                "name": "Collection Object", "category": "陣列、集合與字典", "syntax": "Set coll = New Collection",
                "description": "提供一種方便的方式來引用一組相關的項目作為單個物件。集合中的項目（元素）可以通過索引號或唯一字串鍵來訪問。",
                "parameters": [
                    {"name": "Add item, [key], [before], [after]", "description": "方法：將項目添加到集合中。"},
                    {"name": "Count", "description": "屬性（唯讀）：返回集合中的項目數。"},
                    {"name": "Item(indexOrKey)", "description": "方法/屬性（預設）：通過其索引或鍵從集合中檢索項目。"},
                    {"name": "Remove(indexOrKey)", "description": "方法：從集合中刪除項目。"}
                ],
                "examples": [
                    {"code": "Dim myCollection As New Collection\nmyCollection.Add \"Apple\", \"Fruit1\"\nmyCollection.Add \"Banana\"\nmyCollection.Add 123, \"NumKey\"\nMsgBox \"Count: \" & myCollection.Count ' 顯示 3\nMsgBox \"Item by key 'Fruit1': \" & myCollection.Item(\"Fruit1\")\nMsgBox \"Item by index 2: \" & myCollection(2) ' Banana, 因為索引從1開始\nmyCollection.Remove \"NumKey\"\nFor Each element In myCollection\n    Debug.Print element\nNext", "explanation": "演示如何創建集合、添加帶鍵和不帶鍵的項目、計數、按鍵和索引訪問項目、刪除項目以及遍歷集合。"}
                ],
                "keywords": ["集合", "列表", "動態列表", "collection", "list", "add item", "remove item"]
            },
            {
                "name": "ArrayList (System.Collections.ArrayList)",
                "category": "陣列、集合與字典",
                "syntax": "Set arrList = CreateObject(\"System.Collections.ArrayList\")",
                "description": "建立一個 .NET Framework 的 ArrayList 物件。ArrayList 是一個動態陣列，可以新增、移除項目，並提供排序、搜尋等方法。比 VBA 內建的 Collection 功能更豐富。",
                "parameters": [
                    {"name": "Add(value)", "description": "方法：將物件新增至 ArrayList 的結尾。"},
                    {"name": "AddRange(collection)", "description": "方法：將 ICollection 的元素新增至 ArrayList 的結尾。"},
                    {"name": "Sort()", "description": "方法：使用預設比較子排序整個 ArrayList 中的元素。"},
                    {"name": "Reverse()", "description": "方法：反轉整個 ArrayList 中元素的順序。"},
                    {"name": "Insert(index, value)", "description": "方法：將元素插入 ArrayList 中指定的索引處。"},
                    {"name": "Remove(value)", "description": "方法：從 ArrayList 中移除特定物件的第一個相符項目。"},
                    {"name_": "RemoveAt(index)", "description": "方法：移除 ArrayList 中指定索引處的元素。"},
                    {"name": "Contains(value)", "description": "方法：判斷某個元素是否在 ArrayList 中。"},
                    {"name": "IndexOf(value)", "description": "方法：傳回指定物件在 ArrayList 中的索引 (從零開始)。"},
                    {"name": "ToArray()", "description": "方法：將 ArrayList 的元素複製到新的物件陣列。"},
                    {"name": "Count", "description": "屬性：取得 ArrayList 中實際包含的元素數目。"},
                    {"name": "Capacity", "description": "屬性：取得或設定 ArrayList 可以包含的元素數目。"}
                ],
                "examples": [
                    {"code": "Dim myList As Object\nSet myList = CreateObject(\"System.Collections.ArrayList\")\nmyList.Add \"Banana\"\nmyList.Add \"Apple\"\nmyList.Add \"Orange\"\nmyList.Sort ' 排序: Apple, Banana, Orange\nmyList.Insert 1, \"Grape\" ' 在索引 1 插入 Grape\nDebug.Print \"Count: \" & myList.Count ' 顯示 4\nDim item As Variant\nFor Each item In myList\n  Debug.Print item\nNext\nIf myList.Contains(\"Apple\") Then Debug.Print \"Apple is in the list.\"\nDim vArray As Variant\nvArray = myList.ToArray()\n' vArray 現在是一個 VBA 陣列，包含 ArrayList 的內容\nSet myList = Nothing", "explanation": "演示如何建立 ArrayList、新增項目、排序、插入、檢查包含、轉換為 VBA 陣列等操作。"}
                ],
                "keywords": ["arraylist", "dynamic array", "sortable list", ".net arraylist", "collections", "advanced array", "動態陣列", "可排序列表", "列表"]
            },
            {
                "name": "SortedList (System.Collections.SortedList)",
                "category": "陣列、集合與字典",
                "syntax": "Set sList = CreateObject(\"System.Collections.SortedList\")",
                "description": "建立一個 .NET Framework 的 SortedList 物件。SortedList 代表一個索引鍵/值組的集合，這些組依索引鍵排序，並可透過索引鍵和索引存取。",
                "parameters": [
                    {"name": "Add(key, value)", "description": "方法：將具有指定索引鍵和值的元素新增至 SortedList。"},
                    {"name": "GetKey(index)", "description": "方法：取得 SortedList 中指定索引處的索引鍵。"},
                    {"name": "GetByIndex(index)", "description": "方法：取得 SortedList 中指定索引處的值。"},
                    {"name": "ContainsKey(key)", "description": "方法：判斷 SortedList 是否包含特定索引鍵。"},
                    {"name": "ContainsValue(value)", "description": "方法：判斷 SortedList 是否包含特定值。"},
                    {"name": "IndexOfKey(key)", "description": "方法：傳回 SortedList 中指定索引鍵的以零為起始的索引。"},
                    {"name": "IndexOfValue(value)", "description": "方法：傳回 SortedList 中指定值的第一個相符項目的以零為起始的索引。"},
                    {"name": "Remove(key)", "description": "方法：從 SortedList 中移除具有指定索引鍵的元素。"},
                    {"name": "RemoveAt(index)", "description": "方法：移除 SortedList 中指定索引處的元素。"},
                    {"name": "Keys", "description": "屬性：取得 SortedList 中的索引鍵 (傳回 IList)。"},
                    {"name": "Values", "description": "屬性：取得 SortedList 中的值 (傳回 IList)。"},
                    {"name": "Count", "description": "屬性：取得 SortedList 中包含的索引鍵/值組數目。"}
                ],
                "examples": [
                    {"code": "Dim employeeSalaries As Object\nSet employeeSalaries = CreateObject(\"System.Collections.SortedList\")\nemployeeSalaries.Add \"Charlie\", 60000\nemployeeSalaries.Add \"Alice\", 75000\nemployeeSalaries.Add \"Bob\", 55000\n' 項目會自動依索引鍵 (姓名) 排序：Alice, Bob, Charlie\nDebug.Print \"Bob's salary: \" & employeeSalaries.Item(\"Bob\")\nDebug.Print \"Salary at index 0 (Alice): \" & employeeSalaries.GetByIndex(0)\nDebug.Print \"Key at index 0: \" & employeeSalaries.GetKey(0)\nDim i As Long\nFor i = 0 To employeeSalaries.Count - 1\n  Debug.Print employeeSalaries.GetKey(i) & \": \" & employeeSalaries.GetByIndex(i)\nNext i\nSet employeeSalaries = Nothing", "explanation": "演示如何建立 SortedList、新增鍵值對 (會自動按鍵排序)、按鍵或索引讀取值，以及遍歷所有項目。"}
                ],
                "keywords": ["sortedlist", "dictionary sorted", "key value pair sorted", ".net sortedlist", "ordered dictionary", "已排序列表", "已排序字典", "鍵值對排序"]
            },
            {
                "name": "Hashtable (System.Collections.Hashtable)",
                "category": "陣列、集合與字典",
                "syntax": "Set ht = CreateObject(\"System.Collections.Hashtable\")",
                "description": "建立一個 .NET Framework 的 Hashtable 物件。Hashtable 代表一個索引鍵/值組的集合，這些組是根據索引鍵的雜湊碼來組織的。類似於 VBA 的 Scripting.Dictionary，但來自 .NET Framework。",
                "parameters": [
                    {"name": "Add(key, value)", "description": "方法：將具有指定索引鍵和值的元素新增至 Hashtable。"},
                    {"name": "Remove(key)", "description": "方法：從 Hashtable 中移除具有指定索引鍵的元素。"},
                    {"name": "ContainsKey(key)", "description": "方法：判斷 Hashtable 是否包含特定索引鍵。"},
                    {"name": "ContainsValue(value)", "description": "方法：判斷 Hashtable 是否包含特定值。"},
                    {"name": "Keys", "description": "屬性：取得包含 Hashtable 中索引鍵的 ICollection。"},
                    {"name": "Values", "description": "屬性：取得包含 Hashtable 中值的 ICollection。"},
                    {"name": "Count", "description": "屬性：取得 Hashtable 中包含的索引鍵/值組數目。"},
                    {"name": "Item(key)", "description": "屬性/方法：取得或設定與指定索引鍵關聯的值。"}
                ],
                "examples": [
                    {"code": "Dim configSettings As Object\nSet configSettings = CreateObject(\"System.Collections.Hashtable\")\nconfigSettings.Add \"Server\", \"SQL01\"\nconfigSettings.Add \"Database\", \"ProductionDB\"\nconfigSettings.Add \"Timeout\", 30\nIf configSettings.ContainsKey(\"Server\") Then\n  Debug.Print \"Server: \" & configSettings.Item(\"Server\")\nEnd If\nconfigSettings.Item(\"Timeout\") = 60 ' 修改值\nDim key As Variant\nFor Each key In configSettings.Keys ' 遍歷 Keys (順序不保證)\n  Debug.Print key & \": \" & configSettings(key)\nNext key\nSet configSettings = Nothing", "explanation": "演示如何建立 Hashtable、新增鍵值對、檢查鍵是否存在、修改值以及遍歷所有鍵值對。"}
                ],
                "keywords": ["hashtable", "dictionary .net", ".net dictionary", "key value pair", "雜湊表", "字典物件 (.NET)"]
            },
            {
                "name": "Queue (System.Collections.Queue)",
                "category": "陣列、集合與字典",
                "syntax": "Set q = CreateObject(\"System.Collections.Queue\")",
                "description": "建立一個 .NET Framework 的 Queue 物件。Queue 代表物件的先進先出 (FIFO) 集合。",
                "parameters": [
                    {"name": "Enqueue(obj)", "description": "方法：將物件新增至 Queue 的結尾。"},
                    {"name": "Dequeue()", "description": "方法：移除並傳回位於 Queue 開始處的物件。"},
                    {"name": "Peek()", "description": "方法：傳回位於 Queue 開始處的物件，但不將其移除。"},
                    {"name": "Contains(obj)", "description": "方法：判斷某個元素是否在 Queue 中。"},
                    {"name": "ToArray()", "description": "方法：將 Queue 的元素複製到新的一維陣列。"},
                    {"name": "Count", "description": "屬性：取得 Queue 中包含的元素數目。"}
                ],
                "examples": [
                    {"code": "Dim taskQueue As Object\nSet taskQueue = CreateObject(\"System.Collections.Queue\")\ntaskQueue.Enqueue \"Task 1: Initialize\"\ntaskQueue.Enqueue \"Task 2: Process Data\"\ntaskQueue.Enqueue \"Task 3: Generate Report\"\nDebug.Print \"Next task: \" & taskQueue.Peek() ' 顯示 Task 1\nDim currentTask As Variant\nDo While taskQueue.Count > 0\n  currentTask = taskQueue.Dequeue()\n  Debug.Print \"Processing: \" & currentTask\n  ' ... 執行任務 ...\nLoop\nDebug.Print \"Queue empty. Count: \" & taskQueue.Count", "explanation": "演示如何建立佇列、將任務加入佇列 (Enqueue)、查看下一個任務 (Peek) 以及處理並從佇列中移除任務 (Dequeue)。"}
                ],
                "keywords": ["queue", "fifo", "first in first out", ".net queue", "task queue", "佇列", "先進先出"]
            },
            {
                "name": "Stack (System.Collections.Stack)",
                "category": "陣列、集合與字典",
                "syntax": "Set stk = CreateObject(\"System.Collections.Stack\")",
                "description": "建立一個 .NET Framework 的 Stack 物件。Stack 代表物件的後進先出 (LIFO) 集合。",
                "parameters": [
                    {"name": "Push(obj)", "description": "方法：將物件插入 Stack 的頂端。"},
                    {"name": "Pop()", "description": "方法：移除並傳回位於 Stack 頂端的物件。"},
                    {"name": "Peek()", "description": "方法：傳回位於 Stack 頂端的物件，但不將其移除。"},
                    {"name": "Contains(obj)", "description": "方法：判斷某個元素是否在 Stack 中。"},
                    {"name": "ToArray()", "description": "方法：將 Stack 的元素複製到新的一維陣列。"},
                    {"name": "Count", "description": "屬性：取得 Stack 中包含的元素數目。"}
                ],
                "examples": [
                    {"code": "Dim undoStack As Object\nSet undoStack = CreateObject(\"System.Collections.Stack\")\nundoStack.Push \"Action A\"\nundoStack.Push \"Action B\"\nundoStack.Push \"Action C\"\nDebug.Print \"Last action: \" & undoStack.Peek() ' 顯示 Action C\nDim lastAction As Variant\nDo While undoStack.Count > 0\n  lastAction = undoStack.Pop()\n  Debug.Print \"Undoing: \" & lastAction\n  ' ... 執行復原動作 ...\nLoop\nDebug.Print \"Stack empty. Count: \" & undoStack.Count", "explanation": "演示如何建立堆疊、將動作推入堆疊 (Push)、查看最頂層動作 (Peek) 以及彈出並處理動作 (Pop)，模擬復原操作。"}
                ],
                "keywords": ["stack", "lifo", "last in first out", ".net stack", "undo stack", "堆疊", "後進先出"]
            },
            {
                "name": "Jagged Array (陣列的陣列)",
                "category": "陣列、集合與字典",
                "syntax": "Dim jaggedArray() As Variant\nReDim jaggedArray(0 To N-1)\nFor i = 0 To N-1\n  ReDim jaggedArray(i)(0 To M_i - 1) As ElementType\nNext i",
                "description": "交錯陣列 (Jagged Array) 是一種其元素本身也是陣列的陣列，且內部陣列的維度可以不同。VBA 中通常使用 Variant 類型陣列來實現。",
                "parameters": [
                    {"name": "Outer Array Dimension", "description": "外部陣列的大小。"},
                    {"name": "Inner Array Dimensions", "description": "每個內部陣列的大小，可以各不相同。"}
                ],
                "examples": [
                    {"code": "Dim studentCourses() As Variant ' Array to hold arrays of courses for each student\nDim numStudents As Integer: numStudents = 3\nDim i As Integer, j As Integer\n\nReDim studentCourses(0 To numStudents - 1)\n\n' Student 0 courses\nReDim studentCourses(0)(0 To 2) As String\nstudentCourses(0)(0) = \"Math\"\nstudentCourses(0)(1) = \"Science\"\nstudentCourses(0)(2) = \"History\"\n\n' Student 1 courses\nReDim studentCourses(1)(0 To 1) As String\nstudentCourses(1)(0) = \"Art\"\nstudentCourses(1)(1) = \"Music\"\n\n' Student 2 courses (no courses)\n' studentCourses(2) remains Empty or can be ReDimmed to (0 To -1) if needed\n\n' Display courses\nFor i = 0 To UBound(studentCourses)\n  Debug.Print \"Student \" & i & \" courses:\"\n  If Not IsEmpty(studentCourses(i)) Then ' Check if inner array is initialized\n    If UBound(studentCourses(i)) >= LBound(studentCourses(i)) Then\n        For j = LBound(studentCourses(i)) To UBound(studentCourses(i))\n            Debug.Print \"  - \" & studentCourses(i)(j)\n        Next j\n    Else\n        Debug.Print \"  (No courses listed for this student)\"\n    End If\n  Else\n    Debug.Print \"  (No courses assigned)\"\n  End If\nNext i", "explanation": "建立一個交錯陣列來儲存每個學生的課程列表，其中每個學生可以有不同數量的課程。然後遍歷並顯示這些課程。"}
                ],
                "keywords": ["jagged array", "array of arrays", "dynamic multidimensional array", "variant array", "交錯陣列", "陣列的陣列", "不規則陣列"]
            },
            {
                "name": "Collection of Collections",
                "category": "陣列、集合與字典",
                "syntax": "Set mainColl = New Collection\nSet innerColl1 = New Collection\nmainColl.Add innerColl1",
                "description": "使用 VBA 的 Collection 物件來建立巢狀結構，其中一個主 Collection 包含其他 Collection 物件作為其元素。這可以用於組織階層式資料。",
                "parameters": [
                    {"name": "Main Collection", "description": "外部或父集合。"},
                    {"name": "Inner Collections", "description": "作為主集合元素的子集合。"}
                ],
                "examples": [
                    {"code": "Dim departments As New Collection\nDim hrDept As New Collection, itDept As New Collection\nDim emp1 As Object, emp2 As Object, emp3 As Object ' Could be custom class or Dictionary\n\n' HR Department\nhrDept.Add \"Alice (HR Manager)\"\nhrDept.Add \"Bob (HR Specialist)\"\ndepartments.Add hrDept, \"HR\"\n\n' IT Department\nitDept.Add \"Charlie (IT Director)\"\nitDept.Add \"David (System Admin)\"\nitDept.Add \"Eve (Developer)\"\ndepartments.Add itDept, \"IT\"\n\n' Accessing data\nDebug.Print \"--- HR Department ---\"\nDim hrEmployee As Variant\nFor Each hrEmployee In departments.Item(\"HR\")\n  Debug.Print hrEmployee\nNext hrEmployee\n\nDebug.Print \"--- IT Department --- (Accessing second employee in IT)\"\nIf departments.Item(\"IT\").Count >= 2 Then\n  Debug.Print departments.Item(\"IT\").Item(2) ' David (System Admin)\nEnd If\n\nSet departments = Nothing: Set hrDept = Nothing: Set itDept = Nothing", "explanation": "建立一個名為 'departments' 的主集合，其中包含代表不同部門 ('HR', 'IT') 的子集合。每個子集合包含該部門的員工姓名。然後演示如何訪問這些巢狀資料。"}
                ],
                "keywords": ["collection of collections", "nested collections", "hierarchical data", "vba collection", "集合的集合", "巢狀集合", "階層資料"]
            },
            {
                "name": "Collection of Dictionaries",
                "category": "陣列、集合與字典",
                "syntax": "Set mainColl = New Collection\nSet dict1 = CreateObject(\"Scripting.Dictionary\")\nmainColl.Add dict1",
                "description": "建立一個 VBA Collection，其元素是 Scripting.Dictionary 物件。這允許每個元素都是一組鍵值對，從而實現更結構化的資料儲存。",
                "parameters": [
                    {"name": "Collection", "description": "外部集合，用於儲存字典物件。"},
                    {"name": "Dictionary", "description": "Scripting.Dictionary 物件，包含鍵值對資料。"}
                ],
                "examples": [
                    {"code": "Dim employeeList As New Collection\nDim emp1Dict As Object, emp2Dict As Object\n\n' Employee 1\nSet emp1Dict = CreateObject(\"Scripting.Dictionary\")\nemp1Dict.Add \"ID\", \"E1001\"\nemp1Dict.Add \"Name\", \"Alice Wonderland\"\nemp1Dict.Add \"Department\", \"Sales\"\nemp1Dict.Add \"Salary\", 70000\nemployeeList.Add emp1Dict\n\n' Employee 2\nSet emp2Dict = CreateObject(\"Scripting.Dictionary\")\nemp2Dict.Add \"ID\", \"E1002\"\nemp2Dict.Add \"Name\", \"Bob The Builder\"\nemp2Dict.Add \"Department\", \"Construction\"\nemp2Dict.Add \"Salary\", 65000\nemployeeList.Add emp2Dict\n\n' Access and display data\nDim empData As Object ' Will hold a Dictionary object\nFor Each empData In employeeList\n  Debug.Print \"Employee ID: \" & empData(\"ID\") & \", Name: \" & empData(\"Name\") & _\n                \", Dept: \" & empData(\"Department\") & \", Salary: \" & empData(\"Salary\")\nNext empData\n\n' Access specific employee's data\nIf employeeList.Count >= 1 Then\n  Debug.Print \"First employee's name: \" & employeeList(1)(\"Name\")\nEnd If\n\nSet employeeList = Nothing: Set emp1Dict = Nothing: Set emp2Dict = Nothing", "explanation": "建立一個員工列表 (Collection)，其中每個員工的詳細資訊 (ID、姓名、部門、薪資) 都儲存在一個獨立的 Dictionary 物件中。然後遍歷列表並顯示每個員工的資訊。"}
                ],
                "keywords": ["collection of dictionaries", "list of dictionaries", "structured collection", "vba dictionary", "字典集合", "字典列表"]
            },
            {
                "name": "Converting Collection to Array",
                "category": "陣列、集合與字典",
                "syntax": "Dim arr() As Variant\nReDim arr(0 To myCollection.Count - 1)\nFor i = 1 To myCollection.Count\n  arr(i - 1) = myCollection(i)\nNext i",
                "description": "將 VBA Collection 物件的內容轉換為標準的 VBA 陣列。這在需要陣列操作（例如傳遞給某些需要陣列作為參數的函數）時很有用。",
                "parameters": [
                    {"name": "myCollection", "description": "要轉換的來源 Collection 物件。"},
                    {"name": "arr()", "description": "目標 Variant 陣列。"}
                ],
                "examples": [
                    {"code": "Dim namesCollection As New Collection\nnamesCollection.Add \"Zoe\"\nnamesCollection.Add \"Alex\"\nnamesCollection.Add \"Chris\"\n\nDim namesArray() As Variant\nIf namesCollection.Count > 0 Then\n  ReDim namesArray(1 To namesCollection.Count) ' Assuming 1-based array for simplicity here\n  Dim i As Long\n  For i = 1 To namesCollection.Count\n    If TypeOf namesCollection(i) Is Object Then\n      ' Set namesArray(i) = namesCollection(i) ' If collection holds objects\n      ' Or handle specific properties\n      Debug.Print \"Cannot directly assign object to variant array element for simple display, skipping object.\"\n    Else\n      namesArray(i) = namesCollection(i)\n    End If\n  Next i\n  \n  ' Display array contents (if not objects)\n  ' For i = LBound(namesArray) To UBound(namesArray)\n  '   Debug.Print \"Array item: \" & namesArray(i)\n  ' Next i\n  If UBound(namesArray) >= LBound(namesArray) Then\n    Debug.Print \"Converted array: \" & Join(namesArray, \", \")\n  End If\nElse\n  Debug.Print \"Collection is empty, array not populated.\"\nEnd If\n\nSet namesCollection = Nothing", "explanation": "建立一個包含姓名的 Collection，然後將其元素複製到一個新的 Variant 陣列中。注意：如果集合包含物件，則直接賦值會將物件引用複製到陣列中。如果需要物件的特定屬性，則需要單獨處理。"}
                ],
                "keywords": ["collection to array", "convert collection vba", "vba array from collection", "集合轉陣列"]
            },
            {
                "name": "Converting Dictionary Keys/Items to Array",
                "category": "陣列、集合與字典",
                "syntax": "Dim keysArr As Variant, itemsArr As Variant\nkeysArr = myDictionary.Keys\nitemsArr = myDictionary.Items",
                "description": "將 Scripting.Dictionary 物件的 Keys 或 Items 屬性直接賦值給 Variant 變數，即可將它們轉換為陣列。",
                "parameters": [
                    {"name": "myDictionary", "description": "來源 Scripting.Dictionary 物件。"},
                    {"name": "keysArr", "description": "接收字典所有鍵的 Variant 陣列。"},
                    {"name": "itemsArr", "description": "接收字典所有項目的 Variant 陣列。"}
                ],
                "examples": [
                    {"code": "Dim studentGrades As Object\nSet studentGrades = CreateObject(\"Scripting.Dictionary\")\nstudentGrades.Add \"Alice\", 95\nstudentGrades.Add \"Bob\", 88\nstudentGrades.Add \"Charlie\", 92\n\nDim studentNames As Variant\nDim grades As Variant\n\nstudentNames = studentGrades.Keys ' Get all keys (names) into an array\ngrades = studentGrades.Items   ' Get all items (grades) into an array\n\nDim i As Long\nDebug.Print \"--- Student Names (Keys) ---\"\nFor i = LBound(studentNames) To UBound(studentNames)\n  Debug.Print studentNames(i)\nNext i\n\nDebug.Print \"--- Grades (Items) ---\"\nFor i = LBound(grades) To UBound(grades)\n  Debug.Print grades(i)\nNext i\n\n' The order of keys/items arrays corresponds to each other\nDebug.Print \"--- Combined --- (Order might not be guaranteed as added for Dictionary)\"\nFor i = LBound(studentNames) To UBound(studentNames)\n  Debug.Print studentNames(i) & \" scored \" & grades(i)\nNext i\n\nSet studentGrades = Nothing", "explanation": "建立一個包含學生姓名和成績的 Dictionary。然後，使用 .Keys 和 .Items 屬性將所有鍵（學生姓名）和所有項目（成績）分別提取到兩個獨立的陣列中，並進行顯示。"}
                ],
                "keywords": ["dictionary to array", "dictionary keys to array", "dictionary items to array", "vba dictionary array", "字典轉陣列", "字典鍵轉陣列", "字典項目轉陣列"]
            },

            // --- 資料類型、轉換與驗證 (Data Types, Conversion & Validation) ---
            {
                "name": "CStr", "category": "資料類型、轉換與驗證", "syntax": "CStr(expression)",
                "description": "返回已轉換為 String 資料類型的 expression。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim MyDouble As Double, MyString As String\nMyDouble = 437.324\nMyString = CStr(MyDouble)\nMsgBox \"'\" & MyString & \"'\"", "explanation": "將雙精度浮點數轉換為字串類型。"}
                ],
                "keywords": ["轉換", "字串", "類型轉換", "cast", "string", "conversion", "to string"]
            },
            {
                "name": "CInt", "category": "資料類型、轉換與驗證", "syntax": "CInt(expression)",
                "description": "返回已轉換為 Integer 資料類型的 expression。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim MyDouble As Double, MyInt As Integer\nMyDouble = 23.5\nMyInt = CInt(MyDouble)\nMsgBox MyInt ' MyInt 包含 24", "explanation": "將數字 23.5 四捨五入並轉換為整數類型。"},
                    {"code": "MsgBox CInt(\"100\") ' 返回 100", "explanation": "將數字字串 \"100\" 轉換為整數。"}
                ],
                "keywords": ["轉換", "整數", "類型轉換", "cast", "integer", "conversion", "round", "to integer"]
            },
            {
                "name": "CLng", "category": "資料類型、轉換與驗證", "syntax": "CLng(expression)",
                "description": "返回已轉換為 Long (長整型) 資料類型的 expression。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim MyValue As Double, MyLong As Long\nMyValue = 12345.67\nMyLong = CLng(MyValue)\nMsgBox MyLong ' MyLong 包含 12346 (四捨五入)", "explanation": "將數字 12345.67 四捨五入並轉換為長整型。"}
                ],
                "keywords": ["轉換", "長整型", "類型轉換", "cast", "long", "conversion", "to long"]
            },
            {
                "name": "CDbl", "category": "資料類型、轉換與驗證", "syntax": "CDbl(expression)",
                "description": "返回已轉換為 Double 資料類型的 expression。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim MyInteger As Integer, MyDouble As Double\nMyInteger = 123\nMyDouble = CDbl(MyInteger)\nMsgBox MyDouble ' MyDouble 包含 123.0", "explanation": "將整數轉換為雙精度浮點數。"}
                ],
                "keywords": ["轉換", "雙精度", "類型轉換", "cast", "double", "conversion", "to double"]
            },
            {
                "name": "CBool", "category": "資料類型、轉換與驗證", "syntax": "CBool(expression)",
                "description": "返回已轉換為 Boolean 資料類型的 expression。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的字串或數值表達式。"}],
                "examples": [
                    {"code": "Dim MyNum As Integer, MyBool As Boolean\nMyNum = 0\nMyBool = CBool(MyNum)\nMsgBox MyBool ' MyBool 為 False", "explanation": "將數字 0 轉換為布林值 False。"},
                    {"code": "MsgBox CBool(\"True\") ' 返回 True", "explanation": "將字串 \"True\" 轉換為布林值 True。"}
                ],
                "keywords": ["轉換", "布爾", "類型轉換", "cast", "boolean", "conversion", "to boolean"]
            },
            {
                "name": "CDate", "category": "資料類型、轉換與驗證", "syntax": "CDate(date)",
                "description": "返回已轉換為 Date 資料類型的 expression。",
                "parameters": [{"name": "date", "description": "必需。任何有效的日期表達式。"}],
                "examples": [
                    {"code": "Dim MyStringDate As String, MyRealDate As Date\nMyStringDate = \"October 20, 2023\"\nMyRealDate = CDate(MyStringDate)\nMsgBox TypeName(MyRealDate) & \": \" & MyRealDate", "explanation": "將日期字串轉換為實際的 Date 資料類型。"}
                ],
                "keywords": ["轉換", "日期", "類型轉換", "cast", "date", "conversion", "to date"]
            },
            {
                "name": "CSng", "category": "資料類型、轉換與驗證", "syntax": "CSng(expression)",
                "description": "返回已轉換為 Single (單精度浮點數) 資料類型的 expression。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim MyDouble As Double, MySingle As Single\nMyDouble = 12345.6789\nMySingle = CSng(MyDouble)\nMsgBox MySingle ' MySingle 包含 12345.68 (可能因精度而異)", "explanation": "將雙精度數轉換為單精度浮點数。"}
                ],
                "keywords": ["轉換", "單精度", "類型轉換", "cast", "single", "conversion", "to single"]
            },
            {
                "name": "CCur", "category": "資料類型、轉換與驗證", "syntax": "CCur(expression)",
                "description": "返回已轉換為 Currency 資料類型的 expression。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim MyValue As Double, MyCurrency As Currency\nMyValue = 1234.5678\nMyCurrency = CCur(MyValue)\nMsgBox MyCurrency ' MyCurrency 包含 1234.5678", "explanation": "將數字轉換為貨幣資料類型。"}
                ],
                "keywords": ["轉換", "貨幣", "類型轉換", "cast", "currency", "conversion", "to currency"]
            },
            {
                "name": "CByte", "category": "資料類型、轉換與驗證", "syntax": "CByte(expression)",
                "description": "返回已轉換為 Byte 資料類型的 expression。",
                "parameters": [{"name": "expression", "description": "必需。0 到 255 之間的任何有效表達式。"}],
                "examples": [
                    {"code": "Dim MyInt As Integer, MyByteValue As Byte\nMyInt = 150\nMyByteValue = CByte(MyInt)\nMsgBox MyByteValue ' MyByteValue 為 150", "explanation": "將介於0-255之間的整數轉換為位元組類型。"}
                ],
                "keywords": ["轉換", "位元組", "類型轉換", "cast", "byte", "conversion", "to byte"]
            },
            {
                "name": "IsNumeric", "category": "資料類型、轉換與驗證", "syntax": "IsNumeric(expression)",
                "description": "返回一個 Boolean 值，指示表達式是否可以評估為數字。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim MyVar\nMyVar = 53\nIf IsNumeric(MyVar) Then MsgBox \"Is a number\"", "explanation": "檢查變數 MyVar 是否為數字。"},
                    {"code": "If Not IsNumeric(\"Hello\") Then MsgBox \"Not a number\"", "explanation": "檢查字串 \"Hello\" 是否不是數字。"}
                ],
                "keywords": ["數字", "檢查", "判斷", "numeric", "check", "validate", "is number", "類型檢查"]
            },
            {
                "name": "IsDate", "category": "資料類型、轉換與驗證", "syntax": "IsDate(expression)",
                "description": "返回一個 Boolean 值，指示表達式是否可以轉換為日期。",
                "parameters": [{"name": "expression", "description": "必需。任何日期或字串表達式。"}],
                "examples": [
                    {"code": "Dim MyDateStr As String\nMyDateStr = \"October 19, 2023\"\nIf IsDate(MyDateStr) Then MsgBox \"Is a valid date string\"", "explanation": "檢查字串是否可以被識別為有效日期。"},
                    {"code": "If Not IsDate(Now()) Then MsgBox \"Error! Now() should be a date!\"", "explanation": "檢查 Now() 函數的返回值是否為日期類型 (應為True)。"}
                ],
                "keywords": ["日期", "檢查", "判斷", "date", "check", "validate", "is date", "類型檢查"]
            },
            {
                "name": "IsEmpty", "category": "資料類型、轉換與驗證", "syntax": "IsEmpty(expression)",
                "description": "返回一個 Boolean 值，指示變數是否已初始化。對於 Variant 變數，IsEmpty 返回 True 如果變數未被初始化，或明確設置為 Empty。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的變數。"}],
                "examples": [
                    {"code": "Dim MyVar ' 未初始化\nIf IsEmpty(MyVar) Then MsgBox \"變數 MyVar 未初始化 (Empty)\"", "explanation": "檢查一個 Variant 變數是否從未被賦值（即為 Empty）。"},
                    {"code": "Dim AnotherVar As Integer ' 整數初始化為0\nIf Not IsEmpty(AnotherVar) Then MsgBox \"AnotherVar is not Empty (it's 0)\"", "explanation": "檢查已聲明並自動初始化為0的整數變數是否不為 Empty。"}
                ],
                "keywords": ["空", "檢查", "判斷", "變數", "empty", "check", "variable", "initialized", "is empty", "類型檢查"]
            },
            {
                "name": "IsNull", "category": "資料類型、轉換與驗證", "syntax": "IsNull(expression)",
                "description": "返回一個 Boolean 值，指示表達式是否包含無效數據 (Null)。Null 通常用於表示資料庫字段中的缺失或未知數據。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim MyVar As Variant\nMyVar = Null\nIf IsNull(MyVar) Then MsgBox \"變數 MyVar 包含 Null 值\"", "explanation": "檢查變數是否明確地被賦予了 Null 值。"},
                    {"code": "Dim EmptyString As String\nEmptyString = \"\"\nIf Not IsNull(EmptyString) Then MsgBox \"空字串不等於 Null\"", "explanation": "演示空字串（\"\"）與 Null 值的區別。"}
                ],
                "keywords": ["Null", "檢查", "判斷", "無效數據", "null", "check", "validate", "nodata", "is null", "類型檢查"]
            },
            {
                "name": "IsArray", "category": "資料類型、轉換與驗證", "syntax": "IsArray(varname)",
                "description": "返回一個 Boolean 值，指示變數是否為數組。",
                "parameters": [{"name": "varname", "description": "必需。任何變數的標識符。"}],
                "examples": [
                    {"code": "Dim MyArr(5) As Integer, MyVar As Integer\nIf IsArray(MyArr) Then MsgBox \"MyArr 是數組\"", "explanation": "檢查 MyArr 是否為一個數組變數。"},
                    {"code": "If Not IsArray(MyVar) Then MsgBox \"MyVar 不是數組\"", "explanation": "檢查 MyVar 是否不是一個數組變數。"}
                ],
                "keywords": ["數組", "檢查", "判斷", "array", "check", "validate", "is array", "類型檢查"]
            },
            {
                "name": "IsObject", "category": "資料類型、轉換與驗證", "syntax": "IsObject(identifier)",
                "description": "返回一個 Boolean 值，指示表達式是否引用有效的自動化對象。",
                "parameters": [{"name": "identifier", "description": "必需。任何變數名或表達式。"}],
                "examples": [
                    {"code": "Dim MyObj As Object, MyVar As Integer\nSet MyObj = CreateObject(\"Scripting.Dictionary\")\nIf IsObject(MyObj) Then MsgBox \"MyObj 是一個對象\"", "explanation": "檢查 MyObj 變數是否引用一個有效的對象。"},
                    {"code": "If Not IsObject(MyVar) Then MsgBox \"MyVar 不是一個對象\"", "explanation": "檢查 MyVar 變數是否不引用一個對象。"}
                ],
                "keywords": ["對象", "檢查", "判斷", "object", "check", "validate", "automation", "is object", "類型檢查"]
            },
            {
                "name": "IsError", "category": "資料類型、轉換與驗證", "syntax": "IsError(expression)",
                "description": "返回一個 Boolean 值，指示表達式是否為錯誤值。錯誤值由 CVErr 函數創建。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim RetVal As Variant\nOn Error Resume Next\nRetVal = 1 / 0 ' 這會產生一個錯誤值，但被 On Error Resume Next 捕獲\nIf IsError(RetVal) Then MsgBox \"表達式是一個錯誤值 (例如除以零)。\"\nElse\n  RetVal = CVErr(vbObjectError + 513) '創建一個自定義錯誤值\n  If IsError(RetVal) Then MsgBox \"RetVal is now a user-defined error value.\"\nEnd If", "explanation": "檢查表達式的結果是否為一個錯誤值（通常由 CVErr 函數產生或計算錯誤導致）。"}
                ],
                "keywords": ["錯誤", "檢查", "判斷", "error", "check", "validate", "cverr", "is error", "類型檢查"]
            },
            {
                "name": "TypeName", "category": "資料類型、轉換與驗證", "syntax": "TypeName(varname)",
                "description": "返回一個 String，提供有關變數的資料類型資訊。",
                "parameters": [{"name": "varname", "description": "必需。任何變數。"}],
                "examples": [
                    {"code": "Dim MyVarInt As Integer\nMsgBox TypeName(MyVarInt)    ' 顯示 \"Integer\"", "explanation": "獲取整數變數的類型名稱。"},
                    {"code": "Dim MyVarStr As String\nMsgBox TypeName(MyVarStr)    ' 顯示 \"String\"", "explanation": "獲取字串變數的類型名稱。"}
                ],
                "keywords": ["類型名稱", "資料類型", "變數", "檢查", "data type", "variable", "check", "vartype", "類型檢查"]
            },
            {
                "name": "VarType", "category": "資料類型、轉換與驗證", "syntax": "VarType(varname)",
                "description": "返回一個 Integer，指示變數的子類型。該整數對應於 VbVarType 常數之一。",
                "parameters": [{"name": "varname", "description": "必需。任何變數。"}],
                "examples": [
                    {"code": "Dim MyInt As Integer\nMsgBox VarType(MyInt) ' 返回 2 (vbInteger 的常數值)", "explanation": "獲取整數變數的內部類型代碼。"},
                    {"code": "Dim MyStr As String\nMsgBox VarType(MyStr) ' 返回 8 (vbString 的常數值)", "explanation": "獲取字串變數的內部類型代碼。"}
                ],
                "keywords": ["變數類型", "資料類型", "檢查", "data type", "variable", "check", "vbconstants", "subtype", "類型檢查", "vbInteger", "vbString"]
            },
             {
                "name": "IsMissing", "category": "資料類型、轉換與驗證", "syntax": "IsMissing(argname)",
                "description": "返回一個 Boolean 值，指示是否已將可選的 Variant 參數傳遞給過程。",
                "parameters": [{"name": "argname", "description": "必需。包含可選 Variant 參數名稱的表達式。"}],
                "examples": [
                    {"code": "Sub TestOptionalParam(Optional Param1 As Variant)\n  If IsMissing(Param1) Then\n    MsgBox \"Param1 未提供。\"\n  Else\n    MsgBox \"Param1 的值是: \" & Param1\n  End If\nEnd Sub\n' TestOptionalParam ' 將顯示 \"Param1 未提供。\"\n' TestOptionalParam \"Hello\" ' 將顯示 \"Param1 的值是: Hello\"", "explanation": "檢查一個可選的 Variant 參數是否在調用過程時被省略。"}
                ],
                "keywords": ["可選參數", "省略參數", "參數檢查", "optional argument", "missing parameter", "procedure parameter"]
            },
            {
                "name": "Val", "category": "資料類型、轉換與驗證", "syntax": "Val(string)",
                "description": "返回包含在字串中的數字，作為適當類型的數值。它會讀取字串直到遇到第一個非數字字符（除了某些符號如小數點、正負號）。",
                "parameters": [{"name": "string", "description": "必需。任何有效的字串表達式。"}],
                "examples": [
                    {"code": "Debug.Print Val(\"123.45ABC\") ' 返回 123.45", "explanation": "從字串中提取前導數字部分。"},
                    {"code": "Debug.Print Val(\" 100 Main Street\") ' 返回 100", "explanation": "忽略前導空格並提取數字。"},
                    {"code": "Debug.Print Val(\"USD 50.99\") ' 返回 0 (因為以非數字開頭)", "explanation": "如果字串不以數字或可識別的數字符號開頭，則返回0。"}
                ],
                "keywords": ["字串轉數字", "提取數字", "string to number", "extract number", "parse number"]
            },
            {
                "name": "CBDec", "category": "資料類型、轉換與驗證", "syntax": "CBDec(expression)",
                "description": "返回已轉換為 Decimal 資料類型的 expression。Decimal 類型只能在 Variant 內部使用。",
                "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
                "examples": [
                    {"code": "Dim myDecimal As Variant\nmyDecimal = CBDec(\"1234567890.123456789\")\nMsgBox \"Decimal value: \" & myDecimal & \" Type: \" & TypeName(myDecimal)\n' TypeName(myDecimal) 通常返回 Decimal，但儲存為Variant", "explanation": "將字串或數字轉換為高精度的 Decimal 類型 (儲存在 Variant 中)。"}
                ],
                "keywords": ["轉換Decimal", "高精度數字", "decimal conversion", "high precision number"]
            },

            // --- 檔案與資料夾管理 (File & Folder Management) ---
            {
                "name": "Dir", "category": "檔案與資料夾管理", "syntax": "Dir[(pathname[, attributes])]",
                "description": "返回第一個匹配 pathname 的文件名或文件夾名。",
                "parameters": [{"name": "pathname", "description": "可選。文件、目錄的路徑。"}, {"name": "attributes", "description": "可選。文件屬性。"}],
                "examples": [
                    {"code": "Dim FileName As String\nFileName = Dir(\"C:\\Windows\\*.exe\") ' 查找第一個 exe 文件\nDo While FileName <> \"\"\n  Debug.Print FileName\n  FileName = Dir ' 查找下一個\nLoop", "explanation": "遍歷 C:\\Windows 資料夾中的所有 .exe 檔案並打印其名稱。"}
                ],
                "keywords": ["文件", "目錄", "查找", "列表", "file", "directory", "find", "list", "filesystem"]
            },
            {
                "name": "FileCopy", "category": "檔案與資料夾管理", "syntax": "FileCopy source, destination",
                "description": "複製一個文件。",
                "parameters": [{"name": "source", "description": "必需。源文件名。"}, {"name": "destination", "description": "必需。目標文件名。"}],
                "examples": [
                    {"code": "On Error Resume Next ' 如果文件不存在或無法訪問，則忽略錯誤\nFileCopy \"C:\\SourceFile.txt\", \"D:\\Backup\\TargetFile.txt\"\nIf Err.Number = 0 Then MsgBox \"文件複製成功！\" Else MsgBox \"複製失敗: \" & Err.Description", "explanation": "嘗試將一個文件從源路徑複製到目標路徑。"}
                ],
                "keywords": ["複製文件", "文件操作", "file", "copy", "filesystem"]
            },
            {
                "name": "FileDateTime", "category": "檔案與資料夾管理", "syntax": "FileDateTime(pathname)",
                "description": "返回文件創建或上次修改的日期和時間。",
                "parameters": [{"name": "pathname", "description": "必需。文件名。"}],
                "examples": [
                    {"code": "Dim ModifiedDate As Date\nModifiedDate = FileDateTime(\"C:\\Windows\\notepad.exe\")\nMsgBox \"Notepad 上次修改於: \" & ModifiedDate", "explanation": "獲取指定文件的上次修改日期和時間。"}
                ],
                "keywords": ["文件日期", "文件時間", "修改時間", "file", "date", "time", "modified", "timestamp"]
            },
            {
                "name": "FileLen", "category": "檔案與資料夾管理", "syntax": "FileLen(pathname)",
                "description": "返回文件的長度（以位元組為單位）。",
                "parameters": [{"name": "pathname", "description": "必需。文件名。"}],
                "examples": [
                    {"code": "Dim FileSize As Long\nFileSize = FileLen(\"C:\\Windows\\notepad.exe\")\nMsgBox \"Notepad 大小: \" & FileSize & \" 位元組\"", "explanation": "獲取指定文件的大小（以位元組為單位）。"}
                ],
                "keywords": ["文件大小", "文件長度", "file", "size", "length", "bytes"]
            },
            {
                "name": "GetAttr", "category": "檔案與資料夾管理", "syntax": "GetAttr(pathname)",
                "description": "返回文件、目錄或文件夾屬性的整數。",
                "parameters": [{"name": "pathname", "description": "必需。文件名或目錄名。"}],
                "examples": [
                    {"code": "Dim Attr As VbFileAttribute\nAttr = GetAttr(\"C:\\Windows\")\nIf (Attr And vbDirectory) > 0 Then MsgBox \"C:\\Windows 是一個目錄。\"\nIf (Attr And vbReadOnly) > 0 Then MsgBox \"C:\\Windows 是唯讀的。\"", "explanation": "獲取指定路徑的屬性，並檢查它是否為目錄或唯讀。"}
                ],
                "keywords": ["文件屬性", "目錄屬性", "file", "directory", "attribute", "readonly", "hidden"]
            },
            {
                "name": "SetAttr", "category": "檔案與資料夾管理", "syntax": "SetAttr pathname, attributes",
                "description": "設置文件的屬性。",
                "parameters": [{"name": "pathname", "description": "必需。文件名。"}, {"name": "attributes", "description": "必需。要設置的屬性。"}],
                "examples": [
                    {"code": "' 假設 C:\\Temp\\MyTestFile.txt 存在\n' SetAttr \"C:\\Temp\\MyTestFile.txt\", vbReadOnly ' 設置為唯讀\n' SetAttr \"C:\\Temp\\MyTestFile.txt\", vbNormal   ' 設置為正常", "explanation": "設置指定文件的屬性，例如設置為唯讀或正常。"}
                ],
                "keywords": ["設置屬性", "文件屬性", "file", "attribute", "set"]
            },
            {
                "name": "Kill", "category": "檔案與資料夾管理", "syntax": "Kill pathname",
                "description": "從磁碟刪除文件。",
                "parameters": [{"name": "pathname", "description": "必需。要刪除的文件名。"}],
                "examples": [
                    {"code": "' Kill \"C:\\Temp\\OldFileToDelete.tmp\" ' 刪除指定文件", "explanation": "刪除磁碟上指定路徑的文件。"},
                    {"code": "' Kill \"C:\\Logs\\*.log\" ' 刪除 Logs 資料夾中所有 .log 文件", "explanation": "使用通配符刪除符合條件的多個文件。"}
                ],
                "keywords": ["刪除文件", "文件操作", "file", "delete", "remove"]
            },
            {
                "name": "MkDir", "category": "檔案與資料夾管理", "syntax": "MkDir path",
                "description": "創建一個新目錄或文件夾。",
                "parameters": [{"name": "path", "description": "必需。要創建的目錄路徑。"}],
                "examples": [
                    {"code": "On Error Resume Next\nMkDir \"C:\\MyNewVBAFolder\"\nIf Err.Number = 0 Then MsgBox \"資料夾創建成功！\" Else MsgBox \"創建失敗或已存在\"", "explanation": "在指定路徑創建一個新的資料夾。"}
                ],
                "keywords": ["創建目錄", "創建文件夾", "directory", "folder", "make", "create", "mkdir"]
            },
            {
                "name": "RmDir", "category": "檔案與資料夾管理", "syntax": "RmDir path",
                "description": "刪除一個現有的目錄或文件夾。",
                "parameters": [{"name": "path", "description": "必需。要刪除的目錄路徑。"}],
                "examples": [
                    {"code": "' RmDir \"C:\\EmptyFolderToRemove\" ' 目錄必須為空才能刪除", "explanation": "刪除一個空的資料夾。如果資料夾不為空，則會發生錯誤。"}
                ],
                "keywords": ["刪除目錄", "刪除文件夾", "directory", "folder", "remove", "delete", "rmdir"]
            },
            {
                "name": "Name", "category": "檔案與資料夾管理", "syntax": "Name oldpathname As newpathname",
                "description": "重命名文件或目錄。",
                "parameters": [{"name": "oldpathname", "description": "必需。現有文件名或目錄名。"}, {"name": "newpathname", "description": "必需。新文件名或目錄名。"}],
                "examples": [
                    {"code": "' Name \"C:\\OldFileName.txt\" As \"C:\\NewFileName.txt\"", "explanation": "將文件從舊名稱重命名為新名稱。"},
                    {"code": "' Name \"C:\\MyFolder\" As \"C:\\MyRenamedFolder\"", "explanation": "重命名資料夾。也可以用於移動文件到同一驅動器的不同目錄。"}
                ],
                "keywords": ["重命名", "文件", "目錄", "rename", "file", "directory", "move"]
            },
            {
                "name": "ChDir", "category": "檔案與資料夾管理", "syntax": "ChDir path",
                "description": "更改當前目錄或文件夾。",
                "parameters": [{"name": "path", "description": "必需。新的預設目錄路徑。"}],
                "examples": [
                    {"code": "ChDir \"C:\\Windows\"\nMsgBox CurDir() ' 顯示當前目錄已更改為 C:\\Windows", "explanation": "將當前工作目錄更改為指定的路徑。"}
                ],
                "keywords": ["更改目錄", "當前目錄", "change directory", "current directory", "cd"]
            },
            {
                "name": "ChDrive", "category": "檔案與資料夾管理", "syntax": "ChDrive drive",
                "description": "更改當前驅動器。",
                "parameters": [{"name": "drive", "description": "必需。驅動器字母 (例如 \"C\")。"}],
                "examples": [
                    {"code": "' ChDrive \"D\" ' 將當前驅動器更改為 D 驅動器 (如果存在)\n' MsgBox CurDir()", "explanation": "更改當前的工作驅動器。"}
                ],
                "keywords": ["更改驅動器", "當前驅動器", "change drive", "current drive"]
            },
            {
                "name": "CurDir", "category": "檔案與資料夾管理", "syntax": "CurDir[(drive)]",
                "description": "返回指定驅動器的當前路徑。",
                "parameters": [{"name": "drive", "description": "可選。驅動器字母。"}],
                "examples": [
                    {"code": "MsgBox CurDir() ' 顯示當前驅動器的當前路徑", "explanation": "獲取當前活動驅動器的完整路徑。"},
                    {"code": "' MsgBox CurDir(\"C\") ' 顯示 C 驅動器的當前路徑 (如果 C 不是當前驅動器，則為 C 驅動器上次的當前路徑)", "explanation": "獲取特定驅動器的當前路徑。"}
                ],
                "keywords": ["當前路徑", "當前目錄", "current path", "current directory", "pwd"]
            },
            {
                "name": "Application.GetSaveAsFilename", "category": "檔案與資料夾管理", "syntax": "expression.GetSaveAsFilename(InitialFilename, FileFilter, FilterIndex, Title, ButtonText)",
                "description": "顯示標準的「另存新檔」對話框，並獲取用戶選擇的檔案名稱和路徑。它僅返回選擇的路徑，並不會實際儲存檔案。",
                "parameters": [
                    {"name": "InitialFilename", "description": "可選。建議的檔案名稱。"},
                    {"name": "FileFilter", "description": "可選。檔案過濾器字串，例如 \"Text Files (*.txt), *.txt\"。"},
                    {"name": "Title", "description": "可選。對話框的標題。"}
                ],
                "examples": [
                    {"code": "Sub GetSavePathFromDialog()\n  Dim filePath As Variant\n  filePath = Application.GetSaveAsFilename( _\n    InitialFilename:=\"MyReport.xlsx\", _\n    FileFilter:=\"Excel Workbooks (*.xlsx), *.xlsx,All Files (*.*), *.*\", _\n    Title:=\"請選擇儲存位置與檔名\")\n\n  If filePath = False Then\n    MsgBox \"使用者取消了操作。\"\n  Else\n    MsgBox \"使用者選擇儲存檔案於: \" & filePath\n    ' 此處可以接續 ActiveWorkbook.SaveAs filePath\n  End If\nEnd Sub", "explanation": "彈出「另存新檔」對話框，讓使用者選擇儲存 Excel 檔案的路徑和名稱。如果使用者按下「取消」，則返回 False。"}
                ],
                "keywords": ["另存新檔對話框", "選擇路徑", "檔案儲存", "excel", "word", "powerpoint", "save as dialog", "file dialog", "get path", "通用"]
            },
            {
                "name": "Application.GetOpenFilename", "category": "檔案與資料夾管理", "syntax": "expression.GetOpenFilename(FileFilter, FilterIndex, Title, ButtonText, MultiSelect)",
                "description": "顯示標準的「開啟旧檔」對話框，並獲取用戶選擇的一個或多個檔案名稱。它僅返回選擇的檔案路徑，並不會實際開啟檔案。",
                "parameters": [
                    {"name": "FileFilter", "description": "可選。檔案過濾器字串。"},
                    {"name": "Title", "description": "可選。對話框的標題。"},
                    {"name": "MultiSelect", "description": "可選。如果為 True，則允許選擇多個檔案。"}
                ],
                "examples": [
                    {"code": "Sub GetOpenPathFromDialog()\n  Dim filePath As Variant\n  filePath = Application.GetOpenFilename( _\n    FileFilter:=\"Excel Files (*.xls*), *.xls*,Text Files (*.txt), *.txt\", _\n    Title:=\"請選擇要開啟的檔案\", _\n    MultiSelect:=False)\n\n  If filePath = False Then\n    MsgBox \"使用者取消了操作。\"\n  Else\n    MsgBox \"使用者選擇開啟檔案: \" & filePath\n    ' 此處可以接續 Workbooks.Open filePath\n  End If\nEnd Sub", "explanation": "彈出「開啟旧檔」對話框，讓使用者選擇一個 Excel 或文字檔案。如果使用者按下「取消」，則返回 False。"}
                ],
                "keywords": ["開啟旧檔對話框", "選擇檔案", "檔案開啟", "excel", "word", "powerpoint", "open file dialog", "file dialog", "get file", "通用"]
            },
            {
                "name": "FileSystemObject.FileExists", "category": "檔案與資料夾管理", "syntax": "fso.FileExists(filespec)",
                "description": "檢查指定的檔案是否存在。返回 True 或 False。",
                "parameters": [{"name": "filespec", "description": "必需。檔案的完整路徑和名稱。"}],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nDim filePath As String\nfilePath = \"C:\\MyFolder\\MyFile.txt\"\nIf fso.FileExists(filePath) Then\n  MsgBox \"檔案 \" & filePath & \" 存在。\"\nElse\n  MsgBox \"檔案 \" & filePath & \" 不存在。\"\nEnd If\nSet fso = Nothing", "explanation": "檢查指定的檔案是否存在並顯示訊息。"}
                ],
                "keywords": ["檢查檔案", "檔案存在", "fso", "file system object", "check file", "file exists"]
            },
            {
                "name": "FileSystemObject.FolderExists", "category": "檔案與資料夾管理", "syntax": "fso.FolderExists(folderspec)",
                "description": "檢查指定的資料夾是否存在。返回 True 或 False。",
                "parameters": [{"name": "folderspec", "description": "必需。資料夾的完整路徑。"}],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nDim folderPath As String\nfolderPath = \"C:\\MyFolder\"\nIf fso.FolderExists(folderPath) Then\n  MsgBox \"資料夾 \" & folderPath & \" 存在。\"\nElse\n  MsgBox \"資料夾 \" & folderPath & \" 不存在。\"\nEnd If\nSet fso = Nothing", "explanation": "檢查指定的資料夾是否存在並顯示訊息。"}
                ],
                "keywords": ["檢查資料夾", "資料夾存在", "fso", "folder exists", "check folder"]
            },
            {
                "name": "FileSystemObject.CreateTextFile", "category": "檔案與資料夾管理", "syntax": "fso.CreateTextFile(filename[, overwrite[, unicode]])",
                "description": "創建一個文字檔案並返回一個 TextStream 物件，可用於讀寫檔案。",
                "parameters": [
                    {"name": "filename", "description": "必需。要創建的檔案的名稱。"},
                    {"name": "overwrite", "description": "可選。Boolean 值，True 表示如果檔案已存在則覆蓋 (預設)。False 表示不覆蓋。"},
                    {"name": "unicode", "description": "可選。Boolean 值，True 表示以 Unicode 格式創建檔案。False 表示以 ASCII 格式 (預設)。"}
                ],
                "examples": [
                    {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nDim filePath As String\nfilePath = \"C:\\Temp\\MyTextFile.txt\"\nSet ts = fso.CreateTextFile(filePath, True, False)\nts.WriteLine \"這是第一行文字。\"\nts.WriteLine \"這是第二行文字。\"\nts.Close\nSet ts = Nothing\nSet fso = Nothing\nMsgBox \"文字檔案已創建並寫入內容於: \" & filePath", "explanation": "創建一個新的文字檔案，寫入兩行內容，然後關閉檔案。"}
                ],
                "keywords": ["創建文字檔", "寫入檔案", "fso", "text file", "create file", "writeline"]
            },
            {
                "name": "TextStream.WriteLine", "category": "檔案與資料夾管理", "syntax": "textstream.WriteLine([string])",
                "description": "向 TextStream 檔案寫入指定的字串和一個換行符。",
                "parameters": [{"name": "string", "description": "可選。要寫入檔案的文字。如果省略，則只寫入換行符。"}],
                "examples": [
                    {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.OpenTextFile(\"C:\\Temp\\MyLog.txt\", 8, True) ' 8 = ForAppending, True = Create if not exists\nts.WriteLine Now & \": Log entry 1\"\nts.WriteLine Now & \": Log entry 2\"\nts.Close\nSet fso = Nothing", "explanation": "打開或創建一個日誌檔案，並在末尾追加兩行帶時間戳的日誌記錄。"}
                ],
                "keywords": ["寫入行", "文字檔案", "fso", "textstream", "write line", "append line"]
            },
            {
                "name": "TextStream.ReadLine", "category": "檔案與資料夾管理", "syntax": "textstream.ReadLine",
                "description": "從 TextStream 檔案讀取一整行 (直到但不包括換行符) 並返回結果字串。",
                "parameters": [],
                "examples": [
                    {"code": "Dim fso As Object, ts As Object, fileContent As String, lineText As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.FileExists(\"C:\\Temp\\MyTextFile.txt\") Then\n  Set ts = fso.OpenTextFile(\"C:\\Temp\\MyTextFile.txt\", 1) ' 1 = ForReading\n  Do While Not ts.AtEndOfStream\n    lineText = ts.ReadLine\n    fileContent = fileContent & lineText & vbCrLf\n  Loop\n  ts.Close\n  MsgBox \"檔案內容:\\n\" & fileContent\nElse\n  MsgBox \"檔案不存在。\"\nEnd If\nSet fso = Nothing", "explanation": "逐行讀取一個文字檔案的內容並顯示在訊息框中。"}
                ],
                "keywords": ["讀取行", "文字檔案", "fso", "textstream", "read line"]
            },
            {
                "name": "TextStream.ReadAll", "category": "檔案與資料夾管理", "syntax": "textstream.ReadAll",
                "description": "從 TextStream 檔案讀取所有內容並返回結果字串。",
                "parameters": [],
                "examples": [
                    {"code": "Dim fso As Object, ts As Object, allContent As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.FileExists(\"C:\\Config.ini\") Then\n  Set ts = fso.OpenTextFile(\"C:\\Config.ini\", 1) ' ForReading\n  allContent = ts.ReadAll\n  ts.Close\n  MsgBox \"Config.ini 內容:\\n\" & allContent\nElse\n  MsgBox \"Config.ini 不存在。\"\nEnd If\nSet fso = Nothing", "explanation": "一次性讀取整個文字檔案的內容。"}
                ],
                "keywords": ["讀取全部", "文字檔案", "fso", "textstream", "read all content"]
            },
            {
                "name": "TextStream.Close", "category": "檔案與資料夾管理", "syntax": "textstream.Close",
                "description": "關閉一個已開啟的 TextStream 檔案。",
                "parameters": [],
                "examples": [
                    {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.CreateTextFile(\"C:\\Temp\\Demo.txt\")\nts.WriteLine \"Hello\"\nts.Close ' 務必關閉檔案以保存更改並釋放資源\nSet fso = Nothing", "explanation": "創建文字檔、寫入後，使用 Close 方法關閉檔案流。"}
                ],
                "keywords": ["關閉檔案", "文字流", "fso", "textstream", "close file"]
            },
             {
                "name": "FileSystemObject.GetParentFolderName", "category": "檔案與資料夾管理", "syntax": "fso.GetParentFolderName(path)",
                "description": "返回指定路徑中最後一個組件的父資料夾名稱 (String)。",
                "parameters": [{"name": "path", "description": "必需。檔案或資料夾的路徑。"}],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nMsgBox fso.GetParentFolderName(\"C:\\MyFolder\\MySubFolder\\MyFile.txt\") ' 返回 \"C:\\MyFolder\\MySubFolder\"", "explanation": "獲取指定檔案的父資料夾路徑。"},
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nMsgBox fso.GetParentFolderName(\"C:\\MyFolder\\\") ' 返回 \"C:\\\"", "explanation": "獲取指定資料夾的父資料夾路徑。"}
                ],
                "keywords": ["父資料夾", "上一層目錄", "fso", "parent folder", "directory path"]
            },
            {
                "name": "FileSystemObject.GetFileName", "category": "檔案與資料夾管理", "syntax": "fso.GetFileName(path)",
                "description": "返回指定路徑中最後一個組件的檔案名稱或資料夾名稱 (String)。",
                "parameters": [{"name": "path", "description": "必需。檔案或資料夾的路徑。"}],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nMsgBox fso.GetFileName(\"C:\\Temp\\MyReport.xlsx\") ' 返回 \"MyReport.xlsx\"", "explanation": "從完整路徑中提取檔案名稱。"}
                ],
                "keywords": ["檔案名稱", "獲取檔名", "fso", "file name", "get file name"]
            },
            {
                "name": "FileSystemObject.GetBaseName", "category": "檔案與資料夾管理", "syntax": "fso.GetBaseName(path)",
                "description": "返回指定路徑中檔案或資料夾的基本名稱 (不含副檔名) (String)。",
                "parameters": [{"name": "path", "description": "必需。檔案或資料夾的路徑。"}],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nMsgBox fso.GetBaseName(\"C:\\Docs\\AnnualReport.docx\") ' 返回 \"AnnualReport\"", "explanation": "從檔案路徑中提取不含副檔名的基本名稱。"}
                ],
                "keywords": ["基本名稱", "主檔名", "fso", "base name", "file name no extension"]
            },
            {
                "name": "FileSystemObject.GetExtensionName", "category": "檔案與資料夾管理", "syntax": "fso.GetExtensionName(path)",
                "description": "返回指定路徑中檔案的副檔名 (String)。",
                "parameters": [{"name": "path", "description": "必需。檔案的路徑。"}],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nMsgBox fso.GetExtensionName(\"C:\\Images\\Photo.JPG\") ' 返回 \"JPG\"", "explanation": "從檔案路徑中提取副檔名。"}
                ],
                "keywords": ["副檔名", "擴展名", "fso", "extension name", "file type"]
            },
            {
                "name": "FileSystemObject.BuildPath", "category": "檔案與資料夾管理", "syntax": "fso.BuildPath(path, name)",
                "description": "將名稱附加到現有路徑，並在必要時插入路徑分隔符。返回組合的路徑字串。",
                "parameters": [
                    {"name": "path", "description": "必需。現有的路徑。"},
                    {"name": "name", "description": "必需。要附加到路徑的名稱。"}
                ],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nMsgBox fso.BuildPath(\"C:\\Users\\Default\", \"Desktop\") ' 返回 \"C:\\Users\\Default\\Desktop\"", "explanation": "組合基本路徑和資料夾名稱。"},
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nMsgBox fso.BuildPath(\"C:\\Windows\", \"System32\\notepad.exe\") ' 返回 \"C:\\Windows\\System32\\notepad.exe\"", "explanation": "組合路徑和包含子目錄的檔案名稱。"}
                ],
                "keywords": ["組合路徑", "路徑合併", "fso", "build path", "concatenate path", "join path"]
            },
            {
                "name": "FileSystemObject.CopyFile", "category": "檔案與資料夾管理", "syntax": "fso.CopyFile source, destination[, overwritefiles]",
                "description": "複製一個或多個檔案從一個位置到另一個位置。",
                "parameters": [
                    {"name": "source", "description": "必需。要複製的檔案(可含通配符)。"},
                    {"name": "destination", "description": "必需。目標路徑。"},
                    {"name": "overwritefiles", "description": "可選。True表示覆蓋現有檔案(預設)。"}
                ],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nfso.CopyFile \"C:\\Source\\Report.txt\", \"D:\\Backup\\Report_Backup.txt\", True\nSet fso = Nothing", "explanation": "複製單個檔案到新位置並覆蓋。"}
                ],
                "keywords": ["複製檔案", "FSO複製", "fso", "copy file"]
            },
            {
                "name": "FileSystemObject.DeleteFile", "category": "檔案與資料夾管理", "syntax": "fso.DeleteFile filespec[, force]",
                "description": "刪除指定的檔案。",
                "parameters": [
                    {"name": "filespec", "description": "必需。要刪除的檔案(可含通配符)。"},
                    {"name": "force", "description": "可選。True表示即使檔案有唯讀屬性也刪除(預設False)。"}
                ],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.FileExists(\"C:\\Temp\\Old.log\") Then\n  fso.DeleteFile \"C:\\Temp\\Old.log\", True\nEnd If\nSet fso = Nothing", "explanation": "強制刪除指定的日誌檔案。"}
                ],
                "keywords": ["刪除檔案", "FSO刪除", "fso", "delete file"]
            },
            {
                "name": "FileSystemObject.MoveFile", "category": "檔案與資料夾管理", "syntax": "fso.MoveFile source, destination",
                "description": "移動一個或多個檔案從一個位置到另一個位置。",
                "parameters": [
                    {"name": "source", "description": "必需。要移動的檔案(可含通配符)。"},
                    {"name": "destination", "description": "必需。目標路徑。"}
                ],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nfso.MoveFile \"C:\\Incoming\\data.csv\", \"C:\\Processed\\data.csv\"\nSet fso = Nothing", "explanation": "移動檔案到新資料夾。"}
                ],
                "keywords": ["移動檔案", "FSO移動", "fso", "move file"]
            },
            {
                "name": "FileSystemObject.CopyFolder", "category": "檔案與資料夾管理", "syntax": "fso.CopyFolder source, destination[, overwrite]",
                "description": "遞迴地複製資料夾從一個位置到另一個位置。",
                "parameters": [
                    {"name": "source", "description": "必需。要複製的資料夾。"},
                    {"name": "destination", "description": "必需。目標路徑。"},
                    {"name": "overwrite", "description": "可選。True表示覆蓋現有資料夾或檔案(預設True)。"}
                ],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nfso.CopyFolder \"C:\\MyProject\", \"D:\\Backup\\MyProject_Backup\", True\nSet fso = Nothing", "explanation": "複製整個資料夾及其內容到備份位置。"}
                ],
                "keywords": ["複製資料夾", "FSO複製資料夾", "fso", "copy folder"]
            },
            {
                "name": "FileSystemObject.DeleteFolder", "category": "檔案與資料夾管理", "syntax": "fso.DeleteFolder folderspec[, force]",
                "description": "刪除指定的資料夾及其所有內容。",
                "parameters": [
                    {"name": "folderspec", "description": "必需。要刪除的資料夾。"},
                    {"name": "force", "description": "可選。True表示即使資料夾有唯讀屬性也刪除(預設False)。"}
                ],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.FolderExists(\"C:\\Temp\\OldData\") Then\n  fso.DeleteFolder \"C:\\Temp\\OldData\", True\nEnd If\nSet fso = Nothing", "explanation": "強制刪除指定的資料夾及其所有內容。"}
                ],
                "keywords": ["刪除資料夾", "FSO刪除資料夾", "fso", "delete folder"]
            },
            {
                "name": "FileSystemObject.MoveFolder", "category": "檔案與資料夾管理", "syntax": "fso.MoveFolder source, destination",
                "description": "移動資料夾從一個位置到另一個位置。",
                "parameters": [
                    {"name": "source", "description": "必需。要移動的資料夾。"},
                    {"name": "destination", "description": "必需。目標路徑。"}
                ],
                "examples": [
                    {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nfso.MoveFolder \"C:\\ArchiveCandidate\", \"D:\\OldArchives\\ArchiveCandidate\"\nSet fso = Nothing", "explanation": "移動資料夾到新的存檔位置。"}
                ],
                "keywords": ["移動資料夾", "FSO移動資料夾", "fso", "move folder"]
            },
            {
                "name": "FileSystemObject.GetFile", "category": "檔案與資料夾管理", "syntax": "fso.GetFile(filepath)",
                "description": "返回一個代表指定檔案的 File 物件。",
                "parameters": [{"name": "filepath", "description": "必需。檔案的路徑。"}],
                "examples": [
                    {"code": "Dim fso As Object, fileObj As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fileObj = fso.GetFile(\"C:\\Windows\\notepad.exe\")\nMsgBox \"File Name: \" & fileObj.Name & vbCrLf & \"Size: \" & fileObj.Size & \" bytes\"\nSet fileObj = Nothing\nSet fso = Nothing", "explanation": "獲取檔案物件並顯示其名稱和大小。"}
                ],
                "keywords": ["獲取檔案物件", "檔案資訊", "fso", "get file", "file object"]
            },
            {
                "name": "FileSystemObject.GetFolder", "category": "檔案與資料夾管理", "syntax": "fso.GetFolder(folderpath)",
                "description": "返回一個代表指定資料夾的 Folder 物件。",
                "parameters": [{"name": "folderpath", "description": "必需。資料夾的路徑。"}],
                "examples": [
                    {"code": "Dim fso As Object, folderObj As Object, subFolder As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet folderObj = fso.GetFolder(\"C:\\Windows\")\nMsgBox \"Folder Name: \" & folderObj.Name & vbCrLf & \"Subfolders count: \" & folderObj.SubFolders.Count\nFor Each subFolder In folderObj.SubFolders\n    Debug.Print subFolder.Name\nNext\nSet folderObj = Nothing\nSet fso = Nothing", "explanation": "獲取資料夾物件並列出其子資料夾。"}
                ],
                "keywords": ["獲取資料夾物件", "資料夾資訊", "fso", "get folder", "folder object"]
            },
            {
                "name": "FileSystemObject.GetSpecialFolder", "category": "檔案與資料夾管理", "syntax": "fso.GetSpecialFolder(folderspec)",
                "description": "返回一個代表指定特殊資料夾（如 Windows 資料夾、系統資料夾或臨時資料夾）的 Folder 物件。",
                "parameters": [{"name": "folderspec", "description": "必需。特殊資料夾的類型 (0=WindowsFolder, 1=SystemFolder, 2=TemporaryFolder)。"}],
                "examples": [
                    {"code": "Dim fso As Object, tempFolder As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet tempFolder = fso.GetSpecialFolder(2) ' 2 = TemporaryFolder\nMsgBox \"Temporary Folder Path: \" & tempFolder.Path\nSet tempFolder = Nothing\nSet fso = Nothing", "explanation": "獲取系統臨時資料夾的路徑。"}
                ],
                "keywords": ["特殊資料夾", "系統資料夾", "臨時資料夾", "fso", "special folder", "windows folder", "temp folder"]
            },
            {
                "name": "Open (檔案I/O)", "category": "檔案與資料夾管理", "syntax": "Open pathname For mode [Access access] [lock] As [#]filenumber [Len=reclength]",
                "description": "啟用檔案的輸入/輸出 (I/O)。這是傳統的 VBA 檔案操作方法。",
                "parameters": [
                    {"name": "pathname", "description": "必需。檔案名稱。"},
                    {"name": "mode", "description": "必需。指定檔案模式 (Input, Output, Append, Binary, Random)。"},
                    {"name": "filenumber", "description": "必需。1 到 511 之間的有效檔案號碼。"}
                ],
                "examples": [
                    {"code": "Dim fileNum As Integer\nfileNum = FreeFile ' 獲取一個未使用的檔案號碼\nOpen \"C:\\Temp\\classic_output.txt\" For Output As #fileNum\nPrint #fileNum, \"This is a line written using classic I/O.\"\nPrint #fileNum, \"Another line.\"\nClose #fileNum", "explanation": "使用傳統的 Open...Print #...Close 方式寫入文字檔案。"}
                ],
                "keywords": ["檔案開啟", "檔案讀寫", "傳統IO", "open statement", "file input output", "print #"]
            },
            {
                "name": "Close (檔案I/O)", "category": "檔案與資料夾管理", "syntax": "Close [[#]filenumber]...",
                "description": "結束使用 Open 語句開啟的檔案的 I/O 操作。",
                "parameters": [{"name": "filenumber", "description": "可選。要關閉的一個或多個檔案號碼。若省略，則關閉所有開啟的檔案。"}],
                "examples": [
                    {"code": "Dim fn As Integer\nfn = FreeFile\nOpen \"test.txt\" For Output As #fn\nWrite #fn, \"Data\"\nClose #fn ' 關閉特定的檔案號碼\n' Close ' 關閉所有透過Open開啟的檔案", "explanation": "使用 Close # 關閉先前開啟的檔案。"}
                ],
                "keywords": ["關閉檔案", "檔案IO", "close statement", "file close"]
            },
            {
                "name": "FreeFile", "category": "檔案與資料夾管理", "syntax": "FreeFile[(rangenumber)]",
                "description": "返回下一個可用的檔案號碼 (Integer)，供 Open 語句使用。",
                "parameters": [{"name": "rangenumber", "description": "可選。0 表示返回 1-255 範圍內的檔案號，1 表示返回 256-511 範圍內的檔案號。"}],
                "examples": [
                    {"code": "Dim nextFileNum As Integer\nnextFileNum = FreeFile\nMsgBox \"下一個可用的檔案號碼是: \" & nextFileNum", "explanation": "獲取一個未被使用的檔案號碼。"}
                ],
                "keywords": ["可用檔案號", "檔案IO", "free file number"]
            },
            {
                "name": "Print #", "category": "檔案與資料夾管理", "syntax": "Print #filenumber, [outputlist]",
                "description": "將格式化的資料寫入循序檔案。",
                "parameters": [
                    {"name": "filenumber", "description": "必需。任何有效的檔案號碼。"},
                    {"name": "outputlist", "description": "可選。要寫入檔案的一個或多個以逗號或分號分隔的表達式。"}
                ],
                "examples": [
                    {"code": "Dim fn As Integer: fn = FreeFile\nOpen \"data.txt\" For Output As #fn\nPrint #fn, \"Item:\"; \"Apple\", \"Price:\"; 1.25\nPrint #fn, \"Item:\"; \"Banana\", \"Price:\"; 0.75\nClose #fn", "explanation": "將資料以特定格式寫入文字檔案。"}
                ],
                "keywords": ["寫入檔案", "循序檔", "print statement", "sequential file"]
            },
            {
                "name": "Write #", "category": "檔案與資料夾管理", "syntax": "Write #filenumber, [outputlist]",
                "description": "將資料寫入循序檔案。它會自動在項目間插入逗號，並用引號括住字串。",
                "parameters": [
                    {"name": "filenumber", "description": "必需。任何有效的檔案號碼。"},
                    {"name": "outputlist", "description": "可選。要寫入檔案的一個或多個以逗號分隔的數值或字串表達式。"}
                ],
                "examples": [
                    {"code": "Dim fn As Integer: fn = FreeFile\nOpen \"records.csv\" For Output As #fn\nWrite #fn, \"John Doe\", 30, \"New York\"\nWrite #fn, \"Jane Smith\", 25, \"London\"\nClose #fn", "explanation": "將資料寫入檔案，適合創建 CSV 格式。"}
                ],
                "keywords": ["寫入檔案", "CSV格式", "write statement", "sequential file"]
            },
            {
                "name": "Input #", "category": "檔案與資料夾管理", "syntax": "Input #filenumber, varlist",
                "description": "從開啟的循序檔案讀取資料並將其指派給變數。",
                "parameters": [
                    {"name": "filenumber", "description": "必需。任何有效的檔案號碼。"},
                    {"name": "varlist", "description": "必需。以逗號分隔的變數列表，用於接收讀取的資料。"}
                ],
                "examples": [
                    {"code": "Dim fn As Integer: fn = FreeFile\nDim nameStr As String, ageNum As Integer, cityStr As String\nOpen \"records.csv\" For Input As #fn\nDo While Not EOF(fn)\n  Input #fn, nameStr, ageNum, cityStr\n  Debug.Print nameStr, ageNum, cityStr\nLoop\nClose #fn", "explanation": "從 CSV 檔案中讀取資料到變數中。"}
                ],
                "keywords": ["讀取檔案", "循序檔", "input statement", "sequential file"]
            },
            {
                "name": "EOF", "category": "檔案與資料夾管理", "syntax": "EOF(filenumber)",
                "description": "返回一個 Boolean 值，指示是否已到達為循序 Input 開啟的檔案的末尾，或為 Binary 開啟的檔案的末尾。",
                "parameters": [{"name": "filenumber", "description": "必需。任何有效的檔案號碼。"}],
                "examples": [
                    {"code": "Dim fn As Integer: fn = FreeFile\nDim lineData As String\nOpen \"log.txt\" For Input As #fn\nDo Until EOF(fn)\n  Line Input #fn, lineData ' Line Input 讀取整行\n  Debug.Print lineData\nLoop\nClose #fn", "explanation": "使用 EOF 函數判斷是否已讀取到檔案末尾。"}
                ],
                "keywords": ["檔案結尾", "end of file", "file io", "sequential access"]
            },
            {
                "name": "LOF", "category": "檔案與資料夾管理", "syntax": "LOF(filenumber)",
                "description": "返回一個 Long，代表使用 Open 語句開啟的檔案的大小 (以位元組為單位)。",
                "parameters": [{"name": "filenumber", "description": "必需。任何有效的檔案號碼。"}],
                "examples": [
                    {"code": "Dim fn As Integer: fn = FreeFile\nOpen \"MyDocument.doc\" For Binary As #fn\nMsgBox \"File size: \" & LOF(fn) & \" bytes.\"\nClose #fn", "explanation": "獲取已開啟檔案的總長度（位元組數）。"}
                ],
                "keywords": ["檔案長度", "length of file", "file size", "file io"]
            },
            {
                "name": "Line Input #", "category": "檔案與資料夾管理", "syntax": "Line Input #filenumber, varname",
                "description": "從開啟的循序檔案讀取一整行 (直到但不包括換行符) 並將其指派給字串變數。",
                "parameters": [
                    {"name": "filenumber", "description": "必需。任何有效的檔案號碼。"},
                    {"name": "varname", "description": "必需。有效的 Variant 或 String 變數名，用於接收讀取的行。"}
                ],
                "examples": [
                    {"code": "Dim fn As Integer: fn = FreeFile\nDim textLine As String\nOpen \"C:\\Temp\\MyTextFile.txt\" For Input As #fn\nDo While Not EOF(fn)\n    Line Input #fn, textLine\n    Debug.Print textLine\nLoop\nClose #fn", "explanation": "逐行讀取文字檔案的內容並打印到立即窗口。"}
                ],
                "keywords": ["讀取行", "文字檔", "循序檔", "line input statement", "read line by line"]
            },
            {
                "name": "Seek (Statement/Function)", "category": "檔案與資料夾管理", "syntax": "Seek [#]filenumber, position (Statement)\nposition = Seek(filenumber) (Function)",
                "description": "Statement: 設定下一個讀/寫操作在 Open 語句開啟的檔案中的位置。\nFunction: 返回一個 Long，指定檔案中下一個讀/寫操作的當前位置。",
                "parameters": [
                    {"name": "filenumber", "description": "必需。任何有效的檔案號碼。"},
                    {"name": "position", "description": "必需 (Statement)。1 到 2,147,483,647 之間的數字，指示下一次讀/寫的位置。"}
                ],
                "examples": [
                    {"code": "Dim fn As Integer: fn = FreeFile\nDim currentPos As Long\nOpen \"data.bin\" For Binary As #fn\nSeek #fn, 100 ' 將指針移動到第100個位元組\ncurrentPos = Seek(fn)\nDebug.Print \"Current position: \" & currentPos ' 應該是 100\nClose #fn", "explanation": "設置並獲取檔案指針在二進制檔案中的位置。"}
                ],
                "keywords": ["檔案指針", "定位", "seek statement", "seek function", "file position", "random access", "binary access"]
            },
            {
                "name": "Put (Statement)", "category": "檔案與資料夾管理", "syntax": "Put [#]filenumber, [recnumber], varname",
                "description": "將資料從變數寫入磁碟檔案。通常用於 Random 或 Binary 模式開啟的檔案。",
                "parameters": [
                    {"name": "filenumber", "description": "必需。任何有效的檔案號碼。"},
                    {"name": "recnumber", "description": "可選。記錄號碼 (Random 模式) 或位元組號碼 (Binary 模式) 開始寫入。"},
                    {"name": "varname", "description": "必需。包含要寫入磁碟的資料的變數名。"}
                ],
                "examples": [
                    {"code": "Type MyRecord\n    ID As Integer\n    Name As String * 20\nEnd Type\nDim rec As MyRecord, fn As Integer: fn = FreeFile\nOpen \"records.dat\" For Random As #fn Len = Len(rec)\nrec.ID = 1: rec.Name = \"Alice\"\nPut #fn, 1, rec ' 將記錄寫入第1條記錄位置\nClose #fn", "explanation": "定義一個用戶自定義類型，然後將該類型的一個變數寫入到以 Random 模式開啟的檔案中。"}
                ],
                "keywords": ["寫入記錄", "二進制寫入", "put statement", "random access file", "binary file"]
            },
            {
                "name": "Get (Statement)", "category": "檔案與資料夾管理", "syntax": "Get [#]filenumber, [recnumber], varname",
                "description": "從磁碟檔案讀取資料到變數。通常用於 Random 或 Binary 模式開啟的檔案。",
                "parameters": [
                    {"name": "filenumber", "description": "必需。任何有效的檔案號碼。"},
                    {"name": "recnumber", "description": "可選。記錄號碼 (Random 模式) 或位元組號碼 (Binary 模式) 開始讀取。"},
                    {"name": "varname", "description": "必需。用於接收從磁碟讀取資料的變數名。"}
                ],
                "examples": [
                    {"code": "Type MyRecord\n    ID As Integer\n    Name As String * 20\nEnd Type\nDim recRead As MyRecord, fn As Integer: fn = FreeFile\nOpen \"records.dat\" For Random As #fn Len = Len(recRead)\nGet #fn, 1, recRead ' 從第1條記錄位置讀取資料\nDebug.Print recRead.ID, recRead.Name\nClose #fn", "explanation": "從以 Random 模式開啟的檔案中讀取一條記錄到用戶自定義類型的變數中。"}
                ],
                "keywords": ["讀取記錄", "二進制讀取", "get statement", "random access file", "binary file"]
            },
            {
            "name": "FileSystemObject.GetDrive",
            "category": "檔案與資料夾管理",
            "syntax": "fso.GetDrive(drivespec)",
            "description": "傳回與指定路徑中磁碟機對應的 Drive 物件。",
            "parameters": [{"name": "drivespec", "description": "必需。磁碟機代號 (例如 \"C\") 或从中派生磁碟機代號的完整路徑。"}],
            "examples": [
            {"code": "Dim fso As Object, drv As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet drv = fso.GetDrive(\"C:\\\")\nMsgBox \"磁碟機 C: 序號: \" & drv.SerialNumber & vbCrLf & _\n       \"可用空間 (位元組): \" & drv.FreeSpace & vbCrLf & _\n       \"總空間 (位元組): \" & drv.TotalSize & vbCrLf & _\n       \"磁碟區名稱: \" & drv.VolumeName,\nSet drv = Nothing\nSet fso = Nothing", "explanation": "取得 C: 磁碟機的 Drive 物件，並顯示其序號、可用空間、總空間和磁碟區名稱。"}
            ],
            "keywords": ["get drive", "drive info", "disk space", "fso", "filesystemobject", "獲取磁碟機", "磁碟資訊"]
            },
            {
            "name": "Drive.DriveLetter",
            "category": "檔案與資料夾管理",
            "syntax": "driveObject.DriveLetter",
            "description": "傳回實體本機磁碟機或共用網路磁碟機的磁碟機代號。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, drv As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet drv = fso.GetDrive(\"D:\\SomeFolder\")\nMsgBox \"磁碟機代號是: \" & drv.DriveLetter ' 傳回 \"D\"", "explanation": "從 Drive 物件取得磁碟機代號。"}
            ],
            "keywords": ["drive letter", "disk letter", "fso", "filesystemobject", "磁碟機代號"]
            },
            {
            "name": "Drive.DriveType",
            "category": "檔案與資料夾管理",
            "syntax": "driveObject.DriveType",
            "description": "傳回一個值，指出指定磁碟機的類型 (例如，可卸除式、固定式、網路、CD-ROM、RAM 磁碟)。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, drv As Object, driveTypeStr As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet drv = fso.GetDrive(\"C\")\nSelect Case drv.DriveType\n  Case 0: driveTypeStr = \"未知\"\n  Case 1: driveTypeStr = \"可卸除式\"\n  Case 2: driveTypeStr = \"固定式\"\n  Case 3: driveTypeStr = \"網路\"\n  Case 4: driveTypeStr = \"CD-ROM\"\n  Case 5: driveTypeStr = \"RAM 磁碟\"\nEnd Select\nMsgBox \"磁碟機 C: 類型是 \" & driveTypeStr", "explanation": "判斷並顯示 C: 磁碟機的類型。"}
            ],
            "keywords": ["drive type", "disk type", "fso", "filesystemobject", "磁碟機類型"]
            },
            {
            "name": "Drive.IsReady",
            "category": "檔案與資料夾管理",
            "syntax": "driveObject.IsReady",
            "description": "如果指定的磁碟機已就緒，則傳回 True；否則傳回 False。對於可卸除式媒體磁碟機和 CD-ROM 磁碟機，IsReady 僅在已插入適當媒體並準備好存取時才傳回 True。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, drv As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet drv = fso.GetDrive(\"A\") ' 假設 A: 是軟碟或可卸除式磁碟機\nIf drv.IsReady Then\n  MsgBox \"磁碟機 A: 已就緒。\"\nElse\n  MsgBox \"磁碟機 A: 未就緒。請插入媒體。\"\nEnd If", "explanation": "檢查磁碟機 A: (通常是可卸除式磁碟機) 是否已就緒。"}
            ],
            "keywords": ["drive ready", "disk ready status", "fso", "filesystemobject", "磁碟機就緒"]
            },
            {
            "name": "FileSystemObject.GetAbsolutePathName",
            "category": "檔案與資料夾管理",
            "syntax": "fso.GetAbsolutePathName(pathspec)",
            "description": "從路徑規格傳回完整且明確的路徑。解析相對路徑。",
            "parameters": [{"name": "pathspec", "description": "必需。路徑規格。可以是相對路徑或絕對路徑。"}],
            "examples": [
            {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nChDir \"C:\\Windows\"\nMsgBox fso.GetAbsolutePathName(\"System32\") ' 傳回 \"C:\\Windows\\System32\"", "explanation": "根據目前目錄取得相對資料夾名稱的絕對路徑。"}
            ],
            "keywords": ["absolute path", "full path", "resolve path", "fso", "filesystemobject", "絕對路徑", "完整路徑"]
            },
            {
            "name": "FileSystemObject.GetTempName",
            "category": "檔案與資料夾管理",
            "syntax": "fso.GetTempName",
            "description": "傳回隨機產生的暫存檔案或資料夾名稱，可用於執行需要暫存檔案或資料夾的操作。名稱通常以 \"rad\" 開頭，以 \".tmp\" 結尾。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, tempFileName As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\ntempFileName = fso.GetTempName\nMsgBox \"產生的暫存名稱: \" & tempFileName", "explanation": "產生唯一的暫存檔案/資料夾名稱。"}
            ],
            "keywords": ["temp name", "temporary file name", "generate temp name", "fso", "filesystemobject", "臨時檔名"]
            },
            {
            "name": "File.Attributes",
            "category": "檔案與資料夾管理",
            "syntax": "fileObject.Attributes [= newattributes]",
            "description": "設定或傳回檔案或資料夾的屬性。可以是 VbFileAttribute 常數的組合 (vbNormal, vbReadOnly, vbHidden, vbSystem, vbDirectory, vbArchive)。",
            "parameters": [{"name": "newattributes", "description": "可選。檔案的新屬性設定。"}],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Temp\\MyTest.txt\") ' 假設檔案存在\nIf (f.Attributes And vbReadOnly) Then\n  MsgBox \"檔案是唯讀的。\"\n  f.Attributes = f.Attributes Xor vbReadOnly ' 切換唯讀屬性關閉\n  MsgBox \"唯讀屬性已移除。\"\nElse\n  f.Attributes = f.Attributes Or vbReadOnly ' 設定唯讀屬性開啟\n  MsgBox \"唯讀屬性已設定。\"\nEnd If", "explanation": "檢查並切換檔案的唯讀屬性。"}
            ],
            "keywords": ["file attributes", "folder attributes", "readonly", "hidden", "system", "archive", "fso", "filesystemobject", "檔案屬性", "資料夾屬性"]
            },
            {
            "name": "File.DateCreated",
            "category": "檔案與資料夾管理",
            "syntax": "fileObject.DateCreated",
            "description": "傳回指定檔案或資料夾的建立日期和時間。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Windows\\notepad.exe\")\nMsgBox \"Notepad.exe 建立於: \" & f.DateCreated", "explanation": "顯示 notepad.exe 的建立日期和時間。"}
            ],
            "keywords": ["date created", "file creation date", "fso", "filesystemobject", "檔案建立日期"]
            },
            {
            "name": "File.DateLastAccessed",
            "category": "檔案與資料夾管理",
            "syntax": "fileObject.DateLastAccessed",
            "description": "傳回指定檔案或資料夾的上次存取日期和時間。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Windows\\notepad.exe\")\nMsgBox \"Notepad.exe 上次存取於: \" & f.DateLastAccessed", "explanation": "顯示 notepad.exe 的上次存取日期和時間。"}
            ],
            "keywords": ["date last accessed", "file access time", "fso", "filesystemobject", "檔案上次存取日期"]
            },
            {
            "name": "File.DateLastModified",
            "category": "檔案與資料夾管理",
            "syntax": "fileObject.DateLastModified",
            "description": "傳回指定檔案或資料夾的上次修改日期和時間。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Windows\\notepad.exe\")\nMsgBox \"Notepad.exe 上次修改於: \" & f.DateLastModified", "explanation": "顯示 notepad.exe 的上次修改日期和時間。(這與 VBA FileDateTime 函數對於檔案的作用相同)。"}
            ],
            "keywords": ["date last modified", "file modification time", "timestamp", "fso", "filesystemobject", "檔案上次修改日期"]
            },
            {
            "name": "File.Drive",
            "category": "檔案與資料夾管理",
            "syntax": "fileObject.Drive",
            "description": "傳回指定檔案或資料夾所在磁碟機的磁碟機代號。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Temp\\MyDocument.txt\")\nMsgBox \"檔案位於磁碟機: \" & f.Drive ' 傳回 \"C:\"", "explanation": "取得 MyDocument.txt 所在的磁碟機代號。"}
            ],
            "keywords": ["file drive", "parent drive", "fso", "filesystemobject", "檔案所在磁碟機"]
            },
            {
            "name": "File.Name / Folder.Name",
            "category": "檔案與資料夾管理",
            "syntax": "object.Name [= newname]",
            "description": "設定或傳回指定檔案或資料夾的名稱。",
            "parameters": [{"name": "newname", "description": "可選。檔案或資料夾的新名稱。"}],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Temp\\OldName.txt\")\nMsgBox \"原始名稱: \" & f.Name\nf.Name = \"NewName.txt\"\nMsgBox \"新名稱: \" & f.Name", "explanation": "取得一個檔案物件並重命名該檔案。"}
            ],
            "keywords": ["file name", "folder name", "rename file", "rename folder", "fso", "filesystemobject", "檔案名稱", "資料夾名稱", "重命名"]
            },
            {
            "name": "File.ParentFolder",
            "category": "檔案與資料夾管理",
            "syntax": "fileObject.ParentFolder",
            "description": "傳回指定檔案或資料夾的父資料夾的 Folder 物件。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, f As Object, pf As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Temp\\Docs\\Report.docx\")\nSet pf = f.ParentFolder\nMsgBox \"Report.docx 的父資料夾是: \" & pf.Path", "explanation": "取得 Report.docx 的父資料夾物件並顯示其路徑。"}
            ],
            "keywords": ["parent folder", "file's folder", "fso", "filesystemobject", "父資料夾", "檔案的資料夾"]
            },
            {
            "name": "File.Path / Folder.Path",
            "category": "檔案與資料夾管理",
            "syntax": "object.Path",
            "description": "傳回指定檔案、資料夾或磁碟機的路徑。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Windows\\notepad.exe\")\nMsgBox \"notepad.exe 的完整路徑: \" & f.Path", "explanation": "顯示 notepad.exe 的完整路徑。"}
            ],
            "keywords": ["file path", "folder path", "full path", "fso", "filesystemobject", "檔案路徑", "資料夾路徑"]
            },
            {
            "name": "File.ShortName / Folder.ShortName",
            "category": "檔案與資料夾管理",
            "syntax": "object.ShortName",
            "description": "傳回早期 MS-DOS 命名慣例所需的簡短名稱 (8.3 命名慣例)。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Program Files\\My Application\\VeryLongApplicationName.exe\")\nMsgBox \"簡短名稱: \" & f.ShortName ' 例如，VERYLO~1.EXE", "explanation": "取得長檔名檔案的 8.3 簡短名稱。"}
            ],
            "keywords": ["short name", "8.3 name", "DOS name", "fso", "filesystemobject", "短檔名"]
            },
            {
            "name": "File.ShortPath / Folder.ShortPath",
            "category": "檔案與資料夾管理",
            "syntax": "object.ShortPath",
            "description": "傳回指定檔案或資料夾的簡短路徑 (8.3 命名慣例)。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, fldr As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldr = fso.GetFolder(\"C:\\Program Files (x86)\")\nMsgBox \"簡短路徑: \" & fldr.ShortPath ' 例如，C:\\PROGRA~2", "explanation": "取得資料夾的 8.3 簡短路徑。"}
            ],
            "keywords": ["short path", "8.3 path", "DOS path", "fso", "filesystemobject", "短路徑"]
            },
            {
            "name": "File.Size / Folder.Size",
            "category": "檔案與資料夾管理",
            "syntax": "object.Size",
            "description": "對於檔案，傳回指定檔案的大小 (以位元組為單位)。對於資料夾，傳回資料夾中所有檔案和子資料夾的總大小 (以位元組為單位)。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\Windows\\System32\\calc.exe\")\nMsgBox \"計算機大小: \" & f.Size & \" bytes.\"", "explanation": "取得計算機執行檔的大小。"},
            {"code": "Dim fso As Object, fldr As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldr = fso.GetFolder(\"C:\\Temp\")\nMsgBox \"Temp 資料夾總大小: \" & fldr.Size & \" bytes.\"", "explanation": "取得 C:\\Temp 資料夾內所有內容的總大小。"}
            ],
            "keywords": ["file size", "folder size", "directory size", "fso", "filesystemobject", "檔案大小", "資料夾大小"]
            },
            {
            "name": "File.Type",
            "category": "檔案與資料夾管理",
            "syntax": "fileObject.Type",
            "description": "傳回有關檔案或資料夾類型的資訊 (例如，「文字文件」、「檔案資料夾」、「Microsoft Excel 工作表」)。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, f As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet f = fso.GetFile(\"C:\\MyReport.xlsx\")\nMsgBox \"檔案類型: \" & f.Type", "explanation": "顯示 Excel 檔案的描述性類型。"}
            ],
            "keywords": ["file type", "folder type", "object type", "fso", "filesystemobject", "檔案類型", "資料夾類型"]
            },
            {
            "name": "Folder.SubFolders",
            "category": "檔案與資料夾管理",
            "syntax": "folderObject.SubFolders",
            "description": "傳回一個 Folders 集合，其中包含指定資料夾中所有資料夾，包括隱藏和系統子資料夾。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, mainFolder As Object, subFolder As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet mainFolder = fso.GetFolder(\"C:\\Windows\")\nMsgBox \"Subfolders in \" & mainFolder.Name & \": \" & mainFolder.SubFolders.Count\nFor Each subFolder In mainFolder.SubFolders\n  Debug.Print subFolder.Name\nNext", "explanation": "計算並列出 C:\\Windows 中的所有直接子資料夾。"}
            ],
            "keywords": ["subfolders", "list subdirectories", "fso", "filesystemobject", "子資料夾", "列出子目錄"]
            },
            {
            "name": "Folder.Files",
            "category": "檔案與資料夾管理",
            "syntax": "folderObject.Files",
            "description": "傳回一個 Files 集合，其中包含指定資料夾中所有 File 物件，包括隱藏和系統檔案。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, myFolder As Object, fileItem As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFolder = fso.GetFolder(\"C:\\Temp\")\nMsgBox \"Files in \" & myFolder.Name & \": \" & myFolder.Files.Count\nFor Each fileItem In myFolder.Files\n  Debug.Print fileItem.Name & \" (\" & fileItem.Size & \" bytes)\"\nNext", "explanation": "計算並列出 C:\\Temp 中的所有直接檔案及其大小。"}
            ],
            "keywords": ["folder files", "list files", "directory listing", "fso", "filesystemobject", "資料夾檔案", "列出檔案"]
            },
            {
            "name": "TextStream.AtEndOfLine",
            "category": "檔案與資料夾管理",
            "syntax": "textstreamObject.AtEndOfLine",
            "description": "如果檔案指標位於 TextStream 檔案中行尾標記之前，則傳回 True；否則傳回 False。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, ts As Object, char As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.OpenTextFile(\"C:\\Temp\\Sample.txt\", 1) ' ForReading\nDo While Not ts.AtEndOfStream\n    char = ts.Read(1)\n    If ts.AtEndOfLine Then\n        Debug.Print char & \" <EOL>\"\n    Else\n        Debug.Print char\n    End If\nLoop\nts.Close", "explanation": "逐字元讀取檔案，並在到達行尾時指出。(注意：使用 ReadLine 更實用)。"}
            ],
            "keywords": ["textstream", "end of line", "fso", "filesystemobject", "文字流", "行尾"]
            },
            {
            "name": "TextStream.AtEndOfStream",
            "category": "檔案與資料夾管理",
            "syntax": "textstreamObject.AtEndOfStream",
            "description": "如果檔案指標位於 TextStream 檔案的結尾，則傳回 True；否則傳回 False。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, ts As Object, lineText As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.OpenTextFile(\"C:\\Config.ini\", 1) ' ForReading\nDo While Not ts.AtEndOfStream\n  lineText = ts.ReadLine\n  Debug.Print lineText\nLoop\nts.Close", "explanation": "逐行讀取檔案，直到到達資料流結尾。"}
            ],
            "keywords": ["textstream", "end of stream", "eof", "fso", "filesystemobject", "文字流", "檔案結尾"]
            },
            {
            "name": "TextStream.Column",
            "category": "檔案與資料夾管理",
            "syntax": "textstreamObject.Column",
            "description": "傳回輸入 TextStream 中目前字元位置的欄號。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.OpenTextFile(\"C:\\Temp\\Data.txt\", 1)\nts.Read(5) ' Read 5 characters\nMsgBox \"Current column position: \" & ts.Column", "explanation": "從檔案讀取 5 個字元後，顯示目前的欄號 (將是 6)。"}
            ],
            "keywords": ["textstream", "column position", "fso", "filesystemobject", "文字流", "欄位位置"]
            },
            {
            "name": "TextStream.Line",
            "category": "檔案與資料夾管理",
            "syntax": "textstreamObject.Line",
            "description": "傳回 TextStream 檔案中的目前行號。唯讀。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.OpenTextFile(\"C:\\Temp\\MultiLine.txt\", 1)\nts.ReadLine\nts.ReadLine\nMsgBox \"Current line number: \" & ts.Line", "explanation": "從檔案讀取兩行後，顯示目前的行號 (將是 3，因為它指向下一行的開頭)。"}
            ],
            "keywords": ["textstream", "line number", "fso", "filesystemobject", "文字流", "行號"]
            },
            {
            "name": "TextStream.Read",
            "category": "檔案與資料夾管理",
            "syntax": "textstreamObject.Read(characters)",
            "description": "從 TextStream 檔案讀取指定數量的字元，並傳回結果字串。",
            "parameters": [{"name": "characters", "description": "必需。要讀取的字元數。"}],
            "examples": [
            {"code": "Dim fso As Object, ts As Object, firstTenChars As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.OpenTextFile(\"C:\\Temp\\Story.txt\", 1)\nIf Not ts.AtEndOfStream Then\n  firstTenChars = ts.Read(10)\n  MsgBox \"First 10 characters: \" & firstTenChars\nEnd If\nts.Close", "explanation": "讀取並顯示文字檔案的前 10 個字元。"}
            ],
            "keywords": ["textstream", "read characters", "fso", "filesystemobject", "文字流", "讀取字元"]
            },
            {
            "name": "TextStream.Skip",
            "category": "檔案與資料夾管理",
            "syntax": "textstreamObject.Skip(characters)",
            "description": "從 TextStream 檔案讀取時跳過指定數量的字元。",
            "parameters": [{"name": "characters", "description": "必需。要跳過的字元數。"}],
            "examples": [
            {"code": "Dim fso As Object, ts As Object, data As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.OpenTextFile(\"C:\\Temp\\HeaderFile.txt\", 1)\nts.Skip(100) ' Skip a 100-byte header\nIf Not ts.AtEndOfStream Then\n  data = ts.ReadLine\n  MsgBox \"Data after header: \" & data\nEnd If\nts.Close", "explanation": "跳過檔案的前 100 個字元，然後讀取下一行。"}
            ],
            "keywords": ["textstream", "skip characters", "fso", "filesystemobject", "文字流", "跳過字元"]
            },
            {
            "name": "TextStream.SkipLine",
            "category": "檔案與資料夾管理",
            "syntax": "textstreamObject.SkipLine",
            "description": "從 TextStream 檔案讀取時跳過下一行。檔案指標會移至跳過行之後緊接的行的開頭。",
            "parameters": [],
            "examples": [
            {"code": "Dim fso As Object, ts As Object, relevantLine As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.OpenTextFile(\"C:\\Temp\\DataWithComment.txt\", 1)\nts.SkipLine ' Skip the first line (e.g., a comment or header)\nIf Not ts.AtEndOfStream Then\n  relevantLine = ts.ReadLine\n  MsgBox \"Second line content: \" & relevantLine\nEnd If\nts.Close", "explanation": "跳過檔案的第一行並讀取第二行。"}
            ],
            "keywords": ["textstream", "skip line", "fso", "filesystemobject", "文字流", "跳過行"]
            },
            {
            "name": "TextStream.Write",
            "category": "檔案與資料夾管理",
            "syntax": "textstreamObject.Write(string)",
            "description": "將指定的字串寫入 TextStream 檔案。不會新增換行字元。",
            "parameters": [{"name": "string", "description": "必需。要寫入檔案的字串。"}],
            "examples": [
            {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.CreateTextFile(\"C:\\Temp\\SingleLine.txt\", True)\nts.Write \"Part1\"\nts.Write \"Part2\"\nts.Write \"Part3\" ' Results in \"Part1Part2Part3\" in the file\nts.Close", "explanation": "將多個字串寫入檔案的同一行。"}
            ],
            "keywords": ["textstream", "write string", "fso", "filesystemobject", "文字流", "寫入字串"]
            },
            {
            "name": "TextStream.WriteBlankLines",
            "category": "檔案與資料夾管理",
            "syntax": "textstreamObject.WriteBlankLines(lines)",
            "description": "將指定數量的換行字元寫入 TextStream 檔案。",
            "parameters": [{"name": "lines", "description": "必需。要寫入的換行字元數。"}],
            "examples": [
            {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.CreateTextFile(\"C:\\Temp\\SpacedText.txt\", True)\nts.WriteLine \"First line.\"\nts.WriteBlankLines(2)\nts.WriteLine \"Fourth line (after two blank lines).\"\nts.Close", "explanation": "寫入文字，中間隔兩空行。"}
            ],
            "keywords": ["textstream", "write blank lines", "newline", "fso", "filesystemobject", "文字流", "寫入空行"]
            },
            {
            "name": "FileSystemObject.OpenTextFile",
            "category": "檔案與資料夾管理",
            "syntax": "fso.OpenTextFile(filename[, iomode[, create[, format]]])",
            "description": "開啟指定的檔案並傳回一個 TextStream 物件，可用於讀取、寫入或附加到檔案。",
            "parameters": [
            {"name": "filename", "description": "必需。要開啟的檔案名稱。"},
            {"name": "iomode", "description": "可選。指出輸入/輸出模式。可以是 ForReading (1)、ForWriting (2) 或 ForAppending (8)。"},
            {"name": "create", "description": "可選。布林值。如果 filename 不存在，則 True 表示可以建立新檔案，False 表示不能。預設為 False。"},
            {"name": "format", "description": "可選。三態值，用於指出開啟檔案的格式。可以是 TristateUseDefault (-2)、TristateTrue (-1, Unicode) 或 TristateFalse (0, ASCII)。"}
            ],
            "examples": [
            {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Open for appending, create if not exists\nSet ts = fso.OpenTextFile(\"C:\\Temp\\MyLog.log\", 8, True)\nts.WriteLine Now & \": Application started.\"\nts.Close", "explanation": "開啟一個記錄檔以進行附加，如果不存在則建立它，並寫入帶時間戳的項目。"}
            ],
            "keywords": ["open text file", "read file", "write file", "append file", "textstream", "fso", "filesystemobject", "開啟文字檔"]
            },

            // --- 程式流程與結構控制 (Program Flow & Structure Control) ---
            {
                "name": "CreateObject", "category": "程式流程與結構控制", "syntax": "CreateObject(class, [servername])",
                "description": "創建並返回對 ActiveX 或 OLE 自動化對象的引用。",
                "parameters": [{"name": "class", "description": "必需。對象的應用程序名稱和類。"}, {"name": "servername", "description": "可選。創建對象的網絡服務器的名稱。"}],
                "examples": [
                    {"code": "Dim ExcelApp As Object\nSet ExcelApp = CreateObject(\"Excel.Application\")\n' ExcelApp.Visible = True ' 可以操作 ExcelApp 對象\n' ExcelApp.Quit ' 操作完畢後記得釋放物件", "explanation": "創建一個 Microsoft Excel 應用程式的實例。"},
                    {"code": "Dim FSO As Object\nSet FSO = CreateObject(\"Scripting.FileSystemObject\")\n' MsgBox FSO.Drives.Count ' 可以使用 FSO 進行文件系統操作\n' Set FSO = Nothing ' 操作完畢後記得釋放物件", "explanation": "創建一個文件系統對象（FileSystemObject），用於文件和資料夾操作。"}
                ],
                "keywords": ["對象", "創建", "ActiveX", "OLE", "automation", "object", "new object", "outlook", "word", "excel", "filesystemobject", "fso"]
            },
            {
                "name": "GetObject", "category": "程式流程與結構控制", "syntax": "GetObject([pathname], [class])",
                "description": "返回對自動化對象的文件引用，或獲取正在運行的應用程式的對象。",
                "parameters": [{"name": "pathname", "description": "可選。包含對象的文件的路徑。"}, {"name": "class", "description": "可選。對象的類。"}],
                "examples": [
                    {"code": "Dim ExcelSheet As Object\n' On Error Resume Next ' 如果文件未打開或不存在，GetObject 會產生錯誤\n' Set ExcelSheet = GetObject(\"C:\\MyWorkbook.xlsx\") ' 嘗試獲取已打開文件的對象引用\n' If Not ExcelSheet Is Nothing Then ExcelSheet.Application.Visible = True \n' Else MsgBox \"無法獲取Excel文件對象\"\n' On Error GoTo 0", "explanation": "嘗試獲取一個已打開的 Excel 工作簿文件的對象引用。"},
                    {"code": "Dim WordApp As Object\nOn Error Resume Next\nSet WordApp = GetObject(, \"Word.Application\") ' 獲取正在運行的 Word 實例\nIf WordApp Is Nothing Then\n  Set WordApp = CreateObject(\"Word.Application\") ' 如果未運行則創建新實例\n  MsgBox \"已創建新的Word實例\"\nElse\n  MsgBox \"已獲取現有的Word實例\"\nEnd If\n' WordApp.Visible = True\n' On Error GoTo 0 ' 恢復錯誤處理\n' WordApp.Quit ' 如果是新創建的，記得關閉\n' Set WordApp = Nothing", "explanation": "嘗試獲取一個正在運行的 Word 應用程式實例；如果沒有，則創建一個新的實例。"}
                ],
                "keywords": ["對象", "獲取", "ActiveX", "OLE", "automation", "object", "instance", "get instance", "outlook", "word", "excel"]
            },
            {
                "name": "Call", "category": "程式流程與結構控制", "syntax": "Call name [argumentlist]",
                "description": "將控制權轉移到 Sub 或 Function 過程。",
                "parameters": [{"name": "name", "description": "必需。要調用的過程的名稱。"}, {"name": "argumentlist", "description": "可選。傳遞給過程的參數列表。"}],
                "examples": [
                    {"code": "Sub Main()\n  Call MyProcedure(\"Hello\", 123)\n  MyOtherProcedure \"World\" ' Call 關鍵字通常是可選的\nEnd Sub\nSub MyProcedure(TextParam As String, NumParam As Integer)\n  MsgBox TextParam & \": \" & NumParam\nEnd Sub\nSub MyOtherProcedure(TextParam As String)\n  MsgBox TextParam\nEnd Sub", "explanation": "演示如何使用 Call 關鍵字（或省略它）來調用其他 Sub 過程。"}
                ],
                "keywords": ["調用", "過程", "子程序", "函數", "procedure", "subroutine", "function", "execute"]
            },
            {
                "name": "DoEvents", "category": "程式流程與結構控制", "syntax": "DoEvents()",
                "description": "將控制權交給操作系統，以便處理其他事件。",
                "parameters": [],
                "examples": [
                    {"code": "Sub LongLoopExample()\n  Dim i As Long\n  Application.ScreenUpdating = False ' 搭配使用效果更好\n  For i = 1 To 100000\n    ' 假設這裡有一些耗時的計算\n    Sheet1.Cells(1,1).Value = i ' 範例操作\n    If i Mod 1000 = 0 Then\n      Debug.Print \"Processing... \" & i\n      DoEvents ' 允許操作系統處理其他事件，如UI更新或用戶輸入\n    End If\n  Next i\n  Application.ScreenUpdating = True\n  MsgBox \"Done!\"\nEnd Sub", "explanation": "在長時間運行的循環中，使用 DoEvents 允許應用程式響應其他事件（例如用戶界面更新），防止應用程式看起來像“凍結”了。"}
                ],
                "keywords": ["處理事件", "響應", "操作系統", "events", "os", "yield", "ui update", "凍結", "卡住", "unresponsive"]
            },
            {
                "name": "Dim", "category": "程式流程與結構控制", "syntax": "Dim [WithEvents] varname[([subscripts])] [As [New] type] ...",
                "description": "在過程級別聲明變數並分配存儲空間，或在模塊級別聲明變數。",
                "parameters": [{"name": "varname", "description": "必需。變數的名稱。"}, {"name": "type", "description": "可選。變數的資料類型。"}],
                "examples": [
                    {"code": "Dim Age As Integer", "explanation": "聲明一個名為 Age 的整數類型變數。"},
                    {"code": "Dim Name As String, Salary As Currency", "explanation": "在一行中聲明一個字串變數 Name 和一個貨幣變數 Salary。"},
                    {"code": "Dim Scores(1 To 10) As Double", "explanation": "聲明一個可以存儲10個雙精度浮點數的數組 Scores。"},
                    {"code": "Dim MyObject As New Collection", "explanation": "聲明一個對象變數 MyObject 並立即創建一個新的 Collection 對象實例。"}
                ],
                "keywords": ["聲明變數", "變數", "資料類型", "數組", "declare", "variable", "data type", "array"]
            },
            {
                "name": "ReDim", "category": "程式流程與結構控制", "syntax": "ReDim [Preserve] varname(subscripts) [As type] ...",
                "description": "在過程級別重新分配動態數組變數的存儲空間。",
                "parameters": [{"name": "Preserve", "description": "可選。保留數組中的數據。"}, {"name": "varname", "description": "必需。動態數組變數的名稱。"}, {"name": "subscripts", "description": "必需。數組變數的新維度。"}],
                "examples": [
                    {"code": "Dim MyDynamicArray() As Integer\nReDim MyDynamicArray(5) ' 數組現在有 6 個元素 (0 到 5)\nMyDynamicArray(0) = 100", "explanation": "聲明一個動態整數數組並將其大小調整為6個元素。"},
                    {"code": "Dim Names() As String\nReDim Names(2) ' 0, 1, 2\nNames(0) = \"Alice\"\nReDim Preserve Names(4) ' 擴大數組並保留 \"Alice\"\nNames(3) = \"Bob\"", "explanation": "重新調整動態數組的大小，同時使用 Preserve 關鍵字保留數組中現有的數據。"}
                ],
                "keywords": ["重定義數組", "動態數組", "數組大小", "redimension", "dynamic array", "array size", "preserve"]
            },
            {
                "name": "Const", "category": "程式流程與結構控制", "syntax": "[Public | Private] Const constname [As type] = expression",
                "description": "聲明用於代替文字值的常數。",
                "parameters": [{"name": "constname", "description": "必需。常數的名稱。"}, {"name": "expression", "description": "必需。常數的值。"}],
                "examples": [
                    {"code": "Const PI As Double = 3.1415926535", "explanation": "聲明一個名為 PI 的雙精度浮點型常數。"},
                    {"code": "Public Const MAX_ATTEMPTS As Integer = 3", "explanation": "聲明一個公共整型常數 MAX_ATTEMPTS，可在整個項目中訪問。"}
                ],
                "keywords": ["常數", "聲明", "固定值", "constant", "declare", "literal", "define"]
            },
            {
                "name": "Option Explicit", "category": "程式流程與結構控制", "syntax": "Option Explicit",
                "description": "強制對模塊中的所有變數進行顯式聲明。",
                "parameters": [],
                "examples": [
                    {"code": "Option Explicit ' 應放在模塊的最頂部\nSub MySub()\n  Dim myVar As Integer ' 由於 Option Explicit，此聲明是必需的\n  myVar = 10\n  ' anothrVar = 20 ' 如果 Option Explicit 生效，這行會導致編譯錯誤\nEnd Sub", "explanation": "在模塊頂部使用此語句，可以強制所有變數在使用前必須通過 Dim、Private、Public、Static 等關鍵字進行聲明，有助於避免因拼寫錯誤導致的變數問題。"}
                ],
                "keywords": ["顯式聲明", "變數聲明", "強制聲明", "variable declaration", "explicit", "compiler option"]
            },
            {
                "name": "Option Base", "category": "程式流程與結構控制", "syntax": "Option Base {0 | 1}",
                "description": "在模塊級別指定陣列的預設下限。預設為 0。",
                "parameters": [{"name": "0 | 1", "description": "0 表示陣列索引從0開始 (預設)，1 表示從1開始。"}],
                "examples": [
                    {"code": "Option Base 1 ' 影響此模塊中所有未使用明確下限聲明的陣列\nSub ArrayBaseExample()\n  Dim arrTest(3) As String ' 由於 Option Base 1, arrTest 索引為 1, 2, 3\n  arrTest(1) = \"Apple\"\n  ' arrTest(0) = \"Banana\" ' 這會產生錯誤\n  MsgBox arrTest(1)\nEnd Sub", "explanation": "使用 Option Base 1 使模塊中的陣列預設從索引 1 開始。建議謹慎使用，並在聲明陣列時明確指定上下限 (例如 Dim arr(1 To 10)) 以提高清晰度。"}
                ],
                "keywords": ["陣列基底", "陣列索引", "option base", "array index", "lower bound"]
            },
            {
                "name": "Set", "category": "程式流程與結構控制", "syntax": "Set objectvar = {objectexpression | Nothing}",
                "description": "將物件參考指派給變數或屬性。",
                "parameters": [
                    {"name": "objectvar", "description": "必需。物件變數的名稱。"},
                    {"name": "objectexpression", "description": "必需。物件、另一個已聲明的物件變數或返回物件的函數/方法。"},
                    {"name": "Nothing", "description": "必需 (用於解除關聯)。解除 objectvar 與任何特定物件的關聯。"}
                ],
                "examples": [
                    {"code": "Dim mySheet As Worksheet\nSet mySheet = ThisWorkbook.Sheets(1)\nMsgBox mySheet.Name\nSet mySheet = Nothing ' 釋放物件參考", "explanation": "使用 Set 將 Worksheet 物件指派給 mySheet 變數，然後使用 Nothing 釋放它。"}
                ],
                "keywords": ["物件指派", "set語句", "物件參考", "object assignment", "object reference", "nothing"]
            },
            {
                "name": "ByVal / ByRef (參數傳遞)", "category": "程式流程與結構控制", "syntax": "Sub ProcedureName([ByVal | ByRef] argument As type)",
                "description": "指定參數如何傳遞給過程。ByVal 傳遞參數的副本；ByRef (預設) 傳遞參數的實際記憶體位置參考。",
                "parameters": [
                    {"name": "ByVal", "description": "過程內部對參數的更改不會影響原始變數。"},
                    {"name": "ByRef", "description": "過程內部對參數的更改會直接修改原始變數。"}
                ],
                "examples": [
                    {"code": "Sub TestPassBy()\n  Dim x As Integer: x = 10\n  Dim y As Integer: y = 10\n  PassByValue x\n  PassByReference y\n  MsgBox \"After ByVal, x = \" & x ' x 仍然是 10\n  MsgBox \"After ByRef, y = \" & y ' y 變成 20\nEnd Sub\nSub PassByValue(ByVal num As Integer)\n  num = num * 2\nEnd Sub\nSub PassByReference(ByRef num As Integer)\n  num = num * 2\nEnd Sub", "explanation": "演示 ByVal 和 ByRef 在參數傳遞中的不同效果。"}
                ],
                "keywords": ["參數傳遞", "傳值", "傳址", "byval", "byref", "parameter passing"]
            },
            {
                "name": "Public / Private / Friend (Scope)", "category": "程式流程與結構控制", "syntax": "[Public | Private | Friend] [Static] Sub | Function | Dim | Const ...",
                "description": "定義變數、常數、Sub 或 Function 的可見性範圍。",
                "parameters": [
                    {"name": "Public", "description": "在所有專案的所有模組中都可見。"},
                    {"name": "Private", "description": "僅在聲明它的模組中可見。"},
                    {"name": "Friend", "description": "(僅用於類別模組和標準模組中的物件) 在整個專案中可見，但在專案外部不可見。"}
                ],
                "examples": [
                    {"code": "' In Module1\nPublic PublicVar As String = \"I am public\"\nPrivate PrivateVar As String = \"I am private to Module1\"\n\nPublic Sub ShowPublic()\n  MsgBox PublicVar\nEnd Sub\n\nPrivate Sub ShowPrivate()\n  MsgBox PrivateVar\nEnd Sub", "explanation": "Public 變數和過程可以從其他模組訪問，而 Private 則不行。"}
                ],
                "keywords": ["作用域", "可見性", "public", "private", "friend", "scope", "visibility"]
            },
            {
                "name": "Function ... End Function (UDF)", "category": "程式流程與結構控制", "syntax": "[Public | Private | Friend] [Static] Function name [(arglist)] [As type]\n  [statements]\n  [name = expression]\n  [Exit Function]\n  [statements]\nEnd Function",
                "description": "定義一個使用者自訂函數 (UDF)，可以在 Excel 工作表公式中像內建函数一樣使用，或在其他 VBA 程序中調用。",
                "parameters": [
                    {"name": "name", "description": "必需。函數的名稱。"},
                    {"name": "arglist", "description": "可選。參數列表，每個參數格式為 [Optional] [ByVal | ByRef] [ParamArray] varname[( )] [As type] [= defaultvalue]。"},
                    {"name": "type", "description": "可選。函數返回值的資料類型。"}
                ],
                "examples": [
                    {"code": "' 將此代碼放在標準模塊中\nPublic Function GET_FULL_NAME(firstName As String, lastName As String) As String\n  GET_FULL_NAME = lastName & \", \" & firstName\nEnd Function\n\n' 你可以在工作表儲存格中使用公式: =GET_FULL_NAME(\"John\", \"Doe\")\n' 結果將是 \"Doe, John\"", "explanation": "定義一個名為 GET_FULL_NAME 的自訂函數，它接受名字和姓氏，並返回格式為 '姓, 名' 的字串。"},
                    {"code": "Public Function CALCULATE_COMMISSION(salesAmount As Double, rate As Double) As Currency\n  If salesAmount < 0 Or rate < 0 Then\n    CALCULATE_COMMISSION = CVErr(xlErrValue) ' 返回錯誤值如果輸入無效\n  Else\n    CALCULATE_COMMISSION = salesAmount * rate\n  End If\nEnd Function\n\n' 工作表公式: =CALCULATE_COMMISSION(A1, B1) ", "explanation": "定義一個計算佣金的UDF。如果銷售額或費率為負，則返回 #VALUE! 錯誤。"}
                ],
                "keywords": ["自訂函數", "UDF", "公式", "工作表函數", "excel", "custom function", "user defined function", "worksheet function", "formula"]
            },
            {
                "name": "Sub ... End Sub", "category": "程式流程與結構控制", "syntax": "[Private | Public | Friend] [Static] Sub name [(arglist)]\n  [statements]\n  [Exit Sub]\n  [statements]\nEnd Sub",
                "description": "定義一個子程序 (Sub procedure)。Sub 過程不返回值。",
                "parameters": [
                    {"name": "name", "description": "必需。子程序的名稱。"},
                    {"name": "arglist", "description": "可選。參數列表。"}
                ],
                "examples": [
                    {"code": "Public Sub GreetUser(userName As String)\n  MsgBox \"Hello, \" & userName & \"!\"\nEnd Sub\n\nSub TestGreeting()\n  Call GreetUser(\"Alice\")\nEnd Sub", "explanation": "定義一個名為 GreetUser 的子程序，它接受一個用戶名作為參數並顯示問候語。"}
                ],
                "keywords": ["子程序", "過程", "sub", "procedure", "subroutine"]
            },
            {
                "name": "If...Then...ElseIf...Else...End If", "category": "程式流程與結構控制", "syntax": "If condition1 Then\n  [statements1]\n[ElseIf condition2 Then\n  [statements2]]\n[Else\n  [statements_else]]\nEnd If",
                "description": "根據條件執行不同的程式碼塊。",
                "parameters": [
                    {"name": "condition", "description": "必需。一個評估為 True 或 False 的表達式。"}
                ],
                "examples": [
                    {"code": "Dim score As Integer\nscore = 75\nIf score >= 90 Then\n  MsgBox \"Excellent!\"\nElseIf score >= 60 Then\n  MsgBox \"Good.\"\nElse\n  MsgBox \"Needs improvement.\"\nEnd If", "explanation": "根據分數給出不同的評價。"}
                ],
                "keywords": ["條件判斷", "如果", "if then else", "conditional statement", "branching"]
            },
            {
                "name": "For...Next", "category": "程式流程與結構控制", "syntax": "For counter = start To end [Step stepval]\n  [statements]\n  [Exit For]\n  [statements]\nNext [counter]",
                "description": "重複執行一段程式碼指定的次數。",
                "parameters": [
                    {"name": "counter", "description": "必需。用作迴圈計數器的數值變數。"},
                    {"name": "start", "description": "必需。計數器的初始值。"},
                    {"name": "end", "description": "必需。計數器的最終值。"},
                    {"name": "stepval", "description": "可選。計數器每次遞增/遞減的量。"}
                ],
                "examples": [
                    {"code": "Dim i As Integer\nFor i = 1 To 5\n  Debug.Print \"Iteration: \" & i\nNext i", "explanation": "打印從 1 到 5 的迭代次數。"},
                    {"code": "Dim j As Integer\nFor j = 10 To 0 Step -2\n  Debug.Print \"Countdown: \" & j\nNext j", "explanation": "從 10 開始倒數到 0，每次減 2。"}
                ],
                "keywords": ["迴圈", "for迴圈", "重複", "loop", "for loop", "iteration"]
            },
            {
                "name": "For Each...Next", "category": "程式流程與結構控制", "syntax": "For Each element In group\n  [statements]\n  [Exit For]\n  [statements]\nNext [element]",
                "description": "為集合中的每個物件或陣列中的每個元素重複執行一段程式碼。",
                "parameters": [
                    {"name": "element", "description": "必需。用於迭代集合或陣列元素的變數。"},
                    {"name": "group", "description": "必需。物件集合或陣列。"}
                ],
                "examples": [
                    {"code": "Dim ws As Worksheet\nFor Each ws In ThisWorkbook.Worksheets\n  Debug.Print ws.Name\nNext ws", "explanation": "遍歷目前活頁簿中的所有工作表並打印其名稱。"},
                    {"code": "Dim arrNumbers As Variant, num As Variant\narrNumbers = Array(10, 20, 30)\nFor Each num In arrNumbers\n  Debug.Print num * 2\nNext num", "explanation": "遍歷陣列中的每個數字並將其乘以 2 後打印。"}
                ],
                "keywords": ["遍歷", "for each迴圈", "集合", "陣列", "loop", "collection", "array iteration"]
            },
            {
                "name": "Do...Loop", "category": "程式流程與結構控制", "syntax": "Do [{While | Until} condition]\n  [statements]\n  [Exit Do]\n  [statements]\nLoop\n' Or\nDo\n  [statements]\n  [Exit Do]\n  [statements]\nLoop [{While | Until} condition]",
                "description": "當條件為 True 或直到條件變為 True 時，重複執行一段程式碼。",
                "parameters": [
                    {"name": "condition", "description": "必需。一個評估為 True 或 False 的表達式。"}
                ],
                "examples": [
                    {"code": "Dim counter As Integer\ncounter = 0\nDo While counter < 5\n  Debug.Print \"Do While: \" & counter\n  counter = counter + 1\nLoop", "explanation": "當 counter 小於 5 時重複執行。"},
                    {"code": "Dim attempts As Integer\nattempts = 0\nDo\n  attempts = attempts + 1\n  Debug.Print \"Attempt: \" & attempts\nLoop Until attempts >= 3 Or InputBox(\"Continue? (yes/no)\") = \"no\"\nMsgBox attempts & \" attempts made.\"", "explanation": "至少執行一次，然後直到 attempts 大於等於 3 或使用者輸入 'no' 時停止。"}
                ],
                "keywords": ["do迴圈", "while迴圈", "until迴圈", "重複", "loop", "do while", "do until"]
            },
            {
                "name": "Select Case", "category": "程式流程與結構控制", "syntax": "Select Case testexpression\n  [Case expressionlist1\n    [statements1]]\n  [Case expressionlist2\n    [statements2]]\n  ...\n  [Case Else\n    [elsestatements]]\nEnd Select",
                "description": "根據一個表達式的值，執行多個程式碼塊中的一個。",
                "parameters": [
                    {"name": "testexpression", "description": "必需。任何數值或字串表達式。"}
                ],
                "examples": [
                    {"code": "Dim dayNum As Integer\ndayNum = Weekday(Now)\nSelect Case dayNum\n  Case vbSunday\n    MsgBox \"今天是星期日\"\n  Case vbMonday\n    MsgBox \"今天是星期一\"\n  Case Else\n    MsgBox \"是工作日\"\nEnd Select", "explanation": "根據今天的星期幾顯示不同的訊息。"}
                ],
                "keywords": ["select case", "多重條件", "switch", "conditional branching"]
            },
            {
                "name": "Exit Sub | Function | For | Do", "category": "程式流程與結構控制", "syntax": "Exit Sub | Exit Function | Exit For | Exit Do",
                "description": "立即退出目前正在執行的 Sub 過程、Function 過程、For 迴圈或 Do 迴圈。",
                "parameters": [],
                "examples": [
                    {"code": "Sub CheckValue(val As Integer)\n  If val < 0 Then\n    MsgBox \"值不能為負數。\"\n    Exit Sub ' 如果值為負，則退出 Sub\n  End If\n  MsgBox \"值有效: \" & val\nEnd Sub", "explanation": "演示如何在條件滿足時使用 Exit Sub 提前退出子程序。"}
                ],
                "keywords": ["退出程序", "跳出迴圈", "exit procedure", "exit loop", "break"]
            },
            {
                "name": "With...End With", "category": "程式流程與結構控制", "syntax": "With object\n  [statements]\nEnd With",
                "description": "對單一物件執行一系列語句，而無需重複物件名稱。",
                "parameters": [{"name": "object", "description": "必需。物件的名稱。"}],
                "examples": [
                    {"code": "With ThisWorkbook.Sheets(\"Sheet1\").Range(\"A1\")\n  .Value = \"Sample Text\"\n  .Font.Bold = True\n  .Font.Color = RGB(255, 0, 0)\n  .Interior.Color = RGB(200, 200, 200)\nEnd With", "explanation": "使用 With 語句簡化對 Range(\"A1\") 物件的多個屬性設置。"}
                ],
                "keywords": ["with語句", "物件操作", "簡化程式碼", "with statement", "object manipulation"]
            },
            {
                "name": "Static (變數)", "category": "程式流程與結構控制", "syntax": "Static varname[([subscripts])] [As [New] type] [, varname...]",
                "description": "在過程級別聲明變數，使其在過程調用之間保留其值。",
                "parameters": [{"name": "varname", "description": "必需。變數的名稱。"}],
                "examples": [
                    {"code": "Sub CountCalls()\n  Static callCount As Integer\n  callCount = callCount + 1\n  MsgBox \"此 Sub 已被調用 \" & callCount & \" 次。\"\nEnd Sub\n' 多次調用 CountCalls() 將顯示遞增的計數", "explanation": "使用 Static 變數來計算一個 Sub 被調用的次數。"}
                ],
                "keywords": ["靜態變數", "保留值", "static variable", "preserve value", "procedure level"]
            },
            {
                "name": "GoTo", "category": "程式流程與結構控制", "syntax": "GoTo line",
                "description": "無條件地跳轉到過程中的指定行。通常用於錯誤處理或跳出深層嵌套結構（應謹慎使用）。",
                "parameters": [{"name": "line", "description": "必需。任何行號或行標籤。"}],
                "examples": [
                    {"code": "Sub GoToExample(num As Integer)\n  If num < 0 Then GoTo HandleError\n  MsgBox \"Number is positive: \" & num\n  Exit Sub\nHandleError:\n  MsgBox \"Error: Number cannot be negative.\"\nEnd Sub", "explanation": "如果數字為負，則跳轉到 HandleError 標籤。注意：過度使用 GoTo 會使代碼難以閱讀和維護。"}
                ],
                "keywords": ["跳轉", "goto語句", "流程控制", "unconditional jump", "flow control", "label"]
            },
            {
                "name": "Optional (參數)", "category": "程式流程與結構控制", "syntax": "Sub MySub(Arg1 As String, Optional Arg2 As Variant, Optional Arg3 As Integer = 10)",
                "description": "在 Sub 或 Function 過程中將參數聲明為可選的。可選參數必須是 Variant 類型，或者具有指定的預設值。",
                "parameters": [
                    {"name": "Optional", "description": "關鍵字，用於將參數標記為可選。"},
                    {"name": "As Variant", "description": "如果沒有預設值，可選參數通常聲明為 Variant，這樣可以使用 IsMissing 檢查。"},
                    {"name": "= defaultValue", "description": "為可選參數提供預設值。如果調用時未提供該參數，則使用此預設值。"}
                ],
                "examples": [
                    {"code": "Sub Greet(name As String, Optional title As String = \"Friend\")\n  MsgBox \"Hello, \" & title & \" \" & name & \"!\"\nEnd Sub\n' Greet \"Alice\" ' 顯示 \"Hello, Friend Alice!\"\n' Greet \"Bob\", \"Mr.\" ' 顯示 \"Hello, Mr. Bob!\"", "explanation": "演示如何定義帶有預設值的可選參數。"},
                    {"code": "Function CalculateArea(length As Double, Optional width As Variant) As Double\n  If IsMissing(width) Then\n    CalculateArea = length * length ' Square if width is missing\n  Else\n    CalculateArea = length * CDbl(width)\n  End If\nEnd Function\n' Debug.Print CalculateArea(5) ' Returns 25\n' Debug.Print CalculateArea(5, 10) ' Returns 50", "explanation": "演示如何使用 IsMissing 檢查可選 Variant 參數是否被提供。"}
                ],
                "keywords": ["可選參數", "默認參數值", "optional parameter", "default value", "IsMissing"]
            },
            {
                "name": "ParamArray (參數)", "category": "程式流程與結構控制", "syntax": "Sub MySub(ParamArray Args() As Variant)",
                "description": "允許過程接受任意數量的參數。ParamArray 必須是過程中的最後一個參數，並且必須是 Variant 類型的數組。",
                "parameters": [{"name": "ParamArray Args() As Variant", "description": "聲明一個參數數組，用於接收額外的參數。"}],
                "examples": [
                    {"code": "Sub SumNumbers(ParamArray values() As Variant)\n  Dim total As Double: total = 0\n  Dim val As Variant\n  For Each val In values\n    If IsNumeric(val) Then total = total + CDbl(val)\n  Next val\n  MsgBox \"Sum: \" & total\nEnd Sub\n' SumNumbers 1, 2, 3, 4, 5 ' 顯示 \"Sum: 15\"\n' SumNumbers 10.5, 20 ' 顯示 \"Sum: 30.5\"", "explanation": "創建一個可以接受不定數量數值參數並計算其總和的子程序。"}
                ],
                "keywords": ["參數數組", "可變參數", "paramarray", "variable arguments", "不定參數"]
            },
            {
                "name": "Enum...End Enum", "category": "程式流程與結構控制", "syntax": "[Public | Private] Enum EnumName\n    MemberName1 [= value1]\n    MemberName2 [= value2]\n    ...\nEnd Enum",
                "description": "定義一個枚舉類型。枚舉提供了一種方便的方式來處理一組相關的常數，並賦予這些常數有意義的名稱。",
                "parameters": [
                    {"name": "EnumName", "description": "必需。枚舉類型的名稱。"},
                    {"name": "MemberName", "description": "必需。枚舉的成員名稱。"},
                    {"name": "value", "description": "可選。分配給成員的 Long 整數值。如果省略，第一個成員為0，後續成員依次加1。"}
                ],
                "examples": [
                    {"code": "Public Enum FileAccessMode\n  ReadOnly = 1\n  WriteOnly = 2\n  ReadWrite = 3\nEnd Enum\n\nSub TestEnum(mode As FileAccessMode)\n  If mode = ReadOnly Then MsgBox \"File opened in ReadOnly mode.\"\nEnd Sub\n' TestEnum ReadOnly", "explanation": "定義一個名為 FileAccessMode 的枚舉，並在另一個過程中使用它作為參數類型。"}
                ],
                "keywords": ["枚舉", "常數組", "enum", "enumeration", "constants"]
            },
            {
                "name": "Type...End Type", "category": "程式流程與結構控制", "syntax": "[Private | Public] Type UserDefinedTypeName\n    ElementName1 As TypeName1\n    ElementName2 As TypeName2\n    ...\nEnd Type",
                "description": "在模塊級別定義用戶自定義數據類型 (UDT)，也稱為結構 (structure) 或記錄 (record)。",
                "parameters": [
                    {"name": "UserDefinedTypeName", "description": "必需。用戶自定義類型的名稱。"},
                    {"name": "ElementName", "description": "必需。UDT 中元素的名稱。"},
                    {"name": "TypeName", "description": "必需。元素的數據類型 (可以是內建類型、其他 UDT 或固定長度字串)。"}
                ],
                "examples": [
                    {"code": "Type EmployeeRecord\n  ID As Long\n  FirstName As String * 50 ' 固定長度字串\n  LastName As String\n  HireDate As Date\n  Salary As Currency\nEnd Type\n\nSub ProcessEmployee()\n  Dim emp As EmployeeRecord\n  emp.ID = 101\n  emp.FirstName = \"John\"\n  emp.LastName = \"Doe\"\n  emp.HireDate = DateSerial(2020, 5, 15)\n  emp.Salary = 60000\n  MsgBox emp.FirstName & \" \" & emp.LastName & \" was hired on \" & emp.HireDate\nEnd Sub", "explanation": "定義一個名為 EmployeeRecord 的用戶自定義類型，然後聲明該類型的一個變數並填充其成員。"}
                ],
                "keywords": ["用戶定義類型", "結構", "記錄", "user defined type", "udt", "structure", "record", "custom data type"]
            },

            // --- 錯誤處理與調試 (Error Handling & Debugging) ---
            {
                "name": "On Error GoTo", "category": "錯誤處理與調試",
                "syntax": "On Error GoTo line | On Error Resume Next | On Error GoTo 0",
                "description": "啟用或禁用錯誤處理例程。",
                "parameters": [
                    {"name": "line", "description": "錯誤處理例程的行標籤。"},
                    {"name": "Resume Next", "description": "忽略錯誤並繼續執行下一行。"},
                    {"name": "GoTo 0", "description": "禁用錯誤處理。"}
                ],
                "examples": [
                    {"code": "Sub ErrorHandlingDemo()\n  On Error GoTo MyErrorHandler\n  Dim x As Integer, y As Integer, z As Integer\n  x = 10: y = 0\n  z = x / y ' 這會產生一個除以零的錯誤\n  MsgBox \"結果: \" & z\nExit Sub ' 正常結束時退出，避免執行錯誤處理程序\nMyErrorHandler:\n  MsgBox \"發生錯誤: \" & Err.Description & vbCrLf & \"錯誤號碼: \" & Err.Number\n  ' Resume Next ' 處理完錯誤後，可以選擇從下一行繼續 (如果適用)\nEnd Sub", "explanation": "演示如何使用 On Error GoTo 跳转到指定的錯誤處理標籤 (MyErrorHandler)。"},
                    {"code": "Sub IgnoreErrorExample()\n  On Error Resume Next ' 遇到錯誤時，程序將繼續執行緊隨其後的語句\n  Dim result As Variant\n  result = 1 / 0 ' 這會產生錯誤，但程序不會停止\n  If Err.Number <> 0 Then\n    MsgBox \"發生了一個錯誤 (已被忽略): \" & Err.Description\n    Err.Clear ' 清除錯誤信息，以便後續的錯誤可以被檢測\n  End If\n  MsgBox \"程序繼續執行...\"\n  On Error GoTo 0 ' 禁用錯誤忽略，恢復正常的錯誤報告機制\nEnd Sub", "explanation": "演示如何使用 On Error Resume Next 來忽略運行時錯誤，並在之後檢查 Err 對象來判斷是否發生了錯誤。"}
                ],
                "keywords": ["錯誤處理", "異常處理", "error handling", "exception", "resume", "goto", "trap"]
            },
            {
                "name": "Err", "category": "錯誤處理與調試",
                "syntax": "Err (Object)",
                "description": "包含有關運行時錯誤信息的全局對象。",
                "parameters": [
                    {"name": "Number", "description": "屬性：返回或設置一個數值，指定錯誤。Err.Number 是 Err 對象的預設屬性。"},
                    {"name": "Description", "description": "屬性：返回或設置一個描述錯誤的字串表達式。"},
                    {"name": "Source", "description": "屬性：返回或設置最初生成錯誤的對象或應用程序的名稱。"},
                    {"name": "HelpFile", "description": "屬性：返回或設置包含幫助主題的幫助文件的完整路徑。"},
                    {"name": "HelpContext", "description": "屬性：返回或設置幫助文件中主題的上下文 ID。"},
                    {"name": "Raise method", "description": "方法：生成一個運行時錯誤。"},
                    {"name": "Clear method", "description": "方法：清除 Err 對象的所有屬性設置。"}
                ],
                "examples": [
                    {"code": "Sub CheckErrorObject()\n  On Error Resume Next\n  Dim val As Integer\n  val = \"abc\" ' 這會導致類型不匹配錯誤\n\n  If Err.Number <> 0 Then\n    MsgBox \"錯誤號: \" & Err.Number & vbCrLf & _\n           \"描述: \" & Err.Description & vbCrLf & _\n           \"來源: \" & Err.Source\n    Err.Clear ' 清除錯誤，以便下次可以捕獲新錯誤\n  End If\nEnd Sub", "explanation": "演示在發生錯誤後如何訪問 Err 對象的 Number、Description 和 Source 屬性來獲取錯誤信息，並使用 Clear 方法清除錯誤。"},
                    {"code": "Sub RaiseCustomError()\n  On Error GoTo HandleCustomError\n  Dim userAge As Integer\n  userAge = CInt(InputBox(\"Enter your age:\"))\n  If userAge < 18 Then\n    Err.Raise Number:=vbObjectError + 1001, _\n              Source:=\"RaiseCustomError Sub\", _\n              Description:=\"User must be 18 or older.\"\n  End If\n  MsgBox \"Age accepted: \" & userAge\nExit Sub\nHandleCustomError:\n  MsgBox \"Error \" & Err.Number & \": \" & Err.Description & \" (Source: \" & Err.Source & \")\"\nEnd Sub", "explanation": "演示如何使用 Err.Raise 方法來主動觸發一個自定義的運行時錯誤，並在錯誤處理程序中捕獲它。"}
                ],
                "keywords": ["錯誤對象", "運行時錯誤", "錯誤信息", "error object", "runtime error", "err number", "err description", "raise error", "clear error"]
            },
            {
                "name": "CVErr", "category": "錯誤處理與調試",
                "syntax": "CVErr(errornumber)",
                "description": "返回一個 Variant，其子類型為 Error，包含用戶指定的錯誤號。",
                "parameters": [
                    {"name": "errornumber", "description": "必需。任何有效的錯誤號。"}
                ],
                "examples": [
                    {"code": "Function CalculateRatio(Numerator As Double, Denominator As Double) As Variant\n  If Denominator = 0 Then\n    CalculateRatio = CVErr(11) ' 11 是 VBA 的 '除以零' 錯誤號碼 (vbErrorDividByZero)\n  Else\n    CalculateRatio = Numerator / Denominator\n  End If\nEnd Function\n\nSub TestCalculateRatio()\n  Dim result As Variant\n  result = CalculateRatio(10, 0)\n  If IsError(result) Then\n    MsgBox \"Error in calculation: Division by zero (Error \" & CLng(result) & \")\"\n  Else\n    MsgBox \"Result: \" & result\n  End If\nEnd Sub", "explanation": "演示如何在函數中檢測到特定條件（如除以零）時返回一個錯誤值，並在調用該函數後使用 IsError 檢查返回結果。"}
                ],
                "keywords": ["創建錯誤", "錯誤值", "error", "variant", "custom error", "return error"]
            },

            // --- Excel 核心操作 (Core Excel Operations) ---
            {
                "name": "Application.ScreenUpdating", "category": "Excel 核心操作", "syntax": "Application.ScreenUpdating = True | False",
                "description": "控制螢幕是否在宏執行期間更新。關閉它可以顯著提高宏的執行速度。",
                "parameters": [{"name": "True | False", "description": "True (預設) 表示啟用螢幕更新，False 表示禁用。"}],
                "examples": [
                    {"code": "Sub FastMacro()\n  Application.ScreenUpdating = False\n  ' ... 大量的儲存格操作 ...\n  Application.ScreenUpdating = True\n  MsgBox \"處理完成且螢幕未閃爍！\"\nEnd Sub", "explanation": "在執行大量操作前關閉螢幕更新，完成後再開啟，以加速宏並避免畫面閃爍。"}
                ],
                "keywords": ["螢幕更新", "加速", "效能", "excel", "performance", "speed up", "screen update"]
            },
            {
                "name": "Application.DisplayAlerts", "category": "Excel 核心操作", "syntax": "Application.DisplayAlerts = True | False",
                "description": "控制 Excel 是否在執行某些操作（如刪除工作表）時顯示警告訊息。關閉它可以讓宏不間斷執行。",
                "parameters": [{"name": "True | False", "description": "True (預設) 表示顯示警告，False 表示禁用警告。"}],
                "examples": [
                    {"code": "Sub DeleteSheetWithoutAlert()\n  Application.DisplayAlerts = False\n  On Error Resume Next ' 以防工作表不存在\n  Worksheets(\"舊資料\").Delete\n  On Error GoTo 0\n  Application.DisplayAlerts = True\n  MsgBox \"工作表 '舊資料' (如果存在) 已被刪除，且無警告提示。\"\nEnd Sub", "explanation": "在刪除工作表前關閉警告提示，操作完成後再開啟。"}
                ],
                "keywords": ["警告訊息", "提示", "關閉警告", "excel", "alerts", "suppress alerts", "automation"]
            },
            {
                "name": "Application.Calculation", "category": "Excel 核心操作", "syntax": "Application.Calculation = xlCalculationAutomatic | xlCalculationManual | xlCalculationSemiautomatic",
                "description": "控制 Excel 的計算模式。設置為手動計算可以加快包含大量公式的宏的運行速度。",
                "parameters": [
                    {"name": "xlCalculationAutomatic", "description": "自動計算 (預設)。"},
                    {"name": "xlCalculationManual", "description": "手動計算。公式僅在用戶觸發或 VBA 調用 Calculate 方法時計算。"},
                    {"name": "xlCalculationSemiautomatic", "description": "半自動計算 (除資料表外，自動計算)。"}
                ],
                "examples": [
                    {"code": "Sub ManualCalculationExample()\n  Dim originalCalcMode As XlCalculation\n  originalCalcMode = Application.Calculation\n\n  Application.Calculation = xlCalculationManual\n  ' ... 執行大量公式相關操作 ...\n  Range(\"A1:A1000\").Value = Rnd() ' 填入數據\n  Range(\"B1\").Formula = \"=SUM(A1:A1000)\" ' 輸入公式\n\n  ' 如果需要立即看到結果，可以手動觸發計算\n  ' Application.Calculate ' 或 ActiveSheet.Calculate 或 Range(\"B1\").Calculate\n\n  Application.Calculation = originalCalcMode ' 恢復原始計算模式\n  MsgBox \"計算模式已恢復。B1的值為: \" & Range(\"B1\").Value\nEnd Sub", "explanation": "在大量公式操作前設置為手動計算，操作完成後恢復原模式。"}
                ],
                "keywords": ["計算模式", "手動計算", "自動計算", "公式", "效能", "excel", "calculation mode", "manual calculation", "formula", "performance"]
            },
            {
                "name": "Application.EnableEvents", "category": "Excel 核心操作", "syntax": "Application.EnableEvents = True | False",
                "description": "控制 Excel 是否觸發事件 (如 Worksheet_Change 事件)。在宏中修改儲存格時，若不希望觸發相關事件，可以暫時禁用它。",
                "parameters": [{"name": "True | False", "description": "True (預設) 表示啟用事件，False 表示禁用。"}],
                "examples": [
                    {"code": "Sub ModifyCellsWithoutTriggeringEvents()\n  Application.EnableEvents = False\n  ' 假設 Sheet1 的 Worksheet_Change 事件中有程式碼\n  Sheet1.Range(\"A1\").Value = \"New Value\" ' 此操作不會觸發 Sheet1 的 Worksheet_Change 事件\n  Application.EnableEvents = True ' 務必恢復\n  MsgBox \"儲存格已修改，且事件未被觸發。\"\nEnd Sub", "explanation": "在修改儲存格內容前禁用事件，以避免觸發 Worksheet_Change 等事件，完成後再啟用。"}
                ],
                "keywords": ["事件", "禁用事件", "觸發事件", "excel", "events", "disable events", "automation", "worksheet_change"]
            },
            {
                "name": "Application.InputBox (Excel)", "category": "Excel 核心操作", "syntax": "Application.InputBox(Prompt, [Title], [Default], [Left], [Top], [HelpFile], [HelpContextID], [Type])",
                "description": "Excel 的 InputBox 方法，比 VBA 內建的 InputBox 多了 Type 參數，可以限制輸入的資料類型。",
                "parameters": [
                    {"name": "Prompt", "description": "必需。提示訊息。"},
                    {"name": "Type", "description": "可選。指定期望的返回資料類型 (例如 1=數字, 2=文字, 8=儲存格參照)。"}
                ],
                "examples": [
                    {"code": "Dim userNum As Variant\nuserNum = Application.InputBox(\"請輸入一個數字：\", \"數字輸入\", Type:=1)\nIf userNum <> False And IsNumeric(userNum) Then\n  MsgBox \"您輸入的數字是: \" & userNum\nElse\n  MsgBox \"輸入無效或已取消。\"\nEnd If", "explanation": "彈出 Excel 的 InputBox，要求使用者輸入一個數字。"},
                    {"code": "Dim selectedRange As Range\nOn Error Resume Next ' 如果用戶取消，會產生錯誤\nSet selectedRange = Application.InputBox(\"請選取一個儲存格範圍：\", \"範圍選取\", Type:=8)\nOn Error GoTo 0\nIf Not selectedRange Is Nothing Then\n  MsgBox \"您選取的範圍是: \" & selectedRange.Address\nElse\n  MsgBox \"未選取範圍或已取消。\"\nEnd If", "explanation": "彈出 Excel 的 InputBox，讓使用者選取一個儲存格範圍。"}
                ],
                "keywords": ["Excel輸入框", "限制輸入類型", "excel", "inputbox", "get input", "type argument"]
            },
            {
                "name": "Application.StatusBar", "category": "Excel 核心操作", "syntax": "Application.StatusBar = stringExpression | False",
                "description": "設置或返回應用程式狀態列中顯示的文字。設置為 False 可恢復預設狀態列文字。",
                "parameters": [
                    {"name": "stringExpression", "description": "要在狀態列中顯示的文字。"},
                    {"name": "False", "description": "清除自訂狀態列文字並恢復預設顯示。"}
                ],
                "examples": [
                    {"code": "Sub ShowProgressInStatusBar()\n  Dim i As Long\n  Application.ScreenUpdating = False\n  For i = 1 To 100\n    Application.StatusBar = \"正在處理進度: \" & i & \"%\"\n    Application.Wait (Now + TimeValue(\"0:00:01\")) ' 模擬耗時操作\n  Next i\n  Application.StatusBar = False ' 清除狀態列\n  Application.ScreenUpdating = True\n  MsgBox \"處理完成!\"\nEnd Sub", "explanation": "在 Excel 狀態列中顯示宏的執行進度。"}
                ],
                "keywords": ["狀態列", "進度顯示", "excel", "statusbar", "progress", "application object"]
            },
            {
                "name": "Application.FileDialog", "category": "Excel 核心操作", "syntax": "Set fd = Application.FileDialog(msoFileDialogType)",
                "description": "返回一個 FileDialog 物件，該物件代表檔案對話框的一個實例 (例如，開啟、另存新檔、資料夾選擇器)。",
                "parameters": [
                    {"name": "msoFileDialogType", "description": "必需。MsoFileDialogType 常數，指定對話框類型 (msoFileDialogOpen, msoFileDialogSaveAs, msoFileDialogFolderPicker, msoFileDialogFilePicker)。"}
                ],
                "examples": [
                    {"code": "Sub SelectFolderExample()\n  Dim fd As FileDialog\n  Set fd = Application.FileDialog(msoFileDialogFolderPicker)\n  fd.Title = \"請選擇一個資料夾\"\n  If fd.Show = -1 Then ' -1 means a selection was made\n    MsgBox \"您選擇的資料夾是: \" & fd.SelectedItems(1)\n  Else\n    MsgBox \"使用者取消了操作。\"\n  End If\n  Set fd = Nothing\nEnd Sub", "explanation": "顯示資料夾選擇器對話框，並獲取使用者選擇的資料夾路徑。"},
                    {"code": "Sub SelectMultipleFilesExample()\n  Dim fd As FileDialog, fileItem As Variant\n  Set fd = Application.FileDialog(msoFileDialogFilePicker)\n  fd.AllowMultiSelect = True\n  If fd.Show = -1 Then\n    For Each fileItem In fd.SelectedItems\n      Debug.Print fileItem\n    Next fileItem\n  End If\n  Set fd = Nothing\nEnd Sub", "explanation": "顯示檔案選擇器對話框，允許用戶選擇多個檔案並打印其路徑。"}
                ],
                "keywords": ["檔案對話框", "資料夾選擇器", "file dialog", "folder picker", "msofiledialogfolderpicker", "msofiledialogfilepicker", "excel", "word", "powerpoint", "通用"]
            },
            {
                "name": "Application.ActiveCell", "category": "Excel 核心操作",
                "syntax": "Application.ActiveCell",
                "description": "返回一個代表活動視窗中活動儲存格的 Range 物件。如果活動視窗不是工作表，則此屬性失敗。",
                "parameters": [],
                "examples": [
                {"code": "MsgBox Application.ActiveCell.Address", "explanation": "顯示活動儲存格的位址。"},
                {"code": "Application.ActiveCell.Value = \"Current Cell\"", "explanation": "在活動儲存格中寫入文字 \"Current Cell\"。"}
                ],
                "keywords": ["活動儲存格", "當前儲存格", "選定儲存格", "excel", "active cell", "current cell", "selected cell"]
            },
            {
                "name": "Application.ActiveSheet", "category": "Excel 核心操作",
                "syntax": "Application.ActiveSheet",
                "description": "返回一個代表活動活頁簿中或指定視窗/活頁簿中活動工作表的 Object。如果沒有工作表處於活動狀態，則返回 Nothing。",
                "parameters": [],
                "examples": [
                {"code": "MsgBox Application.ActiveSheet.Name", "explanation": "顯示活動工作表的名稱。"},
                {"code": "Application.ActiveSheet.Range(\"A1\").Value = \"Top Left\"", "explanation": "在活動工作表的 A1 儲存格中寫入文字。"}
                ],
                "keywords": ["活動工作表", "當前工作表", "excel", "active sheet", "current sheet"]
            },
            {
                "name": "Application.ActiveWorkbook", "category": "Excel 核心操作",
                "syntax": "Application.ActiveWorkbook",
                "description": "返回一個代表活動視窗中（最上層視窗）活頁簿的 Workbook 物件。如果沒有活頁簿開啟或活動視窗不是活頁簿，則返回 Nothing。",
                "parameters": [],
                "examples": [
                {"code": "MsgBox Application.ActiveWorkbook.Name", "explanation": "顯示活動活頁簿的名稱。"},
                {"code": "Application.ActiveWorkbook.Save", "explanation": "儲存活動活頁簿。"}
                ],
                "keywords": ["活動活頁簿", "當前活頁簿", "excel", "active workbook", "current workbook"]
            },
            {
                "name": "Application.Selection", "category": "Excel 核心操作",
                "syntax": "Application.Selection",
                "description": "返回活動視窗中選取的物件。可以是 Range、Shape、Chart 等。如果選取的是儲存格，則返回 Range 物件。",
                "parameters": [],
                "examples": [
                {"code": "If TypeName(Application.Selection) = \"Range\" Then\n  MsgBox \"選取範圍的位址是: \" & Application.Selection.Address\nElse\n  MsgBox \"目前選取的不是儲存格範圍。\"\nEnd If", "explanation": "檢查選取的物件類型，如果是儲存格範圍，則顯示其位址。"},
                {"code": "If TypeName(Application.Selection) = \"Range\" Then\n  Application.Selection.Font.Bold = True\nEnd If", "explanation": "如果選取的是儲存格範圍，則將其字型設為粗體。"}
                ],
                "keywords": ["選取範圍", "選取物件", "excel", "selection", "selected range", "selected object"]
            },
            {
                "name": "ThisWorkbook", "category": "Excel 核心操作",
                "syntax": "ThisWorkbook",
                "description": "返回一個代表目前執行 VBA 程式碼的活頁簿的 Workbook 物件。",
                "parameters": [],
                "examples": [
                {"code": "MsgBox ThisWorkbook.Name", "explanation": "顯示包含此 VBA 程式碼的活頁簿的名稱。"},
                {"code": "Dim ws As Worksheet\nSet ws = ThisWorkbook.Sheets(1)\nMsgBox \"此活頁簿的第一個工作表是: \" & ws.Name", "explanation": "獲取執行程式碼所在活頁簿的第一個工作表。"}
                ],
                "keywords": ["目前活頁簿", "此活頁簿", "程式碼所在活頁簿", "excel", "current workbook", "this workbook"]
            },
            {
                "name": "Workbooks.Open", "category": "Excel 核心操作",
                "syntax": "Workbooks.Open(Filename, [UpdateLinks], [ReadOnly], [Format], [Password], [WriteResPassword], ...)",
                "description": "開啟一個活頁簿。",
                "parameters": [
                {"name": "Filename", "description": "必需。要開啟的活頁簿的檔案名稱 (可包含完整路徑)。"},
                {"name": "UpdateLinks", "description": "可選。指定如何更新檔案中的連結。"},
                {"name": "ReadOnly", "description": "可選。True 表示以唯讀模式開啟。"}
                ],
                "examples": [
                {"code": "Workbooks.Open \"C:\\MyFiles\\Report.xlsx\"", "explanation": "開啟指定路徑的 Excel 活頁簿。"},
                {"code": "Dim wb As Workbook\nSet wb = Workbooks.Open(Filename:=\"C:\\Data\\Sales.xlsx\", ReadOnly:=True)\nIf Not wb Is Nothing Then MsgBox wb.Name & \" 已唯讀開啟。\"", "explanation": "以唯讀模式開啟活頁簿，並將其指派給物件變數。"}
                ],
                "keywords": ["開啟活頁簿", "開啟檔案", "excel", "open workbook", "open file"]
            },
            {
                "name": "Workbooks.Add", "category": "Excel 核心操作",
                "syntax": "Workbooks.Add([Template])",
                "description": "建立一個新的活頁簿。新活頁簿會成為活動活頁簿。",
                "parameters": [{"name": "Template", "description": "可選。指定用於建立新活頁簿的範本。可以是檔案路徑或內建範本常數。"}],
                "examples": [
                {"code": "Dim newWb As Workbook\nSet newWb = Workbooks.Add\nMsgBox \"已建立新的活頁簿: \" & newWb.Name", "explanation": "建立一個新的空白活頁簿。"},
                {"code": "' Workbooks.Add Template:=\"C:\\Templates\\MyCustomTemplate.xltx\"\n' MsgBox \"已根據範本建立活頁簿。\"", "explanation": "根據指定的範本檔案 (.xltx 或 .xltm) 建立一個新的活頁簿 (註解狀態，需實際範本路徑)。"}
                ],
                "keywords": ["新增活頁簿", "建立活頁簿", "新檔案", "excel", "add workbook", "create workbook", "new file"]
            },
            {
                "name": "Workbook.Save", "category": "Excel 核心操作",
                "syntax": "workbookObject.Save",
                "description": "儲存對指定活頁簿的變更。如果活頁簿之前從未儲存過，則會提示使用者輸入檔案名稱 (除非 DisplayAlerts 為 False)。",
                "parameters": [],
                "examples": [
                {"code": "ThisWorkbook.Save", "explanation": "儲存包含此 VBA 程式碼的活頁簿。"},
                {"code": "Dim wb As Workbook\nSet wb = ActiveWorkbook\nIf wb.Saved = False Then\n  wb.Save\n  MsgBox wb.Name & \" 已儲存。\"\nElse\n  MsgBox wb.Name & \" 無需儲存。\"\nEnd If", "explanation": "檢查活動活頁簿是否已儲存，如果未儲存則儲存它。"}
                ],
                "keywords": ["儲存活頁簿", "保存檔案", "excel", "save workbook", "save file"]
            },
            {
                "name": "Workbook.SaveAs", "category": "Excel 核心操作",
                "syntax": "workbookObject.SaveAs(Filename, [FileFormat], [Password], [WriteResPassword], ...)",
                "description": "將活頁簿以不同的名稱或格式儲存。",
                "parameters": [
                {"name": "Filename", "description": "必需。新檔案的名稱 (可包含路徑)。"},
                {"name": "FileFormat", "description": "可選。檔案格式，例如 xlOpenXMLWorkbook (xlsx), xlOpenXMLWorkbookMacroEnabled (xlsm), xlExcel8 (xls)。"}
                ],
                "examples": [
                {"code": "ThisWorkbook.SaveAs Filename:=\"C:\\Backup\\MyReport_Backup.xlsx\"", "explanation": "將目前活頁簿另存為指定路徑和名稱的 .xlsx 檔案。"},
                {"code": "ActiveWorkbook.SaveAs Filename:=\"Report.xlsm\", FileFormat:=xlOpenXMLWorkbookMacroEnabled", "explanation": "將活動活頁簿另存為啟用巨集的活頁簿 (.xlsm)。"}
                ],
                "keywords": ["另存新檔", "儲存為", "excel", "save as", "save workbook as"]
            },
            {
                "name": "Workbook.Close", "category": "Excel 核心操作",
                "syntax": "workbookObject.Close([SaveChanges], [Filename], [RouteWorkbook])",
                "description": "關閉指定的活頁簿。",
                "parameters": [
                {"name": "SaveChanges", "description": "可選。True 表示儲存變更，False 表示不儲存變更，省略則提示使用者。"},
                {"name": "Filename", "description": "可選。如果 SaveChanges 為 True 且活頁簿尚未儲存，則以此名稱儲存。"}
                ],
                "examples": [
                {"code": "' 假設 wb 是一個 Workbook 物件\n' wb.Close SaveChanges:=True ' 儲存並關閉\n' wb.Close SaveChanges:=False ' 不儲存直接關閉", "explanation": "關閉活頁簿，可選擇是否儲存變更。"},
                {"code": "If Workbooks.Count > 1 Then\n  ActiveWorkbook.Close SaveChanges:=False\nElse\n  MsgBox \"無法關閉最後一個開啟的活頁簿。\"\nEnd If", "explanation": "如果開啟的活頁簿超過一個，則不儲存變更並關閉活動活頁簿。"}
                ],
                "keywords": ["關閉活頁簿", "關閉檔案", "excel", "close workbook", "close file"]
            },
            {
                "name": "Worksheet.Activate", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Activate",
                "description": "將指定的工作表設為活動工作表。",
                "parameters": [],
                "examples": [
                {"code": "ThisWorkbook.Sheets(\"Sheet1\").Activate", "explanation": "啟用目前活頁簿中名為 \"Sheet1\" 的工作表。"},
                {"code": "Dim ws As Worksheet\nSet ws = Workbooks(\"Data.xlsx\").Sheets(2)\nws.Activate\nMsgBox ActiveSheet.Name & \" 已被啟用。\"", "explanation": "啟用 \"Data.xlsx\" 活頁簿中的第二個工作表。"}
                ],
                "keywords": ["啟用工作表", "切換工作表", "excel", "activate sheet", "select sheet"]
            },
            {
                "name": "Worksheet.Name", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Name [= string]",
                "description": "讀取或設定工作表的名稱。",
                "parameters": [{"name": "string", "description": "可選。要設定的工作表新名稱。"}],
                "examples": [
                {"code": "MsgBox ThisWorkbook.Sheets(1).Name", "explanation": "顯示第一個工作表的名稱。"},
                {"code": "On Error Resume Next ' 避免名稱重複或無效名稱錯誤\nThisWorkbook.Sheets(1).Name = \"Summary Report\"\nIf Err.Number <> 0 Then MsgBox \"無法更改工作表名稱: \" & Err.Description\nOn Error GoTo 0", "explanation": "將第一個工作表的名稱更改為 \"Summary Report\"，並進行錯誤處理。"}
                ],
                "keywords": ["工作表名稱", "命名工作表", "excel", "sheet name", "rename sheet"]
            },
            {
                "name": "Range.Value", "category": "Excel 核心操作",
                "syntax": "rangeObject.Value [= value]",
                "description": "讀取或設定儲存格範圍的值。對於包含多個儲存格的範圍，它會返回一個包含這些儲存格值的二維陣列；設定值時，如果提供的是陣列，則會將陣列中的值填入對應的儲存格。",
                "parameters": [{"name": "value", "description": "可選。要設定到儲存格的值或陣列。"}],
                "examples": [
                {"code": "Dim cellValue As Variant\ncellValue = Range(\"A1\").Value\nMsgBox \"A1 的值是: \" & cellValue", "explanation": "讀取儲存格 A1 的值。"},
                {"code": "Range(\"B1\").Value = \"Hello Excel\"", "explanation": "在儲存格 B1 中寫入文字 \"Hello Excel\"。"},
                {"code": "Dim dataArray(1 To 2, 1 To 2) As Variant\ndataArray(1, 1) = \"ID\"\ndataArray(1, 2) = \"Name\"\ndataArray(2, 1) = 101\ndataArray(2, 2) = \"Alice\"\nRange(\"D1:E2\").Value = dataArray", "explanation": "將一個二維陣列的值寫入 D1:E2 範圍。"}
                ],
                "keywords": ["儲存格值", "讀取值", "寫入值", "範圍值", "excel", "cell value", "read value", "write value", "range value"]
            },
            {
                "name": "Range.Formula", "category": "Excel 核心操作",
                "syntax": "rangeObject.Formula [= string]",
                "description": "讀取或設定儲存格的公式 (A1 參照樣式)。",
                "parameters": [{"name": "string", "description": "可選。要設定的公式字串。"}],
                "examples": [
                {"code": "Range(\"C1\").Formula = \"=A1+B1\"", "explanation": "在 C1 儲存格中設定公式 =A1+B1。"},
                {"code": "Dim formulaStr As String\nformulaStr = Range(\"C1\").Formula\nMsgBox \"C1 的公式是: \" & formulaStr", "explanation": "讀取 C1 儲存格的公式。"}
                ],
                "keywords": ["公式", "設定公式", "讀取公式", "excel", "formula", "set formula", "get formula"]
            },
            {
                "name": "Range.Select", "category": "Excel 核心操作",
                "syntax": "rangeObject.Select",
                "description": "選取指定的儲存格範圍。選取後，該範圍即成為 Application.Selection。",
                "parameters": [],
                "examples": [
                {"code": "Range(\"A1:B5\").Select", "explanation": "選取儲存格範圍 A1:B5。"},
                {"code": "ThisWorkbook.Sheets(\"Sheet2\").Range(\"C3\").Select", "explanation": "啟用 Sheet2 並選取 C3 儲存格。"}
                ],
                "keywords": ["選取儲存格", "選取範圍", "excel", "select range", "select cells"]
            },
            {
                "name": "Range.ClearContents", "category": "Excel 核心操作",
                "syntax": "rangeObject.ClearContents",
                "description": "清除儲存格範圍的內容 (值和公式)，但保留格式。",
                "parameters": [],
                "examples": [
                {"code": "Range(\"A1:D10\").ClearContents", "explanation": "清除範圍 A1:D10 中所有儲存格的內容。"},
                {"code": "ActiveSheet.UsedRange.Offset(1, 0).ClearContents", "explanation": "清除活動工作表已使用範圍中，除第一行標題外的所有資料內容。"}
                ],
                "keywords": ["清除內容", "刪除值", "清空儲存格", "excel", "clear contents", "delete values", "empty cells"]
            },
            {
                "name": "Range.Copy", "category": "Excel 核心操作",
                "syntax": "rangeObject.Copy([Destination])",
                "description": "將指定的儲存格範圍複製到剪貼簿或指定的目標位置。",
                "parameters": [{"name": "Destination", "description": "可選。一個 Range 物件，指定複製內容要貼上的新範圍。如果省略，則複製到剪貼簿。"}],
                "examples": [
                {"code": "Range(\"A1:B2\").Copy", "explanation": "將範圍 A1:B2 複製到剪貼簿。"},
                {"code": "Range(\"A1:A5\").Copy Destination:=Range(\"C1\")", "explanation": "將範圍 A1:A5 複製並貼到以 C1 為起始的儲存格。"}
                ],
                "keywords": ["複製儲存格", "複製範圍", "excel", "copy range", "copy cells"]
            },
            {
                "name": "Range.PasteSpecial", "category": "Excel 核心操作",
                "syntax": "rangeObject.PasteSpecial([Paste], [Operation], [SkipBlanks], [Transpose])",
                "description": "將剪貼簿中的 Range 物件貼到指定的範圍，可選擇性地指定貼上類型、運算等。",
                "parameters": [
                {"name": "Paste", "description": "可選。要貼上的部分，例如 xlPasteValues, xlPasteFormulas, xlPasteFormats。"},
                {"name": "Operation", "description": "可選。貼上時執行的運算，例如 xlNone, xlAdd, xlMultiply。"},
                {"name": "SkipBlanks", "description": "可選。True 表示跳過剪貼簿範圍中的空白儲存格。"},
                {"name": "Transpose", "description": "可選。True 表示貼上時轉置行和列。"}
                ],
                "examples": [
                {"code": "Range(\"A1\").Copy\nRange(\"B1\").PasteSpecial Paste:=xlPasteValues", "explanation": "複製 A1 儲存格，然後將其值貼到 B1 儲存格。"},
                {"code": "Range(\"C1:C5\").Copy\nRange(\"D1\").PasteSpecial Paste:=xlPasteAll, Transpose:=True", "explanation": "複製 C1:C5 (垂直範圍)，然後轉置貼到以 D1 開始的水平範圍。"}
                ],
                "keywords": ["選擇性貼上", "貼上值", "轉置", "excel", "paste special", "paste values", "transpose"]
            },
            {
                "name": "Cells", "category": "Excel 核心操作",
                "syntax": "object.Cells(RowIndex, ColumnIndex) 或 object.Cells(CellIndex)",
                "description": "返回代表工作表中所有儲存格的 Range 物件 (如果沒有參數)，或者返回代表特定儲存格的 Range 物件。object 可以是 Application, Worksheet, 或 Range。",
                "parameters": [
                {"name": "RowIndex", "description": "可選。儲存格的列號。"},
                {"name": "ColumnIndex", "description": "可選。儲存格的欄號 (數字或字母)。"},
                {"name": "CellIndex", "description": "可選。單一儲存格索引號。"}
                ],
                "examples": [
                {"code": "ActiveSheet.Cells(1, 1).Value = \"Row 1, Col 1\"", "explanation": "在活動工作表的第一行第一列儲存格 (A1) 寫入值。"},
                {"code": "MsgBox Range(\"A1:C5\").Cells(2, 3).Address ' Returns $C$2 (relative to A1:C5)", "explanation": "獲取範圍 A1:C5 中，相對第二行第三欄的儲存格 (即 C2) 的位址。"},
                {"code": "For i = 1 To 10\n  Cells(i, \"A\").Value = i * 10\nNext i", "explanation": "在當前活動工作表的 A1 到 A10 儲存格寫入 10, 20, ..., 100。"}
                ],
                "keywords": ["儲存格", "單元格", "行列", "excel", "cell", "row", "column", "individual cell"]
            },
            {
                "name": "Range (Property/Method)", "category": "Excel 核心操作",
                "syntax": "object.Range(Cell1, [Cell2]) 或 object.Range(Name)",
                "description": "返回一個代表儲存格或儲存格範圍的 Range 物件。object 可以是 Application, Worksheet, 或 Range。",
                "parameters": [
                {"name": "Cell1", "description": "必需。範圍的名稱 (A1 樣式字串) 或 Range 物件。"},
                {"name": "Cell2", "description": "可選。如果提供，則表示範圍的左上角和右下角。"}
                ],
                "examples": [
                {"code": "Dim myRange As Range\nSet myRange = ActiveSheet.Range(\"A1:C3\")\nmyRange.Font.Italic = True", "explanation": "獲取活動工作表上的 A1:C3 範圍，並將其字型設為斜體。"},
                {"code": "Set myRange = Range(Cells(1, 1), Cells(5, 3)) ' 等同於 Range(\"A1:C5\")\nmyRange.Interior.Color = RGB(255, 255, 0)", "explanation": "使用 Cells 屬性定義範圍的起始和結束儲存格，然後設定背景色。"},
                {"code": "Worksheets(\"Data\").Range(\"SalesData\").ClearContents ' 假設 SalesData 是一個已命名的範圍", "explanation": "清除名為 \"SalesData\" 的已命名範圍的內容。"}
                ],
                "keywords": ["範圍", "儲存格範圍", "選取區域", "excel", "range object", "cell range", "selection area"]
            },
            {
                "name": "Worksheets", "category": "Excel 核心操作",
                "syntax": "Worksheets([IndexOrName])",
                "description": "從 Worksheets 集合傳回單一 Worksheet 物件，如果未使用引數，則傳回整個 Worksheets 集合。Worksheets 集合包含活頁簿中的所有 Worksheet 物件。",
                "parameters": [
                {"name": "IndexOrName", "description": "可選。工作表的名稱 (字串) 或索引編號 (整數)。如果省略，則傳回整個集合。"}
                ],
                "examples": [
                {"code": "Dim ws As Worksheet\nSet ws = ThisWorkbook.Worksheets(1)\nMsgBox \"First worksheet name: \" & ws.Name", "explanation": "依索引存取目前活頁簿中的第一個工作表。"},
                {"code": "Dim reportSheet As Worksheet\nSet reportSheet = ThisWorkbook.Worksheets(\"SalesReport\")\nreportSheet.Activate", "explanation": "存取名為 \"SalesReport\" 的工作表並將其啟用。"},
                {"code": "Dim i As Integer\nFor i = 1 To ThisWorkbook.Worksheets.Count\n  Debug.Print ThisWorkbook.Worksheets(i).Name\nNext i", "explanation": "迭代目前活頁簿中的所有工作表並列印其名稱。"}
                ],
                "keywords": ["worksheets collection", "get worksheet", "access sheet", "工作表集合", "獲取工作表", "excel", "sheets"]
            },
            {
                "name": "Worksheets.Count", "category": "Excel 核心操作",
                "syntax": "Worksheets.Count",
                "description": "傳回一個 Long 值，表示集合 (活頁簿) 中的工作表數量。唯讀。",
                "parameters": [],
                "examples": [
                {"code": "MsgBox \"This workbook has \" & ThisWorkbook.Worksheets.Count & \" worksheets.\"", "explanation": "顯示目前活頁簿中的工作表總數。"}
                ],
                "keywords": ["worksheet count", "number of sheets", "sheet quantity", "工作表數量", "工作表個數", "excel"]
            },
            {
                "name": "Worksheets.Add", "category": "Excel 核心操作",
                "syntax": "Worksheets.Add([Before], [After], [Count], [Type]) As Worksheet",
                "description": "建立一個新的工作表。新工作表會成為活動工作表。",
                "parameters": [
                {"name": "Before", "description": "可選。一個物件，指定新工作表新增於其前的工作表。"},
                {"name": "After", "description": "可選。一個物件，指定新工作表新增於其後的工作表。"},
                {"name": "Count", "description": "可選。要新增的工作表數量。預設為一。"},
                {"name": "Type", "description": "可選。要新增的工作表類型 (例如，xlWorksheet, xlChart)。"}
                ],
                "examples": [
                {"code": "Dim newWs As Worksheet\nSet newWs = ThisWorkbook.Worksheets.Add\nnewWs.Name = \"NewSheet_\" & Format(Now, \"yyyymmdd_hhmmss\")", "explanation": "新增一個新工作表 (成為活動工作表) 並以時間戳命名。"},
                {"code": "Dim ws As Worksheet\nSet ws = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))\nws.Name = \"Last Sheet\"", "explanation": "在最後一個現有工作表之後新增一個新工作表，並將其命名為 \"Last Sheet\"。"}
                ],
                "keywords": ["add worksheet", "new sheet", "create sheet", "新增工作表", "建立工作表", "excel"]
            },
            {
                "name": "Worksheet.Delete", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Delete",
                "description": "刪除指定的工作表。預設情況下，Excel 會顯示一個對話框要求確認。設定 Application.DisplayAlerts = False 以抑制它。",
                "parameters": [],
                "examples": [
                {"code": "Application.DisplayAlerts = False\nOn Error Resume Next ' In case sheet doesn't exist or is last visible sheet\nThisWorkbook.Worksheets(\"SheetToDelete\").Delete\nIf Err.Number <> 0 Then MsgBox \"Sheet 'SheetToDelete' not found or cannot be deleted.\"\nOn Error GoTo 0\nApplication.DisplayAlerts = True", "explanation": "刪除名為 \"SheetToDelete\" 的工作表，而不顯示確認提示。"}
                ],
                "keywords": ["delete worksheet", "remove sheet", "刪除工作表", "移除工作表", "excel"]
            },
            {
                "name": "Worksheet.Copy", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Copy([Before], [After])",
                "description": "將工作表複製到活頁簿中的其他位置或新的活頁簿。",
                "parameters": [
                {"name": "Before", "description": "可選。複製的工作表將放置於其前的工作表。不能同時指定 Before 和 After。"},
                {"name": "After", "description": "可選。複製的工作表將放置於其後的工作表。不能同時指定 Before 和 After。如果省略，則會建立一個新的活頁簿。"}
                ],
                "examples": [
                {"code": "ThisWorkbook.Worksheets(\"Sheet1\").Copy After:=ThisWorkbook.Worksheets(\"Sheet1\")\nActiveSheet.Name = \"Sheet1_Copy\"", "explanation": "複製 \"Sheet1\" 並將副本緊接在原始 \"Sheet1\" 之後，然後重命名副本。"},
                {"code": "' ThisWorkbook.Worksheets(\"Data\").Copy ' Copies \"Data\" sheet to a new workbook.", "explanation": "將 \"Data\" 工作表複製到一個新的獨立活頁簿 (這個新活頁簿會成為活動活頁簿)。"}
                ],
                "keywords": ["copy worksheet", "duplicate sheet", "複製工作表", "excel"]
            },
            {
                "name": "Worksheet.Move", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Move([Before], [After])",
                "description": "將工作表移動到活頁簿中的其他位置或其他 (已開啟或新的) 活頁簿。",
                "parameters": [
                {"name": "Before", "description": "可選。移動的工作表將放置於其前的工作表。"},
                {"name": "After", "description": "可選。移動的工作表將放置於其後的工作表。如果省略，則會為移動的工作表建立一個新的活頁簿。"}
                ],
                "examples": [
                {"code": "ThisWorkbook.Worksheets(\"Sheet3\").Move Before:=ThisWorkbook.Worksheets(1)", "explanation": "將 \"Sheet3\" 移動成為活頁簿中的第一個工作表。"},
                {"code": "' ThisWorkbook.Worksheets(\"ArchiveData\").Move ' Moves \"ArchiveData\" to a new workbook.", "explanation": "將 \"ArchiveData\" 工作表移動到一個新的獨立活頁簿。"}
                ],
                "keywords": ["move worksheet", "reorder sheet", "移動工作表", "排序工作表", "excel"]
            },
            {
                "name": "Worksheet.Visible", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Visible [= xlSheetVisibility]",
                "description": "判斷物件是否可見。可以是 xlSheetVisible、xlSheetHidden 或 xlSheetVeryHidden。",
                "parameters": [
                {"name": "xlSheetVisibility", "description": "一個常數：xlSheetVisible (可見)、xlSheetHidden (隱藏，使用者可以取消隱藏)、xlSheetVeryHidden (隱藏，使用者無法從 UI 取消隱藏)。"}
                ],
                "examples": [
                {"code": "ThisWorkbook.Worksheets(\"AdminSheet\").Visible = xlSheetVeryHidden", "explanation": "將 \"AdminSheet\" 設為非常隱藏，表示無法透過 Excel 使用者介面取消隱藏。"},
                {"code": "ThisWorkbook.Worksheets(\"TempSheet\").Visible = xlSheetHidden", "explanation": "隱藏 \"TempSheet\"。使用者可以取消隱藏它。"},
                {"code": "If ThisWorkbook.Worksheets(\"Report\").Visible = xlSheetVisible Then\n MsgBox \"Report sheet is visible.\"\nEnd If", "explanation": "檢查 \"Report\" 工作表是否可見。"}
                ],
                "keywords": ["hide worksheet", "unhide worksheet", "sheet visibility", "隱藏工作表", "顯示工作表", "工作表可見性", "excel", "xlSheetHidden", "xlSheetVeryHidden"]
            },
            {
                "name": "Worksheet.Protect", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Protect([Password], [DrawingObjects], [Contents], [Scenarios], [UserInterfaceOnly], ...)",
                "description": "保護工作表，使其無法修改。許多可選引數允許對保護內容進行精細控制。",
                "parameters": [
                {"name": "Password", "description": "可選。一個字串，指定工作表的區分大小寫密碼。"},
                {"name": "Contents", "description": "可選。True (預設) 以保護儲存格內容。"},
                {"name": "DrawingObjects", "description": "可選。True 以保護圖案。"}
                ],
                "examples": [
                {"code": "ThisWorkbook.Worksheets(\"Sheet1\").Protect Password:=\"mypassword\"", "explanation": "使用密碼保護 \"Sheet1\"，防止儲存格內容變更 (預設)。"},
                {"code": "ActiveSheet.Protect DrawingObjects:=True, Contents:=True, Scenarios:=True, UserInterfaceOnly:=True, AllowFormattingCells:=False", "explanation": "保護活動工作表，允許 VBA 進行變更 (UserInterfaceOnly:=True)，但不允許使用者格式化儲存格。"}
                ],
                "keywords": ["protect worksheet", "lock sheet", "保護工作表", "鎖定工作表", "excel", "password protect"]
            },
            {
                "name": "Worksheet.Unprotect", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Unprotect([Password])",
                "description": "移除工作表的保護。如果工作表未受保護，此方法無效。",
                "parameters": [
                {"name": "Password", "description": "可選。一個字串，指定取消保護工作表的密碼。如果工作表受密碼保護，則為必需。"}
                ],
                "examples": [
                {"code": "On Error Resume Next ' If sheet is not protected or password is wrong\nThisWorkbook.Worksheets(\"Sheet1\").Unprotect Password:=\"mypassword\"\nIf Err.Number <> 0 Then MsgBox \"Failed to unprotect sheet. Check password or protection status.\"\nOn Error GoTo 0", "explanation": "使用指定的密碼取消保護 \"Sheet1\"。"}
                ],
                "keywords": ["unprotect worksheet", "unlock sheet", "取消保護工作表", "解除鎖定工作表", "excel"]
            },
            {
                "name": "Worksheet.UsedRange", "category": "Excel 核心操作",
                "syntax": "worksheetObject.UsedRange",
                "description": "傳回一個 Range 物件，代表指定工作表上的已使用範圍。這是包含任何曾包含值或格式之儲存格的最小範圍。",
                "parameters": [],
                "examples": [
                {"code": "Dim ur As Range\nSet ur = ActiveSheet.UsedRange\nMsgBox \"Used range is: \" & ur.Address", "explanation": "取得活動工作表上已使用範圍的位址。"},
                {"code": "ActiveSheet.UsedRange.Font.Color = vbRed", "explanation": "將已使用範圍中所有儲存格的字型顏色變更為紅色。"}
                ],
                "keywords": ["used range", "data range", "已使用範圍", "資料範圍", "excel"]
            },
            {
                "name": "Worksheet.Rows", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Rows([IndexOrName])",
                "description": "傳回一個 Range 物件，代表指定工作表上的所有列，如果提供 Index，則代表特定列。",
                "parameters": [
                {"name": "IndexOrName", "description": "可選。列號 (整數) 或可轉換為列號的字串 (例如，\"1:3\" 代表第 1 到 3 列)。"}
                ],
                "examples": [
                {"code": "MsgBox \"Total rows in sheet: \" & ActiveSheet.Rows.Count", "explanation": "顯示活動工作表中的總列數 (現代 Excel 通常為 1048576)。"},
                {"code": "ActiveSheet.Rows(1).Font.Bold = True", "explanation": "將活動工作表的第一整列設為粗體。"},
                {"code": "ActiveSheet.Rows(\"3:5\").Interior.Color = RGB(200, 200, 255)", "explanation": "變更第 3 到 5 列的背景顏色。"}
                ],
                "keywords": ["rows", "worksheet rows", "access rows", "列", "工作表列", "excel"]
            },
            {
                "name": "Worksheet.Columns", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Columns([IndexOrName])",
                "description": "傳回一個 Range 物件，代表指定工作表上的所有欄，如果提供 Index，則代表特定欄。",
                "parameters": [
                {"name": "IndexOrName", "description": "可選。欄號 (整數，例如 1 代表 A，2 代表 B) 或欄字母 (字串，例如 \"A\", \"B:D\")。"}
                ],
                "examples": [
                {"code": "MsgBox \"Total columns in sheet: \" & ActiveSheet.Columns.Count", "explanation": "顯示活動工作表中的總欄數 (現代 Excel 通常為 16384)。"},
                {"code": "ActiveSheet.Columns(\"A\").Font.Bold = True", "explanation": "將活動工作表的整個 A 欄設為粗體。"},
                {"code": "ActiveSheet.Columns(3).EntireColumn.AutoFit", "explanation": "自動調整第三欄 (C 欄) 的寬度。"}
                ],
                "keywords": ["columns", "worksheet columns", "access columns", "欄", "工作表欄", "excel"]
            },
            {
                "name": "Worksheet.Calculate", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Calculate",
                "description": "計算所有開啟的活頁簿、活頁簿中的特定工作表，或工作表上的指定儲存格範圍。",
                "parameters": [],
                "examples": [
                {"code": "Application.Calculation = xlCalculationManual\n' ... make changes ...\nThisWorkbook.Worksheets(\"Sheet1\").Calculate\nMsgBox \"Sheet1 has been recalculated.\"\nApplication.Calculation = xlCalculationAutomatic", "explanation": "如果計算設為手動，則此程式碼會強制重新計算 \"Sheet1\"。"}
                ],
                "keywords": ["calculate worksheet", "recalculate", "formula calculation", "計算工作表", "重新計算", "excel"]
            },
            {
                "name": "Worksheet.CodeName", "category": "Excel 核心操作",
                "syntax": "worksheetObject.CodeName",
                "description": "傳回物件的程式碼名稱。程式碼名稱是 VBA 專案總管中顯示的名稱 (例如，Sheet1)，使用者無法透過 Excel UI 變更。執行階段唯讀。",
                "parameters": [],
                "examples": [
                {"code": "MsgBox \"The code name for the active sheet is: \" & ActiveSheet.CodeName", "explanation": "顯示活動工作表的 VBA 程式碼名稱。"},
                {"code": "Dim ws As Worksheet\nFor Each ws In ThisWorkbook.Worksheets\n  If ws.CodeName = \"Sheet1\" Then\n    ws.Range(\"A1\").Value = \"Found by CodeName\"\n    Exit For\n  End If\nNext ws", "explanation": "依其 CodeName (如果使用者可以重命名工作表，則此名稱比顯示名稱更可靠) 尋找工作表，並寫入 A1。"}
                ],
                "keywords": ["codename", "vba name", "sheet object name", "程式碼名稱", "VBA物件名稱", "excel"]
            },
            {
                "name": "Worksheet.Index", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Index",
                "description": "傳回一個 Long 值，代表物件在相似物件集合中的索引編號 (例如，工作表在 Worksheets 集合中的位置)。唯讀。",
                "parameters": [],
                "examples": [
                {"code": "MsgBox \"The active sheet is sheet number: \" & ActiveSheet.Index", "explanation": "顯示活動工作表在所有工作表中的索引 (位置)。"},
                {"code": "Dim ws As Worksheet\nFor Each ws In ThisWorkbook.Worksheets\n    Debug.Print \"Sheet Name: \" & ws.Name & \", Index: \" & ws.Index\nNext ws", "explanation": "迴圈遍歷所有工作表並列印其名稱和索引編號。"}
                ],
                "keywords": ["sheet index", "worksheet position", "工作表索引", "工作表位置", "excel"]
            },
            {
                "name": "Worksheet.Next", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Next",
                "description": "傳回一個 Worksheet 物件，代表活頁簿中的下一個工作表。如果沒有下一個工作表，則傳回 Nothing。唯讀。",
                "parameters": [],
                "examples": [
                {"code": "Dim nextSheet As Worksheet\nSet nextSheet = ActiveSheet.Next\nIf Not nextSheet Is Nothing Then\n  nextSheet.Activate\nElse\n  MsgBox \"This is the last sheet.\"\nEnd If", "explanation": "如果存在下一個工作表，則啟用它。"}
                ],
                "keywords": ["next sheet", "following sheet", "下一個工作表", "excel"]
            },
            {
                "name": "Worksheet.Previous", "category": "Excel 核心操作",
                "syntax": "worksheetObject.Previous",
                "description": "傳回一個 Worksheet 物件，代表活頁簿中的上一個工作表。如果沒有上一個工作表，則傳回 Nothing。唯讀。",
                "parameters": [],
                "examples": [
                {"code": "Dim prevSheet As Worksheet\nSet prevSheet = ActiveSheet.Previous\nIf Not prevSheet Is Nothing Then\n  prevSheet.Activate\nElse\n  MsgBox \"This is the first sheet.\"\nEnd If", "explanation": "如果存在上一個工作表，則啟用它。"}
                ],
                "keywords": ["previous sheet", "preceding sheet", "上一個工作表", "excel"]
            },
            {
                "name": "Worksheet.PageSetup", "category": "Excel 核心操作",
                "syntax": "worksheetObject.PageSetup",
                "description": "傳回一個 PageSetup 物件，其中包含指定工作表的所有頁面設定。",
                "parameters": [],
                "examples": [
                {"code": "With ActiveSheet.PageSetup\n  .Orientation = xlLandscape\n  .Zoom = False\n  .FitToPagesWide = 1\n  .FitToPagesTall = 1\n  .PrintArea = \"A1:G50\"\nEnd With\nMsgBox \"Page setup for \" & ActiveSheet.Name & \" has been modified.\"", "explanation": "修改活動工作表的數個頁面設定屬性，例如方向、符合頁面大小和列印範圍。"}
                ],
                "keywords": ["page setup", "print settings", "orientation", "margins", "print area", "頁面設定", "列印設定", "excel"]
            },

            // --- Outlook 郵件與項目管理 (Outlook Mail & Item Management) ---
            {
                "name": "Outlook.Application (CreateObject/GetObject)", "category": "Outlook 郵件與項目管理",
                "syntax": "Set olApp = CreateObject(\"Outlook.Application\") \n' or (less common for starting Outlook, good for checking if running)\nSet olApp = GetObject(, \"Outlook.Application\")",
                "description": "建立 Microsoft Outlook 的新執行個體，或取得對已執行執行個體的參照。與 Word/Excel 不同，Outlook 通常是單一執行個體應用程式，因此 GetObject 較常用於連接到現有會話。",
                "parameters": [],
                "examples": [
                {"code": "Dim olApp As Object\nOn Error Resume Next\nSet olApp = GetObject(, \"Outlook.Application\")\nIf olApp Is Nothing Then\n  Set olApp = CreateObject(\"Outlook.Application\")\n  MsgBox \"已建立新的 Outlook 執行個體參照 (或 Outlook 已啟動)。\"\nElse\n  MsgBox \"已擷取現有的 Outlook 執行個體參照。\"\nEnd If\n' Outlook Application 物件沒有像 Word/Excel 那樣的 Visible 屬性。\n' Outlook 通常自行管理其可見性。\n' 完成後記得 Set olApp = Nothing。", "explanation": "嘗試取得現有的 Outlook 會話；如果沒有或無法存取，則建立新的參照 (如果 Outlook 未執行，則可能會啟動它)。"}
                ],
                "keywords": ["outlook application", "create outlook", "get outlook", "open outlook", "outlook automation", "outlook", "Outlook物件"]
            },
            {
                "name": "Outlook.CreateItem", "category": "Outlook 郵件與項目管理",
                "syntax": "Set olItem = olApp.CreateItem(ItemType As OlItemType)",
                "description": "建立並傳回新的 Microsoft Outlook 項目。",
                "parameters": [
                {"name": "ItemType", "description": "必需。一個 OlItemType 常數，指定要建立的 Outlook 項目類型 (例如，olMailItem, olAppointmentItem, olContactItem, olTaskItem)。"}
                ],
                "examples": [
                {"code": "Dim olApp As Object, olMail As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olMail = olApp.CreateItem(0) ' 0 is olMailItem\nolMail.Subject = \"Test Email from VBA\"\nolMail.Body = \"This is the body of the test email.\"\nolMail.To = \"recipient@example.com\"\n' olMail.Display ' To show the email before sending\n' olMail.Send   ' To send directly\nMsgBox \"Email item created. Subject: \" & olMail.Subject", "explanation": "建立一個新的電子郵件項目，設定其主旨、內文和收件者。"}
                ],
                "keywords": ["outlook create item", "new email outlook", "new appointment outlook", "new contact outlook", "new task outlook", "outlook", "olMailItem", "olAppointmentItem", "建立項目"]
            },
            {
                "name": "MailItem.To", "category": "Outlook 郵件與項目管理",
                "syntax": "olMail.To [= String]",
                "description": "設定或傳回 Outlook 項目的 [收件者] 顯示名稱的分號分隔字串清單。",
                "parameters": [{"name": "String", "description": "[收件者] 收件者的電子郵件地址。多個地址以分號分隔。"}],
                "examples": [
                {"code": "Dim olMail As Object ' Assume olMail is a MailItem object\n' Set olMail = olApp.CreateItem(olMailItem)\nolMail.To = \"user1@example.com; user2@example.com\"", "explanation": "將電子郵件的「收件者」欄位設定為兩個收件者。"}
                ],
                "keywords": ["outlook to recipient", "email to field", "set recipient", "outlook", "收件者"]
            },
            {
                "name": "MailItem.CC", "category": "Outlook 郵件與項目管理",
                "syntax": "olMail.CC [= String]",
                "description": "設定或傳回 Outlook 項目的 [副本 (CC)] 收件者顯示名稱的分號分隔字串清單。",
                "parameters": [{"name": "String", "description": "[副本] 收件者的電子郵件地址。"}],
                "examples": [
                {"code": "Dim olMail As Object ' Assume olMail is a MailItem object\nolMail.CC = \"manager@example.com\"", "explanation": "設定電子郵件的「副本」欄位。"}
                ],
                "keywords": ["outlook cc recipient", "email cc field", "carbon copy", "outlook", "副本收件者"]
            },
            {
                "name": "MailItem.BCC", "category": "Outlook 郵件與項目管理",
                "syntax": "olMail.BCC [= String]",
                "description": "設定或傳回 Outlook 項目的 [密件副本 (BCC)] 收件者顯示名稱的分號分隔字串清單。",
                "parameters": [{"name": "String", "description": "[密件副本] 收件者的電子郵件地址。"}],
                "examples": [
                {"code": "Dim olMail As Object ' Assume olMail is a MailItem object\nolMail.BCC = \"supervisor@example.com\"", "explanation": "設定電子郵件的「密件副本」欄位。"}
                ],
                "keywords": ["outlook bcc recipient", "email bcc field", "blind carbon copy", "outlook", "密件副本收件者"]
            },
            {
                "name": "MailItem.Subject", "category": "Outlook 郵件與項目管理",
                "syntax": "olMail.Subject [= String]",
                "description": "設定或傳回一個字串，指出 Outlook 項目的主旨。",
                "parameters": [{"name": "String", "description": "主旨文字。"}],
                "examples": [
                {"code": "Dim olMail As Object ' Assume olMail is a MailItem object\nolMail.Subject = \"Important Update - Action Required\"", "explanation": "設定電子郵件的主旨行。"}
                ],
                "keywords": ["outlook email subject", "set subject", "outlook", "郵件主旨"]
            },
            {
                "name": "MailItem.Body", "category": "Outlook 郵件與項目管理",
                "syntax": "olMail.Body [= String]",
                "description": "設定或傳回一個字串，代表 Outlook 項目的純文字內文。對於 HTML 格式的電子郵件，請使用 .HTMLBody。",
                "parameters": [{"name": "String", "description": "電子郵件內文的純文字內容。"}],
                "examples": [
                {"code": "Dim olMail As Object ' Assume olMail is a MailItem object\nolMail.Body = \"Dear Team,\\n\\nPlease find the attached report.\\n\\nBest regards,\\nYour Name\"", "explanation": "設定電子郵件的純文字內文，包括換行符號 (在 VBA 中 vbCrLf 較安全，視情況而定，\\n 可能也適用)。"}
                ],
                "keywords": ["outlook email body", "set body text", "plain text email", "outlook", "郵件內文"]
            },
            {
                "name": "MailItem.HTMLBody", "category": "Outlook 郵件與項目管理",
                "syntax": "olMail.HTMLBody [= String]",
                "description": "設定或傳回一個字串，代表指定項目的 HTML 內文。設定 HTMLBody 會覆寫 Body。",
                "parameters": [{"name": "String", "description": "電子郵件內文的 HTML 內容。"}],
                "examples": [
                {"code": "Dim olMail As Object ' Assume olMail is a MailItem object\nolMail.HTMLBody = \"<h1>Report</h1><p>Please see the <font color='red'><b>attached</b></font> report.</p>\" & _\n                  \"<p><a href='http://www.example.com'>Visit our website</a></p>\"", "explanation": "使用 HTML 格式設定電子郵件的內文。"}
                ],
                "keywords": ["outlook html email", "set html body", "formatted email", "outlook", "HTML郵件內文"]
            },
            {
                "name": "MailItem.Attachments.Add", "category": "Outlook 郵件與項目管理",
                "syntax": "olMail.Attachments.Add(Source, [Type], [Position], [DisplayName]) As Attachment",
                "description": "將附件新增至 Outlook 項目。",
                "parameters": [
                {"name": "Source", "description": "必需。附件的檔案路徑，或構成附件的 Outlook 項目。"},
                {"name": "DisplayName", "description": "可選。附件圖示下方顯示的名稱。如果省略，則使用檔案名稱。"}
                ],
                "examples": [
                {"code": "Dim olMail As Object ' Assume olMail is a MailItem object\n' olMail.Attachments.Add \"C:\\Reports\\MonthlyReport.pdf\"\n' olMail.Attachments.Add \"C:\\Data\\SalesData.xlsx\", , , \"Latest Sales Figures\"", "explanation": "新增一個 PDF 檔案作為附件，以及一個帶有自訂顯示名稱的 Excel 檔案。"}
                ],
                "keywords": ["outlook add attachment", "attach file email", "outlook", "新增附件"]
            },
            {
                "name": "MailItem.Send", "category": "Outlook 郵件與項目管理",
                "syntax": "olMail.Send",
                "description": "傳送電子郵件訊息。如果 Outlook 在線上，此方法會立即傳送項目，而不會將其排入寄件匣。",
                "parameters": [],
                "examples": [
                {"code": "Dim olApp As Object, olMail As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olMail = olApp.CreateItem(0) ' olMailItem\nWith olMail\n  .To = \"test@example.com\"\n  .Subject = \"Automatic Email\"\n  .Body = \"This email was sent automatically via VBA.\"\n  .Send\nEnd With\nMsgBox \"Email sent!\"", "explanation": "直接建立並傳送電子郵件。"}
                ],
                "keywords": ["outlook send email", "send mail", "outlook", "傳送郵件"]
            },
            {
                "name": "MailItem.Display", "category": "Outlook 郵件與項目管理",
                "syntax": "olMail.Display([Modal As Boolean])",
                "description": "為項目顯示新的 Inspector 物件。這允許使用者在傳送或儲存項目之前檢閱或編輯項目。",
                "parameters": [{"name": "Modal", "description": "可選。True 表示使視窗成為強制回應視窗。預設為 False。"}],
                "examples": [
                {"code": "Dim olApp As Object, olMail As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olMail = olApp.CreateItem(0) ' olMailItem\nWith olMail\n  .To = \"review@example.com\"\n  .Subject = \"Please Review\"\n  .Body = \"Kindly review the content.\"\n  .Display ' Shows the email window for user review\nEnd With\n' User can then send it manually or close it.", "explanation": "建立一封電子郵件並在 Outlook 視窗中顯示，供使用者檢閱或手動傳送。"}
                ],
                "keywords": ["outlook display email", "show email window", "outlook", "顯示郵件"]
            },
            {
                "name": "Outlook.GetNamespace", "category": "Outlook 郵件與項目管理",
                "syntax": "Set olNamespace = olApp.GetNamespace(\"MAPI\")",
                "description": "傳回指定類型的 NameSpace 物件。目前唯一支援的類型是 \"MAPI\"。此物件是存取 Outlook 資料 (如資料夾) 的進入點。",
                "parameters": [{"name": "\"MAPI\"", "description": "必需。字串 \"MAPI\"。"}],
                "examples": [
                {"code": "Dim olApp As Object, olNamespace As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olNamespace = olApp.GetNamespace(\"MAPI\")\nIf olNamespace Is Nothing Then MsgBox \"Failed to get MAPI namespace.\" Else MsgBox \"MAPI namespace retrieved.\"", "explanation": "取得 MAPI 命名空間，這對於存取 Outlook 資料夾至關重要。"}
                ],
                "keywords": ["outlook namespace", "mapi namespace", "access outlook data", "outlook", "命名空間"]
            },
            {
                "name": "NameSpace.GetDefaultFolder", "category": "Outlook 郵件與項目管理",
                "syntax": "Set olFolder = olNamespace.GetDefaultFolder(FolderType As OlDefaultFolders)",
                "description": "傳回一個 MAPIFolder 物件，代表目前設定檔中要求類型的預設資料夾。",
                "parameters": [
                {"name": "FolderType", "description": "必需。一個 OlDefaultFolders 常數，指定要傳回的預設資料夾類型 (例如，olFolderInbox, olFolderSentMail, olFolderOutbox, olFolderCalendar)。"}
                ],
                "examples": [
                {"code": "Dim olApp As Object, olNamespace As Object, olInbox As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olNamespace = olApp.GetNamespace(\"MAPI\")\nSet olInbox = olNamespace.GetDefaultFolder(6) ' 6 is olFolderInbox\nMsgBox \"Your default Inbox folder is: \" & olInbox.Name & \" (Contains \" & olInbox.Items.Count & \" items)\"", "explanation": "取得預設的收件匣資料夾並顯示其名稱和項目計數。"}
                ],
                "keywords": ["outlook getdefaultfolder", "inbox folder", "sent items", "calendar folder", "outlook folders", "outlook", "olFolderInbox", "預設資料夾"]
            },
            {
                "name": "MAPIFolder.Items", "category": "Outlook 郵件與項目管理",
                "syntax": "Set olItems = olFolder.Items",
                "description": "傳回一個 Items 集合，代表指定資料夾中的所有 Outlook 項目。",
                "parameters": [],
                "examples": [
                {"code": "Dim olApp As Object, olNS As Object, olInbox As Object, olItem As Object, emailCount As Integer\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olNS = olApp.GetNamespace(\"MAPI\")\nSet olInbox = olNS.GetDefaultFolder(6) ' olFolderInbox\nemailCount = 0\nFor Each olItem In olInbox.Items\n  If TypeOf olItem Is MailItem Then ' Or olItem.Class = olMail (43)\n    emailCount = emailCount + 1\n    ' Debug.Print olItem.Subject ' Print subject of each email\n  End If\nNext olItem\nMsgBox \"There are \" & emailCount & \" mail items in your Inbox.\"", "explanation": "迭代收件匣中的所有項目，並計算有多少是 MailItems。"}
                ],
                "keywords": ["outlook folder items", "read emails", "access calendar items", "outlook", "資料夾項目"]
            },
            {
                "name": "Items.Restrict", "category": "Outlook 郵件與項目管理",
                "syntax": "Set olRestrictedItems = olItems.Restrict(Filter As String)",
                "description": "將篩選套用至 Items 集合，傳回一個新集合，其中包含原始集合中符合篩選的所有項目。使用 DAV 搜尋和定位 (DASL) 語法進行篩選。",
                "parameters": [{"name": "Filter", "description": "必需。包含篩選條件的字串。"}],
                "examples": [
                {"code": "Dim olApp As Object, olNS As Object, olInbox As Object, olFilteredMail As Object, olMail As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olNS = olApp.GetNamespace(\"MAPI\")\nSet olInbox = olNS.GetDefaultFolder(6) ' olFolderInbox\nDim strFilter As String\nstrFilter = \"@SQL=\" & Chr(34) & \"urn:schemas:httpmail:subject\" & Chr(34) & \" LIKE '%Report%' AND \" & _\n            Chr(34) & \"urn:schemas:httpmail:datereceived\" & Chr(34) & \" >= '\" & Format(Date - 7, \"yyyy/mm/dd\") & \"'\"\nSet olFilteredMail = olInbox.Items.Restrict(strFilter)\nMsgBox \"Found \" & olFilteredMail.Count & \" emails with 'Report' in subject from last 7 days.\"\nFor Each olMail In olFilteredMail\n  Debug.Print olMail.Subject & \" - Received: \" & olMail.ReceivedTime\nNext olMail", "explanation": "篩選收件匣中主旨包含 \"Report\" 且在過去 7 天內收到的電子郵件。"}
                ],
                "keywords": ["outlook filter items", "search email outlook", "restrict items", "dasl filter", "outlook", "篩選項目"]
            },
            {
                "name": "AppointmentItem.Start", "category": "Outlook 郵件與項目管理",
                "syntax": "olAppointment.Start [= DateTime]",
                "description": "設定或傳回一個 Date，指出 Outlook 項目的開始日期和時間。",
                "parameters": [{"name": "DateTime", "description": "開始日期和時間。"}],
                "examples": [
                {"code": "Dim olApp As Object, olApt As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olApt = olApp.CreateItem(1) ' olAppointmentItem\nolApt.Subject = \"Team Meeting\"\nolApt.Start = DateAdd(\"d\", 1, Date) + TimeValue(\"10:00:00\") ' Tomorrow at 10 AM\nolApt.Duration = 60 ' Minutes\nolApt.Display", "explanation": "建立一個明天上午 10:00 開始，持續 60 分鐘的新約會並顯示它。"}
                ],
                "keywords": ["outlook appointment start", "set appointment time", "calendar item", "outlook", "約會開始時間"]
            },
            {
                "name": "AppointmentItem.End", "category": "Outlook 郵件與項目管理",
                "syntax": "olAppointment.End [= DateTime]",
                "description": "設定或傳回一個 Date，指出約會的結束日期和時間。",
                "parameters": [{"name": "DateTime", "description": "結束日期和時間。"}],
                "examples": [
                {"code": "Dim olApt As Object ' Assume olApt is an AppointmentItem\n' olApt.End = olApt.Start + TimeValue(\"01:30:00\") ' Set end time 1.5 hours after start", "explanation": "將約會的結束時間設定為其開始時間後的 1 小時 30 分鐘。"}
                ],
                "keywords": ["outlook appointment end", "set appointment duration", "outlook", "約會結束時間"]
            },
            {
                "name": "AppointmentItem.Location", "category": "Outlook 郵件與項目管理",
                "syntax": "olAppointment.Location [= String]",
                "description": "設定或傳回一個字串，指出約會的特定地點 (例如，「會議室 B」)。",
                "parameters": [{"name": "String", "description": "地點文字。"}],
                "examples": [
                {"code": "Dim olApt As Object ' Assume olApt is an AppointmentItem\nolApt.Location = \"Conference Room 301\"", "explanation": "設定約會的地點。"}
                ],
                "keywords": ["outlook appointment location", "set meeting place", "outlook", "約會地點"]
            },
            {
                "name": "AppointmentItem.ReminderSet", "category": "Outlook 郵件與項目管理",
                "syntax": "olAppointment.ReminderSet [= Boolean]",
                "description": "傳回或設定一個布林值，如果已為項目設定提醒，則為 True。",
                "parameters": [{"name": "Boolean", "description": "True 表示設定提醒，False 表示清除提醒。"}],
                "examples": [
                {"code": "Dim olApt As Object ' Assume olApt is an AppointmentItem\nolApt.ReminderSet = True\nolApt.ReminderMinutesBeforeStart = 15 ' Reminder 15 minutes before start", "explanation": "為約會啟用提醒，並將其設定為開始前 15 分鐘。"}
                ],
                "keywords": ["outlook appointment reminder", "set reminder", "outlook", "設定提醒"]
            },
            {
                "name": "ContactItem.FullName", "category": "Outlook 郵件與項目管理",
                "syntax": "olContact.FullName [= String]",
                "description": "設定或傳回一個字串，代表連絡人的全名。雖然可以設定此屬性，但它通常是從 FirstName、MiddleName、LastName 和 Suffix 派生的。",
                "parameters": [{"name": "String", "description": "全名。"}],
                "examples": [
                {"code": "Dim olApp As Object, olContact As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olContact = olApp.CreateItem(2) ' olContactItem\nolContact.FirstName = \"John\"\nolContact.LastName = \"Doe\"\n' olContact.FullName will be \"John Doe\"\n' olContact.Email1Address = \"john.doe@example.com\"\n' olContact.Save\nMsgBox \"Contact created: \" & olContact.FullName", "explanation": "建立一個新連絡人，設定名字和姓氏，FullName 屬性將反映這一點。"}
                ],
                "keywords": ["outlook contact name", "full name contact", "outlook", "連絡人全名"]
            },

            // --- Word 文件處理 (Word Document Processing) ---
            {
                "name": "Word.Application (CreateObject/GetObject)", "category": "Word 文件處理",
                "syntax": "Set wdApp = CreateObject(\"Word.Application\") \n' or\nSet wdApp = GetObject(, \"Word.Application\")",
                "description": "建立 Microsoft Word 應用程式的新執行個體，或取得對已執行執行個體的參照。",
                "parameters": [
                    {"name": "Class (CreateObject)", "description": "字串 \"Word.Application\"。"},
                    {"name": "Class (GetObject)", "description": "可選。字串 \"Word.Application\"，用於取得已執行的 Word 實例。"}
                ],
                "examples": [
                    {"code": "Dim wdApp As Object\nOn Error Resume Next\nSet wdApp = GetObject(, \"Word.Application\")\nIf wdApp Is Nothing Then\n  Set wdApp = CreateObject(\"Word.Application\")\n  MsgBox \"已建立新的 Word 應用程式執行個體。\"\nElse\n  MsgBox \"已連結到現有的 Word 應用程式執行個體。\"\nEnd If\nwdApp.Visible = True\n' ... 在此處執行 Word 自動化操作 ...\n' Set wdApp = Nothing ' 完成後釋放物件", "explanation": "嘗試連結到已執行的 Word 應用程式，如果失敗則建立一個新的執行個體，並使其可見。"}
                ],
                "keywords": ["word application", "create word", "get word", "open word", "word automation", "word", "Word物件", "啟動Word"]
            },
            {
                "name": "Documents.Add", "category": "Word 文件處理",
                "syntax": "Set wdDoc = wdApp.Documents.Add([Template], [NewTemplate], [DocumentType], [Visible])",
                "description": "建立一個新的 Word 文件並將其新增到 Documents 集合中。新文件會成為活動文件。",
                "parameters": [
                    {"name": "Template", "description": "可選。用於新文件的範本名稱 (字串)。可以是範本檔案的路徑或內建範本的名稱。"},
                    {"name": "Visible", "description": "可選。True 使文件在 Word 應用程式中可見。預設為 True。"}
                ],
                "examples": [
                    {"code": "Dim wdApp As Object, wdDoc As Object\nSet wdApp = CreateObject(\"Word.Application\")\nwdApp.Visible = True\nSet wdDoc = wdApp.Documents.Add\nwdDoc.Content.Text = \"這是一個新文件。\"\n' wdDoc.SaveAs2 \"C:\\Temp\\MyNewWordDoc.docx\"", "explanation": "建立一個新的空白 Word 文件，並在其中新增一些文字。"},
                    {"code": "Dim wdApp As Object, wdDoc As Object\nSet wdApp = CreateObject(\"Word.Application\")\nwdApp.Visible = True\n' 假設有一個範本 C:\\Templates\\MyLetter.dotx\n' Set wdDoc = wdApp.Documents.Add(Template:=\"C:\\Templates\\MyLetter.dotx\")\n' MsgBox \"已根據範本建立文件。\"", "explanation": "根據指定的 Word 範本檔案建立一個新文件 (此範例為註解狀態，需要實際範本路徑)。"}
                ],
                "keywords": ["word add document", "new word document", "create document", "word", "新增文件", "建立Word檔"]
            },
            {
                "name": "Documents.Open", "category": "Word 文件處理",
                "syntax": "Set wdDoc = wdApp.Documents.Open(FileName, [ConfirmConversions], [ReadOnly], [AddToRecentFiles], [PasswordDocument], ...)",
                "description": "開啟一個現有的 Word 文件。",
                "parameters": [
                    {"name": "FileName", "description": "必需。要開啟的文件的檔案名稱 (字串，可包含完整路徑)。"},
                    {"name": "ReadOnly", "description": "可選。True 表示以唯讀模式開啟文件。"}
                ],
                "examples": [
                    {"code": "Dim wdApp As Object, wdDoc As Object\nSet wdApp = CreateObject(\"Word.Application\")\nwdApp.Visible = True\n' Set wdDoc = wdApp.Documents.Open(\"C:\\MyDocs\\ExistingReport.docx\")\n' If Not wdDoc Is Nothing Then\n'   MsgBox wdDoc.Name & \" 已開啟。\"\n' Else\n'   MsgBox \"無法開啟文件。\"\n' End If", "explanation": "開啟指定路徑的現有 Word 文件。"}
                ],
                "keywords": ["word open document", "open file word", "load document", "word", "開啟文件", "讀取Word檔"]
            },
            {
                "name": "Document.Save", "category": "Word 文件處理",
                "syntax": "wdDoc.Save",
                "description": "儲存對指定 Word 文件的變更。如果文件之前從未儲存過，則會提示使用者輸入檔案名稱 (除非 DisplayAlerts 設為 False)。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdDoc As Object ' 假設 wdDoc 是一個已開啟的 Document 物件\n' If wdDoc.Saved = False Then\n'  wdDoc.Save\n'  MsgBox wdDoc.Name & \" 已儲存。\"\n' End If", "explanation": "如果文件有未儲存的變更，則儲存該文件。"}
                ],
                "keywords": ["word save document", "save file word", "word", "儲存文件", "保存Word檔"]
            },
            {
                "name": "Document.SaveAs2", "category": "Word 文件處理",
                "syntax": "wdDoc.SaveAs2(FileName, [FileFormat], [LockComments], [Password], ...)",
                "description": "將 Word 文件以不同的名稱或格式儲存。這是較新的 SaveAs 方法，建議使用。",
                "parameters": [
                    {"name": "FileName", "description": "必需。新檔案的名稱 (字串，可包含路徑)。"},
                    {"name": "FileFormat", "description": "可選。文件的儲存格式，例如 wdFormatDocumentDefault (docx), wdFormatXMLDocumentMacroEnabled (docm), wdFormatPDF (pdf)。"}
                ],
                "examples": [
                    {"code": "Dim wdDoc As Object ' 假設 wdDoc 是一個 Document 物件\n' wdDoc.SaveAs2 FileName:=\"C:\\Archive\\Report_Final.docx\", FileFormat:=12 ' 12 = wdFormatXMLDocument (docx)\n' MsgBox \"文件已另存為 Report_Final.docx\"", "explanation": "將目前文件另存為指定路徑和名稱的 .docx 檔案。"},
                    {"code": "Dim wdDoc As Object ' 假設 wdDoc 是一個 Document 物件\n' wdDoc.SaveAs2 FileName:=\"C:\\PDFs\\MyDocument.pdf\", FileFormat:=17 ' 17 = wdFormatPDF\n' MsgBox \"文件已另存為 MyDocument.pdf\"", "explanation": "將目前文件另存為 PDF 格式。"}
                ],
                "keywords": ["word save as", "save document as", "export to pdf word", "word", "另存新檔", "儲存為PDF"]
            },
            {
                "name": "Document.Close", "category": "Word 文件處理",
                "syntax": "wdDoc.Close([SaveChanges], [OriginalFormat], [RouteDocument])",
                "description": "關閉指定的 Word 文件。",
                "parameters": [
                    {"name": "SaveChanges", "description": "可選。指定關閉文件前是否儲存變更。可以是 WdSaveOptions 常數 (wdSaveChanges, wdDoNotSaveChanges, wdPromptToSaveChanges)。"}
                ],
                "examples": [
                    {"code": "Dim wdDoc As Object ' 假設 wdDoc 是一個 Document 物件\n' wdDoc.Close SaveChanges:=0 ' 0 = wdDoNotSaveChanges (不儲存並關閉)\n' MsgBox \"文件已關閉，未儲存變更。\"", "explanation": "關閉文件而不儲存任何變更。"},
                    {"code": "Dim wdApp As Object\nSet wdApp = CreateObject(\"Word.Application\")\n' ... 開啟或建立文件 ...\n' If wdApp.Documents.Count > 0 Then\n'   wdApp.Documents(1).Close SaveChanges:=-2 ' -2 = wdPromptToSaveChanges\n' End If\n' If wdApp.Documents.Count = 0 Then wdApp.Quit", "explanation": "關閉第一個開啟的文件，並在關閉前提示使用者儲存變更。如果沒有其他文件開啟，則關閉 Word。"}
                ],
                "keywords": ["word close document", "close file word", "word", "關閉文件", "關閉Word檔"]
            },
            {
                "name": "Document.Content", "category": "Word 文件處理",
                "syntax": "Set rngContent = wdDoc.Content",
                "description": "傳回一個 Range 物件，代表文件的主要內容區域。此範圍包含文件的所有文字、圖形等，但不包括頁首、頁尾或註解。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdDoc As Object, rngStory As Object ' Word.Range\n' Set wdDoc = ActiveDocument ' 假設在 Word 中執行\n' Set rngStory = wdDoc.Content\n' rngStory.Font.Name = \"標楷體\"\n' rngStory.InsertAfter vbCrLf & \"--- 文件結束 --- \"", "explanation": "獲取文件的主要內容範圍，更改其字型，並在末尾添加文字。"}
                ],
                "keywords": ["word document content", "main story", "get document text", "word", "文件內容", "主要文字範圍"]
            },
            {
                "name": "Document.Paragraphs", "category": "Word 文件處理",
                "syntax": "Set colParagraphs = wdDoc.Paragraphs",
                "description": "傳回一個 Paragraphs 集合，代表指定文件中的所有段落。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdDoc As Object, para As Object ' Word.Paragraph\n' Set wdDoc = ActiveDocument\n' For Each para In wdDoc.Paragraphs\n'   If Len(para.Range.Text) > 100 Then ' 檢查段落長度\n'     para.Range.Font.ColorIndex = wdRed ' 將長段落標紅\n'   End If\n' Next para", "explanation": "遍歷文件中的所有段落，並將長度超過100個字元的段落文字顏色設為紅色。"}
                ],
                "keywords": ["word paragraphs", "iterate paragraphs", "document structure", "word", "段落集合", "遍歷段落"]
            },
            {
                "name": "Paragraph.Range", "category": "Word 文件處理",
                "syntax": "Set rngPara = paraObject.Range",
                "description": "傳回一個 Range 物件，代表 Paragraph 物件所包含的內容 (包括段落標記)。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdDoc As Object, firstParaRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' If wdDoc.Paragraphs.Count > 0 Then\n'   Set firstParaRange = wdDoc.Paragraphs(1).Range\n'   firstParaRange.Font.Bold = True\n'   MsgBox \"第一個段落的文字: \" & Left(firstParaRange.Text, Len(firstParaRange.Text) - 1) ' 移除尾部段落標記\n' End If", "explanation": "獲取文件第一個段落的範圍，將其設為粗體，並顯示其文字內容 (不含段落標記)。"}
                ],
                "keywords": ["word paragraph range", "get paragraph text", "word", "段落範圍", "獲取段落文字"]
            },
            {
                "name": "Range.Text (Word)", "category": "Word 文件處理",
                "syntax": "rngWord.Text [= String]",
                "description": "設定或傳回指定 Word Range 物件中的純文字內容。",
                "parameters": [{"name": "String", "description": "要設定的文字。"}],
                "examples": [
                    {"code": "Dim wdDoc As Object, rng As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' Set rng = wdDoc.Range(Start:=0, End:=0) ' 在文件開頭插入\n' rng.Text = \"這是插入的標題。\" & vbCrLf", "explanation": "在文件開頭插入一行標題文字。"},
                    {"code": "Dim currentText As String\n' Set rng = ActiveDocument.Paragraphs(1).Range\n' currentText = rng.Text\n' rng.Text = UCase(currentText) ' 將段落文字轉為大寫", "explanation": "獲取第一個段落的文字，將其轉換為大寫，然後寫回該段落。"}
                ],
                "keywords": ["word range text", "set text word", "get text word", "word", "範圍文字", "設定文字", "取得文字"]
            },
            {
                "name": "Range.Font (Word)", "category": "Word 文件處理",
                "syntax": "Set fnt = rngWord.Font",
                "description": "傳回或設定一個 Font 物件，代表指定 Word Range 物件的字元格式。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdDoc As Object, rng As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' Set rng = wdDoc.Sentences(1) ' 選取第一句話\n' With rng.Font\n'   .Name = \"Verdana\"\n'   .Size = 14\n'   .Bold = True\n'   .Color = RGB(0, 0, 128) ' 深藍色\n' End With", "explanation": "選取文件的第一句話，並設定其字型名稱、大小、粗體和顏色。"}
                ],
                "keywords": ["word font object", "format text word", "character formatting", "word", "字型物件", "文字格式化"]
            },
            {
                "name": "Font Object Properties (Word)", "category": "Word 文件處理",
                "syntax": "fontObject.Name | .Size | .Bold | .Italic | .Underline | .Color | .ColorIndex | .Hidden | ...",
                "description": "Font 物件的各種屬性，用於控制文字的外觀，例如字型名稱、大小、粗體、斜體、底線、顏色、是否隱藏等。",
                "parameters": [
                    {"name": "Name", "description": "字型名稱 (例如 \"Arial\", \"Times New Roman\")。"},
                    {"name": "Size", "description": "字型大小 (以點為單位)。"},
                    {"name": "Bold", "description": "True 表示粗體。"},
                    {"name": "Italic", "description": "True 表示斜體。"},
                    {"name": "Underline", "description": "底線樣式 (例如 wdUnderlineSingle, wdUnderlineNone)。"},
                    {"name": "Color", "description": "RGB 顏色值 (長整型)。"},
                    {"name": "ColorIndex", "description": "WdColorIndex 常數。"}
                ],
                "examples": [
                    {"code": "Dim selFont As Object ' Word.Font\n' Set selFont = Selection.Font ' 假設在 Word 中操作，且有選取文字\n' selFont.Name = \"Calibri\"\n' selFont.Size = 11\n' selFont.Bold = False\n' selFont.Italic = True\n' selFont.Underline = wdUnderlineDotted ' 虛線底線\n' selFont.Color = RGB(255, 0, 0) ' 紅色", "explanation": "設定目前選取文字的各種字型屬性。"}
                ],
                "keywords": ["word font properties", "text formatting", "font name", "font size", "bold", "italic", "underline", "font color", "word", "字型屬性", "文字格式"]
            },
            {
                "name": "Range.ParagraphFormat (Word)", "category": "Word 文件處理",
                "syntax": "Set paraFmt = rngWord.ParagraphFormat",
                "description": "傳回或設定一個 ParagraphFormat 物件，代表指定 Word Range 的段落格式。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdDoc As Object, rng As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' Set rng = wdDoc.Paragraphs(1).Range ' 選取第一個段落\n' With rng.ParagraphFormat\n'   .Alignment = 1 ' 1 = wdAlignParagraphCenter (置中對齊)\n'   .SpaceBefore = 12 ' 段前間距 12 點\n'   .SpaceAfter = 6  ' 段後間距 6 點\n'   .LineSpacingRule = wdLineSpaceSingle ' 單行間距\n' End With", "explanation": "選取文件的第一個段落，並設定其對齊方式、段前/段後間距和行距。"}
                ],
                "keywords": ["word paragraph format", "paragraph alignment", "spacing", "indentation", "word", "段落格式", "對齊", "縮排", "間距"]
            },
            {
                "name": "ParagraphFormat Object Properties (Word)", "category": "Word 文件處理",
                "syntax": "paraFormatObject.Alignment | .LeftIndent | .RightIndent | .FirstLineIndent | .SpaceBefore | .SpaceAfter | .LineSpacing | .KeepTogether | ...",
                "description": "ParagraphFormat 物件的各種屬性，用於控制段落的格式，如對齊方式、縮排、間距、行距、是否與下段同頁等。",
                "parameters": [
                    {"name": "Alignment", "description": "對齊方式 (WdParagraphAlignment 常數，如 wdAlignParagraphLeft, wdAlignParagraphCenter, wdAlignParagraphRight, wdAlignParagraphJustify)。"},
                    {"name": "LeftIndent", "description": "左縮排 (以點為單位)。"},
                    {"name": "FirstLineIndent", "description": "首行縮排 (以點為單位)。"},
                    {"name": "SpaceBefore", "description": "段前間距 (以點為單位)。"},
                    {"name": "SpaceAfter", "description": "段後間距 (以點為單位)。"},
                    {"name": "LineSpacing", "description": "行距 (以點為單位)。"},
                    {"name": "LineSpacingRule", "description": "行距規則 (WdLineSpacing 常數)。"}
                ],
                "examples": [
                    {"code": "Dim selParaFmt As Object ' Word.ParagraphFormat\n' Set selParaFmt = Selection.ParagraphFormat ' 假設在 Word 中操作\n' selParaFmt.Alignment = wdAlignParagraphJustify ' 左右對齊\n' selParaFmt.LeftIndent = InchesToPoints(0.5) ' 左縮排 0.5 英吋\n' selParaFmt.FirstLineIndent = InchesToPoints(0.25) ' 首行縮排 0.25 英吋\n' selParaFmt.SpaceBefore = 0\n' selParaFmt.SpaceAfter = 8\n' selParaFmt.LineSpacingRule = wdLineSpaceMultiple\n' selParaFmt.LineSpacing = 1.15 ' 1.15 倍行高", "explanation": "設定目前選取段落的各種格式屬性，包括使用 InchesToPoints 函數進行單位轉換。"}
                ],
                "keywords": ["word paragraph properties", "alignment", "indentation", "spacing", "line spacing", "word", "段落屬性", "對齊", "縮排", "行距"]
            },
            {
                "name": "Range.Find (Word)", "category": "Word 文件處理",
                "syntax": "Set findObj = rngWord.Find",
                "description": "傳回一個 Find 物件，用於在指定的範圍內執行尋找作業。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdDoc As Object, searchRange As Object ' Word.Range\nDim myFind As Object ' Word.Find\n' Set wdDoc = ActiveDocument\n' Set searchRange = wdDoc.Content ' 在整個文件內容中尋找\n' Set myFind = searchRange.Find\n' With myFind\n'   .ClearFormatting\n'   .Text = \"特定文字\"\n'   .Replacement.ClearFormatting\n'   .Replacement.Text = \"取代文字\"\n'   .Forward = True\n'   .Wrap = wdFindContinue\n'   .Format = False\n'   .MatchCase = False\n'   .MatchWholeWord = True\n'   .Execute Replace:=wdReplaceAll ' 尋找並全部取代\n' End With", "explanation": "設定 Find 物件的屬性以在文件中尋找 \"特定文字\" 並將其全部取代為 \"取代文字\"，條件為符合整個單字且不區分大小寫。"}
                ],
                "keywords": ["word find text", "search document word", "find and replace", "word", "尋找文字", "搜尋並取代"]
            },
            {
                "name": "Find.Execute (Word)", "category": "Word 文件處理",
                "syntax": "foundResult = findObject.Execute([FindText], [MatchCase], [MatchWholeWord], ..., [Replace], [ReplaceWith], ...)",
                "description": "執行尋找作業。如果尋找成功，則傳回 True。",
                "parameters": [
                    {"name": "FindText", "description": "可選。要尋找的文字。"},
                    {"name": "MatchCase", "description": "可選。True 表示區分大小寫。"},
                    {"name": "MatchWholeWord", "description": "可選。True 表示僅符合整個單字。"},
                    {"name": "Replace", "description": "可選。WdReplace 常數 (wdReplaceNone, wdReplaceOne, wdReplaceAll)。"},
                    {"name": "ReplaceWith", "description": "可選。取代文字。"}
                ],
                "examples": [
                    {"code": "Dim searchRange As Object ' Word.Range\nDim myFind As Object ' Word.Find\n' Set searchRange = ActiveDocument.Content\n' Set myFind = searchRange.Find\n' myFind.Text = \"舊詞\"\n' Do While myFind.Execute\n'   If MsgBox(\"找到 '\" & searchRange.Text & \"'. 取代它嗎？\", vbYesNo) = vbYes Then\n'     searchRange.Text = \"新詞\"\n'     searchRange.Collapse wdCollapseEnd ' 移到找到範圍的末尾以繼續尋找\n'   Else\n'     searchRange.Collapse wdCollapseEnd\n'   End If\n' Loop", "explanation": "在文件中逐個尋找 \"舊詞\"，並提示使用者是否要將其取代為 \"新詞\"。"}
                ],
                "keywords": ["word execute find", "find operation", "search loop", "word", "執行尋找", "尋找取代迴圈"]
            },
            {
                "name": "Selection Object (Word)", "category": "Word 文件處理",
                "syntax": "Set sel = wdApp.Selection",
                "description": "傳回一個 Selection 物件，代表 Word 視窗中目前選取的內容 (例如文字、圖形或插入點)。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdApp As Object, sel As Object ' Word.Selection\n' Set wdApp = GetObject(, \"Word.Application\")\n' If wdApp Is Nothing Then Exit Sub\n' Set sel = wdApp.Selection\n' If sel.Type = wdSelectionIP Then ' wdSelectionIP = 插入點\n'   sel.TypeText \"在插入點輸入文字。\"\n' ElseIf sel.Type = wdSelectionNormal Then\n'   sel.Font.Bold = True\n'   MsgBox \"選取的文字已設為粗體。\"\n' End If", "explanation": "獲取 Word 中目前的選取。如果是一個插入點，則輸入文字；如果選取了文字，則將其設為粗體。"}
                ],
                "keywords": ["word selection", "current selection word", "selected text word", "word", "選取物件", "目前選取範圍"]
            },
            {
                "name": "Tables.Add (Word)", "category": "Word 文件處理",
                "syntax": "Set tbl = docOrRange.Tables.Add(Range, NumRows, NumColumns, [DefaultTableBehavior], [AutoFitBehavior])",
                "description": "在指定範圍內建立一個新的空白表格，並傳回代表該表格的 Table 物件。",
                "parameters": [
                    {"name": "Range", "description": "必需。Range 物件，表格將在此範圍內建立。"},
                    {"name": "NumRows", "description": "必需。表格的列數。"},
                    {"name": "NumColumns", "description": "必需。表格的欄數。"}
                ],
                "examples": [
                    {"code": "Dim wdDoc As Object, tbl As Object ' Word.Table\nDim insertRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' Set insertRange = wdDoc.Range(Start:=wdDoc.Content.End -1, End:=wdDoc.Content.End -1) ' 在文件末尾插入\n' Set tbl = wdDoc.Tables.Add(Range:=insertRange, NumRows:=3, NumColumns:=4)\n' tbl.Cell(1, 1).Range.Text = \"標題1\"\n' tbl.Borders.Enable = True", "explanation": "在文件末尾新增一個 3 列 4 欄的表格，並在第一個儲存格中填入文字，然後啟用表格框線。"}
                ],
                "keywords": ["word add table", "create table word", "insert table", "word", "新增表格", "建立表格"]
            },
            {
                "name": "Table Object (Word)", "category": "Word 文件處理",
                "syntax": "tblObject.Cell(Row, Column) | .Rows | .Columns | .Borders | .ApplyStyleDirectFormatting | ...",
                "description": "代表 Word 文件中的一個表格。提供存取儲存格、列、欄、框線和套用樣式等功能。",
                "parameters": [
                    {"name": "Cell(Row, Column)", "description": "方法：傳回代表表格中特定儲存格的 Cell 物件。"},
                    {"name": "Rows", "description": "屬性：傳回代表表格中所有列的 Rows 集合。"},
                    {"name": "Columns", "description": "屬性：傳回代表表格中所有欄的 Columns 集合。"},
                    {"name": "Borders", "description": "屬性：傳回代表表格所有框線的 Borders 集合。"}
                ],
                "examples": [
                    {"code": "Dim tbl As Object ' Word.Table, 假設 tbl 已指向一個表格\n' tbl.Cell(1, 1).Range.Text = \"A1\"\n' tbl.Cell(1, 2).Range.Text = \"B1\"\n' tbl.Rows(1).Range.Font.Bold = True ' 將第一列設為粗體\n' tbl.Columns(2).Shading.BackgroundPatternColor = RGB(200, 200, 200) ' 將第二欄背景設為灰色\n' tbl.ApplyStyleHeadingRows = True\n' tbl.AutoFitBehavior wdAutoFitWindow ' 自動調整表格以符合視窗寬度", "explanation": "操作表格物件，設定儲存格內容、格式化列和欄，並套用表格樣式。"}
                ],
                "keywords": ["word table object", "format table word", "table cells", "table rows", "table columns", "word", "表格物件", "格式化表格"]
            },
            {
                "name": "Cell.Range (Word Table)", "category": "Word 文件處理",
                "syntax": "Set rngCell = cellObject.Range",
                "description": "傳回一個 Range 物件，代表 Table Cell 物件所包含的內容。",
                "parameters": [],
                "examples": [
                    {"code": "Dim tbl As Object ' Word.Table\nDim cellContent As String\n' Set tbl = ActiveDocument.Tables(1)\n' cellContent = tbl.Cell(2, 3).Range.Text\n' MsgBox \"表格(1)的儲存格(2,3)內容 (含儲存格結束符號): \" & cellContent\n' tbl.Cell(2, 3).Range.Text = \"新內容\"", "explanation": "獲取並設定表格中特定儲存格的文字內容。注意，Cell.Range.Text 包含儲存格結束符號。"}
                ],
                "keywords": ["word table cell range", "get cell text word", "set cell text word", "word", "儲存格範圍", "表格儲存格文字"]
            },
            {
                "name": "Bookmarks.Add (Word)", "category": "Word 文件處理",
                "syntax": "Set bkm = wdDoc.Bookmarks.Add(Name As String, [Range])",
                "description": "在指定範圍處新增一個書籤到文件，並傳回代表該書籤的 Bookmark 物件。",
                "parameters": [
                    {"name": "Name", "description": "必需。書籤的名稱 (字串)。"},
                    {"name": "Range", "description": "可選。Range 物件，指定書籤標記的位置。如果省略，則書籤標記目前選取範圍或插入點。"}
                ],
                "examples": [
                    {"code": "Dim wdDoc As Object, bkm As Object ' Word.Bookmark\n' Set wdDoc = ActiveDocument\n' If wdDoc.Bookmarks.Exists(\"MySection\") Then wdDoc.Bookmarks(\"MySection\").Delete ' Delete if exists\n' Set bkm = wdDoc.Bookmarks.Add(Name:=\"MySection\", Range:=Selection.Range)\n' MsgBox \"書籤 '\" & bkm.Name & \"' 已新增於目前選取範圍。\"", "explanation": "在目前選取範圍新增一個名為 \"MySection\" 的書籤，如果已存在則先刪除舊的。"}
                ],
                "keywords": ["word add bookmark", "create bookmark word", "document navigation", "word", "新增書籤", "建立書籤"]
            },
            {
                "name": "Bookmarks.Exists (Word)", "category": "Word 文件處理",
                "syntax": "booleanResult = wdDoc.Bookmarks.Exists(Name As String)",
                "description": "檢查具有指定名稱的書籤是否存在於文件中。",
                "parameters": [{"name": "Name", "description": "必需。書籤的名稱 (字串)。"}],
                "examples": [
                    {"code": "Dim wdDoc As Object\n' Set wdDoc = ActiveDocument\n' If wdDoc.Bookmarks.Exists(\"Introduction\") Then\n'   wdDoc.Bookmarks(\"Introduction\").Select\n'   MsgBox \"書籤 'Introduction' 存在並已選取。\"\n' Else\n'   MsgBox \"書籤 'Introduction' 不存在。\"\n' End If", "explanation": "檢查名為 \"Introduction\" 的書籤是否存在，如果存在則選取它。"}
                ],
                "keywords": ["word check bookmark", "bookmark exists", "word", "檢查書籤是否存在", "書籤存在"]
            },
            {
                "name": "Bookmark.Select (Word)", "category": "Word 文件處理",
                "syntax": "bkmObject.Select",
                "description": "選取指定的書籤。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdDoc As Object\n' Set wdDoc = ActiveDocument\n' If wdDoc.Bookmarks.Exists(\"Chapter1\") Then\n'   wdDoc.Bookmarks(\"Chapter1\").Select\n' End If", "explanation": "如果書籤 \"Chapter1\" 存在，則選取該書籤的內容。"}
                ],
                "keywords": ["word select bookmark", "go to bookmark", "word", "選取書籤", "跳至書籤"]
            },
            {
                "name": "Bookmark.Range (Word)", "category": "Word 文件處理",
                "syntax": "Set rngBkm = bkmObject.Range",
                "description": "傳回一個 Range 物件，代表指定 Bookmark 物件所包含的內容。",
                "parameters": [],
                "examples": [
                    {"code": "Dim wdDoc As Object, bkmRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' If wdDoc.Bookmarks.Exists(\"ImportantNote\") Then\n'   Set bkmRange = wdDoc.Bookmarks(\"ImportantNote\").Range\n'   bkmRange.Font.ColorIndex = wdBrightGreen\n'   bkmRange.InsertAfter \" (已更新)\"\n' End If", "explanation": "獲取名為 \"ImportantNote\" 的書籤的範圍，更改其文字顏色並在其後插入文字。"}
                ],
                "keywords": ["word bookmark range", "get bookmark text", "modify bookmark content", "word", "書籤範圍", "修改書籤內容"]
            },
            {
                "name": "InlineShapes.AddPicture (Word)", "category": "Word 文件處理",
                "syntax": "Set ils = docOrRange.InlineShapes.AddPicture(FileName, [LinkToFile], [SaveWithDocument], [Range])",
                "description": "將圖片新增至文件作為內嵌圖案 (InlineShape)。內嵌圖案被視為文字字元，並隨文字流動。",
                "parameters": [
                    {"name": "FileName", "description": "必需。圖片檔案的完整路徑和名稱。"},
                    {"name": "LinkToFile", "description": "可選。True 表示連結到原始檔案，False (預設) 表示嵌入圖片。"},
                    {"name": "SaveWithDocument", "description": "可選。True (預設) 表示將圖片與文件一起儲存。"},
                    {"name": "Range", "description": "可選。圖片插入的位置。如果省略，則插入到目前選取範圍或插入點。"}
                ],
                "examples": [
                    {"code": "Dim wdDoc As Object, myPicture As Object ' Word.InlineShape\n' Set wdDoc = ActiveDocument\n' Set myPicture = wdDoc.InlineShapes.AddPicture(FileName:=\"C:\\Images\\logo.png\", _\n'                                             LinkToFile:=False, SaveWithDocument:=True, _\n'                                             Range:=Selection.Range)\n' myPicture.Height = InchesToPoints(1)\n' myPicture.Width = InchesToPoints(2)", "explanation": "在目前選取位置插入一個圖片作為內嵌圖案，並設定其高度和寬度。"}
                ],
                "keywords": ["word add picture", "insert image word", "inline picture", "word", "新增圖片", "插入圖片", "內嵌圖案"]
            },
            {
                "name": "Shapes.AddPicture (Word)", "category": "Word 文件處理",
                "syntax": "Set shp = docOrRange.Shapes.AddPicture(FileName, [LinkToFile], [SaveWithDocument], [Left], [Top], [Width], [Height], [Anchor])",
                "description": "將圖片新增至文件作為浮動圖案 (Shape)。浮動圖案可以精確定位，並且文字可以圍繞它。",
                "parameters": [
                    {"name": "FileName", "description": "必需。圖片檔案的路徑。"},
                    {"name": "Left, Top", "description": "可選。圖片左上角的水平和垂直位置 (以點為單位)，相對於 Anchor。"},
                    {"name": "Width, Height", "description": "可選。圖片的寬度和高度 (以點為單位)。"},
                    {"name": "Anchor", "description": "可選。Range 物件，圖片將錨定到此範圍。"}
                ],
                "examples": [
                    {"code": "Dim wdDoc As Object, logoShape As Object ' Word.Shape\n' Set wdDoc = ActiveDocument\n' Set logoShape = wdDoc.Shapes.AddPicture(FileName:=\"C:\\Graphics\\CompanyLogo.jpg\", _\n'                                       LinkToFile:=False, SaveWithDocument:=True, _\n'                                       Left:=InchesToPoints(1), Top:=InchesToPoints(1), _\n'                                       Width:=InchesToPoints(1.5), Height:=InchesToPoints(0.75))\n' logoShape.WrapFormat.Type = wdWrapSquare ' 設定文繞圖為方形", "explanation": "在文件指定位置新增一個浮動圖片，並設定其大小和文繞圖樣式。"}
                ],
                "keywords": ["word add floating picture", "insert shape picture", "picture formatting", "word", "新增浮動圖片", "圖案圖片"]
            },
            {
                "name": "Document.PrintOut (Word)", "category": "Word 文件處理",
                "syntax": "wdDoc.PrintOut([Background], [Append], [Range], [OutputFileName], [From], [To], [Item], [Copies], ...)",
                "description": "列印指定的文件、部分文件或文件集合。",
                "parameters": [
                    {"name": "Range", "description": "可選。WdPrintOutRange 常數，指定要列印的部分 (例如，wdPrintAllDocument, wdPrintCurrentPage, wdPrintSelection, wdPrintFromTo)。"},
                    {"name": "Copies", "description": "可選。要列印的份數。"},
                    {"name": "OutputFileName", "description": "可選。如果列印到檔案，則為檔案路徑和名稱。"}
                ],
                "examples": [
                    {"code": "Dim wdDoc As Object\n' Set wdDoc = ActiveDocument\n' wdDoc.PrintOut Copies:=2, Range:=wdPrintAllDocument ' 列印整個文件兩份", "explanation": "列印整個文件的兩份副本。"},
                    {"code": "' ActiveDocument.PrintOut From:=\"1\", To:=\"3\" ' 列印第 1 到 3 頁", "explanation": "列印文件的第 1 頁到第 3 頁。"}
                ],
                "keywords": ["word print document", "print file word", "printout", "word", "列印文件", "Word列印"]
            },
            {
                "name": "新建Word文檔並應用複雜格式及啟用追蹤修訂", "category": "Word 文件處理",
                "syntax": "Scenario: Create a new Word document from scratch or based on a very basic template. Then, programmatically apply a comprehensive set of formatting to different parts of the document: set default font and paragraph settings for the entire document, define and apply specific styles for headings and body text, adjust page setup (margins, orientation), insert headers/footers with page numbers, and finally, enable Track Changes before saving the document for collaborative review.",
                "description": "此案例演示了如何使用VBA從頭開始創建一個新的Word文檔，並對其進行詳細的格式化，最後啟用追蹤修訂功能。腳本會：1. 啟動Word應用程式並創建一個新的空白文檔。2. **設定文檔級別預設格式**：a. 設定整個文檔的預設字型 (例如，`ActiveDocument.Styles(wdStyleNormal).Font.Name`, `.Size`, `.Color`)。b. 設定預設段落格式 (例如，`ActiveDocument.Styles(wdStyleNormal).ParagraphFormat.LineSpacingRule`, `.SpaceBefore`, `.SpaceAfter`, `.Alignment`)。3. **定義和應用樣式 (可選但推薦)**：a. (可選) 創建或修改內建樣式，例如“標題1”、“標題2”和“內文本文”，設定它們的字型、段落格式（縮排、間距、大綱級別等）。b. 在文檔中插入一些示範內容，並將這些樣式應用於相應的段落。4. **設定頁面佈局 (Page Setup)**：a. 調整頁面邊距 (`wdDoc.PageSetup.LeftMargin`, `.RightMargin`, etc.)。b. 設定紙張方向（縱向/橫向）和大小。5. **插入頁首和頁尾 (Headers/Footers)**：a. 訪問主要頁首/頁尾區域 (`wdDoc.Sections(1).Headers(wdHeaderFooterPrimary).Range`)。b. 在頁首插入文檔標題或公司Logo (可選)。c. 在頁尾插入頁碼 (`.Fields.Add Range:= ..., Type:=wdFieldPage`) 和可能的其他信息（例如，文件路徑或日期）。6. **插入內容示例**：為了演示格式效果，插入一些標題和段落文本。7. **啟用追蹤修訂 (Track Changes)**：a. 在保存文檔之前，啟用追蹤修訂功能 (`wdDoc.TrackRevisions = True`)。b. (可選) 設定追蹤修訂的選項，例如顯示格式 (`wdDoc.RevisionsView = wdRevisionsViewFinal`) 或註解的顯示方式。8. **保存文檔**：將格式化並啟用追蹤修訂的文檔保存到指定位置。這個自動化流程對於需要標準化文檔外觀、確保所有新文檔都遵循特定格式指南，並且準備好進行協作審閱的場景非常有用。",
                "parameters": [
                    {"name": "Default Font Settings", "description": "整個文檔的預設字型名稱、大小、顏色等。"},
                    {"name": "Default Paragraph Settings", "description": "預設的行距、段前/段後間距、對齊方式等。"},
                    {"name": "Custom Styles (Optional)", "description": "為標題、正文等定義的特定樣式及其格式。"},
                    {"name": "Page Setup Options", "description": "頁面邊距、紙張大小、方向。"},
                    {"name": "Header/Footer Content", "description": "頁首/頁尾中要包含的文本、頁碼或其他元素。"},
                    {"name": "Track Changes Settings", "description": "是否啟用追蹤修訂以及相關的顯示選項。"}
                ],
                "examples": [
                    {"code": "Sub CreateFormattedWordDocWithTrackChanges()\n    Dim wdApp As Object ' Word.Application\n    Dim wdDoc As Object ' Word.Document\n    Dim wdStyleNormal As Object ' Word.Style\n    Dim wdStyleHeading1 As Object ' Word.Style\n    Dim tempParagraph As Object ' Word.Paragraph\n\n    On Error GoTo ErrorHandler\n\n    ' --- 1. Create Word Application and New Document ---\n    On Error Resume Next\n    Set wdApp = GetObject(, \"Word.Application\")\n    If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    If wdApp Is Nothing Then MsgBox \"無法啟動Word。\", vbCritical: Exit Sub\n    On Error GoTo ErrorHandler\n    wdApp.Visible = True\n    Set wdDoc = wdApp.Documents.Add\n\n    ' --- 2. Set Document-Level Default Formatting (via Normal style) ---\n    Set wdStyleNormal = wdDoc.Styles(wdStyleNormal) ' -1 = wdStyleNormal\n    With wdStyleNormal.Font\n        .Name = \"Calibri\" ' 設定預設字型\n        .Size = 11\n        .ColorIndex = wdAuto ' 自動黑色\n    End With\n    With wdStyleNormal.ParagraphFormat\n        .Alignment = wdAlignParagraphJustify ' 0 = wdAlignParagraphLeft, 3 = wdAlignParagraphJustify (左右對齊)\n        .LineSpacingRule = wdLineSpaceMultiple ' 4 = wdLineSpaceMultiple (多倍行高)\n        .LineSpacing = wdApp.LinesToPoints(1.15) ' 1.15 倍行高\n        .SpaceBefore = 0\n        .SpaceAfter = 8 ' 段後 8 磅\n        .WidowControl = True\n        .KeepWithNext = False\n        .KeepTogether = False\n    End With\n\n    ' --- 3. Define and Apply Styles (Example for Heading 1) ---\n    On Error Resume Next ' In case style doesn't exist or cannot be modified (though unlikely for built-in)\n    Set wdStyleHeading1 = wdDoc.Styles(wdStyleHeading1) ' -2 = wdStyleHeading1\n    If wdStyleHeading1 Is Nothing Then\n        Set wdStyleHeading1 = wdDoc.Styles.Add(\"My Heading 1\", wdStyleTypeParagraph) ' Type 1 = Paragraph style\n        wdStyleHeading1.BasedOn = wdStyleNormal ' Based on Normal\n    End If\n    On Error GoTo ErrorHandler\n    With wdStyleHeading1.Font\n        .Name = \"Arial Black\"\n        .Size = 16\n        .Bold = True\n        .Color = RGB(0, 51, 102) ' 深藍色\n    End With\n    With wdStyleHeading1.ParagraphFormat\n        .SpaceBefore = 24\n        .SpaceAfter = 12\n        .KeepWithNext = True\n        .OutlineLevel = wdOutlineLevel1 ' 1 = wdOutlineLevel1 (大綱級別1)\n    End With\n\n    ' --- 4. Set Page Setup ---\n    With wdDoc.PageSetup\n        .LeftMargin = wdApp.InchesToPoints(1)\n        .RightMargin = wdApp.InchesToPoints(1)\n        .TopMargin = wdApp.InchesToPoints(1)\n        .BottomMargin = wdApp.InchesToPoints(1)\n        .Orientation = wdOrientPortrait ' 0 = wdOrientPortrait (縱向)\n        .PaperSize = wdPaperA4 ' 9 = wdPaperA4 (A4紙張)\n    End With\n\n    ' --- 5. Insert Headers/Footers ---\n    Dim sec As Object ' Word.Section\n    Set sec = wdDoc.Sections(1)\n    With sec.Headers(wdHeaderFooterPrimary).Range ' 1 = wdHeaderFooterPrimary (主要頁首)\n        .ParagraphFormat.Alignment = wdAlignParagraphRight ' 2 = wdAlignParagraphRight\n        .Font.Size = 9\n        .Text = \"公司內部文件 - 機密\" ' CHINESE\n    End With\n    With sec.Footers(wdHeaderFooterPrimary).Range\n        .ParagraphFormat.Alignment = wdAlignParagraphCenter ' 1 = wdAlignParagraphCenter\n        .Font.Size = 9\n        .Text = \"第 \" ' CHINESE\n        .Fields.Add Range:=.Characters.Last, Type:=wdFieldPage ' 33 = wdFieldPage (頁碼)\n        .InsertAfter \" 頁，共 \" ' CHINESE\n        .Fields.Add Range:=.Characters.Last, Type:=wdFieldNumPages ' 26 = wdFieldNumPages (總頁數)\n        .InsertAfter \" 頁\" ' CHINESE\n    End With\n\n    ' --- 6. Insert Sample Content and Apply Styles ---\n    wdDoc.Content.InsertParagraphAfter\n    Set tempParagraph = wdDoc.Content.Paragraphs.Last\n    tempParagraph.Range.Text = \"第一章：介紹\" ' CHINESE\n    tempParagraph.Style = wdStyleHeading1\n    tempParagraph.Range.InsertParagraphAfter\n    \n    Set tempParagraph = wdDoc.Content.Paragraphs.Last\n    tempParagraph.Range.Text = \"這是一些示範內文，將會套用預設的 'Normal' 樣式。此段落展示了行距、段後間距和左右對齊的效果。\" & _\n                             \"重複一些文字來填充空間，以便更好地觀察格式。\" ' CHINESE\n    tempParagraph.Style = wdStyleNormal ' Explicitly apply, though it's default\n    tempParagraph.Range.InsertParagraphAfter\n\n    wdDoc.Content.InsertParagraphAfter\n    Set tempParagraph = wdDoc.Content.Paragraphs.Last\n    tempParagraph.Range.Text = \"第二章：主要發現\" ' CHINESE\n    tempParagraph.Style = wdStyleHeading1\n    tempParagraph.Range.InsertParagraphAfter\n\n    Set tempParagraph = wdDoc.Content.Paragraphs.Last\n    tempParagraph.Range.Text = \"本章節將詳述研究的主要成果和數據分析。\" ' CHINESE\n    tempParagraph.Style = wdStyleNormal\n    tempParagraph.Range.InsertParagraphAfter\n\n    ' --- 7. Enable Track Changes ---\n    wdDoc.TrackRevisions = True\n    ' Options for Track Changes (examples)\n    ' wdDoc.RevisionsView = wdRevisionsViewFinalShowingMarkup ' 0 = wdRevisionsViewFinalShowingMarkup\n    ' wdDoc.ShowRevisions = True ' (This is usually default when TrackRevisions is true)\n\n    ' --- 8. Save the Document ---\n    Dim savePath As String\n    savePath = \"C:\\Temp\\FormattedDoc_WithTrackChanges_\" & Format(Now, \"yyyymmdd_hhmmss\") & \".docx\"\n    wdDoc.SaveAs2 savePath\n\n    MsgBox \"已創建並格式化Word文檔，並啟用追蹤修訂功能。\" & vbCrLf & \"文件已保存至: \" & savePath, vbInformation\n\nCleanExit:\n    ' Optional: Close document or leave Word open\n    ' If Not wdDoc Is Nothing Then wdDoc.Close False ' Close without saving again if already saved\n    ' If Not wdApp Is Nothing And wdApp.Documents.Count = 0 Then wdApp.Quit\n    Set wdDoc = Nothing: Set wdApp = Nothing: Set wdStyleNormal = Nothing: Set wdStyleHeading1 = Nothing: Set tempParagraph = Nothing\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"創建格式化Word文檔時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanExit\nEnd Sub", "explanation": "此VBA子程序 `CreateFormattedWordDocWithTrackChanges` 演示了如何創建一個新的Word文檔並應用全面的格式設置。1. 它首先設定整個文檔的**預設字型和段落格式** (通過修改 `wdStyleNormal` 樣式)。2. 然後，它定義並修改了**“標題1” (`wdStyleHeading1`) 樣式**，包括字型、顏色、段落間距和大綱級別。3. 接下來，它設定**頁面佈局**，包括邊距、紙張方向和大小。4. 之後，它在**頁首插入了保密聲明，並在頁尾插入了“第 X 頁，共 Y 頁”格式的頁碼**。5. 為了展示效果，它插入了一些**示範內容**，並將定義好的樣式應用於這些內容。6. 在所有格式化完成後，它通過設定 `wdDoc.TrackRevisions = True` **啟用了追蹤修訂功能**。7. 最後，它將此新文檔以時間戳命名**保存**到 `C:\\Temp\\` 文件夾。這個腳本提供了一個創建符合特定企業或項目格式要求的標準化Word文檔的完整框架，並且該文檔已準備好進行協作審閱。"}
                ],
                "keywords": ["vba create word document formatting", "word automate document style", "set default font paragraph vba word", "insert header footer page number word vba", "enable track changes vba word", "Word文檔自動格式化", "VBA設定Word樣式", "Word頁首頁尾頁碼", "啟用追蹤修訂VBA"]
            },

            // --- PowerPoint 簡報製作 (PowerPoint Presentation Creation) ---
            {
                "name": "PowerPoint.Presentations.Add", "category": "PowerPoint 簡報製作", "syntax": "Set pptPres = pptApp.Presentations.Add([WithWindow As MsoTriState = msoTrue])",
                "description": "在 PowerPoint 中創建一個新的空白簡報。",
                "parameters": [{"name": "WithWindow", "description": "可選。指定是否在新視窗中開啟簡報。"}],
                "examples": [
                    {"code": "Dim pptApp As Object, pptPres As Object\nOn Error Resume Next\nSet pptApp = GetObject(, \"PowerPoint.Application\")\nIf pptApp Is Nothing Then Set pptApp = CreateObject(\"PowerPoint.Application\")\nOn Error GoTo 0\npptApp.Visible = True\nSet pptPres = pptApp.Presentations.Add\nMsgBox \"已建立新的 PowerPoint 簡報: \" & pptPres.Name", "explanation": "創建一個新的 PowerPoint 簡報。"}
                ],
                "keywords": ["PowerPoint", "新增簡報", "簡報", "ppt", "new presentation", "其他"]
            },
            {
                "name": "PowerPoint.Slides.Add", "category": "PowerPoint 簡報製作", "syntax": "Set pptSlide = pptPres.Slides.Add(Index As Long, Layout As PpSlideLayout)",
                "description": "在簡報中新增一張投影片。",
                "parameters": [
                    {"name": "Index", "description": "必需。新投影片在 Slides 集合中的索引號。"},
                    {"name": "Layout", "description": "必需。PpSlideLayout 列舉，指定投影片版面配置。"}
                ],
                "examples": [
                    {"code": "Dim pptApp As Object, pptPres As Object, pptSlide As Object\nSet pptApp = CreateObject(\"PowerPoint.Application\")\npptApp.Visible = True\nSet pptPres = pptApp.Presentations.Add\nSet pptSlide = pptPres.Slides.Add(1, 12) ' 12 = ppLayoutBlank\npptSlide.Shapes.AddTextbox msoTextOrientationHorizontal, 50, 50, 200, 50\npptSlide.Shapes(1).TextFrame.TextRange.Text = \"Hello PowerPoint\"", "explanation": "在新簡報中新增一張空白投影片並加入文字方塊。"}
                ],
                "keywords": ["PowerPoint", "新增投影片", "投影片", "ppt", "add slide", "其他"]
            },
            {
                "name": "PowerPoint.Application (CreateObject/GetObject)", "category": "PowerPoint 簡報製作",
                "syntax": "Set ppApp = CreateObject(\"PowerPoint.Application\") \n' or\nSet ppApp = GetObject(, \"PowerPoint.Application\")",
                "description": "建立 Microsoft PowerPoint 應用程式的新執行個體，或取得對已執行執行個體的參照。",
                "parameters": [
                    {"name": "Class (CreateObject)", "description": "字串 \"PowerPoint.Application\"。"},
                    {"name": "Class (GetObject)", "description": "可選。字串 \"PowerPoint.Application\"。"}
                ],
                "examples": [
                    {"code": "Dim ppApp As Object\nOn Error Resume Next\nSet ppApp = GetObject(, \"PowerPoint.Application\")\nIf ppApp Is Nothing Then\n  Set ppApp = CreateObject(\"PowerPoint.Application\")\n  MsgBox \"已建立新的 PowerPoint 應用程式執行個體。\"\nElse\n  MsgBox \"已連結到現有的 PowerPoint 應用程式執行個體。\"\nEnd If\nppApp.Visible = msoTrue ' msoTrue = -1\n' ... 在此處執行 PowerPoint 自動化操作 ...\n' Set ppApp = Nothing ' 完成後釋放物件", "explanation": "嘗試連結到已執行的 PowerPoint 應用程式，如果失敗則建立一個新的執行個體，並使其可見。"}
                ],
                "keywords": ["powerpoint application", "create powerpoint", "get powerpoint", "open powerpoint", "ppt automation", "ppt", "PowerPoint物件", "啟動PowerPoint"]
            },
            {
                "name": "Presentations.Add (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set ppPres = ppApp.Presentations.Add([WithWindow As MsoTriState = msoTrue])",
                "description": "建立一個新的空白簡報，並將其新增到 Presentations 集合中。新簡報會成為活動簡報。",
                "parameters": [
                    {"name": "WithWindow", "description": "可選。MsoTriState 常數，指定是否在新視窗中開啟簡報 (msoTrue, msoFalse)。預設為 msoTrue。"}
                ],
                "examples": [
                    {"code": "Dim ppApp As Object, ppPres As Object\nSet ppApp = CreateObject(\"PowerPoint.Application\")\nppApp.Visible = msoTrue\nSet ppPres = ppApp.Presentations.Add\nMsgBox \"已建立新的 PowerPoint 簡報: \" & ppPres.Name\n' ppPres.SaveAs \"C:\\Temp\\MyNewPresentation.pptx\"", "explanation": "建立一個新的空白 PowerPoint 簡報。"}
                ],
                "keywords": ["powerpoint add presentation", "new presentation ppt", "create presentation", "ppt", "新增簡報", "建立PPT"]
            },
            {
                "name": "Presentations.Open (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set ppPres = ppApp.Presentations.Open(FileName, [ReadOnly], [Untitled], [WithWindow])",
                "description": "開啟一個現有的 PowerPoint 簡報。",
                "parameters": [
                    {"name": "FileName", "description": "必需。要開啟的簡報的檔案名稱 (字串，可包含完整路徑)。"},
                    {"name": "ReadOnly", "description": "可選。MsoTriState 常數，msoTrue 表示以唯讀模式開啟。"},
                    {"name": "WithWindow", "description": "可選。MsoTriState 常數，msoTrue (預設) 表示在視窗中開啟簡報。"}
                ],
                "examples": [
                    {"code": "Dim ppApp As Object, ppPres As Object\nSet ppApp = CreateObject(\"PowerPoint.Application\")\nppApp.Visible = msoTrue\n' Set ppPres = ppApp.Presentations.Open(\"C:\\MySlides\\ExistingDeck.pptx\")\n' If Not ppPres Is Nothing Then\n'   MsgBox ppPres.Name & \" 已開啟。\"\n' Else\n'   MsgBox \"無法開啟簡報。\"\n' End If", "explanation": "開啟指定路徑的現有 PowerPoint 簡報。"}
                ],
                "keywords": ["powerpoint open presentation", "open file ppt", "load presentation", "ppt", "開啟簡報", "讀取PPT"]
            },
            {
                "name": "Presentation.Save (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "ppPres.Save",
                "description": "儲存對指定 PowerPoint 簡報的變更。如果簡報之前從未儲存過，則會提示使用者輸入檔案名稱。",
                "parameters": [],
                "examples": [
                    {"code": "Dim ppPres As Object ' 假設 ppPres 是一個已開啟的 Presentation 物件\n' If ppPres.Saved = msoFalse Then\n'  ppPres.Save\n'  MsgBox ppPres.Name & \" 已儲存。\"\n' End If", "explanation": "如果簡報有未儲存的變更，則儲存該簡報。"}
                ],
                "keywords": ["powerpoint save presentation", "save file ppt", "ppt", "儲存簡報", "保存PPT"]
            },
            {
                "name": "Presentation.SaveAs (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "ppPres.SaveAs(FileName, [FileFormat], [EmbedTrueTypeFonts], [Password], ...)",
                "description": "將 PowerPoint 簡報以不同的名稱或格式儲存。",
                "parameters": [
                    {"name": "FileName", "description": "必需。新檔案的名稱 (字串，可包含路徑)。"},
                    {"name": "FileFormat", "description": "可選。PpSaveAsFileType 常數，指定檔案格式 (例如，ppSaveAsDefault (預設格式，通常 .pptx), ppSaveAsPDF, ppSaveAsPNG)。"}
                ],
                "examples": [
                    {"code": "Dim ppPres As Object ' 假設 ppPres 是一個 Presentation 物件\n' ppPres.SaveAs FileName:=\"C:\\Archive\\MySlides_Backup.pptx\", FileFormat:=ppSaveAsDefault\n' MsgBox \"簡報已另存為 MySlides_Backup.pptx\"", "explanation": "將目前簡報另存為指定路徑和名稱的 .pptx 檔案。"},
                    {"code": "Dim ppPres As Object ' 假設 ppPres 是一個 Presentation 物件\n' ppPres.SaveAs FileName:=\"C:\\PDFs\\MyPresentation.pdf\", FileFormat:=32 ' 32 = ppSaveAsPDF\n' MsgBox \"簡報已另存為 MyPresentation.pdf\"", "explanation": "將目前簡報另存為 PDF 格式。"}
                ],
                "keywords": ["powerpoint save as", "save presentation as", "export to pdf ppt", "ppt", "另存新檔PPT", "儲存為PDF(PPT)"]
            },
            {
                "name": "Presentation.Close (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "ppPres.Close",
                "description": "關閉指定的 PowerPoint 簡報。如果簡報有未儲存的變更，PowerPoint 會提示使用者儲存。",
                "parameters": [],
                "examples": [
                    {"code": "Dim ppPres As Object ' 假設 ppPres 是一個 Presentation 物件\n' ppPres.Close\n' MsgBox \"簡報已關閉。\" ' 如果有未儲存變更會提示", "explanation": "關閉簡報。PowerPoint 通常會處理儲存提示。"},
                    {"code": "Dim ppApp As Object\nSet ppApp = CreateObject(\"PowerPoint.Application\")\n' ... 開啟或建立簡報 ...\n' If ppApp.Presentations.Count > 0 Then\n'   Dim ppPresToClose As Object\n'   Set ppPresToClose = ppApp.Presentations(1)\n'   If ppPresToClose.Saved = msoFalse Then ppPresToClose.Save ' 先儲存\n'   ppPresToClose.Close\n' End If\n' If ppApp.Presentations.Count = 0 Then ppApp.Quit", "explanation": "儲存第一個開啟的簡報（如果未儲存），然後關閉它。如果沒有其他簡報開啟，則關閉 PowerPoint。"}
                ],
                "keywords": ["powerpoint close presentation", "close file ppt", "ppt", "關閉簡報", "關閉PPT"]
            },
            {
                "name": "Slides.Add (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set ppSlide = ppPres.Slides.Add(Index As Long, Layout As PpSlideLayout)",
                "description": "在簡報中新增一張投影片到 Slides 集合中，並傳回代表新投影片的 Slide 物件。",
                "parameters": [
                    {"name": "Index", "description": "必需。新投影片在 Slides 集合中的索引號。"},
                    {"name": "Layout", "description": "必需。PpSlideLayout 常數，指定要套用於新投影片的版面配置 (例如，ppLayoutTitle, ppLayoutText, ppLayoutBlank)。"}
                ],
                "examples": [
                    {"code": "Dim ppPres As Object, ppSlide As Object\n' Set ppPres = ActivePresentation ' 假設在 PowerPoint 中執行\n' Set ppSlide = ppPres.Slides.Add(Index:=ppPres.Slides.Count + 1, Layout:=1) ' 1 = ppLayoutTitle\n' ppSlide.Shapes.Title.TextFrame.TextRange.Text = \"我的新標題投影片\"\n' MsgBox \"已新增標題投影片。\"", "explanation": "在簡報末尾新增一張標題投影片，並設定其標題文字。"}
                ],
                "keywords": ["powerpoint add slide", "new slide ppt", "create slide", "ppt", "新增投影片", "建立PPT頁"]
            },
            {
                "name": "Slides.FindBySlideID (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set ppSlide = ppPres.Slides.FindBySlideID(SlideID As Long)",
                "description": "從 Slides 集合傳回具有指定投影片 ID 的 Slide 物件。每個投影片都有一個唯一的 ID。",
                "parameters": [{"name": "SlideID", "description": "必需。要尋找的投影片的 ID 號碼。"}],
                "examples": [
                    {"code": "Dim ppPres As Object, targetSlide As Object, sld As Object\nDim firstSlideID As Long\n' Set ppPres = ActivePresentation\n' If ppPres.Slides.Count > 0 Then\n'   firstSlideID = ppPres.Slides(1).SlideID\n'   Set targetSlide = ppPres.Slides.FindBySlideID(firstSlideID)\n'   If Not targetSlide Is Nothing Then\n'     MsgBox \"找到 ID 為 \" & firstSlideID & \" 的投影片，名稱為: \" & targetSlide.Name\n'   End If\n' End If", "explanation": "獲取第一張投影片的 ID，然後使用該 ID 再次尋找並驗證該投影片。"}
                ],
                "keywords": ["powerpoint find slide by id", "get slide by id", "slide id", "ppt", "依ID尋找投影片"]
            },
            {
                "name": "Slide.Shapes (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set shps = ppSlide.Shapes",
                "description": "傳回一個 Shapes 集合，代表指定投影片上的所有圖案 (包括文字方塊、圖片、圖表、SmartArt 等)。",
                "parameters": [],
                "examples": [
                    {"code": "Dim ppSlide As Object, shp As Object ' PowerPoint.Shape\n' Set ppSlide = ActiveWindow.View.Slide ' 假設在 PowerPoint 編輯模式下\n' For Each shp In ppSlide.Shapes\n'   If shp.HasTextFrame Then\n'     If shp.TextFrame.HasText Then\n'       Debug.Print \"圖案 '\" & shp.Name & \"' 包含文字: \" & shp.TextFrame.TextRange.Text\n'     End If\n'   End If\n' Next shp", "explanation": "遍歷目前投影片上的所有圖案，如果圖案包含文字，則列印其名稱和文字內容。"}
                ],
                "keywords": ["powerpoint slide shapes", "shapes collection ppt", "access shapes", "ppt", "投影片圖案", "圖案集合"]
            },
            {
                "name": "Shapes.AddTextbox (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set shpTextBox = ppSlide.Shapes.AddTextbox(Orientation As MsoTextOrientation, Left As Single, Top As Single, Width As Single, Height As Single)",
                "description": "在投影片上建立一個新的文字方塊，並傳回代表該文字方塊的 Shape 物件。",
                "parameters": [
                    {"name": "Orientation", "description": "必需。文字方塊的文字方向 (例如，msoTextOrientationHorizontal)。"},
                    {"name": "Left, Top", "description": "必需。文字方塊左上角的水平和垂直位置 (以點為單位)。"},
                    {"name": "Width, Height", "description": "必需。文字方塊的寬度和高度 (以點為單位)。"}
                ],
                "examples": [
                    {"code": "Dim ppSlide As Object, newTextBox As Object ' PowerPoint.Shape\n' Set ppSlide = ActivePresentation.Slides(1)\n' Set newTextBox = ppSlide.Shapes.AddTextbox(Orientation:=1, Left:=72, Top:=72, Width:=288, Height:=36) ' 1=msoTextOrientationHorizontal\n' newTextBox.TextFrame.TextRange.Text = \"這是新的文字方塊內容。\"\n' newTextBox.TextFrame.TextRange.Font.Size = 18", "explanation": "在第一張投影片上新增一個文字方塊，設定其內容和字型大小。"}
                ],
                "keywords": ["powerpoint add textbox", "insert text box ppt", "create textbox", "ppt", "新增文字方塊", "插入文字框"]
            },
            {
                "name": "Shapes.AddPicture (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set shpPic = ppSlide.Shapes.AddPicture(FileName, LinkToFile, SaveWithDocument, Left, Top, [Width], [Height])",
                "description": "將圖片檔案新增至投影片作為一個 Shape 物件。",
                "parameters": [
                    {"name": "FileName", "description": "必需。圖片檔案的完整路徑。"},
                    {"name": "LinkToFile", "description": "必需。MsoTriState 常數 (msoTrue/msoFalse)。"},
                    {"name": "SaveWithDocument", "description": "必需。MsoTriState 常數 (msoTrue/msoFalse)。"},
                    {"name": "Left, Top", "description": "必需。圖片左上角的位置。"},
                    {"name": "Width, Height", "description": "可選。圖片的寬度和高度。如果省略，則使用圖片的原始尺寸。"}
                ],
                "examples": [
                    {"code": "Dim ppSlide As Object, imgShape As Object ' PowerPoint.Shape\n' Set ppSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, 12) ' 12 = ppLayoutBlank\n' Set imgShape = ppSlide.Shapes.AddPicture(FileName:=\"C:\\Pictures\\Sample.jpg\", _\n'                                       LinkToFile:=msoFalse, SaveWithDocument:=msoTrue, _\n'                                       Left:=50, Top:=50, Width:=200, Height:=150)\n' MsgBox \"圖片 '\" & imgShape.Name & \"' 已新增至新投影片。\"", "explanation": "在新投影片上新增一張圖片，並設定其位置和大小。"}
                ],
                "keywords": ["powerpoint add picture shape", "insert image shape ppt", "add floating picture ppt", "ppt", "新增圖片(圖案)", "插入圖片(浮動)"]
            },
            {
                "name": "Shape.TextFrame (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set tf = shpObject.TextFrame",
                "description": "如果圖案包含文字框，則傳回代表該圖案文字框的 TextFrame 物件。",
                "parameters": [],
                "examples": [
                    {"code": "Dim shp As Object ' PowerPoint.Shape, 假設 shp 是投影片上的一個圖案\n' If shp.HasTextFrame Then\n'   With shp.TextFrame\n'     If .HasText Then\n'       .TextRange.Text = \"已更新的文字內容\"\n'       .TextRange.Font.Bold = msoTrue\n'       .TextRange.Font.Color.RGB = RGB(255, 0, 0)\n'       .HorizontalAnchor = msoAnchorCenter ' 水平置中\n'       .VerticalAnchor = msoAnchorMiddle   ' 垂直置中\n'     End If\n'   End With\n' End If", "explanation": "檢查圖案是否有文字框，如果有文字，則更新其內容並設定文字格式與對齊。"}
                ],
                "keywords": ["powerpoint textframe", "shape text content", "format shape text", "ppt", "圖案文字框", "設定圖案文字"]
            },
            {
                "name": "TextRange.Text (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "txtRange.Text [= String]",
                "description": "設定或傳回指定 TextRange 物件中的文字。",
                "parameters": [{"name": "String", "description": "要設定的文字。"}],
                "examples": [
                    {"code": "Dim titleShape As Object ' PowerPoint.Shape\n' Set titleShape = ActivePresentation.Slides(1).Shapes.Title ' 假設是標題圖案\n' If Not titleShape Is Nothing Then\n'   titleShape.TextFrame.TextRange.Text = \"VBA 自動化簡報標題\"\n' End If", "explanation": "設定第一張投影片標題圖案的文字內容。"}
                ],
                "keywords": ["powerpoint textrange text", "set text ppt", "get text ppt", "ppt", "文字範圍文字", "設定PPT文字"]
            },
            {
                "name": "TextRange.Font (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set fnt = txtRange.Font",
                "description": "傳回一個 Font 物件，代表指定 TextRange 物件的字元格式。",
                "parameters": [],
                "examples": [
                    {"code": "Dim shp As Object ' PowerPoint.Shape\n' Set shp = ActiveWindow.Selection.ShapeRange(1) ' 假設選取了一個圖案\n' If shp.HasTextFrame Then\n'   With shp.TextFrame.TextRange.Font\n'     .Name = \"Arial Black\"\n'     .Size = 24\n'     .Color.RGB = RGB(0, 51, 102) ' 深藍色\n'     .Bold = msoTrue\n'   End With\n' End If", "explanation": "設定選取圖案中文字的字型名稱、大小、顏色和粗體。"}
                ],
                "keywords": ["powerpoint font object", "format text ppt", "character formatting ppt", "ppt", "PPT字型物件", "文字格式化PPT"]
            },
            {
                "name": "Slide.SlideShowTransition (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set sst = ppSlide.SlideShowTransition",
                "description": "傳回一個 SlideShowTransition 物件，代表指定投影片的特殊效果設定，用於投影片切換。",
                "parameters": [],
                "examples": [
                    {"code": "Dim ppSlide As Object ' PowerPoint.Slide\n' Set ppSlide = ActivePresentation.Slides(1)\n' With ppSlide.SlideShowTransition\n'   .AdvanceOnTime = msoTrue ' 設定為按時間換頁\n'   .AdvanceTime = 5 ' 5 秒後換頁\n'   .EntryEffect = ppEffectFade ' 淡出效果 (ppEffectFade = 769)\n'   .Speed = ppTransitionSpeedMedium ' 中速\n' End With", "explanation": "設定第一張投影片的切換效果為淡出、中速，並在 5 秒後自動換頁。"}
                ],
                "keywords": ["powerpoint slide transition", "animation effects ppt", "slide change effect", "ppt", "投影片切換動畫", "換頁效果"]
            },
            {
                "name": "Slide.NotesPage (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set np = ppSlide.NotesPage",
                "description": "傳回一個 SlideRange 物件，代表指定投影片的備忘稿頁面。",
                "parameters": [],
                "examples": [
                    {"code": "Dim ppSlide As Object, notesTextRange As Object ' PowerPoint.TextRange\n' Set ppSlide = ActivePresentation.Slides(1)\n' If ppSlide.NotesPage.Shapes.Placeholders.Count >= 2 Then ' 假設備忘稿區是第二個預留位置\n'   Set notesTextRange = ppSlide.NotesPage.Shapes.Placeholders(2).TextFrame.TextRange\n'   notesTextRange.Text = \"這是第一張投影片的演講者備忘稿。\" & vbCrLf & \"- 強調要點 A\" & vbCrLf & \"- 說明圖表 B\"\n'   MsgBox \"備忘稿已更新。\"\n' End If", "explanation": "在第一張投影片的備忘稿頁面中新增或更新文字。"}
                ],
                "keywords": ["powerpoint notes page", "speaker notes ppt", "add notes to slide", "ppt", "投影片備忘稿", "演講者備註"]
            },
            {
                "name": "Presentation.SlideShowSettings (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "Set sss = ppPres.SlideShowSettings",
                "description": "傳回一個 SlideShowSettings 物件，代表指定簡報的投影片放映設定。",
                "parameters": [],
                "examples": [
                    {"code": "Dim ppPres As Object ' PowerPoint.Presentation\n' Set ppPres = ActivePresentation\n' With ppPres.SlideShowSettings\n'   .LoopUntilStopped = msoTrue ' 循環播放直到手動停止\n'   .ShowType = ppShowTypeSpeaker ' 演講者放映 (全螢幕)\n'   .AdvanceMode = ppSlideShowUseSlideTimings ' 使用投影片計時\n'   ' .RangeType = ppShowNamedShow ' 如果要播放自訂放映，則設定此項\n'   ' .NamedSlideShow = \"MyCustomShowName\"\n' End With\n' ' ppPres.SlideShowSettings.Run ' 開始放映", "explanation": "設定簡報的投影片放映選項，例如循環播放、使用演講者模式和使用投影片計時。"}
                ],
                "keywords": ["powerpoint slideshow settings", "configure slideshow", "run slideshow", "ppt", "投影片放映設定", "設定播放"]
            },
            {
                "name": "SlideShowSettings.Run (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "sssObject.Run",
                "description": "開始使用 SlideShowSettings 物件中定義的設定來執行投影片放映。",
                "parameters": [],
                "examples": [
                    {"code": "Dim ppPres As Object ' PowerPoint.Presentation\n' Set ppPres = ActivePresentation\n' With ppPres.SlideShowSettings\n'   .StartingSlide = 1\n'   .EndingSlide = ppPres.Slides.Count\n'   .ShowWithAnimation = msoTrue\n' End With\n' ppPres.SlideShowSettings.Run\n' MsgBox \"投影片放映已開始。\"", "explanation": "執行從第一張到最後一張的完整投影片放映，並啟用動畫。"}
                ],
                "keywords": ["powerpoint run slideshow", "start presentation", "play slideshow", "ppt", "執行投影片放映", "開始播放"]
            },
            {
                "name": "Slide.Export (PowerPoint)", "category": "PowerPoint 簡報製作",
                "syntax": "ppSlide.Export(FileName As String, FilterName As String, [ScaleWidth As Long], [ScaleHeight As Long])",
                "description": "將投影片匯出為圖形檔案。",
                "parameters": [
                    {"name": "FileName", "description": "必需。要建立的圖形檔案的完整路徑和名稱。"},
                    {"name": "FilterName", "description": "必需。圖形篩選器的檔案副檔名 (例如 \"JPG\", \"PNG\", \"GIF\", \"BMP\")。"}
                ],
                "examples": [
                    {"code": "Dim ppSlide As Object ' PowerPoint.Slide\n' Set ppSlide = ActivePresentation.Slides(1)\n' On Error Resume Next\n' ppSlide.Export FileName:=\"C:\\Exports\\Slide1_Image.PNG\", FilterName:=\"PNG\"\n' If Err.Number = 0 Then\n'   MsgBox \"第一張投影片已匯出為 PNG 圖片。\"\n' Else\n'   MsgBox \"匯出失敗: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "將第一張投影片匯出為 PNG 格式的圖片檔案。"}
                ],
                "keywords": ["powerpoint export slide", "save slide as image", "convert slide to picture", "ppt", "匯出投影片", "另存投影片為圖片"]
            },

            // --- Excel 資料分析與樞紐 (Excel Data Analysis & PivotTables) ---
            {
                "name": "Workbook.PivotCaches.Create", "category": "Excel 資料分析與樞紐",
                "syntax": "Set ptCache = ActiveWorkbook.PivotCaches.Create(SourceType As XlPivotTableSourceType, SourceData, [Version])",
                "description": "建立一個新的樞紐分析表快取。PivotCache 物件代表樞紐分析表報表的記憶體快取。",
                "parameters": [
                {"name": "SourceType", "description": "必需。來源資料的類型 (例如，xlDatabase, xlExternal)。"},
                {"name": "SourceData", "description": "必需。新快取的資料。可以是 Range 物件、值陣列或指定另一個樞紐分析表報表名稱的字串。"},
                {"name": "Version", "description": "可選。樞紐分析表快取的版本。"}
                ],
                "examples": [
                {"code": "Dim ptCache As PivotCache\nDim dataSheet As Worksheet, ptSheet As Worksheet\nDim sourceRange As Range\n\nSet dataSheet = ThisWorkbook.Sheets(\"SourceDataSheet\")\nSet ptSheet = ThisWorkbook.Sheets(\"PivotTableSheet\")\n' Assuming data is in A1 to D100 on dataSheet\nSet sourceRange = dataSheet.Range(\"A1:D100\")\n\nSet ptCache = ThisWorkbook.PivotCaches.Create(SourceType:=xlDatabase, SourceData:=sourceRange)\nMsgBox \"PivotCache created from range: \" & sourceRange.Address(External:=True)", "explanation": "從 'SourceDataSheet' 上的資料範圍建立 PivotCache。然後可以使用此快取建立樞紐分析表。"}
                ],
                "keywords": ["pivotcache create", "excel pivottable cache", "create pivot cache", "樞紐分析表快取", "建立快取", "excel"]
            },
            {
                "name": "PivotCache.CreatePivotTable", "category": "Excel 資料分析與樞紐",
                "syntax": "Set pt = ptCache.CreatePivotTable(TableDestination, [TableName], [ReadData], [DefaultVersion])",
                "description": "根據 PivotCache 建立樞紐分析表報表。",
                "parameters": [
                {"name": "TableDestination", "description": "必需。一個 Range 物件，指定樞紐分析表報表應放置於工作表上的位置。"},
                {"name": "TableName", "description": "可選。一個字串，指定新樞紐分析表報表的名稱。"},
                {"name": "ReadData", "description": "可選。True 表示建立包含外部資料庫所有記錄的樞紐分析表快取；然後使用此快取建立樞紐分析表報表。"}
                ],
                "examples": [
                {"code": "Dim ptCache As PivotCache, pt As PivotTable\nDim ptSheet As Worksheet, destRange As Range\n\n' Assume ptCache is already created (see PivotCaches.Create example)\nSet ptCache = ThisWorkbook.PivotCaches(1) ' Assuming one cache exists\nSet ptSheet = ThisWorkbook.Sheets.Add ' Add a new sheet for the PivotTable\nptSheet.Name = \"MyNewPivot\"\nSet destRange = ptSheet.Range(\"A3\")\n\nSet pt = ptCache.CreatePivotTable(TableDestination:=destRange, TableName:=\"SalesPivot\")\nMsgBox \"PivotTable '\" & pt.Name & \"' created on sheet '\" & ptSheet.Name & \"' at \" & destRange.Address", "explanation": "使用現有的 PivotCache 在新工作表的儲存格 A3 上建立名為 'SalesPivot' 的樞紐分析表。"}
                ],
                "keywords": ["create pivottable", "pivottable from cache", "new pivottable", "建立樞紐分析表", "excel"]
            },
            {
                "name": "PivotTable.PivotFields", "category": "Excel 資料分析與樞紐",
                "syntax": "Set pf = pt.PivotFields(IndexOrName)",
                "description": "從樞紐分析表的 PivotFields 集合傳回單一 PivotField 物件。PivotField 代表樞紐分析表報表中的一個欄位。",
                "parameters": [
                {"name": "IndexOrName", "description": "欄位的名稱或索引編號。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable, pf_Product As PivotField\n' Assume pt is an existing PivotTable object\nSet pt = ActiveSheet.PivotTables(\"SalesPivot\")\n\nOn Error Resume Next ' In case 'Product' field doesn't exist\nSet pf_Product = pt.PivotFields(\"Product\")\nIf Err.Number = 0 Then\n  pf_Product.Orientation = xlRowField ' Set 'Product' as a Row field\n  pf_Product.Position = 1\n  MsgBox \"'Product' field set as row field.\"\nElse\n  MsgBox \"Field 'Product' not found.\"\nEnd If\nOn Error GoTo 0", "explanation": "存取 'SalesPivot' 樞紐分析表中的 'Product' 欄位，並將其設定為列欄位。"}
                ],
                "keywords": ["pivotfield", "pivottable field", "access pivot field", "樞紐分析表欄位", "excel"]
            },
            {
                "name": "PivotField.Orientation", "category": "Excel 資料分析與樞紐",
                "syntax": "pivotFieldObject.Orientation = XlPivotFieldOrientation",
                "description": "設定或傳回欄位在樞紐分析表報表中的位置。(例如，xlRowField, xlColumnField, xlPageField, xlDataField, xlHidden)。",
                "parameters": [
                {"name": "XlPivotFieldOrientation", "description": "一個指定方向的常數。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable\n' Assume pt is an existing PivotTable object for sales data\nSet pt = ActiveSheet.PivotTables(1)\npt.PivotFields(\"Region\").Orientation = xlRowField\npt.PivotFields(\"Category\").Orientation = xlColumnField\npt.PivotFields(\"SalesAmount\").Orientation = xlDataField\npt.PivotFields(\"SalesAmount\").Function = xlSum ' Summarize by Sum\npt.PivotFields(\"SalesAmount\").NumberFormat = \"#,##0.00\"", "explanation": "設定樞紐分析表：'Region' 為列，'Category' 為欄，'SalesAmount' 為資料 (加總並格式化)。"}
                ],
                "keywords": ["pivotfield orientation", "row field", "column field", "data field", "page field", "欄位方向", "列欄位", "欄欄位", "資料欄位", "excel"]
            },
            {
                "name": "PivotField.Function", "category": "Excel 資料分析與樞紐",
                "syntax": "dataFieldObject.Function = XlConsolidationFunction",
                "description": "設定或傳回用於摘要樞紐分析表資料欄位的函數 (例如，xlSum, xlCount, xlAverage, xlMax, xlMin)。僅適用於資料欄位。",
                "parameters": [
                {"name": "XlConsolidationFunction", "description": "一個指定摘要函數的常數。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable, pf_Sales As PivotField\nSet pt = ActiveSheet.PivotTables(1)\nSet pf_Sales = pt.PivotFields(\"Revenue\")\n\nIf pf_Sales.Orientation <> xlDataField Then\n  pf_Sales.Orientation = xlDataField\nEnd If\n\npf_Sales.Function = xlAverage ' Change summarization to Average\nMsgBox \"'Revenue' field is now summarized by Average.\"", "explanation": "將樞紐分析表中的 'Revenue' 資料欄位設定為依平均值摘要。"}
                ],
                "keywords": ["pivotfield function", "summarize by", "sum", "average", "count", "pivottable calculation", "欄位函數", "摘要方式", "excel"]
            },
            {
                "name": "PivotTable.AddDataField", "category": "Excel 資料分析與樞紐",
                "syntax": "Set pf = pt.AddDataField(Field, [Caption], [Function])",
                "description": "將資料欄位新增至樞紐分析表報表。傳回代表新資料欄位的 PivotField 物件。",
                "parameters": [
                {"name": "Field", "description": "必需。要新增為資料欄位的來源資料中的 PivotField 物件。"},
                {"name": "Caption", "description": "可選。樞紐分析表中資料欄位使用的標籤。"},
                {"name": "Function", "description": "可選。用於摘要的 XlConsolidationFunction。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable, pf_Quantity As PivotField\nSet pt = ActiveSheet.PivotTables(1)\n' Assuming \"Quantity\" is a field in the source data\nSet pf_Quantity = pt.AddDataField(pt.PivotFields(\"Quantity\"), \"Total Quantity\", xlSum)\npf_Quantity.NumberFormat = \"#,##0\"", "explanation": "將 'Quantity' 欄位新增至樞紐分析表的資料區域，將其命名為 'Total Quantity'，依加總摘要，並格式化數字。"}
                ],
                "keywords": ["add data field", "pivottable values", "新增資料欄位", "樞紐分析表值", "excel"]
            },
            {
                "name": "PivotTable.TableRange1", "category": "Excel 資料分析與樞紐",
                "syntax": "Set rng = pt.TableRange1",
                "description": "傳回一個 Range 物件，代表包含整個樞紐分析表報表的範圍，但不包括頁面欄位。",
                "parameters": [],
                "examples": [
                {"code": "Dim pt As PivotTable, reportRange As Range\nSet pt = ActiveSheet.PivotTables(1)\nSet reportRange = pt.TableRange1\nreportRange.Font.Name = \"Arial\"\nMsgBox \"Font of PivotTable (excluding page fields) set to Arial. Range: \" & reportRange.Address", "explanation": "取得樞紐分析表主體所佔據的範圍，並將其字型變更為 Arial。"}
                ],
                "keywords": ["pivottable range", "report range", "樞紐分析表範圍", "excel"]
            },
            {
                "name": "PivotTable.TableRange2", "category": "Excel 資料分析與樞紐",
                "syntax": "Set rng = pt.TableRange2",
                "description": "傳回一個 Range 物件，代表包含整個樞紐分析表報表的範圍，包括頁面欄位。",
                "parameters": [],
                "examples": [
                {"code": "Dim pt As PivotTable, fullReportRange As Range\nSet pt = ActiveSheet.PivotTables(1)\nSet fullReportRange = pt.TableRange2\nfullReportRange.CopyPicture Appearance:=xlScreen, Format:=xlBitmap\n' This can then be pasted elsewhere, e.g., Chart.Paste\nMsgBox \"PivotTable (including page fields) copied as picture. Range: \" & fullReportRange.Address", "explanation": "取得整個樞紐分析表 (包括頁面欄位) 的範圍，並將其複製為圖片。"}
                ],
                "keywords": ["pivottable full range", "report with page fields", "樞紐分析表完整範圍", "excel"]
            },
            {
                "name": "PivotTable.RefreshTable", "category": "Excel 資料分析與樞紐",
                "syntax": "pt.RefreshTable",
                "description": "從其來源資料重新整理樞紐分析表報表。",
                "parameters": [],
                "examples": [
                {"code": "Dim pt As PivotTable\nSet pt = ActiveSheet.PivotTables(\"SalesPivot\")\npt.RefreshTable\nMsgBox \"'\" & pt.Name & \"' has been refreshed.\"", "explanation": "重新整理名為 'SalesPivot' 的樞紐分析表。"}
                ],
                "keywords": ["refresh pivottable", "update pivottable", "pivottable data update", "重新整理樞紐分析表", "更新樞紐分析表", "excel"]
            },
            {
                "name": "PivotTable.PivotCache.Refresh", "category": "Excel 資料分析與樞紐",
                "syntax": "pt.PivotCache.Refresh",
                "description": "從來源資料重新整理樞紐分析表的快取。如果來源資料本身的結構或位置已變更，則通常在此之前使用 (不過，對於簡單的資料值變更，RefreshTable 可能已足夠或會自動觸發此動作)。",
                "parameters": [],
                "examples": [
                {"code": "Dim pt As PivotTable\nSet pt = ActiveSheet.PivotTables(\"MainReport\")\npt.PivotCache.Refresh\npt.RefreshTable ' Good practice to refresh table after cache\nMsgBox \"PivotCache for '\" & pt.Name & \"' and the table itself have been refreshed.\"", "explanation": "重新整理 PivotCache，然後重新整理 PivotTable 本身。"}
                ],
                "keywords": ["refresh pivotcache", "update pivotcache", "樞紐分析表快取重新整理", "excel"]
            },
            {
                "name": "PivotItem.Visible", "category": "Excel 資料分析與樞紐",
                "syntax": "pivotFieldObject.PivotItems(IndexOrName).Visible = Boolean",
                "description": "設定或傳回一個布林值，指出 PivotField 中的指定 PivotItem 是否可見 (即包含在報表篩選中)。",
                "parameters": [
                {"name": "Boolean", "description": "True 表示使項目可見，False 表示隱藏它 (篩選掉)。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable, pf_Country As PivotField\nSet pt = ActiveSheet.PivotTables(1)\nSet pf_Country = pt.PivotFields(\"Country\")\n\n' First, make all items visible to reset previous filters on this field\nDim pi As PivotItem\nFor Each pi In pf_Country.PivotItems\n  pi.Visible = True\nNext pi\n\n' Then hide specific items\npf_Country.PivotItems(\"Canada\").Visible = False\npf_Country.PivotItems(\"France\").Visible = False\npt.RefreshTable ' May not be strictly necessary for item visibility changes but good practice\nMsgBox \"PivotTable filtered to exclude Canada and France.\"", "explanation": "透過隱藏 'Country' 欄位中的 'Canada' 和 'France' 項目來篩選樞紐分析表。"}
                ],
                "keywords": ["filter pivottable", "pivotitem visible", "hide pivot item", "show pivot item", "篩選樞紐分析表", "樞紐分析項目可見", "excel"]
            },
            {
                "name": "PivotTable.ShowPages", "category": "Excel 資料分析與樞紐",
                "syntax": "pt.ShowPages(PageField As Object)",
                "description": "為指定頁面欄位中的每個項目建立一個獨立的工作表。每個新工作表都包含一個樞紐分析表報表，僅顯示一個頁面欄位項目的資料。",
                "parameters": [
                {"name": "PageField", "description": "必需。頁面欄位的名稱 (字串) 或 PivotField 物件本身。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable\nSet pt = ActiveSheet.PivotTables(\"RegionalSales\")\n' Ensure \"Region\" is a Page Field (Filter Field)\nIf pt.PageFields.Count > 0 Then\n  On Error Resume Next ' In case field name is wrong or not a page field\n  pt.ShowPages PageField:=\"Region\"\n  If Err.Number = 0 Then\n    MsgBox \"Separate sheets created for each item in the 'Region' page field.\"\n  Else\n    MsgBox \"Could not show pages. Error: \" & Err.Description\n  End If\n  On Error GoTo 0\nElse\n  MsgBox \"No page fields found in the PivotTable.\"\nEnd If", "explanation": "如果 'Region' 是 'RegionalSales' 樞紐分析表中的頁面欄位，則此程式碼會為每個唯一的區域建立一個新工作表，其中包含針對該區域篩選的樞紐分析表。"}
                ],
                "keywords": ["pivottable show pages", "report filter pages", "split pivottable by page field", "顯示報表篩選頁", "excel"]
            },
            {
                "name": "PivotTable.ChangePivotCache", "category": "Excel 資料分析與樞紐",
                "syntax": "pt.ChangePivotCache(PivotCache As Object)",
                "description": "變更指定樞紐分析表的 PivotCache。這對於變更現有樞紐分析表的資料來源很有用。",
                "parameters": [
                {"name": "PivotCache", "description": "必需。將成為新資料來源的 PivotCache 物件。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable, newCache As PivotCache\nDim newDataSource As Range\n\nSet pt = ThisWorkbook.Sheets(\"ReportSheet\").PivotTables(\"SalesSummary\")\n' Assume new data is on \"NewDataSheet\" in range A1:E200\nSet newDataSource = ThisWorkbook.Sheets(\"NewDataSheet\").Range(\"A1:E200\")\n\n' Create a new cache for the new data source\nSet newCache = ThisWorkbook.PivotCaches.Create(SourceType:=xlDatabase, SourceData:=newDataSource)\n\n' Change the PivotTable to use the new cache\npt.ChangePivotCache newCache\npt.RefreshTable\nMsgBox \"PivotTable data source changed and refreshed.\"", "explanation": "透過建立新的 PivotCache 並指派它，將現有樞紐分析表 ('SalesSummary') 的資料來源變更為新的資料範圍。"}
                ],
                "keywords": ["change pivottable source", "update data source pivot", "modify pivotcache", "變更樞紐分析表資料來源", "excel"]
            },
            {
                "name": "PivotTable.DrillDown", "category": "Excel 資料分析與樞紐",
                "syntax": "pivotFieldObject.DrillDown(PivotItem As Object, [Level])",
                "description": "允許您在樞紐分析表報表中向下鑽研 PivotField。如果 OLAP 資料來源，這相當於按兩下 PivotItem，或展開已摺疊的項目。",
                "parameters": [
                {"name": "PivotItem", "description": "必需。要向下鑽研的 PivotItem 物件。"},
                {"name": "Level", "description": "可選。對於 OLAP 資料來源，要向下鑽研的層級。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable, pf_Category As PivotField, pi_Electronics As PivotItem\nSet pt = ActiveSheet.PivotTables(1)\nSet pf_Category = pt.PivotFields(\"Category\")\n' Assume 'Electronics' is an item in 'Category' field and it has sub-items (e.g., Product)\nOn Error Resume Next\nSet pi_Electronics = pf_Category.PivotItems(\"Electronics\")\nIf Not pi_Electronics Is Nothing Then\n  ' For non-OLAP, this usually expands if it was collapsed\n  ' For OLAP, this shows next level of detail\n  ' pf_Category.DrillDown pi_Electronics ' This specific syntax might be more for OLAP\n  ' For non-OLAP, often ShowDetail property is used or direct manipulation of sub-fields\n  pi_Electronics.ShowDetail = True ' More common for non-OLAP to expand\n  MsgBox \"'Electronics' item details shown (if applicable).\"\nElse\n  MsgBox \"PivotItem 'Electronics' not found.\"\nEnd If\nOn Error GoTo 0", "explanation": "嘗試顯示 'Category' 欄位中 'Electronics' 項目的詳細資料 (向下鑽研)。確切的行為和語法在 OLAP 和非 OLAP 樞紐分析表之間可能略有不同。ShowDetail 對於非 OLAP 很常見。"}
                ],
                "keywords": ["pivottable drilldown", "show detail pivot", "expand pivot item", "向下鑽研", "顯示詳細資料", "excel", "OLAP"]
            },
            {
                "name": "PivotItem.ShowDetail", "category": "Excel 資料分析與樞紐",
                "syntax": "pivotItemObject.ShowDetail = Boolean",
                "description": "如果指定 PivotItem 的大綱已展開 (如果項目具有詳細資料)，則為 True。將此屬性設定為 True 相當於展開項目。將其設定為 False 相當於摺疊項目。",
                "parameters": [
                {"name": "Boolean", "description": "True 表示展開，False 表示摺疊。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable, pi As PivotItem\nSet pt = ActiveSheet.PivotTables(1)\n' Assume 'Year' field has items like '2023', '2024'\n' And '2023' has child items (e.g., Quarters or Months)\nOn Error Resume Next\nSet pi = pt.PivotFields(\"Year\").PivotItems(\"2023\")\nIf Not pi Is Nothing Then\n  If pi.ShowDetail = False Then\n    pi.ShowDetail = True\n    MsgBox \"Item '2023' expanded.\"\n  Else\n    pi.ShowDetail = False\n    MsgBox \"Item '2023' collapsed.\"\n  End If\nElse\n  MsgBox \"Item '2023' not found.\"\nEnd If\nOn Error GoTo 0", "explanation": "切換 'Year' 欄位中 '2023' PivotItem 的展開 (ShowDetail)。"}
                ],
                "keywords": ["pivottable expand item", "pivottable collapse item", "show detail", "hide detail", "展開項目", "摺疊項目", "excel"]
            },
            {
                "name": "PivotTable.CalculatedFields.Add", "category": "Excel 資料分析與樞紐",
                "syntax": "Set cf = pt.CalculatedFields.Add(Name As String, Formula As String, [UseStandardFormula As Boolean])",
                "description": "將計算欄位新增至樞紐分析表。計算欄位是基於樞紐分析表中其他欄位的自訂公式。",
                "parameters": [
                {"name": "Name", "description": "必需。新計算欄位的名稱。"},
                {"name": "Formula", "description": "必需。計算欄位的公式，使用以單引號括住的欄位名稱 (例如，'Sales' - 'Cost')。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable, cf_Profit As PivotField\nSet pt = ActiveSheet.PivotTables(1)\n' Assuming 'Sales' and 'Cost' fields exist\nOn Error Resume Next\nSet cf_Profit = pt.CalculatedFields.Add(\"Profit\", \"='Sales' - 'Cost'\")\nIf Err.Number = 0 Then\n  cf_Profit.Orientation = xlDataField\n  cf_Profit.NumberFormat = \"$#,##0.00\"\n  MsgBox \"Calculated field 'Profit' added.\"\nElse\n  MsgBox \"Error adding calculated field: \" & Err.Description\nEnd If\nOn Error GoTo 0", "explanation": "將名為 'Profit' (Sales - Cost) 的計算欄位新增至樞紐分析表，並將其設定為資料欄位。"}
                ],
                "keywords": ["pivottable calculated field", "add calculated item pivot", "custom formula pivot", "計算欄位", "新增計算欄位", "excel"]
            },
            {
                "name": "PivotTable.ClearAllFilters", "category": "Excel 資料分析與樞紐",
                "syntax": "pt.ClearAllFilters",
                "description": "清除目前套用至樞紐分析表的所有篩選，包括所有 PivotFields 的報表篩選、值篩選和標籤篩選。",
                "parameters": [],
                "examples": [
                {"code": "Dim pt As PivotTable\nSet pt = ActiveSheet.PivotTables(\"SalesAnalysis\")\npt.ClearAllFilters\nMsgBox \"All filters cleared from PivotTable '\" & pt.Name & \"'.\"", "explanation": "清除 'SalesAnalysis' 樞紐分析表中的所有篩選。"}
                ],
                "keywords": ["clear pivottable filters", "reset pivot filters", "remove all filters", "清除樞紐分析表篩選", "excel"]
            },
            {
                "name": "PivotTable.DisplayFieldCaptions", "category": "Excel 資料分析與樞紐",
                "syntax": "pt.DisplayFieldCaptions = Boolean",
                "description": "如果樞紐分析表中顯示列和欄欄位標題，則為 True。預設為 True。",
                "parameters": [
                {"name": "Boolean", "description": "True 表示顯示，False 表示隱藏。"}
                ],
                "examples": [
                {"code": "Dim pt As PivotTable\nSet pt = ActiveSheet.PivotTables(1)\npt.DisplayFieldCaptions = False\nMsgBox \"Field captions are now hidden for PivotTable: \" & pt.Name", "explanation": "隱藏樞紐分析表中的欄位標題 (列/欄欄位的標頭)。"}
                ],
                "keywords": ["pivottable field captions", "hide pivot headers", "show pivot headers", "顯示欄位標題", "樞紐分析表標頭", "excel"]
            },
            {
                "name": "自動生成帶有動態圖表的數據透視表報告", "category": "Excel 資料分析與樞紐",
                "syntax": "Scenario: Consolidate raw data from multiple sources (e.g., CSV files or database queries) into a master Excel sheet, create a PivotTable to summarize the data, and then generate a PivotChart based on the PivotTable. The entire process is automated.",
                "description": "此案例演示了如何自動化創建包含動態圖表的數據透視表報告的完整流程。腳本會：1. (可選) 從多個來源（如CSV文件夾或資料庫）導入原始數據，並將其合併到一個Excel工作表（“原始數據表”）中。2. 基於“原始數據表”中的數據創建一個數據透視表快取 (PivotCache)。3. 使用此快取在一個新的工作表（“透視表報告”）上創建一個數據透視表 (PivotTable)。4. 設定數據透視表的行欄位、列欄位、值欄位以及篩選欄位，並指定值欄位的摘要函數（例如，加總、平均、計數）。5. 基於此數據透視表創建一個數據透視圖 (PivotChart)，例如長條圖或折線圖，以視覺化呈現摘要數據。6. 可選地，對圖表進行格式化，例如添加標題、數據標籤、更改顏色等。7. 整個流程可以由一個主VBA過程觸發，實現一鍵生成報告。",
                "parameters": [
                    {"name": "Raw Data Source(s)", "description": "原始數據的位置，可以是Excel範圍、CSV文件路徑、資料庫連接字串和查詢等。"},
                    {"name": "PivotTable Configuration", "description": "定義數據透視表的結構：哪些欄位作為列、欄、值和篩選器。"},
                    {"name": "PivotChart Type and Configuration", "description": "要生成的圖表類型（例如，xlColumnClustered, xlLineMarkers）以及其格式化選項。"},
                    {"name": "Output Worksheets", "description": "指定用於存放原始數據、數據透視表和數據透視圖的工作表名稱。"}
                ],
                "examples": [
                    {"code": "Sub CreateAutomatedPivotReportWithChart()\n    Dim rawDataSheet As Worksheet, pivotSheet As Worksheet\n    Dim sourceDataRange As Range, pivotTableDestination As Range, chartDestination As Range\n    Dim ptCache As PivotCache, pt As PivotTable, ptChart As ChartObject\n    Dim lastRow As Long\n\n    On Error GoTo ErrorHandler\n    Application.ScreenUpdating = False\n    Application.DisplayAlerts = False\n\n    ' --- 0. (Optional) Setup: Ensure sheets exist, clear previous content ---\n    On Error Resume Next ' Create sheets if they don't exist\n    Set rawDataSheet = ThisWorkbook.Sheets(\"RawDataSource\")\n    If rawDataSheet Is Nothing Then Set rawDataSheet = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count)): rawDataSheet.Name = \"RawDataSource\"\n    Set pivotSheet = ThisWorkbook.Sheets(\"PivotReportSheet\")\n    If pivotSheet Is Nothing Then Set pivotSheet = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count)): pivotSheet.Name = \"PivotReportSheet\"\n    On Error GoTo ErrorHandler\n    pivotSheet.Cells.Clear\n    ' rawDataSheet.Cells.ClearContents ' Usually, raw data is imported or already there\n\n    ' --- 1. Define Source Data (Assuming data is already in RawDataSource sheet) ---\n    ' Example: Raw data in A1:E100 with headers in row 1.\n    ' Columns: Region, ProductCategory, Salesperson, OrderDate, SalesAmount\n    If rawDataSheet.Cells(1, 1).Value = \"\" Then ' Basic check if raw data sheet is empty\n        MsgBox \"原始數據工作表 'RawDataSource' 為空或未正確設定。請先填入數據。\", vbExclamation\n        GoTo CleanUp\n    End If\n    lastRow = rawDataSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n    Set sourceDataRange = rawDataSheet.Range(\"A1:E\" & lastRow) ' Adjust columns as needed\n\n    ' --- 2. Create PivotCache ---\n    ' Delete old PivotCaches to avoid conflicts if re-running\n    Dim tempCache As PivotCache\n    For Each tempCache In ThisWorkbook.PivotCaches\n        On Error Resume Next ' In case a cache is in use by a table on a protected sheet\n        tempCache.CreatePivotTable \"NUL\" ' Hack to check if it can be deleted\n        If Err.Number = 0 Then tempCache.Delete Else Err.Clear\n        On Error GoTo ErrorHandler\n    Next tempCache\n    \n    Set ptCache = ThisWorkbook.PivotCaches.Create(SourceType:=xlDatabase, SourceData:=sourceDataRange, Version:=xlPivotTableVersion15) ' Or newer version if available\n\n    ' --- 3. Create PivotTable ---\n    Set pivotTableDestination = pivotSheet.Range(\"A3\")\n    ' Delete existing PivotTable if it exists at the destination to avoid overlap or errors\n    On Error Resume Next\n    pivotSheet.PivotTables(pivotSheet.Range(pivotTableDestination.Address).PivotTable.Name).TableRange2.Clear\n    On Error GoTo ErrorHandler\n\n    Set pt = ptCache.CreatePivotTable(TableDestination:=pivotTableDestination, TableName:=\"SalesPivotSummary\")\n\n    ' --- 4. Configure PivotTable Fields ---\n    With pt\n        ' Row Fields\n        With .PivotFields(\"Region\")\n            .Orientation = xlRowField\n            .Position = 1\n        End With\n        With .PivotFields(\"ProductCategory\")\n            .Orientation = xlRowField\n            .Position = 2\n        End With\n        ' Column Fields\n        ' With .PivotFields(\"Salesperson\") ' Example if Salesperson was a column field\n        '     .Orientation = xlColumnField\n        '     .Position = 1\n        ' End With\n        ' Value Fields\n        With .PivotFields(\"SalesAmount\")\n            .Orientation = xlDataField\n            .Function = xlSum\n            .Name = \"總銷售額\" ' CHINESE\n            .NumberFormat = \"#,##0.00 €\"\n        End With\n        ' Filter Fields (Page Fields)\n        With .PivotFields(\"OrderDate\") ' Assuming OrderDate is a date field\n            .Orientation = xlPageField\n            .Position = 1\n            ' Optional: Group by month if OrderDate is detailed\n            ' .DataRange.Cells(1).Group Start:=True, End:=True, Periods:=Array(False, False, False, False, True, False, False) ' Group by Months (xlMonths = 4)\n        End With\n        .RowGrand = True\n        .ColumnGrand = True\n        .NullString = \"(空白)\" ' CHINESE\n        .DisplayErrorString = True\n        .ErrorString = \"#錯誤!\" ' CHINESE\n    End With\n\n    ' --- 5. Create PivotChart ---\n    ' Delete old chart if it exists\n    On Error Resume Next\n    pivotSheet.ChartObjects(\"SalesSummaryChart\").Delete\n    On Error GoTo ErrorHandler\n\n    Set chartDestination = pivotSheet.Range(\"G3\") ' Position chart next to PivotTable\n    Set ptChart = pivotSheet.ChartObjects.Add(Left:=chartDestination.Left, Width:=450, Top:=chartDestination.Top, Height:=300)\n    \n    With ptChart.Chart\n        .SetSourceData Source:=pt.TableRange1 ' Base chart on the PivotTable data area\n        .ChartType = xlColumnClustered ' Example: Clustered Column Chart\n        .HasTitle = True\n        .ChartTitle.Text = \"按區域和產品類別劃分的銷售額\" ' CHINESE\n        .HasLegend = True\n        .Legend.Position = xlLegendPositionBottom\n        ' Further chart formatting...\n        ' Example: Add data labels to the first series\n        ' If .SeriesCollection.Count > 0 Then\n        '    .SeriesCollection(1).ApplyDataLabels\n        ' End If\n    End With\n    ptChart.Name = \"SalesSummaryChart\"\n\n    pivotSheet.Activate\n    MsgBox \"數據透視表和圖表報告已成功生成！\", vbInformation\n\nCleanUp:\n    Application.ScreenUpdating = True\n    Application.DisplayAlerts = True\n    Set rawDataSheet = Nothing: Set pivotSheet = Nothing: Set sourceDataRange = Nothing\n    Set ptCache = Nothing: Set pt = Nothing: Set ptChart = Nothing\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"生成報告時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & _\n           \"錯誤描述: \" & Err.Description & vbCrLf & _\n           \"來源: \" & Err.Source, vbCritical\n    Resume CleanUp\nEnd Sub", "explanation": "此VBA子程序首先確保“RawDataSource”和“PivotReportSheet”工作表存在。然後，它從“RawDataSource”讀取數據範圍以創建一個PivotCache。接下來，它在“PivotReportSheet”上使用此快取創建一個名為“SalesPivotSummary”的數據透視表，並配置其行欄位（區域、產品類別）、值欄位（銷售額總和）和篩選欄位（訂單日期）。最後，它基於此數據透視表創建一個簇狀柱形圖，並對其進行基本格式化。腳本中包含了清理先前內容和錯誤處理的邏輯。數據源和欄位名稱應根據實際情況進行調整。"}
                ],
                "keywords": ["vba create pivottable and chart", "automate excel pivot report", "dynamic pivotchart vba", "excel data analysis automation", "excel reporting automation", "數據透視表自動化", "動態樞紐分析圖", "Excel報告生成"]
            },
            {
                "name": "執行複雜條件篩選與數據提取", "category": "Excel 資料分析與樞紐",
                "syntax": "Scenario: Apply multiple complex criteria (e.g., date ranges, text contains, numerical thresholds) to a large dataset in Excel, extract the matching rows to a new sheet, and then perform summary calculations on the extracted data.",
                "description": "此案例演示瞭如何使用VBA對大型數據集執行高級篩選，然後對篩選結果進行進一步處理。腳本會：1. 識別包含原始數據的Excel工作表和數據範圍。2. 定義一組篩選條件。這些條件可以涉及多個列，並且可以是多種類型，例如：a. 日期範圍 (例如，過去一個月的所有記錄)。b. 文本包含 (例如，產品描述中包含“關鍵字”)。c. 數值比較 (例如，銷售額大於1000且利潤率小於20%)。d. 多個OR條件 (例如，狀態為“已完成”或“待處理”)。3. 使用Excel的AutoFilter功能或更靈活的循環遍歷方法來應用這些篩選條件。對於非常複雜的邏輯，循環遍歷和條件判斷可能更合適，儘管速度可能較慢。4. 將所有符合所有篩選條件的數據行複製到一個新的“篩選結果”工作表中。5. (可選) 在“篩選結果”工作表上執行摘要計算，例如計算符合條件的記錄數、總金額、平均值，或創建一個小型的摘要表格。6. 清除原始數據表上的篩選（如果使用了AutoFilter）。",
                "parameters": [
                    {"name": "Source Data Sheet and Range", "description": "包含原始數據的Excel工作表及範圍。"},
                    {"name": "Filter Criteria", "description": "一個或多個篩選條件的集合，每個條件指定列、比較運算符和值。"},
                    {"name": "Output Sheet for Filtered Data", "description": "用於存放篩選後數據的新工作表。"},
                    {"name": "Summary Calculations (Optional)", "description": "在篩選數據上執行的計算類型。"}
                ],
                "examples": [
                    {"code": "Sub AdvancedFilterAndExtractData()\n    Dim sourceSheet As Worksheet, filteredSheet As Worksheet\n    Dim sourceRange As Range, dataBodyRange As Range\n    Dim lastRowSource As Long, lastColSource As Long, nextFilteredRow As Long\n    Dim criteriaDateStart As Date, criteriaDateEnd As Date\n    Dim criteriaText As String, criteriaValueMin As Double\n    Dim i As Long, criteriaMet As Boolean\n\n    ' --- Configuration ---\n    Set sourceSheet = ThisWorkbook.Sheets(\"AllTransactions\") ' 原始數據表\n    On Error Resume Next\n    Set filteredSheet = ThisWorkbook.Sheets(\"FilteredResults\")\n    If filteredSheet Is Nothing Then\n        Set filteredSheet = ThisWorkbook.Sheets.Add(After:=sourceSheet)\n        filteredSheet.Name = \"FilteredResults\"\n    End If\n    On Error GoTo ErrorHandler\n    filteredSheet.Cells.ClearContents\n    nextFilteredRow = 1 ' Start writing from row 1 on filtered sheet\n\n    ' Define filter criteria (examples)\n    criteriaDateStart = DateSerial(Year(Now), Month(Now) - 1, 1) ' Start of last month\n    criteriaDateEnd = DateSerial(Year(Now), Month(Now), 1) - 1     ' End of last month\n    criteriaText = \"urgent\"\n    criteriaValueMin = 500\n    ' Assume: Col A=TransactionID, B=TransactionDate, C=Description, D=Amount, E=Status\n\n    Application.ScreenUpdating = False\n\n    If sourceSheet.FilterMode Then sourceSheet.ShowAllData ' Clear any existing filters\n\n    lastRowSource = sourceSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n    If lastRowSource < 2 Then MsgBox \"數據源為空或只有表頭。\", vbInformation: GoTo CleanUp ' Assume row 1 is header\n    \n    ' Copy headers to filtered sheet\n    sourceSheet.Rows(1).Copy filteredSheet.Rows(1)\n    nextFilteredRow = 2\n\n    ' --- Loop through data and apply criteria (Manual Filtering Approach) ---\n    For i = 2 To lastRowSource\n        criteriaMet = True ' Assume criteria are met until proven otherwise\n        \n        ' Criterion 1: Date Range (Column B)\n        Dim transDate As Date\n        If IsDate(sourceSheet.Cells(i, \"B\").Value) Then\n            transDate = CDate(sourceSheet.Cells(i, \"B\").Value)\n            If Not (transDate >= criteriaDateStart And transDate <= criteriaDateEnd) Then\n                criteriaMet = False\n            End If\n        Else ' If date is not valid, consider it not meeting date criteria\n            criteriaMet = False \n        End If\n\n        ' Criterion 2: Text Contains (Column C) - only if previous criteria met\n        If criteriaMet Then\n            If InStr(1, LCase(CStr(sourceSheet.Cells(i, \"C\").Value)), LCase(criteriaText)) = 0 Then\n                criteriaMet = False\n            End If\n        End If\n\n        ' Criterion 3: Numerical Threshold (Column D) - only if previous criteria met\n        If criteriaMet Then\n            If Not (IsNumeric(sourceSheet.Cells(i, \"D\").Value) And CDbl(sourceSheet.Cells(i, \"D\").Value) > criteriaValueMin) Then\n                criteriaMet = False\n            End If\n        End If\n        \n        ' Criterion 4: Status is 'Completed' OR 'Pending' (Column E) - example of OR logic\n        ' If criteriaMet Then\n        '    Dim currentStatus As String\n        '    currentStatus = LCase(Trim(CStr(sourceSheet.Cells(i, \"E\").Value)))\n        '    If Not (currentStatus = \"completed\" Or currentStatus = \"pending\") Then\n        '        criteriaMet = False\n        '    End If\n        ' End If\n\n        ' --- If all criteria are met, copy the row ---\n        If criteriaMet Then\n            sourceSheet.Rows(i).Copy filteredSheet.Rows(nextFilteredRow)\n            nextFilteredRow = nextFilteredRow + 1\n        End If\n        \n        If i Mod 100 = 0 Then DoEvents ' Yield for large datasets\n    Next i\n    \n    filteredSheet.Columns.AutoFit\n\n    ' --- (Optional) Perform summary calculations on filteredSheet ---\n    If nextFilteredRow > 2 Then ' If data was copied (beyond header)\n        Dim sumFilteredAmount As Double\n        sumFilteredAmount = Application.WorksheetFunction.Sum(filteredSheet.Range(\"D2:D\" & nextFilteredRow - 1))\n        filteredSheet.Cells(nextFilteredRow + 1, \"C\").Value = \"篩選後總金額:\"\n        filteredSheet.Cells(nextFilteredRow + 1, \"D\").Value = sumFilteredAmount\n        filteredSheet.Cells(nextFilteredRow + 1, \"D\").NumberFormat = \"#,##0.00\"\n    End If\n\n    MsgBox (nextFilteredRow - 2) & \" 條記錄符合篩選條件並已提取。\", vbInformation\n\nCleanUp:\n    Application.ScreenUpdating = True\n    Set sourceSheet = Nothing: Set filteredSheet = Nothing: Set sourceRange = Nothing\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"執行篩選和提取時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub", "explanation": "此VBA子程序首先設置源數據表和目標篩選結果表。它定義了一些篩選條件（上個月的日期範圍、描述包含特定文本、金額大於閾值）。然後，它逐行遍歷源數據，檢查每行是否同時滿足所有這些條件。如果滿足，則將該行複製到“FilteredResults”工作表中。最後，它會在篩選結果表上計算篩選後金額的總和。此範例採用手動循環和判斷的方式進行篩選，對於非常複雜的AND/OR邏輯組合可能更靈活，但對於超大數據集，Excel內建的AdvancedFilter（如果適用）或ADO查詢可能會更快。"}
                ],
                "keywords": ["vba advanced filter excel", "excel data extraction multiple criteria", "filter and copy data vba", "excel conditional data processing", "excel data analysis automation", "多條件篩選Excel", "VBA提取數據", "複雜數據篩選"]
            },
            {
                "name": "基於動態條件生成帶有公式的摘要報告", "category": "Excel 資料分析與樞紐",
                "syntax": "Scenario: Create a summary report sheet where rows represent categories (e.g., products, regions) and columns represent metrics (e.g., Total Sales, Average Price, Transaction Count). The categories are dynamically pulled from a raw data sheet, and the metric values are calculated using formulas (e.g., SUMIFS, AVERAGEIFS, COUNTIFS) that reference the raw data sheet.",
                "description": "此案例演示了如何創建一個動態的摘要報告，其中報告的結構（例如，行標題）和計算（使用Excel公式）都是由VBA自動生成的。腳本會：1. 識別原始數據工作表。2. 從原始數據中提取唯一的類別列表（例如，唯一的產品名稱或區域列表），這些將用作摘要報告的行標題。3. 在新的“摘要報告”工作表中，將這些唯一類別填充到第一列。4. 為每個類別，在後續的列中自動填入Excel公式 (例如 `SUMIFS`, `AVERAGEIFS`, `COUNTIFS`)。這些公式會引用原始數據工作表，並根據當前行的類別進行條件計算。例如，計算每個產品的總銷售額、平均銷售單價、訂單數量等。5. (可選) 添加總計行和列，也使用Excel公式（例如 `SUM`）。6. (可選) 對摘要報告進行格式化，例如設定數字格式、表頭樣式、條件格式等。這種方法的好處是，如果原始數據更新，摘要報告中的公式會自動重新計算，保持數據的即時性。",
                "parameters": [
                    {"name": "Raw Data Sheet", "description": "包含詳細交易記錄的Excel工作表。"},
                    {"name": "Category Column in Raw Data", "description": "原始數據中用於生成摘要報告行標題的類別列 (例如，產品名稱列)。"},
                    {"name": "Metrics to Calculate", "description": "要為每個類別計算的指標及其對應的原始數據列 (例如，計算“銷售額列”的總和)。"},
                    {"name": "Summary Report Sheet", "description": "用於生成摘要報告的新工作表或現有工作表。"}
                ],
                "examples": [
                    {"code": "Sub CreateDynamicSummaryReportWithFormulas()\n    Dim rawDataSheet As Worksheet, summarySheet As Worksheet\n    Dim уникальныеКатегории As Object ' Scripting.Dictionary or Collection for unique categories\n    Dim lastRowRaw As Long, lastColRaw As Long\n    Dim i As Long, currentRowSummary As Long\n    Dim categoryColLetter As String, salesColLetter As String, quantityColLetter As String\n    Dim rawDataRangeAddress As String\n\n    ' --- Configuration ---\n    Set rawDataSheet = ThisWorkbook.Sheets(\"SalesData\") ' 原始數據表\n    ' 假設原始數據: A列=OrderID, B列=Product, C列=Quantity, D列=UnitPrice, E列=TotalSale (C*D)\n    Const CATEGORY_COLUMN_RAW As String = \"B\" ' 產品列作為類別\n    Const SALES_AMOUNT_COLUMN_RAW As String = \"E\" ' 總銷售額列\n    Const QUANTITY_COLUMN_RAW As String = \"C\"   ' 數量列\n    Const UNIT_PRICE_COLUMN_RAW As String = \"D\" ' 單價列\n\n    On Error Resume Next\n    Set summarySheet = ThisWorkbook.Sheets(\"DynamicSummary\")\n    If summarySheet Is Nothing Then\n        Set summarySheet = ThisWorkbook.Sheets.Add(After:=rawDataSheet)\n        summarySheet.Name = \"DynamicSummary\"\n    End If\n    On Error GoTo ErrorHandler\n    summarySheet.Cells.Clear\n    currentRowSummary = 1 ' Start from row 1 for headers\n\n    Application.ScreenUpdating = False\n\n    If rawDataSheet.Cells(1, CATEGORY_COLUMN_RAW).Value = \"\" Then\n        MsgBox \"原始數據表 '\" & rawDataSheet.Name & \"' 或其類別列為空。\", vbExclamation\n        GoTo CleanUp\n    End If\n    lastRowRaw = rawDataSheet.Cells(Rows.Count, CATEGORY_COLUMN_RAW).End(xlUp).Row\n    If lastRowRaw < 2 Then MsgBox \"原始數據不足。\", vbInformation: GoTo CleanUp\n\n    ' --- 1. Get Unique Categories ---\n    Set уникальныеКатегории = CreateObject(\"Scripting.Dictionary\")\n    For i = 2 To lastRowRaw ' Assuming row 1 is header\n        Dim categoryValue As String\n        categoryValue = Trim(CStr(rawDataSheet.Cells(i, CATEGORY_COLUMN_RAW).Value))\n        If categoryValue <> \"\" And Not уникальныеКатегории.Exists(categoryValue) Then\n            уникальныеКатегории.Add categoryValue, categoryValue\n        End If\n    Next i\n\n    If уникальныеКатегории.Count = 0 Then MsgBox \"未找到唯一類別。\", vbInformation: GoTo CleanUp\n\n    ' --- 2. Populate Headers in Summary Sheet ---\n    summarySheet.Cells(currentRowSummary, 1).Value = \"產品類別\" ' CHINESE\n    summarySheet.Cells(currentRowSummary, 2).Value = \"總銷售額\"   ' CHINESE\n    summarySheet.Cells(currentRowSummary, 3).Value = \"總銷售數量\" ' CHINESE\n    summarySheet.Cells(currentRowSummary, 4).Value = \"平均銷售單價\" ' CHINESE\n    summarySheet.Cells(currentRowSummary, 5).Value = \"訂單筆數\"   ' CHINESE\n    summarySheet.Rows(currentRowSummary).Font.Bold = True\n    currentRowSummary = currentRowSummary + 1\n\n    ' --- 3. Populate Categories and Formulas ---\n    ' Get column letters for formula construction\n    categoryColLetter = Split(rawDataSheet.Cells(1, CATEGORY_COLUMN_RAW).Address, \"$\")(1)\n    salesColLetter = Split(rawDataSheet.Cells(1, SALES_AMOUNT_COLUMN_RAW).Address, \"$\")(1)\n    quantityColLetter = Split(rawDataSheet.Cells(1, QUANTITY_COLUMN_RAW).Address, \"$\")(1)\n    unitPriceColLetter = Split(rawDataSheet.Cells(1, UNIT_PRICE_COLUMN_RAW).Address, \"$\")(1)\n    \n    ' Define the absolute range for raw data for formulas (e.g., 'SalesData'!$B$2:$B$100)\n    Dim rawCategoryRangeAddr As String, rawSalesRangeAddr As String, rawQtyRangeAddr As String, rawPriceRangeAddr As String\n    rawCategoryRangeAddr = \"'\" & rawDataSheet.Name & \"'!$\" & categoryColLetter & \"$2:$\" & categoryColLetter & \"$\" & lastRowRaw\n    rawSalesRangeAddr = \"'\" & rawDataSheet.Name & \"'!$\" & salesColLetter & \"$2:$\" & salesColLetter & \"$\" & lastRowRaw\n    rawQtyRangeAddr = \"'\" & rawDataSheet.Name & \"'!$\" & quantityColLetter & \"$2:$\" & quantityColLetter & \"$\" & lastRowRaw\n    rawPriceRangeAddr = \"'\" & rawDataSheet.Name & \"'!$\" & unitPriceColLetter & \"$2:$\" & unitPriceColLetter & \"$\" & lastRowRaw\n\n    Dim catKey As Variant\n    For Each catKey In уникальныеКатегории.Keys\n        summarySheet.Cells(currentRowSummary, 1).Value = catKey\n        \n        ' Total Sales: =SUMIFS('SalesData'!$E$2:$E$100, 'SalesData'!$B$2:$B$100, A2)\n        summarySheet.Cells(currentRowSummary, 2).Formula = \"=SUMIFS(\" & rawSalesRangeAddr & \",\" & rawCategoryRangeAddr & \",A\" & currentRowSummary & \")\"\n        \n        ' Total Quantity: =SUMIFS('SalesData'!$C$2:$C$100, 'SalesData'!$B$2:$B$100, A2)\n        summarySheet.Cells(currentRowSummary, 3).Formula = \"=SUMIFS(\" & rawQtyRangeAddr & \",\" & rawCategoryRangeAddr & \",A\" & currentRowSummary & \")\"\n        \n        ' Average Unit Price: =AVERAGEIFS('SalesData'!$D$2:$D$100, 'SalesData'!$B$2:$B$100, A2)\n        summarySheet.Cells(currentRowSummary, 4).Formula = \"=IFERROR(AVERAGEIFS(\" & rawPriceRangeAddr & \",\" & rawCategoryRangeAddr & \",A\" & currentRowSummary & \"),0)\"\n        \n        ' Order Count: =COUNTIFS('SalesData'!$B$2:$B$100, A2)\n        summarySheet.Cells(currentRowSummary, 5).Formula = \"=COUNTIFS(\" & rawCategoryRangeAddr & \",A\" & currentRowSummary & \")\"\n        \n        currentRowSummary = currentRowSummary + 1\n    Next catKey\n\n    ' --- 4. (Optional) Add Totals ---\n    If currentRowSummary > 2 Then ' If data rows were added\n        summarySheet.Cells(currentRowSummary, 1).Value = \"總計\" ' CHINESE\n        summarySheet.Cells(currentRowSummary, 1).Font.Bold = True\n        summarySheet.Cells(currentRowSummary, 2).Formula = \"=SUM(B2:B\" & currentRowSummary - 1 & \")\"\n        summarySheet.Cells(currentRowSummary, 3).Formula = \"=SUM(C2:C\" & currentRowSummary - 1 & \")\"\n        ' Avg price total might not be meaningful directly, could be overall avg or weighted avg\n        summarySheet.Cells(currentRowSummary, 4).Formula = \"=IFERROR(SUMPRODUCT(B2:B\" & currentRowSummary-1 & \",D2:D\" & currentRowSummary-1 & \")/SUM(B2:B\" & currentRowSummary-1 & \"),0)\" ' Weighted Avg Price approximation, or simply SUM(D:D) if appropriate for orders\n        summarySheet.Cells(currentRowSummary, 5).Formula = \"=SUM(E2:E\" & currentRowSummary - 1 & \")\"\n        summarySheet.Rows(currentRowSummary).Font.Bold = True\n    End If\n\n    ' --- 5. (Optional) Formatting ---\n    summarySheet.Columns(\"A\").AutoFit\n    summarySheet.Columns(\"B:D\").NumberFormat = \"#,##0.00\"\n    summarySheet.Columns(\"E\").NumberFormat = \"#,##0\"\n    summarySheet.Columns(\"B:E\").HorizontalAlignment = xlRight\n    ' Add table style, conditional formatting etc. as needed\n\n    summarySheet.Activate\n    MsgBox \"動態摘要報告已成功生成並填入公式！\", vbInformation\n\nCleanUp:\n    Application.ScreenUpdating = True\n    Set rawDataSheet = Nothing: Set summarySheet = Nothing: Set уникальныеКатегории = Nothing\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"生成摘要報告時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub", "explanation": "此VBA子程序首先從“SalesData”工作表中指定的類別列（例如“產品”）提取唯一的類別值。然後，它在一個新的或現有的“DynamicSummary”工作表中創建表頭。對於每個唯一類別，它會在摘要表中對應的行中填入使用 `SUMIFS`, `AVERAGEIFS`, 和 `COUNTIFS` 等Excel公式。這些公式動態地引用原始數據表的相應列和當前摘要行中的類別，以計算總銷售額、總數量、平均單價和訂單筆數。最後，它還會添加一個包含總計公式的總計行，並進行基本的格式化。這樣，當原始數據發生變化時，摘要報告中的值會自動更新。"}
                ],
                "keywords": ["vba dynamic summary report excel", "excel create report with formulas", "sumifs averageifs vba", "automate excel reporting formulas", "excel data aggregation formulas", "動態摘要報告Excel", "VBA生成公式報告", "Excel數據彙總公式"]
            },
            {
                "name": "企業客戶貸後監控預警UserForm與報告生成 (Excel)", "category": "Excel 資料分析與樞紐",
                "syntax": "Scenario: An Excel-based system for post-loan management of corporate clients. A UserForm is used to input or update key client financial indicators and operational data periodically. VBA then compares this data against predefined covenants or warning triggers stored in an Excel configuration sheet. If triggers are met, a 'Monitoring Report' sheet is updated, highlighting at-risk clients, and optionally, a summary alert can be prepared for relationship managers.",
                "description": "此案例演示了如何使用Excel和VBA建立一個企業客戶貸後監控和預警系統。系統核心功能包括：1. **Excel數據表結構**：a. **“ClientPortfolio”表**：存儲客戶基本信息、貸款產品、放款日期、到期日期、貸款餘額、主要財務契約（例如，資產負債率上限、利息保障倍數下限、最低營收增長率等，這些契約條件本身可能存儲在此或關聯的“Covenants”表中）。b. **“FinancialDataInput”表**：用於定期（例如，每季度、每半年）記錄客戶提交的財務報表關鍵指標，如總資產、總負債、淨利潤、EBITDA、營業收入等。每條記錄包含客戶ID、報告期、指標名稱和值。c. **“MonitoringRules”表**：定義預警觸發規則。例如：  i. 規則ID，描述，預警級別（例如，黃色、橙色、紅色）。  ii. 監控指標（例如，資產負債率、DTI、連續虧損期數）。  iii. 比較運算符（例如，>, <, >=, <=, =, 包含）。  iv. 閾值（可能因客戶類型或貸款產品而異）。  v. 觸發時的動作提示。d. **“MonitoringReport”表**：動態生成的報告，列出所有客戶，並根據“FinancialDataInput”的最新數據和“MonitoringRules”的規則，顯示每個客戶的預警狀態、觸發的規則、關鍵指標值。2. **數據錄入/更新UserForm**：a. 設計一個UserForm，允許信貸員選擇客戶ID和報告期。b. UserForm上顯示該客戶需要更新的關鍵財務指標輸入框（例如，從“FinancialDataInput”表結構動態生成）。c. 數據驗證確保輸入的財務數據格式正確。d. 提交後，數據保存到“FinancialDataInput”表。3. **VBA預警分析引擎**：a. 一個VBA過程（可手動觸發或定期運行）遍歷“ClientPortfolio”中的每個活躍客戶。b. 對於每個客戶，從“FinancialDataInput”獲取其最新的財務數據。c. 根據客戶類型或貸款產品，從“Covenants”表或“ClientPortfolio”表獲取其應遵守的財務契約。d. 遍歷“MonitoringRules”表中的每條預警規則。e. 將客戶的最新財務數據與契約要求及預警規則的閾值進行比較。f. **更新“MonitoringReport”表**：  i. 列出客戶ID、名稱、貸款餘額。  ii. 顯示最新的關鍵財務指標值。  iii. 根據是否觸發預警規則，顯示預警級別（例如，使用條件格式標紅高風險客戶）。  iv. 列出觸發的具體規則描述。4. **(可選) 生成摘要通知**：如果某些客戶達到紅色預警級別，可以生成一個簡短的文本摘要或準備一個Outlook郵件草稿，通知相關的客戶經理。",
                "parameters": [
                    {"name": "Excel Data Sheets", "description": "如上所述的 “ClientPortfolio”, “FinancialDataInput”, “MonitoringRules”, “MonitoringReport” 工作表。"},
                    {"name": "UserForm for Data Input", "description": "用於錄入或更新客戶最新財務指標的UserForm界面。"},
                    {"name": "VBA Analysis Engine", "description": "遍歷客戶、獲取數據、比較規則並更新報告的VBA代碼。"},
                    {"name": "Covenant and Warning Rule Definitions", "description": "清晰定義的財務契約和預警觸發條件。"}
                ],
                "examples": [
                    {"code": "' --- This is a highly conceptual outline for a complex system. --- \n' --- Actual implementation would involve multiple UserForms, modules, and extensive VBA code. ---\n\n' --- UserForm (ufClientFinancialsInput) Example Snippet for Submit Button ---\n' Private Sub cmdSubmitFinancials_Click()\n'   Dim wsFinancials As Worksheet, nextFinRow As Long\n'   Dim clientID As String, reportPeriod As Date\n'\n'   Set wsFinancials = ThisWorkbook.Sheets(\"FinancialDataInput\")\n'   clientID = Me.cboClientID.Value ' ComboBox for selecting client\n'   If Not IsDate(Me.txtReportPeriod.Value) Then MsgBox \"報告期日期無效。\": Exit Sub\n'   reportPeriod = CDate(Me.txtReportPeriod.Value)\n'\n'   ' --- Validate other financial input fields (e.g., Me.txtTotalAssets, Me.txtNetProfit) ---\n'   If Not ValidateFinancialInputs() Then Exit Sub\n'\n'   nextFinRow = wsFinancials.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n'   wsFinancials.Cells(nextFinRow, \"A\").Value = clientID\n'   wsFinancials.Cells(nextFinRow, \"B\").Value = reportPeriod\n'   wsFinancials.Cells(nextFinRow, \"C\").Value = \"TotalAssets\" ' Metric Name\n'   wsFinancials.Cells(nextFinRow, \"D\").Value = CDbl(Me.txtTotalAssets.Value)\n'   ' ... Add rows for other metrics like NetProfit, EBITDA, Revenue etc.\n'   ' This structure (one metric per row) is one way, or multiple metrics in one row for that period.\n'\n'   MsgBox \"客戶 \" & clientID & \" 的財務數據已於 \" & reportPeriod & \" 記錄。\", vbInformation\n'   ' Clear UserForm fields for next entry\n' End Sub\n\n' --- Main VBA Module for Generating Monitoring Report ---\nSub GeneratePostLoanMonitoringReport()\n    Dim wsPortfolio As Worksheet, wsFinancials As Worksheet, wsRules As Worksheet, wsReport As Worksheet\n    Dim dictLatestFinancials As Object ' Stores latest financials for each client: Key=ClientID, Item=Dictionary of Metrics\n    Dim lastRowPortfolio As Long, lastRowRules As Long, lastRowFinancials As Long\n    Dim i As Long, r As Long, reportNextRow As Long\n    Dim clientID As String, ruleDesc As String, metricName As String, comparisonOp As String, threshold As Double\n    Dim actualValue As Variant, covenantValue As Variant, alertLevel As String, alertDetails As String\n\n    ' --- Setup ---\n    Set wsPortfolio = ThisWorkbook.Sheets(\"ClientPortfolio\")\n    Set wsFinancials = ThisWorkbook.Sheets(\"FinancialDataInput\")\n    Set wsRules = ThisWorkbook.Sheets(\"MonitoringRules\")\n    Set wsReport = ThisWorkbook.Sheets(\"MonitoringReport\")\n    Set dictLatestFinancials = CreateObject(\"Scripting.Dictionary\")\n    wsReport.Cells.ClearContents\n    wsReport.Range(\"A1:H1\").Value = Array(\"客戶ID\", \"客戶名稱\", \"貸款餘額\", \"報告期\", \"監控指標\", \"實際值\", \"預警級別\", \"觸發說明\") ' CHINESE\n    wsReport.Rows(1).Font.Bold = True\n    reportNextRow = 2\n    Application.ScreenUpdating = False\n\n    ' --- 1. Load Latest Financials for All Clients (Simplified: assumes one row per client-period-metric in FinancialDataInput) ---\n    ' More robustly, find the LATEST period for each client and each required metric.\n    lastRowFinancials = wsFinancials.Cells(Rows.Count, \"A\").End(xlUp).Row\n    For i = lastRowFinancials To 2 Step -1 ' Loop backwards to get latest by client and metric if multiple entries for same period\n        Dim finClientID As String: finClientID = CStr(wsFinancials.Cells(i, \"A\").Value)\n        Dim finReportPeriod As Date: finReportPeriod = CDate(wsFinancials.Cells(i, \"B\").Value)\n        Dim finMetricName As String: finMetricName = CStr(wsFinancials.Cells(i, \"C\").Value)\n        Dim finMetricValue As Double: finMetricValue = CDbl(wsFinancials.Cells(i, \"D\").Value)\n        \n        If Not dictLatestFinancials.Exists(finClientID) Then\n            Set dictLatestFinancials(finClientID) = CreateObject(\"Scripting.Dictionary\")\n            dictLatestFinancials(finClientID)(\"ReportPeriod\") = finReportPeriod ' Store latest report period found\n        End If\n        ' Store the metric if it's for the latest known report period for this client, or if metric not yet stored\n        If finReportPeriod >= dictLatestFinancials(finClientID)(\"ReportPeriod\") Then\n            If Not dictLatestFinancials(finClientID).Exists(finMetricName) Or finReportPeriod > dictLatestFinancials(finClientID)(\"ReportPeriod\") Then\n                 dictLatestFinancials(finClientID)(\"ReportPeriod\") = finReportPeriod ' Update if this period is newer\n            End If\n            dictLatestFinancials(finClientID)(finMetricName) = finMetricValue\n        End If\n    Next i\n\n    ' --- 2. Iterate through Client Portfolio and Apply Monitoring Rules ---\n    lastRowPortfolio = wsPortfolio.Cells(Rows.Count, \"A\").End(xlUp).Row\n    lastRowRules = wsRules.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    For i = 2 To lastRowPortfolio ' Assuming row 1 is header in Portfolio sheet\n        clientID = CStr(wsPortfolio.Cells(i, \"A\").Value) ' Col A: ClientID\n        Dim clientName As String: clientName = CStr(wsPortfolio.Cells(i, \"B\").Value) ' Col B: ClientName\n        Dim loanBalance As Double: loanBalance = CDbl(wsPortfolio.Cells(i, \"E\").Value) ' Col E: LoanBalance (example)\n        alertDetails = \"\"\n        alertLevel = \"正常\" ' CHINESE - Default to Normal\n        Dim clientSpecificReportPeriod As Date: clientSpecificReportPeriod = CDate(0)\n\n        wsReport.Cells(reportNextRow, \"A\").Value = clientID\n        wsReport.Cells(reportNextRow, \"B\").Value = clientName\n        wsReport.Cells(reportNextRow, \"C\").Value = loanBalance\n        wsReport.Cells(reportNextRow, \"C\").NumberFormat = \"#,##0.00\"\n\n        If dictLatestFinancials.Exists(clientID) Then\n            Dim clientFins As Object: Set clientFins = dictLatestFinancials(clientID)\n            If clientFins.Exists(\"ReportPeriod\") Then clientSpecificReportPeriod = clientFins(\"ReportPeriod\")\n            wsReport.Cells(reportNextRow, \"D\").Value = clientSpecificReportPeriod\n            wsReport.Cells(reportNextRow, \"D\").NumberFormat = \"yyyy-mm-dd\"\n\n            For r = 2 To lastRowRules ' Assuming row 1 is header in Rules sheet\n                ruleDesc = CStr(wsRules.Cells(r, \"B\").Value) ' Col B: RuleDescription\n                metricName = CStr(wsRules.Cells(r, \"C\").Value) ' Col C: MetricName (e.g., \"DebtToEquityRatio\", \"NetProfitMargin\")\n                comparisonOp = CStr(wsRules.Cells(r, \"D\").Value) ' Col D: Operator (e.g., \">\", \"<=\", \"CONTAINS\")\n                threshold = CDbl(wsRules.Cells(r, \"E\").Value)    ' Col E: Threshold Value\n                Dim ruleAlertLevel As String: ruleAlertLevel = CStr(wsRules.Cells(r, \"F\").Value) ' Col F: AlertLevel (e.g., Yellow, Red)\n\n                If clientFins.Exists(metricName) Then\n                    actualValue = clientFins(metricName)\n                    Dim trigger As Boolean: trigger = False\n                    Select Case comparisonOp\n                        Case \">\": If actualValue > threshold Then trigger = True\n                        Case \"<\": If actualValue < threshold Then trigger = True\n                        Case \">=\": If actualValue >= threshold Then trigger = True\n                        Case \"<=\": If actualValue <= threshold Then trigger = True\n                        Case \"=\": If actualValue = threshold Then trigger = True ' Handle floating point with tolerance if needed\n                        Case \"<>\", \"!=\": If actualValue <> threshold Then trigger = True\n                        ' Add more complex ops like \"BETWEEN\", \"NOT BETWEEN\", \"CONTAINS\" (for text metrics)\n                    End Select\n\n                    If trigger Then\n                        alertDetails = alertDetails & ruleDesc & \" (實際: \" & Format(actualValue, \"Standard\") & \"); \"\n                        ' Determine overall alert level (e.g., highest severity encountered)\n                        If ruleAlertLevel = \"紅色\" Then alertLevel = \"紅色\" ' CHINESE\n                        If ruleAlertLevel = \"橙色\" And alertLevel <> \"紅色\" Then alertLevel = \"橙色\" ' CHINESE\n                        If ruleAlertLevel = \"黃色\" And alertLevel <> \"紅色\" And alertLevel <> \"橙色\" Then alertLevel = \"黃色\" ' CHINESE\n                        ' Write metric specific detail line (optional - this makes report very long)\n                        ' wsReport.Cells(reportNextRow, \"E\").Value = metricName\n                        ' wsReport.Cells(reportNextRow, \"F\").Value = actualValue\n                        ' wsReport.Cells(reportNextRow, \"G\").Value = ruleAlertLevel\n                        ' wsReport.Cells(reportNextRow, \"H\").Value = ruleDesc & \" (閾值: \" & threshold & \")\"\n                        ' reportNextRow = reportNextRow + 1\n                        ' wsReport.Cells(reportNextRow, \"A\").Value = clientID ' Repeat client info if multi-line per client\n                    End If\n                Else ' Metric not found in latest financials for this client\n                     ' alertDetails = alertDetails & \"指標 '\" & metricName & \"' 的最新數據缺失; \"\n                     ' If alertLevel = \"正常\" Then alertLevel = \"數據缺失\" ' CHINESE\n                End If ' End if clientFins.Exists(metricName)\n            Next r ' Next Rule\n            wsReport.Cells(reportNextRow, \"E\").Value = IIf(alertDetails = \"\", \"所有監控指標正常\", \"觸發預警:\") ' CHINESE - Summary of metrics here\n            wsReport.Cells(reportNextRow, \"F\").Value = \"N/A\" ' Placeholder if not showing individual metrics\n            wsReport.Cells(reportNextRow, \"G\").Value = alertLevel\n            wsReport.Cells(reportNextRow, \"H\").Value = Left(alertDetails, 1020) ' Limit length for cell\n        Else ' No financial data found for this client\n            wsReport.Cells(reportNextRow, \"D\").Value = \"無最新財務數據\" ' CHINESE\n            wsReport.Cells(reportNextRow, \"G\").Value = \"數據缺失\" ' CHINESE\n        End If\n        \n        ' Apply conditional formatting for alert level\n        Select Case alertLevel\n            Case \"紅色\": wsReport.Rows(reportNextRow).Interior.Color = RGB(255, 199, 206) ' Light Red\n            Case \"橙色\": wsReport.Rows(reportNextRow).Interior.Color = RGB(255, 235, 156) ' Light Orange/Yellow\n            Case \"黃色\": wsReport.Rows(reportNextRow).Interior.Color = RGB(255, 249, 199) ' Light Yellow\n            Case \"數據缺失\": wsReport.Rows(reportNextRow).Interior.Color = RGB(217, 217, 217) ' Grey\n        End Select\n        reportNextRow = reportNextRow + 1\n        If i Mod 10 = 0 Then Application.StatusBar = \"正在分析客戶 \" & i & \" / \" & lastRowPortfolio: DoEvents\n    Next i ' Next Client\n\n    wsReport.Columns.AutoFit\n    Application.StatusBar = \"\"\n    MsgBox \"貸後監控預警報告已生成！\", vbInformation\n    wsReport.Activate\n\nCleanUp:\n    Application.ScreenUpdating = True\n    Application.StatusBar = \"\"\n    Set wsPortfolio = Nothing: Set wsFinancials = Nothing: Set wsRules = Nothing: Set wsReport = Nothing\n    Set dictLatestFinancials = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.ScreenUpdating = True\n    Application.StatusBar = \"\"\n    MsgBox \"生成貸後監控報告時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub\n\n' --- Example UserForm (ufClientFinancialsInput) Initialize Event ---\n' Private Sub UserForm_Initialize()\n'   Dim wsPortfolio As Worksheet, lastRowP As Long, i As Long\n'   Set wsPortfolio = ThisWorkbook.Sheets(\"ClientPortfolio\")\n'   Me.cboClientID.Clear\n'   For i = 2 To lastRowP\n'       Me.cboClientID.AddItem wsPortfolio.Cells(i, \"A\").Value ' Populate ClientID ComboBox\n'   Next i\n'   Me.txtReportPeriod.Value = Format(Date, \"yyyy-mm-dd\") ' Default to today\n' End Sub\n'\n' --- Example UserForm (ufClientFinancialsInput) Validation Function (Conceptual) ---\n' Private Function ValidateFinancialInputs() As Boolean\n'    ValidateFinancialInputs = False ' Default\n'    If Me.cboClientID.ListIndex = -1 Then MsgBox \"請選擇客戶ID。\": Exit Function\n'    If Not IsDate(Me.txtReportPeriod.Value) Then MsgBox \"報告期日期無效。\": Exit Function\n'    If Not IsNumeric(Me.txtTotalAssets.Value) Or CDbl(Me.txtTotalAssets.Value) < 0 Then MsgBox \"總資產無效。\": Exit Function\n'    ' ... Add validation for all other financial fields ...\n'    ValidateFinancialInputs = True\n' End Function\n", "explanation": "此案例描述了一個Excel系統，用於企業客戶的貸後監控和預警。**系統組成**：1. **Excel數據表**：  a. `ClientPortfolio`：存儲客戶基本信息和貸款主要契約（或指向契約的引用）。  b. `FinancialDataInput`：定期記錄客戶提交的財務報表中的關鍵指標（例如，總資產、淨利潤）。  c. `MonitoringRules`：定義預警觸發規則，包括監控的指標、比較運算符（>、<等）、閾值和預警級別（黃、橙、紅）。  d. `MonitoringReport`：VBA自動生成的報告，顯示每個客戶的預警狀態。2. **UserForm (`ufClientFinancialsInput`)**：用於信貸員選擇客戶、報告期，並輸入或更新該客戶的最新財務指標。提交後數據存入`FinancialDataInput`表。3. **VBA預警分析引擎 (`GeneratePostLoanMonitoringReport`)**：  a. **加載最新財務數據**：遍歷`FinancialDataInput`表，為每個客戶構建其最新的財務數據快照（存儲在一個字典對象`dictLatestFinancials`中，鍵為客戶ID，值為另一個包含指標名稱和值的字典）。  b. **遍歷客戶組合**：對`ClientPortfolio`中的每個客戶執行以下操作：    i. 獲取其應遵守的財務契約（此處簡化，可能直接從`ClientPortfolio`或一個單獨的契約表獲取）。    ii. 遍歷`MonitoringRules`表中的每條預警規則。    iii. 將客戶的最新財務數據與契約要求及預警規則的閾值進行比較。    iv. 判斷是否觸發預警，並確定預警級別。  c. **更新監控報告**：在`MonitoringReport`表中為每個客戶創建一行，記錄其ID、名稱、貸款餘額、最新報告期、預警級別（例如“正常”、“黃色警告”、“紅色預警”），以及觸發的具體規則描述。使用條件格式根據預警級別高亮行。4. **UserForm初始化**：`UserForm_Initialize`事件可以在UserForm加載時從`ClientPortfolio`表填充客戶ID下拉列表。**核心邏輯**在於VBA引擎如何有效地獲取客戶的最新財務數據，並將其與多個來源（客戶自身的契約、銀行內部的預警規則）的標準進行比較，然後生成一個易於理解的風險概覽報告。此範例概念性地展示了主要流程，實際系統會更複雜，尤其是在財務指標的計算（例如，比率計算）、契約的動態獲取、以及更精細的預警級別判定方面。"}
                ],
                "keywords": ["vba excel post-loan monitoring", "excel corporate loan risk management", "userform financial data input vba", "automate client financial analysis excel", "vba warning system banking", "Excel貸後管理自動化", "企業貸款風險監控VBA", "UserForm財務數據錄入", "銀行預警系統Excel"]
            },
            {
                "name": "企業貸款到期自動提醒及展期初步評估工具 (Excel)", "category": "Excel 資料分析與樞紐",
                "syntax": "Scenario: An Excel-based tool that monitors corporate loan maturity dates. It automatically identifies loans nearing expiration (e.g., within the next 30, 60, or 90 days), flags them, and provides a UserForm interface for relationship managers to initiate a preliminary rollover/renewal assessment. The UserForm could capture initial client interest, current financial highlights, and proposed new terms, logging this for further action.",
                "description": "此案例演示了如何使用Excel和VBA來管理企業貸款的到期提醒並輔助展期（續貸）的初步評估流程。系統功能包括：1. **Excel貸款數據表 (“LoanPortfolio”)**：a. 包含客戶ID、客戶名稱、貸款合同號、原始放款日期、**貸款到期日期**、貸款類型、貸款金額、當前餘額、利率、擔保方式、客戶經理等。b. (新增列) **“到期預警級別”** (例如，30天內到期、60天內到期、90天內到期、已逾期)。c. (新增列) **“展期初步意向”** (例如，客戶有意展期、客戶無意展期、待接觸、已進入展期流程)。d. (新增列) **“上次跟進日期”** 和 **“跟進備註”**。2. **VBA自動預警與標記**：a. 一個VBA過程 (`UpdateLoanMaturityAlerts`)，可以在活頁簿打開時自動運行，或由用戶手動觸發，或設定為Windows計劃任務定期執行（如果Excel文件可以被服務器端腳本訪問）。b. 此過程遍歷“LoanPortfolio”表中的每一筆未結清貸款。c. 計算每筆貸款距離今天的剩餘到期天數。d. 根據剩餘天數（例如，<=30天, <=60天, <=90天, <0天為逾期），更新該貸款記錄的“到期預警級別”列，並可選地使用條件格式高亮顯示這些行。3. **貸款到期列表與初步展期評估UserForm (`ufLoanRolloverAssessment`)**：a. Excel中可以有一個“即將到期貸款”工作表，通過篩選或VBA複製的方式，僅顯示“到期預警級別”為30/60/90天的貸款。b. UserForm功能：  i. **顯示貸款信息**：當客戶經理從“即將到期貸款”列表中選擇一筆貸款（或在UserForm中通過貸款合同號搜索），UserForm會顯示該筆貸款的關鍵詳細信息（客戶名、到期日、餘額等）。  ii. **記錄客戶展期意向**：提供選項按鈕或下拉框讓客戶經理記錄與客戶溝通後的展期意向（例如，“客戶強烈意願展期”，“客戶考慮中”，“客戶計劃還款”，“尚未聯繫”）。  iii. **輸入初步展期條款 (如果適用)**：如果客戶有意展期，可以有欄位輸入建議的展期金額、期限、初步利率意向等。  iv. **記錄關鍵現狀**：簡要記錄客戶當前經營狀況、還款能力等正面或負面因素。  v. **更新Excel**：點擊“提交評估”按鈕後，VBA將UserForm中記錄的展期意向、初步條款、關鍵現狀、以及本次跟進日期和操作員等信息，更新回“LoanPortfolio”工作表中對應貸款記錄的相關列。  vi. **(可選) 生成任務**：可以在Outlook中為客戶經理創建一個跟進任務，提醒其在特定日期前完成更詳細的展期審批流程。4. **報告與篩選**：“LoanPortfolio”工作表本身可以通過Excel的篩選功能，方便地查看不同預警級別或不同展期意向狀態的貸款列表。這個系統有助於銀行主動管理即將到期的貸款，及早與客戶溝通，評估展期需求和風險，並標準化初步的展期信息收集過程。",
                "parameters": [
                    {"name": "Excel Loan Portfolio Sheet", "description": "包含詳細貸款信息的Excel工作表，包括到期日期和用於更新狀態的列。"},
                    {"name": "VBA for Alert Calculation", "description": "計算剩餘到期天數並更新預警級別的VBA代碼。"},
                    {"name": "UserForm for Rollover Assessment", "description": "用於顯示貸款詳情、記錄展期意向和初步條款的UserForm界面。"},
                    {"name": "Data Update Logic (VBA)", "description": "將UserForm中的評估信息寫回Excel主表的VBA代碼。"}
                ],
                "examples": [
                    {"code": "' --- Conceptual Outline for Loan Maturity Alert and Rollover Assessment Tool --- \n\n' --- VBA Module: LoanMaturityMonitor ---\nSub UpdateLoanMaturityAlerts()\n    Dim wsPortfolio As Worksheet\n    Dim lastRow As Long, i As Long\n    Dim maturityDate As Date, daysRemaining As Long\n    Dim alertLevelCol As Long, expiryDateCol As Long, loanStatusCol As Long\n\n    Set wsPortfolio = ThisWorkbook.Sheets(\"LoanPortfolio\") ' **調整工作表名稱**\n    ' Assume Columns: A=LoanID, ..., F=MaturityDate, G=LoanStatus (e.g.,\"Active\"), H=MaturityAlertLevel\n    expiryDateCol = GetColumnIndex(wsPortfolio, \"MaturityDate\") ' Helper to get col index by name\n    loanStatusCol = GetColumnIndex(wsPortfolio, \"LoanStatus\")\n    alertLevelCol = GetColumnIndex(wsPortfolio, \"MaturityAlertLevel\")\n\n    If expiryDateCol = 0 Or loanStatusCol = 0 Or alertLevelCol = 0 Then\n        MsgBox \"必要的欄位 (MaturityDate, LoanStatus, MaturityAlertLevel) 未在LoanPortfolio表中找到表頭。\", vbCritical\n        Exit Sub\n    End If\n\n    lastRow = wsPortfolio.Cells(Rows.Count, \"A\").End(xlUp).Row\n    Application.ScreenUpdating = False\n\n    For i = 2 To lastRow ' Assuming row 1 is header\n        ' Only process active loans\n        If LCase(Trim(CStr(wsPortfolio.Cells(i, loanStatusCol).Value))) = \"active\" Then\n            If IsDate(wsPortfolio.Cells(i, expiryDateCol).Value) Then\n                maturityDate = CDate(wsPortfolio.Cells(i, expiryDateCol).Value)\n                daysRemaining = DateDiff(\"d\", Date, maturityDate)\n                Dim currentAlert As String: currentAlert = \"\"\n                Dim alertColor As Long: alertColor = xlNone\n\n                If daysRemaining < 0 Then\n                    currentAlert = \"已逾期 (\" & Abs(daysRemaining) & \" 天)\" ' CHINESE\n                    alertColor = RGB(200, 0, 0) ' Dark Red\n                ElseIf daysRemaining <= 30 Then\n                    currentAlert = \"30天內到期\"\n                    alertColor = RGB(255, 0, 0) ' Red\n                ElseIf daysRemaining <= 60 Then\n                    currentAlert = \"60天內到期\"\n                    alertColor = RGB(255, 192, 0) ' Orange\n                ElseIf daysRemaining <= 90 Then\n                    currentAlert = \"90天內到期\"\n                    alertColor = RGB(255, 255, 0) ' Yellow\n                Else\n                    currentAlert = \"正常\"\n                    alertColor = xlNone ' No color or light green\n                End If\n                wsPortfolio.Cells(i, alertLevelCol).Value = currentAlert\n                wsPortfolio.Cells(i, alertLevelCol).Interior.Color = alertColor\n            Else ' Invalid maturity date\n                wsPortfolio.Cells(i, alertLevelCol).Value = \"無效到期日\"\n                wsPortfolio.Cells(i, alertLevelCol).Interior.Color = RGB(128, 128, 128) ' Grey\n            End If\n        Else ' Loan not active, clear alert\n            wsPortfolio.Cells(i, alertLevelCol).Value = \"\"\n            wsPortfolio.Cells(i, alertLevelCol).Interior.ColorIndex = xlNone\n        End If\n    Next i\n    wsPortfolio.Columns(alertLevelCol).AutoFit\n    Application.ScreenUpdating = True\n    MsgBox \"貸款到期預警級別已更新。\", vbInformation\nEnd Sub\n\n' --- UserForm (ufLoanRolloverAssessment) Code Snippets ---\n' ' (UserForm would have TextBoxes for LoanID, ClientName, MaturityDate, Balance etc.)\n' ' (ComboBox for RolloverIntent: cboRolloverIntent)\n' ' (TextBoxes for ProposedNewTerm, ProposedNewRate, FollowUpNotes: txtNewTerm, txtNewRate, txtFollowUpNotes)\n' ' (CommandButton: cmdSubmitAssessment)\n\n' ' Example: When a LoanID is selected or entered, load its details into UserForm\n' Private Sub txtLoanID_AfterUpdate() ' Or a Search Button Click\n'   Dim loanID As String: loanID = Trim(Me.txtLoanID.Value)\n'   Dim wsPortfolio As Worksheet, findRow As Range, r As Long\n'   Set wsPortfolio = ThisWorkbook.Sheets(\"LoanPortfolio\")\n'   If loanID = \"\" Then Exit Sub\n'   Set findRow = wsPortfolio.Columns(\"A\").Find(What:=loanID, LookIn:=xlValues, LookAt:=xlWhole)\n'   If Not findRow Is Nothing Then\n'       r = findRow.Row\n'       Me.lblClientName.Caption = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"ClientName\")).Value\n'       Me.lblMaturityDate.Caption = Format(CDate(wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"MaturityDate\")).Value), \"yyyy-mm-dd\")\n'       Me.lblLoanBalance.Caption = Format(CDbl(wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"CurrentBalance\")).Value), \"#,##0.00\")\n'       Me.cboRolloverIntent.Value = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"RolloverIntent\")).Value\n'       Me.txtFollowUpNotes.Text = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"FollowUpNotes\")).Value\n'       ' Clear proposed terms for new input\n'       Me.txtNewTerm.Value = \"\"\n'       Me.txtNewRate.Value = \"\"\n'   Else\n'       MsgBox \"未找到貸款ID: \" & loanID, vbExclamation\n'       ' Clear form fields\n'   End If\n' End Sub\n\n' ' Example: Submit Assessment Button Click\n' Private Sub cmdSubmitAssessment_Click()\n'   Dim loanID As String: loanID = Trim(Me.txtLoanID.Value)\n'   Dim wsPortfolio As Worksheet, findRow As Range, r As Long\n'   Set wsPortfolio = ThisWorkbook.Sheets(\"LoanPortfolio\")\n'   If loanID = \"\" Then MsgBox \"請先載入或輸入貸款ID。\": Exit Sub\n'   Set findRow = wsPortfolio.Columns(\"A\").Find(What:=loanID, LookIn:=xlValues, LookAt:=xlWhole)\n'   If findRow Is Nothing Then MsgBox \"貸款ID無效，無法更新。\": Exit Sub\n'   r = findRow.Row\n'\n'   ' Validate UserForm inputs for rollover assessment if any (e.g., new term/rate format)\n'   ' ... validation logic ...\n'\n'   wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"RolloverIntent\")).Value = Me.cboRolloverIntent.Value\n'   wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"ProposedNewTerm\")).Value = Me.txtNewTerm.Value ' Store as text or number\n'   wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"ProposedNewRate\")).Value = Me.txtNewRate.Value ' Store as text or number\n'   wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"FollowUpNotes\")).Value = Me.txtFollowUpNotes.Text\n'   wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"LastFollowUpDate\")).Value = Date\n'   wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"AssessedBy\")).Value = Application.UserName\n'\n'   MsgBox \"貸款 \" & loanID & \" 的展期評估信息已更新。\", vbInformation\n'   ' Optional: Close UserForm or clear for next entry\n'   ' Unload Me\n' End Sub\n\n' --- Helper function to get column index by header name ---\nFunction GetColumnIndex(ByVal targetSheet As Worksheet, ByVal headerName As String) As Long\n    Dim foundCell As Range\n    GetColumnIndex = 0 ' Default if not found\n    If targetSheet Is Nothing Then Exit Function\n    On Error Resume Next\n    Set foundCell = targetSheet.Rows(1).Find(What:=headerName, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False)\n    On Error GoTo 0\n    If Not foundCell Is Nothing Then\n        GetColumnIndex = foundCell.Column\n    End If\nEnd Function\n\n' --- Auto_Open to run alerts when workbook opens (in ThisWorkbook module) ---\n' Private Sub Workbook_Open()\n'   Call UpdateLoanMaturityAlerts\n' End Sub\n", "explanation": "此案例描述了一個Excel工具，用於自動監控企業貸款的到期情況並輔助展期評估。**系統組成**：1. **Excel貸款組合表 (`LoanPortfolio`)**：此表是核心，包含每筆貸款的詳細信息，如貸款ID、客戶名、到期日期、貸款狀態，以及新增的“到期預警級別”、“展期初步意向”、“上次跟進日期”、“跟進備註”、“建議展期條款”等列。2. **VBA到期預警模塊 (`UpdateLoanMaturityAlerts`)**：  a. 此過程可以設置為在工作簿打開時自動運行（使用 `Workbook_Open` 事件），或手動觸發。  b. 它會遍歷 `LoanPortfolio` 表中所有“活動”狀態的貸款。  c. 計算每筆貸款距離今天的剩餘到期天數 (`DateDiff(\"d\", Date, maturityDate)`)。  d. 根據預設的閾值（例如，90天、60天、30天內到期，或已逾期），更新“到期預警級別”列的值，並使用不同的背景色高亮顯示這些行以示提醒。3. **UserForm展期初步評估 (`ufLoanRolloverAssessment`)**：  a. **加載貸款信息**：當客戶經理在UserForm中輸入或選擇一個貸款ID時，UserForm會從 `LoanPortfolio` 表中查找並顯示該貸款的關鍵信息（例如，客戶名稱、到期日、當前餘額、已記錄的展期意向和備註）。  b. **記錄/更新展期信息**：客戶經理可以在UserForm中：    i. 選擇或更新客戶的展期意向（例如，下拉框選擇“強烈意願展期”、“考慮中”、“計劃還款”）。    ii. 如果客戶有意展期，可以輸入初步的建議展期條款，如新的期限、利率意向。    iii. 記錄本次跟進的詳細備註。  c. **提交更新**：點擊“提交”按鈕後，VBA會將UserForm中更新的信息寫回到 `LoanPortfolio` 表中對應該貸款ID的行，同時記錄本次操作的日期和操作員（例如，`Application.UserName`）。4. **輔助函數 (`GetColumnIndex`)**：提供一個通過表頭名稱查找列索引號的輔助函數，使代碼更具可讀性和可維護性，避免硬編碼列號。**應用場景**：銀行客戶經理可以使用此工具：每天打開Excel文件時，自動高亮顯示即將到期的貸款。對於需要跟進的貸款，打開UserForm，快速查看貸款詳情並記錄與客戶溝通的結果及初步的展期評估。所有信息集中記錄在Excel中，便於後續的報告、篩選和更詳細的信貸審批流程。"}
                ],
                "keywords": ["vba excel loan maturity alert", "excel loan rollover management tool", "userform for loan follow-up", "automate loan portfolio monitoring vba", "banking post-loan management excel", "Excel貸款到期提醒", "VBA展期管理", "UserForm貸款跟進", "貸後管理自動化"]
            },
            {
                "name": "從文件夾內多個Excel報告中提取數據並生成貸後統計匯總表", "category": "Excel 資料分析與樞紐",
                "syntax": "Scenario: A bank's relationship managers or a central unit regularly receive multiple Excel report files from different branches or for different clients, all stored in a common folder. These reports might have a somewhat similar structure (e.g., specific data points are always in certain cells or named ranges, or in tables with known headers). This tool automates the process of iterating through all Excel files in the folder, extracting predefined key data points from each, and consolidating them into a master summary Excel sheet for overall post-loan monitoring dashboards or statistical analysis.",
                "description": "此案例演示了如何使用VBA從指定文件夾中的多個Excel報告文件中批量提取數據，並將這些數據彙整到一個主Excel工作表中，以生成貸後數據統計匯總。系統功能包括：1. **指定報告文件夾**：用戶指定一個包含所有待處理Excel報告文件（例如，各分行提交的月度風險報告、客戶財務狀況更新表）的本地或網絡文件夾路徑。2. **定義數據提取規則**：由於源Excel文件的結構可能略有不同，需要靈活定義如何從每個文件中提取數據。規則可以基於：a. **固定儲存格位置**：例如，客戶ID總是在A1儲存格，貸款餘額在B5儲存格。b. **已命名範圍 (Named Ranges)**：如果源文件使用了已命名範圍來標識關鍵數據，VBA可以直接讀取這些已命名範圍的值。這是比較穩健的方法。c. **查找表頭後的數據**：在特定工作表中，先找到包含特定文本的表頭儲存格，然後提取該表頭下方或右方特定偏移位置的儲存格數據。d. **從特定表格中提取**：定位文件中的特定表格（通過索引或標題），然後提取表格中特定行/列的數據。3. **VBA執行流程**：a. **遍歷文件**：使用 `FileSystemObject` 遍歷指定文件夾中的所有Excel文件 (`.xlsx`, `.xls`, `.xlsm`)。b. **打開與讀取**：對於每個符合條件的Excel文件：  i. 以唯讀、背景模式打開該文件，以提高效率並避免意外修改。  ii. 根據預定義的數據提取規則，從文件中的一個或多個工作表中提取所需的數據點（例如，客戶ID、報告日期、風險評級、逾期金額、關鍵財務比率等）。  iii. 處理可能發生的錯誤（例如，文件損壞、找不到指定的工作表或儲存格、數據格式不符）。c. **寫入主彙總表**：將從當前文件提取到的所有數據點作為一行記錄，寫入到一個主Excel工作表（“貸後數據匯總表”）中。可以包含一列記錄源文件名，以便追溯。d. **關閉源文件**：提取完畢後，關閉被讀取的Excel文件，不保存任何更改。4. **數據統計與分析 (在主彙總表上)**：a. 一旦所有數據提取到主彙總表中，就可以利用Excel的內建功能（數據透視表、圖表、公式如 `SUMIFS`, `COUNTIFS`, `AVERAGEIFS`）對彙總數據進行統計分析。b. VBA也可以在數據提取完成後，自動創建或刷新基於此彙總數據的數據透視表和圖表，生成貸後監控儀表板。5. **日誌與用戶反饋**：記錄處理了哪些文件、成功提取的記錄數、以及在處理過程中遇到的任何錯誤。這個工具非常適用於需要定期從分散的、格式相似（但不完全一致）的Excel報告中收集數據，以進行集中監控、分析和報告的貸後管理場景。",
                "parameters": [
                    {"name": "Source Excel Reports Folder", "description": "包含多個Excel報告文件的文件夾路徑。"},
                    {"name": "Data Extraction Rules per Report Type (if structure varies)", "description": "如何從不同類型或版本的報告文件中定位和提取數據的規則。"},
                    {"name": "Master Summary Sheet in Excel", "description": "用於存放從所有報告文件中提取並彙整的數據的主工作表。"},
                    {"name": "Error Handling and Logging", "description": "處理文件讀取錯誤和記錄處理過程的機制。"}
                ],
                "examples": [
                    {"code": "Sub ConsolidateDataFromMultipleExcelReports()\n    Dim xlApp As Object ' Current Excel Application\n    Dim sourceWB As Workbook, summarySheet As Worksheet\n    Dim fso As Object ' Scripting.FileSystemObject\n    Dim sourceFolder As Object, fileItem As Object\n    Dim nextSummaryRow As Long\n    Dim filesProcessed As Long: filesProcessed = 0\n    Dim errorsEncountered As Long: errorsEncountered = 0\n    Dim errorLog As String: errorLog = \"錯誤日誌:\" & vbCrLf\n\n    ' --- Configuration ---\n    Const REPORTS_FOLDER_PATH As String = \"C:\\LoanPostMonitoringReports\\SourceFiles\\\" ' **替換為實際文件夾路徑**\n    Set summarySheet = ThisWorkbook.Sheets(\"ConsolidatedPostLoanData\") ' 主彙總工作表\n    ' Ensure summary sheet has headers. Example headers:\n    ' FileName, ReportDate, ClientID, LoanBalance, RiskRating, OverdueAmount, Comments\n    summarySheet.Cells.ClearContents ' Or find last row to append\n    summarySheet.Range(\"A1:G1\").Value = Array(\"源文件名\", \"報告日期\", \"客戶ID\", \"貸款餘額\", \"風險評級\", \"逾期金額\", \"關鍵備註\") ' CHINESE\n    summarySheet.Rows(1).Font.Bold = True\n    nextSummaryRow = 2\n\n    On Error GoTo ErrorHandlerOuter\n    Set xlApp = Application\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    If Not fso.FolderExists(REPORTS_FOLDER_PATH) Then\n        MsgBox \"指定的報告文件夾未找到: \" & REPORTS_FOLDER_PATH, vbCritical\n        Exit Sub\n    End If\n\n    xlApp.ScreenUpdating = False\n    xlApp.DisplayAlerts = False\n    xlApp.EnableEvents = False ' Prevent events in opened workbooks from firing\n    Application.StatusBar = \"正在從多個Excel報告中提取數據...\"\n\n    ' --- Iterate through Excel files in the folder ---\n    Set sourceFolder = fso.GetFolder(REPORTS_FOLDER_PATH)\n    For Each fileItem In sourceFolder.Files\n        If (LCase(fso.GetExtensionName(fileItem.Name)) = \"xlsx\" Or _\n            LCase(fso.GetExtensionName(fileItem.Name)) = \"xls\" Or _\n            LCase(fso.GetExtensionName(fileItem.Name)) = \"xlsm\") And _\n           Left(fileItem.Name, 2) <> \"~$\" Then ' Not a temp file\n            \n            Dim dataExtractedSuccessfully As Boolean: dataExtractedSuccessfully = False\n            On Error GoTo ErrorHandlerInFileProcessing ' Specific error handling for each file\n            \n            Debug.Print \"正在開啟報告文件: \" & fileItem.Path\n            Set sourceWB = xlApp.Workbooks.Open(FileName:=fileItem.Path, ReadOnly:=True, UpdateLinks:=0, AddToMru:=False)\n            \n            ' --- Data Extraction Logic (Highly Dependent on Source File Structure) ---\n            ' This needs to be customized based on how data is stored in your source reports.\n            ' Example 1: Data from fixed cells in a specific sheet named \"Summary\"\n            Dim reportSheet As Worksheet, foundSheet As Boolean: foundSheet = False\n            On Error Resume Next ' Check if sheet exists\n            Set reportSheet = sourceWB.Sheets(\"Summary\") ' **假設數據在名為 \"Summary\" 的工作表**\n            If Err.Number = 0 Then foundSheet = True Else Err.Clear\n            On Error GoTo ErrorHandlerInFileProcessing ' Restore error handling for file\n\n            If foundSheet Then\n                Dim reportDate As Variant, clientID As Variant, loanBalance As Variant\n                Dim riskRating As Variant, overdueAmount As Variant, comments As Variant\n\n                ' **以下儲存格位置僅為示例，需要根據您的實際報告文件進行修改**\n                reportDate = reportSheet.Range(\"B1\").Value ' Example: Report Date in B1\n                clientID = reportSheet.Range(\"B2\").Value   ' Example: Client ID in B2\n                loanBalance = reportSheet.Range(\"B3\").Value ' Example: Loan Balance in B3\n                riskRating = reportSheet.Range(\"B4\").Value  ' Example: Risk Rating in B4\n                overdueAmount = reportSheet.Range(\"B5\").Value' Example: Overdue Amount in B5\n                comments = reportSheet.Range(\"B6\").Value   ' Example: Comments in B6\n                \n                ' Basic validation or cleaning of extracted data\n                If Not IsDate(reportDate) Then reportDate = Empty ' Or some default/error marker\n                If IsError(loanBalance) Or Not IsNumeric(loanBalance) Then loanBalance = 0\n                If IsError(overdueAmount) Or Not IsNumeric(overdueAmount) Then overdueAmount = 0\n\n                ' Write to summary sheet\n                summarySheet.Cells(nextSummaryRow, \"A\").Value = fileItem.Name\n                summarySheet.Cells(nextSummaryRow, \"B\").Value = reportDate\n                summarySheet.Cells(nextSummaryRow, \"C\").Value = CStr(clientID)\n                summarySheet.Cells(nextSummaryRow, \"D\").Value = CDbl(loanBalance)\n                summarySheet.Cells(nextSummaryRow, \"E\").Value = CStr(riskRating)\n                summarySheet.Cells(nextSummaryRow, \"F\").Value = CDbl(overdueAmount)\n                summarySheet.Cells(nextSummaryRow, \"G\").Value = CStr(comments)\n                nextSummaryRow = nextSummaryRow + 1\n                dataExtractedSuccessfully = True\n            Else\n                errorLog = errorLog & \"文件 '\" & fileItem.Name & \"' 中未找到 'Summary' 工作表。\" & vbCrLf\n                errorsEncountered = errorsEncountered + 1\n            End If\n            ' --- End of Data Extraction Logic Example ---\n            \n            sourceWB.Close False ' Close without saving changes\n            Set sourceWB = Nothing\n            Set reportSheet = Nothing\n            If dataExtractedSuccessfully Then filesProcessed = filesProcessed + 1\n            Debug.Print \"已處理文件: \" & fileItem.Name\n        End If\nFileLoopExit:\n        On Error GoTo ErrorHandlerOuter ' Reset to outer error handler\n        If filesProcessed Mod 5 = 0 Then Application.StatusBar = \"已處理 \" & filesProcessed & \" 個文件...\"\n    Next fileItem\n\n    summarySheet.Columns.AutoFit\n    Application.StatusBar = \"\"\n    MsgBox filesProcessed & \" 個Excel報告文件已成功處理並彙整數據。\" & vbCrLf & _\n           IIf(errorsEncountered > 0, errorsEncountered & \" 次錯誤發生 (詳見錯誤日誌變量)。\", \"無錯誤發生。\"), _\n           IIf(errorsEncountered > 0, vbExclamation, vbInformation)\n    \n    If errorsEncountered > 0 Then\n        Debug.Print \"--- 錯誤日誌 ---\"\n        Debug.Print errorLog\n        ' Optionally write errorLog to a sheet or file\n    End If\n\nCleanUp:\n    xlApp.ScreenUpdating = True\n    xlApp.DisplayAlerts = True\n    xlApp.EnableEvents = True\n    Application.StatusBar = \"\"\n    If Not sourceWB Is Nothing Then sourceWB.Close False\n    Set summarySheet = Nothing: Set fso = Nothing: Set sourceFolder = Nothing: Set fileItem = Nothing\n    Exit Sub\n\nErrorHandlerInFileProcessing:\n    errorLog = errorLog & \"處理文件 '\" & fileItem.Name & \"' 時發生錯誤: \" & Err.Description & vbCrLf\n    errorsEncountered = errorsEncountered + 1\n    Debug.Print \"  處理文件 '\" & fileItem.Name & \"' 時發生錯誤: \" & Err.Number & \" - \" & Err.Description\n    If Not sourceWB Is Nothing Then sourceWB.Close False: Set sourceWB = Nothing\n    Resume FileLoopExit ' Skip to the next file\n\nErrorHandlerOuter:\n    Application.StatusBar = \"\"\n    MsgBox \"執行過程中發生嚴重錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub", "explanation": "此VBA子程序 `ConsolidateDataFromMultipleExcelReports` 用於從指定文件夾 (`REPORTS_FOLDER_PATH`) 中的所有Excel文件（.xlsx, .xls, .xlsm）中提取數據，並將其彙整到當前活頁簿中名為“ConsolidatedPostLoanData”的工作表。**核心邏輯**：1. **初始化**：準備彙總工作表，寫入表頭。禁用Excel的屏幕更新、警告和事件以提高性能。2. **遍歷文件**：使用`FileSystemObject`遍歷指定文件夾中的每個Excel文件。忽略臨時文件（以“~$”開頭的）。3. **打開與數據提取**：  a. 對於每個符合條件的文件，以只讀方式在背景打開。  b. **數據提取規則 (此處為範例)**：假設每個源文件的“Summary”工作表中，B1單元格存儲報告日期，B2存儲客戶ID，B3存儲貸款餘額，B4存儲風險評級，B5存儲逾期金額，B6存儲備註。**這部分的邏輯需要根據您實際的報告文件結構進行高度定制。** 您可能需要查找特定的已命名範圍，或在表格中按表頭查找數據列。  c. 對提取的數據進行基礎的驗證或清理（例如，確保日期是日期，數值是數值）。  d. 將提取到的數據（連同源文件名）作為新的一行寫入到主彙總工作表中。4. **關閉與記錄**：提取完畢後，關閉源Excel文件（不保存任何更改）。記錄已處理的文件數量和遇到的錯誤。5. **錯誤處理**：包含兩層錯誤處理。`ErrorHandlerInFileProcessing` 處理單個文件讀取或處理時的錯誤，記錄錯誤信息並跳過該文件繼續處理下一個。`ErrorHandlerOuter` 處理更一般性的或未被內部處理捕獲的錯誤。6. **完成**：所有文件處理完畢後，自動調整彙總表的列寬，恢復Excel的屏幕更新等設置，並向用戶顯示處理結果摘要，包括成功處理的文件數和錯誤數。如果存在錯誤，詳細的錯誤日誌會打印到VBA的立即窗口 (Debug.Print)，也可以選擇將其寫入Excel工作表或文本文件。**重要提示**：數據提取的具體邏BAP (`' --- Data Extraction Logic ---`部分) 是此腳本成功的關鍵，必須根據源報告文件的實際佈局進行編寫。"}
                ],
                "keywords": ["vba consolidate excel files from folder", "excel extract data multiple workbooks", "automate data aggregation excel reports", "post-loan data consolidation vba", "批量提取Excel數據到匯總表", "VBA合併文件夾內Excel文件", "貸後數據自動彙總"]
            },

            // --- Excel VBA 開發與表單 (Excel VBA Development & UserForms) ---
            {
                "name": "UserForm.Show", "category": "Excel VBA 開發與表單", "syntax": "UserFormName.Show [vbModal | vbModeless]",
                "description": "顯示一個 UserForm 物件。",
                "parameters": [
                    {"name": "vbModal", "description": "可選 (預設)。以強制回應模式顯示 UserForm。用戶必須關閉 UserForm 後才能繼續與應用程式的其他部分互動。"},
                    {"name": "vbModeless", "description": "可選。以非強制回應模式顯示 UserForm。用戶可以在 UserForm 顯示時與應用程式的其他部分互動。"}
                ],
                "examples": [
                    {"code": "' 假設您有一個名為 UserForm1 的用戶窗體\n' UserForm1.Show ' 預設以強制回應模式顯示\n' UserForm1.Show vbModeless ' 以非強制回應模式顯示", "explanation": "顯示一個用戶窗體。如果以強制回應模式顯示，代碼執行會暫停直到窗體關閉；如果以非強制回應模式顯示，代碼會繼續執行。"}
                ],
                "keywords": ["用戶窗體", "顯示窗體", "userform", "show form", "vbmodal", "vbmodeless", "gui"]
            },
            {
                "name": "UserForm.Hide", "category": "Excel VBA 開發與表單", "syntax": "UserFormName.Hide",
                "description": "隱藏一個 UserForm 但不將其從內存中卸載。窗體上的控件值會保留。",
                "parameters": [],
                "examples": [
                    {"code": "' 在 UserForm1 的某個按鈕事件中:\n' Private Sub CommandButton1_Click()\n'   Me.Hide ' 隱藏當前 UserForm\n'   ' ... 執行一些後台操作 ...\n'   ' Me.Show ' 之後可以再次顯示它\n' End Sub", "explanation": "隱藏用戶窗體，但它仍然在內存中，其狀態被保留。"}
                ],
                "keywords": ["隱藏窗體", "userform hide", "gui"]
            },
            {
                "name": "Load (UserForm)", "category": "Excel VBA 開發與表單", "syntax": "Load UserFormName",
                "description": "將 UserForm 加載到內存中，但不顯示它。這會觸發 UserForm_Initialize 事件。",
                "parameters": [{"name": "UserFormName", "description": "必需。要加載的 UserForm 的名稱。"}],
                "examples": [
                    {"code": "Sub PrepareForm()\n  Load UserForm1 ' 加載 UserForm1 到內存，觸發其 Initialize 事件\n  ' UserForm1.Caption = \"Data Entry Form - Prepared\"\n  ' UserForm1.Show ' 之後再顯示\nEnd Sub", "explanation": "將 UserForm1 加載到內存中，執行其初始化代碼，然後可以修改其屬性，最後再顯示。"}
                ],
                "keywords": ["加載窗體", "load userform", "initialize form", "gui"]
            },
            {
                "name": "Unload (UserForm)", "category": "Excel VBA 開發與表單", "syntax": "Unload UserFormName",
                "description": "從內存中移除 UserForm。這會觸發 UserForm_QueryClose 和 UserForm_Terminate 事件。",
                "parameters": [{"name": "UserFormName", "description": "必需。要卸載的 UserForm 的名稱。"}],
                "examples": [
                    {"code": "' 在 UserForm1 的關閉按鈕或OK按鈕事件中:\n' Private Sub cmdClose_Click()\n'   Unload Me ' 卸載當前 UserForm\n' End Sub", "explanation": "從內存中完全移除 UserForm，釋放其資源。"}
                ],
                "keywords": ["卸載窗體", "unload userform", "terminate form", "gui"]
            },
            {
                "name": "客戶開戶申請與資料管理UserForm (Excel)", "category": "Excel VBA 開發與表單",
                "syntax": "Scenario: A complex UserForm in Excel is designed for bank tellers or officers to input new customer information and open various types of accounts. The UserForm includes multiple fields, data validation, and interacts with several Excel worksheets to store customer data, account details, and generate unique IDs.",
                "description": "此案例演示了如何使用Excel UserForm來標準化和自動化銀行新客戶開戶流程。UserForm會包含以下功能：1. **客戶基本信息輸入**：姓名、出生日期、性別、國籍、證件類型（例如，身份證、護照）、證件號碼、聯繫地址（多行）、電話號碼、電子郵箱。2. **賬戶類型選擇**：下拉列表或選項按鈕選擇賬戶類型（例如，活期存款、定期存款、儲蓄賬戶、支票賬戶）。3. **賬戶特定信息**：a. 如果是定期存款，可能需要輸入存款期限、利率（可從後台配置表讀取）。b. 初始存款金額。c. (可選) 關聯服務選擇（例如，網上銀行、手機銀行、借記卡申請 - 通過複選框）。4. **受益人信息 (可選)**：如果適用，輸入受益人姓名和關係。5. **數據驗證**：a. 必填欄位檢查。b. 出生日期格式和合理性（例如，不能是未來日期，年齡限制）。c. 證件號碼格式（可根據證件類型進行初步校驗）。d. 電話號碼和郵箱格式。e. 初始存款金額必須為數字且可能大於等於最低存款要求。6. **自動ID生成**：a. 點擊“提交”前或提交時，自動生成一個唯一的客戶ID (CustomerID) 和新的賬戶號碼 (AccountNumber)。生成邏輯可以基於現有最大ID/賬號加1，或包含日期和隨機數等。7. **數據寫入Excel工作表**：a. **“Customers” 表**：存儲客戶的個人信息，以CustomerID為主鍵。b. **“Accounts” 表**：存儲賬戶詳細信息，包括CustomerID（外鍵）、AccountNumber（主鍵）、賬戶類型、開戶日期、初始餘額、狀態（例如，“活動”）等。c. **“AccountLinkServices” 表 (可選)**：如果客戶選擇了關聯服務，則記錄AccountNumber和服務類型。d. **“ActionLog” 表**：記錄開戶操作的時間、操作員ID（可從系統獲取或UserForm輸入）、客戶ID和賬戶號。8. **用戶反饋**：提交成功後，顯示包含新客戶ID和賬戶號碼的確認信息。清空UserForm以便輸入下一位客戶，或提供打印開戶確認單的選項（概念性）。UserForm上的按鈕可能包括：“提交開戶”、“重置表單”、“查找現有客戶”（打開另一個搜索界面或功能）。",
                "parameters": [
                    {"name": "UserForm Design", "description": "包含上述所有輸入欄位的UserForm界面 (TextBoxes, ComboBoxes, OptionButtons, CheckBoxes, CommandButtons)。"},
                    {"name": "Excel Worksheets", "description": "用於存儲客戶、賬戶、關聯服務和操作日誌的結構化工作表。"},
                    {"name": "Data Validation Logic (VBA)", "description": "在UserForm的控件事件（如 `TextBox_Exit`）或提交按鈕點擊事件中執行的驗證代碼。"},
                    {"name": "Unique ID Generation (VBA)", "description": "生成唯一客戶ID和賬戶號的函數。"},
                    {"name": "Data Persistence (VBA)", "description": "將UserForm數據寫入相應Excel工作表的VBA代碼。"}
                ],
                "examples": [
                    {"code": "' --- This is a conceptual outline. Actual UserForm code is extensive. ---\n' --- UserForm Name: ufNewAccount --- \n\n' --- Example: In the 'Submit' button Click event (cmdSubmit_Click) --- \n' Private Sub cmdSubmit_Click()\n'   Dim wsCustomers As Worksheet, wsAccounts As Worksheet, wsLog As Worksheet\n'   Dim nextCustRow As Long, nextAccRow As Long, nextLogRow As Long\n'   Dim newCustomerID As String, newAccountNumber As String\n'\n'   ' Set worksheet objects\n'   Set wsCustomers = ThisWorkbook.Sheets(\"Customers\")\n'   Set wsAccounts = ThisWorkbook.Sheets(\"Accounts\")\n'   Set wsLog = ThisWorkbook.Sheets(\"ActionLog\")\n'\n'   ' --- 1. Validate UserForm Inputs (Call a validation function) ---\n'   If Not ValidateFormInputs() Then Exit Sub ' Validation function checks all fields\n'\n'   ' --- 2. Generate Unique IDs ---\n'   newCustomerID = GenerateUniqueID(\"CUST\", wsCustomers, \"A\") ' Assume Col A for CustomerID\n'   newAccountNumber = GenerateUniqueID(\"ACC\", wsAccounts, \"B\")  ' Assume Col B for AccountNumber\n'\n'   ' --- 3. Write to Customers Sheet ---\n'   nextCustRow = wsCustomers.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n'   wsCustomers.Cells(nextCustRow, \"A\").Value = newCustomerID\n'   wsCustomers.Cells(nextCustRow, \"B\").Value = Me.txtFullName.Value ' From UserForm textbox\n'   wsCustomers.Cells(nextCustRow, \"C\").Value = CDate(Me.txtDOB.Value)\n'   ' ... other customer fields ...\n'   wsCustomers.Cells(nextCustRow, \"H\").Value = Now ' RecordCreationDate\n'\n'   ' --- 4. Write to Accounts Sheet ---\n'   nextAccRow = wsAccounts.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n'   wsAccounts.Cells(nextAccRow, \"A\").Value = newCustomerID ' Foreign Key\n'   wsAccounts.Cells(nextAccRow, \"B\").Value = newAccountNumber\n'   wsAccounts.Cells(nextAccRow, \"C\").Value = Me.cboAccountType.Value ' From ComboBox\n'   wsAccounts.Cells(nextAccRow, \"D\").Value = CDbl(Me.txtInitialDeposit.Value)\n'   wsAccounts.Cells(nextAccRow, \"E\").Value = Date ' Opening Date\n'   wsAccounts.Cells(nextAccRow, \"F\").Value = \"Active\" ' Status\n'   ' ... other account fields ...\n'\n'   ' --- 5. Log Action ---\n'   nextLogRow = wsLog.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n'   wsLog.Cells(nextLogRow, \"A\").Value = Now\n'   wsLog.Cells(nextLogRow, \"B\").Value = Application.UserName ' Or a teller ID from UserForm\n'   wsLog.Cells(nextLogRow, \"C\").Value = \"NEW ACCOUNT OPENED\"\n'   wsLog.Cells(nextLogRow, \"D\").Value = \"Customer: \" & newCustomerID & \", Account: \" & newAccountNumber\n'\n'   ' --- 6. User Feedback & Reset Form ---\n'   MsgBox \"賬戶成功開設！\" & vbCrLf & _\n'          \"客戶ID: \" & newCustomerID & vbCrLf & _\n'          \"賬戶號碼: \" & newAccountNumber, vbInformation, \"開戶成功\"\n'   Call ResetFormFields ' Another Sub to clear all UserForm inputs\n' End Sub\n'\n' ' --- Example Validation Function (called by cmdSubmit_Click) ---\n' Private Function ValidateFormInputs() As Boolean\n'   ValidateFormInputs = False ' Default to False\n'   If Trim(Me.txtFullName.Value) = \"\" Then MsgBox \"客戶姓名不能為空。\", vbExclamation, \"輸入錯誤\": Me.txtFullName.SetFocus: Exit Function\n'   If Not IsDate(Me.txtDOB.Value) Then MsgBox \"出生日期格式無效。\", vbExclamation, \"輸入錯誤\": Me.txtDOB.SetFocus: Exit Function\n'   If CDate(Me.txtDOB.Value) > Date Then MsgBox \"出生日期不能是未來日期。\", vbExclamation, \"輸入錯誤\": Me.txtDOB.SetFocus: Exit Function\n'   If Trim(Me.cboAccountType.Value) = \"\" Then MsgBox \"請選擇賬戶類型。\", vbExclamation, \"輸入錯誤\": Me.cboAccountType.SetFocus: Exit Function\n'   If Not IsNumeric(Me.txtInitialDeposit.Value) Or CDbl(Me.txtInitialDeposit.Value) < 0 Then MsgBox \"初始存款金額無效。\", vbExclamation, \"輸入錯誤\": Me.txtInitialDeposit.SetFocus: Exit Function\n'   ' ... more validation rules ...\n'   ValidateFormInputs = True\n' End Function\n'\n' ' --- Example Unique ID Generation Function ---\n' Private Function GenerateUniqueID(prefix As String, sh As Worksheet, idColumn As String) As String\n'   Dim lastIDNum As Long, newIDNum As Long\n'   Dim lastCell As Range, lastID As String\n'   On Error Resume Next\n'   Set lastCell = sh.Cells(Rows.Count, idColumn).End(xlUp)\n'   If lastCell.Row = 1 And IsEmpty(lastCell.Value) Then ' Sheet is empty or only header\n'       lastIDNum = 0\n'   Else\n'       lastID = lastCell.Value\n'       ' Extract numeric part assuming format like CUST0001 or ACC0000123\n'       Dim tempStr As String\n'       tempStr = Replace(lastID, prefix, \"\")\n'       If IsNumeric(tempStr) Then lastIDNum = CLng(tempStr) Else lastIDNum = sh.Cells(Rows.Count, idColumn).End(xlUp).Row ' Fallback if parsing fails\n'   End If\n'   On Error GoTo 0\n'   newIDNum = lastIDNum + 1\n'   GenerateUniqueID = prefix & Format(newIDNum, String(7 - Len(prefix), \"0\")) ' e.g., CUST000123 or ACC001234\n' End Function\n'\n' ' --- ResetFormFields Sub ---\n' Private Sub ResetFormFields()\n'    Me.txtFullName.Value = \"\"\n'    Me.txtDOB.Value = \"\"\n'    Me.cboAccountType.ListIndex = -1\n'    Me.txtInitialDeposit.Value = \"\"\n'    ' ... clear other fields ...\n'    Me.txtFullName.SetFocus\n' End Sub\n", "explanation": "此案例描述了一個Excel UserForm (`ufNewAccount`)，用於處理銀行新客戶的開戶申請。**UserForm設計** (未實際顯示代碼，僅描述) 將包含客戶姓名、出生日期、賬戶類型（下拉框）、初始存款等輸入框，以及“提交”和“重置”按鈕。**VBA核心邏輯** (在提交按鈕的點擊事件中)：1. **數據驗證**：調用 `ValidateFormInputs` 函數檢查所有必填項是否已填寫，數據格式是否正確（例如，日期、數字）。如果驗證失敗，則提示用戶並終止提交。2. **ID生成**：調用 `GenerateUniqueID` 輔助函數，根據指定的前綴（“CUST”或“ACC”）和對應工作表中的現有最大ID來生成新的唯一客戶ID和賬戶號碼。3. **數據寫入**：將經過驗證的客戶信息寫入“Customers”工作表的新行；將賬戶信息（包括關聯的客戶ID）寫入“Accounts”工作表的新行。4. **日誌記錄**：在“ActionLog”工作表中記錄此次開戶操作的詳情（時間、操作員、相關ID）。5. **反饋與重置**：向用戶顯示一個包含新客戶ID和賬戶號的成功消息框，然後調用 `ResetFormFields` 子程序清空UserForm上的所有輸入欄位，以便進行下一次開戶操作。此範例展示了UserForm、數據驗證、唯一ID生成以及與多個Excel工作表交互的綜合應用。"}
                ],
                "keywords": ["vba excel userform banking", "excel userform new account opening", "vba data entry form excel multiple sheets", "userform data validation unique id generation", "Excel UserForm銀行開戶", "VBA多表數據錄入", "UserForm數據驗證"]
            },
            {
                "name": "個人貸款申請資格初步評估UserForm (Excel)", "category": "Excel VBA 開發與表單",
                "syntax": "Scenario: An Excel UserForm allows potential borrowers to input their financial details (income, existing debts, loan amount requested, loan type) to get a preliminary assessment of their loan eligibility and an estimated affordable loan amount or monthly installment. The UserForm interacts with Excel sheets that might store lending rules or product parameters.",
                "description": "此案例演示了如何使用Excel UserForm為個人貸款申請提供一個初步的資格評估工具。UserForm會包含以下功能：1. **申請人信息**：姓名（可選）、年齡（用於判斷是否成年）。2. **財務狀況**：a. 年收入（稅前或稅後，需明確）。b. 每月現有固定債務總額（例如，其他貸款還款、信用卡最低還款額）。c. 信用評分（可由用戶輸入一個範圍，或在實際系統中從API獲取——此處簡化為用戶輸入）。3. **貸款請求**：a. 貸款類型（下拉列表：個人消費貸款、汽車貸款、小額經營貸款）。b. 期望貸款金額。c. (可選) 期望貸款期限（年或月）。4. **UserForm上的按鈕**：“評估資格”、“重置”。5. **評估邏輯 (VBA)**：a. **數據驗證**：檢查所有必填數字欄位是否有效（例如，收入>0，貸款金額>0）。b. **計算債務收入比 (DTI)**：`DTI = (每月現有固定債務總額 + 預估新貸款每月還款額) / (年收入 / 12)`。預估新貸款每月還款額可以使用簡化的PMT函數概念或一個固定的利率進行估算。c. **資格規則引擎 (可基於Excel配置表或VBA內硬編碼)**：  i. 年齡必須在特定範圍內（例如，18-65歲）。  ii. DTI必須低於銀行設定的閾值（例如，< 40% 或 < 50%，可能因貸款類型而異）。  iii. 信用評分必須高於最低要求（例如，> 600分）。  iv. (可選) 期望貸款金額不能超過基於收入和貸款類型計算出的最高可貸額度。d. **結果顯示**：在UserForm上的一個標籤或文本框中顯示初步評估結果，例如：“初步符合資格”、“建議降低貸款金額”、“需要進一步審核”或“初步不符合資格，原因：DTI過高/信用評分不足”。同時可以顯示計算出的DTI值。6. **數據記錄 (Excel)**：a. 將每次評估的輸入參數和評估結果記錄到一個名為“LoanAssessLog”的Excel工作表中，以便後續分析或跟進。b. (可選) 從一個名為“LoanProducts”的配置表中讀取不同貸款類型的利率、DTI上限、最高額度等參數，使規則更易於維護。7. **用戶交互**：“重置”按鈕清空所有輸入欄位。",
                "parameters": [
                    {"name": "UserForm Design", "description": "包含上述輸入欄位、結果顯示區域和操作按鈕的UserForm。"},
                    {"name": "Excel Worksheets", "description": "“LoanAssessLog”用於記錄評估日誌，“LoanProducts”（可選）用於存儲貸款產品參數和規則。"},
                    {"name": "Eligibility Logic (VBA)", "description": "計算DTI並根據一系列規則判斷初步資格的VBA代碼。"},
                    {"name": "Input Validation (VBA)", "description": "驗證UserForm輸入數據的有效性。"}
                ],
                "examples": [
                    {"code": "' --- This is a conceptual outline. Actual UserForm code is extensive. ---\n' --- UserForm Name: ufLoanPreApproval --- \n\n' --- Example: In the 'Assess Eligibility' button Click event (cmdAssess_Click) --- \n' Private Sub cmdAssess_Click()\n'   Dim annualIncome As Double, monthlyDebts As Double, requestedLoanAmount As Double, loanTermYears As Integer\n'   Dim creditScore As Integer, age As Integer\n'   Dim loanType As String\n'   Dim dti As Double, estimatedMonthlyPayment As Double, maxEligibleDTI As Double, minCreditScore As Integer\n'   Dim eligibilityStatus As String, remarks As String\n'   Dim wsLog As Worksheet, nextLogRow As Long\n'   Dim wsLoanParams As Worksheet ' Optional: For loan parameters\n'\n'   ' Set worksheet objects\n'   Set wsLog = ThisWorkbook.Sheets(\"LoanAssessLog\")\n'   ' Set wsLoanParams = ThisWorkbook.Sheets(\"LoanProducts\") ' If using a config sheet\n'\n'   ' --- 1. Validate UserForm Inputs (Simplified) ---\n'   If Not IsNumeric(Me.txtAnnualIncome.Value) Or CDbl(Me.txtAnnualIncome.Value) <= 0 Then eligibilityStatus = \"無效收入\": GoTo DisplayResult\n'   annualIncome = CDbl(Me.txtAnnualIncome.Value)\n'   If Not IsNumeric(Me.txtMonthlyDebts.Value) Or CDbl(Me.txtMonthlyDebts.Value) < 0 Then eligibilityStatus = \"無效債務\": GoTo DisplayResult\n'   monthlyDebts = CDbl(Me.txtMonthlyDebts.Value)\n'   If Not IsNumeric(Me.txtLoanAmount.Value) Or CDbl(Me.txtLoanAmount.Value) <= 0 Then eligibilityStatus = \"無效貸款金額\": GoTo DisplayResult\n'   requestedLoanAmount = CDbl(Me.txtLoanAmount.Value)\n'   If Not IsNumeric(Me.txtLoanTerm.Value) Or CInt(Me.txtLoanTerm.Value) <= 0 Then eligibilityStatus = \"無效貸款期限\": GoTo DisplayResult\n'   loanTermYears = CInt(Me.txtLoanTerm.Value)\n'   If Not IsNumeric(Me.txtCreditScore.Value) Then eligibilityStatus = \"無效信用評分\": GoTo DisplayResult\n'   creditScore = CInt(Me.txtCreditScore.Value)\n'   If Not IsNumeric(Me.txtAge.Value) Or CInt(Me.txtAge.Value) < 18 Or CInt(Me.txtAge.Value) > 70 Then eligibilityStatus = \"年齡不符要求\": GoTo DisplayResult\n'   age = CInt(Me.txtAge.Value)\n'   loanType = Me.cboLoanType.Value\n'   If loanType = \"\" Then eligibilityStatus = \"請選擇貸款類型\": GoTo DisplayResult\n'   eligibilityStatus = \"\"\n'   remarks = \"\"\n\n'   ' --- 2. Get Loan Parameters (Example: from wsLoanParams or hardcoded) ---\n'   ' Dim interestRate As Double: interestRate = 0.05 ' Example: 5% annual rate\n'   ' maxEligibleDTI = 0.4 ' Example: 40% DTI limit\n'   ' minCreditScore = 620\n'   ' Based on loanType, these parameters might change. For simplicity, using fixed values here.\n'   Dim interestRate As Double\n'   Select Case loanType\n'       Case \"個人消費貸款\": interestRate = 0.07: maxEligibleDTI = 0.45: minCreditScore = 600\n'       Case \"汽車貸款\": interestRate = 0.05: maxEligibleDTI = 0.40: minCreditScore = 640\n'       Case \"小額經營貸款\": interestRate = 0.06: maxEligibleDTI = 0.50: minCreditScore = 660\n'       Case Else: eligibilityStatus = \"無效的貸款類型選擇。\": GoTo DisplayResult\n'   End Select\n\n'   ' --- 3. Calculate Estimated Monthly Payment & DTI ---\n'   ' Simplified PMT: P = L * [r(1+r)^n] / [(1+r)^n-1] where r is monthly rate, n is months\n'   Dim monthlyRate As Double: monthlyRate = interestRate / 12\n'   Dim numberOfPayments As Long: numberOfPayments = loanTermYears * 12\n'   If monthlyRate > 0 Then\n'       estimatedMonthlyPayment = (requestedLoanAmount * monthlyRate * (1 + monthlyRate) ^ numberOfPayments) / ((1 + monthlyRate) ^ numberOfPayments - 1)\n'   Else ' If interest rate is 0\n'       estimatedMonthlyPayment = requestedLoanAmount / numberOfPayments\n'   End If\n'   If annualIncome / 12 <= 0 Then eligibilityStatus = \"月收入計算錯誤。\": GoTo DisplayResult\n'   dti = (monthlyDebts + estimatedMonthlyPayment) / (annualIncome / 12)\n'\n'   Me.lblEstimatedMonthlyPayment.Caption = Format(estimatedMonthlyPayment, \"#,##0.00\")\n'   Me.lblCalculatedDTI.Caption = Format(dti, \"0.0%\")\n'\n'   ' --- 4. Apply Eligibility Rules ---\n'   If age < 18 Or age > 65 Then eligibilityStatus = \"不符合資格\"; remarks = remarks & \"申請人年齡不符 (\" & age & \"). \"\n'   If creditScore < minCreditScore Then eligibilityStatus = \"不符合資格\"; remarks = remarks & \"信用評分過低 (\" & creditScore & \", 要求 > \" & minCreditScore & \"). \"\n'   If dti > maxEligibleDTI Then eligibilityStatus = \"不符合資格\"; remarks = remarks & \"債務收入比過高 (\" & Format(dti, \"0.0%\") & \", 上限 \" & Format(maxEligibleDTI, \"0.0%\") & \"). \"\n'   ' Add more rules, e.g., requestedLoanAmount vs max allowed based on income tier\n'\n'   If eligibilityStatus = \"\" Then ' If no negative flags yet\n'       eligibilityStatus = \"初步符合資格\"\n'       remarks = \"所有初步檢查通過。\"\n'   ElseIf eligibilityStatus = \"不符合資格\" Then\n'       ' Already set by specific rule failures\n'   Else ' If only minor warnings or needs review\n'       eligibilityStatus = \"需要進一步審核\"\n'       If remarks = \"\" Then remarks = \"請提交完整申請以供詳細審核。\"\n'   End If\n'\n'DisplayResult:\n'   Me.lblEligibilityStatus.Caption = eligibilityStatus\n'   Me.txtEligibilityRemarks.Text = remarks ' Assuming a multiline textbox for remarks\n'\n'   ' --- 5. Log Assessment ---\n'   nextLogRow = wsLog.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n'   wsLog.Cells(nextLogRow, \"A\").Value = Now ' Timestamp\n'   wsLog.Cells(nextLogRow, \"B\").Value = Me.txtApplicantName.Value ' Assuming a name field exists\n'   wsLog.Cells(nextLogRow, \"C\").Value = loanType\n'   wsLog.Cells(nextLogRow, \"D\").Value = annualIncome\n'   wsLog.Cells(nextLogRow, \"E\").Value = monthlyDebts\n'   wsLog.Cells(nextLogRow, \"F\").Value = requestedLoanAmount\n'   wsLog.Cells(nextLogRow, \"G\").Value = loanTermYears\n'   wsLog.Cells(nextLogRow, \"H\}).Value = creditScore\n'   wsLog.Cells(nextLogRow, \"I\").Value = Format(dti, \"0.00%\")\n'   wsLog.Cells(nextLogRow, \"J\").Value = Format(estimatedMonthlyPayment, \"Standard\")\n'   wsLog.Cells(nextLogRow, \"K\").Value = eligibilityStatus\n'   wsLog.Cells(nextLogRow, \"L\").Value = remarks\n'\n' End Sub\n'\n' ' --- In UserForm_Initialize or Reset Button Click ---\n' Private Sub ResetForm()\n'   Me.txtAnnualIncome.Value = \"\"\n'   Me.txtMonthlyDebts.Value = \"\"\n'   Me.txtLoanAmount.Value = \"\"\n'   Me.txtLoanTerm.Value = \"\"\n'   Me.txtCreditScore.Value = \"\"\n'   Me.txtAge.Value = \"\"\n'   Me.cboLoanType.ListIndex = -1\n'   Me.lblEligibilityStatus.Caption = \"(待評估)\"\n'   Me.lblEstimatedMonthlyPayment.Caption = \"0.00\"\n'   Me.lblCalculatedDTI.Caption = \"0.0%\"\n'   Me.txtEligibilityRemarks.Text = \"\"\n'   Me.txtAnnualIncome.SetFocus\n' End Sub\n", "explanation": "此案例描述了一個Excel UserForm (`ufLoanPreApproval`)，用於對個人貸款申請進行初步資格評估。**UserForm設計**將包括年收入、現有月度債務、期望貸款金額、貸款期限（年）、信用評分、年齡以及貸款類型（下拉框，如個人消費、汽車、小額經營）的輸入框。還會有用於顯示計算出的“預估月還款額”、“債務收入比(DTI)”、“初步資格狀態”和“備註”的標籤或文本框。**VBA核心邏輯**（在“評估資格”按鈕的點擊事件中）：1. **數據驗證**：檢查所有輸入是否為有效數字和在合理範圍內。2. **獲取貸款參數**：根據選擇的貸款類型，從一個（可選的）名為“LoanProducts”的Excel配置表中讀取或在VBA中硬編碼相應的基準利率、最高可接受DTI、最低信用評分要求等。3. **計算**：a. 使用簡化的PMT公式估算所申請貸款的每月還款額。b. 計算債務收入比 (DTI)。4. **資格判斷**：基於一系列規則（例如，年齡限制、DTI上限、信用評分下限）來確定初步的資格狀態。5. **結果顯示**：在UserForm上更新相關的標籤，顯示計算結果和初步評估意見。6. **日誌記錄**：將所有輸入參數、計算出的DTI和月還款以及最終的評估狀態記錄到名為“LoanAssessLog”的Excel工作表中。UserForm還應有一個“重置”按鈕以清空所有欄位。"}
                ],
                "keywords": ["vba excel userform loan eligibility", "excel loan pre-approval calculator vba", "userform dti calculation", "banking automation userform excel", "Excel UserForm貸款資格評估", "VBA計算DTI", "銀行業務UserForm"]
            },
            {
                "name": "客戶經理實地查訪報告錄入與管理UserForm (Excel)", "category": "Excel VBA 開發與表單",
                "syntax": "Scenario: Relationship managers (RMs) conduct on-site visits to corporate clients as part of post-loan monitoring. An Excel UserForm is used to standardize the input of visit findings, observations, risk assessments, and follow-up actions. This data is stored in a structured Excel sheet for record-keeping, trend analysis, and reporting.",
                "description": "此案例演示了如何使用Excel UserForm來規範和管理客戶經理對企業客戶進行實地查訪的報告錄入。系統功能包括：1. **Excel查訪報告數據庫 (“VisitLog”)**：a. 包含列：查訪ID (唯一)、客戶ID、客戶名稱、查訪日期、查訪客戶地點、陪同查訪人員 (銀行內部)、客戶方接待人員及其職位。b. **查訪目的** (多選或文本框，例如：常規貸後檢查、了解經營近況、跟進特定風險點、討論新增融資需求)。c. **經營狀況觀察** (多行文本框)：關於客戶生產、銷售、庫存、員工穩定性、行業動態等方面的觀察。d. **財務狀況初步了解** (多行文本框)：與客戶討論的近期財務表現、現金流情況、主要收支變化等（非正式財報，而是RM的觀察和溝通結果）。e. **擔保品狀況檢查 (如果適用)** (多行文本框)：對抵押品、質押品的現狀、維護情況的描述。f. **主要風險點與疑慮** (多行文本框)：RM在此次查訪中發現或客戶提及的潛在風險或值得關注的問題。g. **客戶提出的主要訴求或問題** (多行文本框)。h. **本次查訪結論與建議** (多行文本框)：RM對客戶當前狀況的總體評價和下一步建議。i. **需採取的後續行動** (多行文本框，可包含行動項、責任人、預計完成日期)。j. **查訪照片/文件記錄 (可選)**：記錄是否有相關照片或文件存檔，並可備註存檔路徑（實際文件存儲在共享服務器）。k. 查訪RM姓名、錄入日期。2. **查訪報告錄入UserForm (`ufSiteVisitReport`)**：a. **基本信息區**：下拉選擇客戶ID (可聯動帶出客戶名稱)、自動填入或選擇查訪日期、輸入查訪地點、陪同人員、客戶接待人員等。b. **多頁面控件 (MultiPage) 或滾動區域**：將查訪目的、經營狀況、財務了解、擔保品、風險點、客戶訴求、結論建議、後續行動等內容分別放在不同的頁面或可滾動的文本框組中，以便清晰錄入。c. **標準化選項 (可選)**：對於某些觀察點（例如，經營狀況評級：良好、一般、需關注），可以使用下拉框或選項按鈕提供標準選項。d. **日期選擇器**：用於查訪日期和後續行動的預計完成日期。e. **提交與保存按鈕**：點擊後，驗證數據完整性，生成唯一的查訪ID，並將所有信息寫入“VisitLog”工作表的新行中。f. **(可選) 查找/編輯現有報告按鈕**：允許RM查詢已提交的查訪報告並進行必要的修改或補充（需有權限控制）。3. **數據應用**：a. “VisitLog”表中的數據可以用於生成客戶的查訪歷史記錄。b. 可以對特定風險點或客戶訴求進行篩選和匯總，供管理層參考。c. 可以追蹤後續行動的完成情況。這個系統有助於標準化查訪報告的格式和內容，確保關鍵信息的完整性，便於後續的風險監控和客戶關係管理。",
                "parameters": [
                    {"name": "Excel Visit Log Sheet", "description": "結構化的工作表，用於存儲所有查訪報告的詳細信息。"},
                    {"name": "UserForm for Visit Report Input", "description": "包含上述所有信息點錄入欄位的UserForm界面。"},
                    {"name": "Data Validation and Storage Logic (VBA)", "description": "驗證UserForm輸入並將數據寫入Excel的VBA代碼。"},
                    {"name": "Unique Visit ID Generation", "description": "為每次查訪報告生成唯一標識符的邏輯。"}
                ],
                "examples": [
                    {"code": "' --- Conceptual Outline for RM On-Site Visit Report UserForm & Log System --- \n\n' --- UserForm (ufSiteVisitReport) Structure (Conceptual) ---\n' Page 1: Basic Info (Client ComboBox, VisitDate DatePicker, Location Text, BankStaff Text, ClientStaff Text)\n' Page 2: Visit Purpose (Checkboxes or Multi-select ListBox), Operating Status (Multi-line Text)\n' Page 3: Financial Understanding (Multi-line Text), Collateral Check (Multi-line Text)\n' Page 4: Key Risks/Concerns (Multi-line Text), Client Requests (Multi-line Text)\n' Page 5: Conclusion/Recommendations (Multi-line Text), Follow-up Actions (Multi-line Text, DueDate DatePicker)\n' Buttons: cmdSubmitVisit, cmdResetForm, cmdSearchPrevious (Optional)\n\n' --- VBA Module: SiteVisitLogger ---\nSub SubmitSiteVisitReportFromForm(ByVal frm As Object) ' Pass the UserForm object as parameter\n    Dim wsVisitLog As Worksheet, nextLogRow As Long\n    Dim visitID As String\n\n    Set wsVisitLog = ThisWorkbook.Sheets(\"VisitLog\") ' **調整工作表名稱**\n    ' Assume UserForm is named 'ufSiteVisitReport' and has controls like frm.cboClientID, frm.dtpVisitDate, etc.\n\n    ' --- Basic Validation (should be more comprehensive in UserForm code) ---\n    If frm.cboClientID.ListIndex = -1 Then MsgBox \"請選擇客戶ID。\", vbExclamation: frm.cboClientID.SetFocus: Exit Sub\n    If Not IsDate(frm.dtpVisitDate.Value) Then MsgBox \"查訪日期無效。\", vbExclamation: frm.dtpVisitDate.SetFocus: Exit Sub\n    If Trim(frm.txtVisitLocation.Value) = \"\" Then MsgBox \"請填寫查訪地點。\", vbExclamation: frm.txtVisitLocation.SetFocus: Exit Sub\n\n    ' --- Generate Unique Visit ID ---\n    visitID = \"VISIT_\" & frm.cboClientID.Value & \"_\" & Format(frm.dtpVisitDate.Value, \"yyyymmdd\") & \"_\" & Format(Time, \"hhmmss\")\n\n    ' --- Write to VisitLog Sheet ---\n    nextLogRow = wsVisitLog.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n    With wsVisitLog\n        .Cells(nextLogRow, \"A\").Value = visitID ' VisitID\n        .Cells(nextLogRow, \"B\").Value = frm.cboClientID.Value ' CustomerID\n        .Cells(nextLogRow, \"C\").Value = frm.lblClientName.Caption ' ClientName (assuming a label populated on ClientID change)\n        .Cells(nextLogRow, \"D\").Value = CDate(frm.dtpVisitDate.Value) ' VisitDate\n        .Cells(nextLogRow, \"E\").Value = frm.txtVisitLocation.Value ' Location\n        .Cells(nextLogRow, \"F\").Value = frm.txtBankStaff.Value ' Bank Staff Present\n        .Cells(nextLogRow, \"G\").Value = frm.txtClientStaff.Value ' Client Staff Met\n        \n        ' Example for Visit Purpose (assuming a multi-line textbox or concatenated from checkboxes)\n        .Cells(nextLogRow, \"H\").Value = frm.txtVisitPurpose.Value ' VisitPurpose\n        \n        .Cells(nextLogRow, \"I\").Value = frm.txtOperatingStatus.Value ' OperatingStatus\n        .Cells(nextLogRow, \"J\").Value = frm.txtFinancialUnderstanding.Value ' FinancialUnderstanding\n        .Cells(nextLogRow, \"K\").Value = frm.txtCollateralCheck.Value ' CollateralCheck\n        .Cells(nextLogRow, \"L\").Value = frm.txtKeyRisks.Value ' KeyRisks\n        .Cells(nextLogRow, \"M\").Value = frm.txtClientRequests.Value ' ClientRequests\n        .Cells(nextLogRow, \"N\").Value = frm.txtConclusionRecs.Value ' ConclusionRecommendations\n        .Cells(nextLogRow, \"O\").Value = frm.txtFollowUpActions.Value ' FollowUpActions\n        ' If frm.dtpFollowUpDueDate.Value <> Empty Then .Cells(nextLogRow, \"P\").Value = CDate(frm.dtpFollowUpDueDate.Value) ' FollowUpDueDate\n        .Cells(nextLogRow, \"Q\").Value = frm.txtPhotoFileRecord.Value ' Photo/File Record Path\n        .Cells(nextLogRow, \"R\").Value = Application.UserName ' RM Name\n        .Cells(nextLogRow, \"S\").Value = Now ' Entry Timestamp\n    End With\n\n    MsgBox \"查訪報告已成功記錄！查訪ID: \" & visitID, vbInformation\n    ' frm.cmdResetForm_Click ' Call UserForm's reset procedure\nEnd Sub\n\n' --- In UserForm (ufSiteVisitReport) Code ---\n' Private Sub cmdSubmitVisit_Click()\n'   Call SubmitSiteVisitReportFromForm(Me)\n' End Sub\n'\n' Private Sub UserForm_Initialize()\n'   ' Populate cboClientID ComboBox from \"ClientPortfolio\" sheet\n'   Dim wsClients As Worksheet, lastR As Long, i As Long\n'   Set wsClients = ThisWorkbook.Sheets(\"ClientPortfolio\")\n'   Me.cboClientID.Clear\n'   If wsClients Is Nothing Then Exit Sub\n'   lastR = wsClients.Cells(Rows.Count, \"A\").End(xlUp).Row\n'   For i = 2 To lastR\n'       Me.cboClientID.AddItem wsClients.Cells(i, \"A\").Value ' Assuming ClientID is in Col A\n'   Next i\n'   Me.dtpVisitDate.Value = Date ' Default visit date to today\n' End Sub\n'\n' Private Sub cboClientID_Change()\n'   ' When ClientID changes, populate client name label\n'   Dim wsClients As Worksheet, clientName As String, clientRow As Range\n'   Set wsClients = ThisWorkbook.Sheets(\"ClientPortfolio\")\n'   If Me.cboClientID.ListIndex > -1 Then\n'       Set clientRow = wsClients.Columns(\"A\").Find(What:=Me.cboClientID.Value, LookIn:=xlValues, LookAt:=xlWhole)\n'       If Not clientRow Is Nothing Then\n'           Me.lblClientName.Caption = wsClients.Cells(clientRow.Row, \"B\").Value ' Assuming ClientName in Col B\n'       Else\n'           Me.lblClientName.Caption = \"(未找到客戶名)\"\n'       End If\n'   Else\n'       Me.lblClientName.Caption = \"\"\n'   End If\n' End Sub\n", "explanation": "此案例描述了一個Excel UserForm (`ufSiteVisitReport`) 系統，用於客戶經理 (RM) 記錄對企業客戶的實地查訪結果。**系統組成**：1. **Excel查訪日誌表 (`VisitLog`)**：此工作表用於存儲所有查訪報告的結構化數據。欄位包括查訪ID、客戶ID、客戶名稱、查訪日期、地點、參與人員、查訪目的、經營狀況觀察、財務了解、擔保品檢查、風險點、客戶訴求、結論建議、後續行動、RM姓名和錄入時間等。2. **查訪報告錄入UserForm (`ufSiteVisitReport`)**：  a. **界面設計**：UserForm應包含對應`VisitLog`表各欄位的輸入控件。例如，使用ComboBox選擇客戶ID（可聯動顯示客戶名稱），使用DatePicker選擇查訪日期，使用多個大的TextBox輸入各項觀察和結論的文本。為了組織大量輸入，可以考慮使用`MultiPage`控件將相關欄位分組到不同頁面上。  b. **初始化 (`UserForm_Initialize`)**：在UserForm加載時，從“ClientPortfolio”工作表（包含客戶列表）讀取客戶ID，並填充到客戶ID的ComboBox中。預設查訪日期為當天。  c. **客戶選擇聯動 (`cboClientID_Change`)**：當客戶經理從ComboBox中選擇一個客戶ID時，UserForm可以自動查詢並顯示客戶的名稱，以供確認。  d. **提交邏輯 (`cmdSubmitVisit_Click`)**：    i. 調用一個VBA子程序 (`SubmitSiteVisitReportFromForm`)，並將UserForm本身 (`Me`) 作為參數傳遞。    ii. 在該子程序中，首先進行**輸入驗證**（例如，客戶ID和查訪日期為必填）。    iii. 生成一個**唯一的查訪ID**（例如，基於客戶ID、日期和時間組合）。    iv. 將UserForm上所有欄位的值**寫入到`VisitLog`工作表的一新行中**。    v. 向用戶顯示成功消息，並可選地重置UserForm以便錄入下一份報告。3. **數據應用**：存儲在`VisitLog`中的數據可以被客戶經理和管理層用於：回顧特定客戶的查訪歷史。篩選和分析特定風險類型的查訪記錄。跟蹤後續行動的執行情況。生成貸後管理報告的數據源。**核心價值**：此系統通過標準化的UserForm界面確保了查訪信息的完整性和一致性，將非結構化的查訪筆記轉化為結構化的數據，便於存儲、查詢和分析，從而提高貸後管理的效率和質量。"}
                ],
                "keywords": ["vba excel userform site visit report", "excel rm client visit log", "post-loan management tool vba", "standardize visit reports excel", "banking client relationship management excel", "Excel貸後查訪報告", "客戶經理拜訪記錄UserForm", "VBA貸後管理工具"]
            },
            {
                "name": "授信審批部貸後抽查報告自動生成工具 (Excel)", "category": "Excel VBA 開發與表單",
                "syntax": "Scenario: The Credit Approval Department or a Post-Loan Monitoring Unit needs to perform random or targeted spot checks on existing corporate loans. This Excel tool helps automate the generation of a 'Spot Check Report' by pulling relevant data from various sources (e.g., client portfolio, recent financial inputs, RM's visit logs) for a selected client/loan, and presenting it in a standardized report format within a new Excel sheet or a Word document (via mail merge like functionality).",
                "description": "此案例演示了如何使用Excel和VBA為授信審批部門或貸後監控部門自動生成貸後抽查報告。工具功能包括：1. **Excel數據源**：a. **“LoanPortfolio”表**：客戶基本信息、貸款詳情、主要契約。b. **“FinancialDataInput”表**：客戶最新的財務數據。c. **“VisitLog”表**：客戶經理的最新查訪報告摘要。d. **“MonitoringRules”表 (可選)**：預警規則，用於在抽查報告中顯示當前預警狀態。e. **“SpotCheckReportTemplate”工作表 (可選)**：一個預設好格式的Excel工作表，作為生成抽查報告的模板，包含標題、固定文本和用於填充數據的儲存格位置。2. **抽查客戶選擇UserForm (`ufSpotCheckSelection`) 或輸入界面**：a. 允許用戶輸入或選擇要進行抽查的客戶ID或貸款合同號。b. (可選) 提供基於特定條件（例如，特定風險評級的客戶、特定行業、即將到期的大額貸款）隨機抽取客戶的功能。3. **VBA報告生成引擎 (`GenerateSpotCheckReport`)**：a. **獲取選定客戶的數據**：  i. 從“LoanPortfolio”表獲取客戶基本信息和貸款詳情。  ii. 從“FinancialDataInput”表查找並提取該客戶最新的財務指標。  iii. 從“VisitLog”表查找並提取該客戶最近一次（或幾次）的查訪報告的關鍵摘要（例如，查訪日期、主要風險點、RM結論）。  iv. (可選) 根據“MonitoringRules”評估客戶當前的預警狀態。b. **生成抽查報告**：  i. **方式一 (Excel內部報告)**：    - 複製“SpotCheckReportTemplate”工作表，並以客戶ID和日期重命名。    - 將提取到的所有數據填充到新工作表中預定義的儲存格位置。    - 可以包含客戶基本信息、貸款概要、最新財務比率分析（例如，與契約比較）、查訪摘要、當前風險評估等部分。    - (可選) 自動生成簡單的圖表，例如關鍵財務指標的趨勢圖（如果有多期數據）。  ii. **方式二 (Word文檔報告 - 概念性)**：    - VBA可以打開一個Word報告模板 (.dotx)。    - 使用書籤 (Bookmarks) 或內容控件 (Content Controls) 將從Excel提取的數據填充到Word模板的相應位置。    - 將生成的Word文檔以客戶ID和日期命名保存。c. **報告內容示例**：    - **基本信息**：客戶名稱、ID、行業、貸款產品、金額、餘額、到期日。    - **財務狀況**：最新一期主要財務指標（資產負債率、流動比率、速動比率、淨利潤率、營收增長率等），並與契約要求或行業平均水平進行比較（如果數據可用）。    - **經營與查訪情況**：最新查訪日期、RM觀察到的經營亮點與風險點。    - **擔保品狀況 (如果適用)**：最新評估或檢查結果。    - **風險綜合評估**：基於以上信息的總體風險判斷和建議。4. **用戶界面與輸出**：a. 完成後，提示用戶報告已生成，並可選擇直接打開生成的報告文件。這個工具旨在減少人工收集和整理數據的時間，確保抽查報告的標準化和一致性，使審批人員能更快速地了解客戶的最新狀況。",
                "parameters": [
                    {"name": "Consolidated Excel Data Sources", "description": "包含客戶、貸款、財務、查訪記錄等信息的多個結構化工作表。"},
                    {"name": "Report Template (Excel or Word)", "description": "預定義的抽查報告模板，包含數據填充位置。"},
                    {"name": "Client/Loan Selection Method", "description": "如何選擇要進行抽查的客戶或貸款 (手動輸入、列表選擇、隨機抽取)。"},
                    {"name": "VBA Data Aggregation and Report Population Logic", "description": "從各數據源提取數據並填充到報告模板的VBA代碼。"}
                ],
                "examples": [
                    {"code": "' --- Conceptual Outline for Credit Dept. Spot Check Report Generator (Excel Output) ---\n\n' --- UserForm (ufSpotCheckSelection) Snippet for Generate Button ---\n' Private Sub cmdGenerateReport_Click()\n'   Dim clientIDToReview As String\n'   clientIDToReview = Me.txtClientIDForSpotCheck.Value ' Or selected from a list\n'   If clientIDToReview = \"\" Then MsgBox \"請輸入或選擇一個客戶ID進行抽查。\": Exit Sub\n'   Call GenerateSpotCheckReportForClient(clientIDToReview)\n' End Sub\n\n' --- Main VBA Module ---\nSub GenerateSpotCheckReportForClient(ByVal targetClientID As String)\n    Dim wsPortfolio As Worksheet, wsFinancials As Worksheet, wsVisits As Worksheet, wsRules As Worksheet\n    Dim wsReportTemplate As Worksheet, wsNewReport As Worksheet\n    Dim dictClientData As Object ' Scripting.Dictionary to hold all data for the client\n    Dim clientPortfolioRow As Range, lastFinRow As Long, lastVisitRow As Long, i As Long\n\n    ' --- Setup Sheets ---\n    Set wsPortfolio = ThisWorkbook.Sheets(\"ClientPortfolio\")\n    Set wsFinancials = ThisWorkbook.Sheets(\"FinancialDataInput\")\n    Set wsVisits = ThisWorkbook.Sheets(\"VisitLog\")\n    ' Set wsRules = ThisWorkbook.Sheets(\"MonitoringRules\") ' Optional for current alert status\n    Set wsReportTemplate = ThisWorkbook.Sheets(\"SpotCheckReportTemplate\") ' **確保此模板工作表存在且設計好**\n    Set dictClientData = CreateObject(\"Scripting.Dictionary\")\n    dictClientData.CompareMode = vbTextCompare\n\n    On Error GoTo ErrorHandler\n    Application.ScreenUpdating = False\n\n    ' --- 1. Find and Load Core Client & Loan Data from Portfolio ---\n    Set clientPortfolioRow = wsPortfolio.Columns(\"A\").Find(What:=targetClientID, LookIn:=xlValues, LookAt:=xlWhole)\n    If clientPortfolioRow Is Nothing Then\n        MsgBox \"在 'ClientPortfolio' 中未找到客戶ID: \" & targetClientID, vbExclamation\n        GoTo CleanUp\n    End If\n    Dim r As Long: r = clientPortfolioRow.Row\n    dictClientData(\"ClientID\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"ClientID\")).Value\n    dictClientData(\"ClientName\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"ClientName\")).Value\n    dictClientData(\"Industry\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"Industry\")).Value\n    dictClientData(\"LoanProduct\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"LoanProduct\")).Value\n    dictClientData(\"LoanAmount\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"LoanAmount\")).Value\n    dictClientData(\"CurrentBalance\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"CurrentBalance\")).Value\n    dictClientData(\"MaturityDate\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"MaturityDate\")).Value\n    dictClientData(\"InterestRate\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"InterestRate\")).Value\n    dictClientData(\"CollateralType\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"CollateralDetails\")).Value ' Example\n    ' Load Covenants if stored directly or linked\n    ' dictClientData(\"Covenant_DebtRatioMax\") = wsPortfolio.Cells(r, GetColumnIndex(wsPortfolio, \"DebtRatioCovenant\")).Value\n\n    ' --- 2. Load Latest Financial Data ---\n    ' (Simplified: finds the very last entry for the client; robustly find by latest report period)\n    lastFinRow = wsFinancials.Cells(Rows.Count, \"A\").End(xlUp).Row\n    For i = lastFinRow To 2 Step -1\n        If CStr(wsFinancials.Cells(i, \"A\").Value) = targetClientID Then\n            dictClientData(\"LatestFinReportPeriod\") = wsFinancials.Cells(i, \"B\").Value ' ReportPeriod\n            ' Assuming FinancialDataInput has MetricName in Col C, MetricValue in Col D\n            ' This loop would need to be smarter to pick up multiple *different* metrics for the *same latest period*\n            ' For this example, let's assume we pick up a few specific known metrics from that row or related rows.\n            ' This part highly depends on the structure of FinancialDataInput sheet.\n            ' Conceptual: search for specific metrics for this client and latest period.\n            dictClientData(\"Fin_TotalAssets\") = GetSpecificFinancial(wsFinancials, targetClientID, dictClientData(\"LatestFinReportPeriod\"), \"TotalAssets\")\n            dictClientData(\"Fin_NetProfit\") = GetSpecificFinancial(wsFinancials, targetClientID, dictClientData(\"LatestFinReportPeriod\"), \"NetProfit\")\n            dictClientData(\"Fin_DebtToEquity\") = GetSpecificFinancial(wsFinancials, targetClientID, dictClientData(\"LatestFinReportPeriod\"), \"DebtToEquityRatio\")\n            Exit For ' Found latest period's data block (assuming one block per period)\n        End If\n    Next i\n\n    ' --- 3. Load Latest Visit Log Summary ---\n    lastVisitRow = wsVisits.Cells(Rows.Count, \"B\").End(xlUp).Row ' Assuming ClientID in Col B of VisitLog\n    For i = lastVisitRow To 2 Step -1\n        If CStr(wsVisits.Cells(i, \"B\").Value) = targetClientID Then\n            dictClientData(\"LastVisitDate\") = wsVisits.Cells(i, GetColumnIndex(wsVisits, \"VisitDate\")).Value\n            dictClientData(\"LastVisitKeyRisks\") = wsVisits.Cells(i, GetColumnIndex(wsVisits, \"KeyRisks\")).Value\n            dictClientData(\"LastVisitConclusion\") = wsVisits.Cells(i, GetColumnIndex(wsVisits, \"ConclusionRecommendations\")).Value\n            Exit For ' Found latest visit\n        End If\n    Next i\n\n    ' --- 4. (Optional) Assess Current Alert Status from MonitoringRules ---\n    ' (This would involve logic similar to the 'PostLoanMonitoringReport' case for the specific client)\n    ' dictClientData(\"CurrentAlertLevel\") = AssessClientAlert(targetClientID, dictClientData) \n\n    ' --- 5. Create New Report Sheet from Template and Populate ---\n    wsReportTemplate.Copy After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count)\n    Set wsNewReport = ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count)\n    On Error Resume Next ' Handle if name already exists slightly differently\n    wsNewReport.Name = \"SpotCheck_\" & CreateValidSheetName(targetClientID) & \"_\" & Format(Date, \"yyyymmdd\")\n    If Err.Number <> 0 Then wsNewReport.Name = \"SpotCheck_\" & Format(Date, \"yyyymmddhhmmss\") : Err.Clear\n    On Error GoTo ErrorHandler\n\n    ' Populate the new report sheet - locations depend on wsReportTemplate design\n    ' Example placeholder cell mappings (these cells in template should be ready for data)\n    wsNewReport.Range(\"C3\").Value = dictClientData.Item(\"ClientName\") ' Template cell C3 for Client Name\n    wsNewReport.Range(\"C4\").Value = dictClientData.Item(\"ClientID\")\n    wsNewReport.Range(\"C5\").Value = dictClientData.Item(\"Industry\")\n    wsNewReport.Range(\"G3\").Value = Format(Date, \"yyyy-mm-dd\") ' Report Date\n\n    wsNewReport.Range(\"C7\").Value = dictClientData.Item(\"LoanProduct\")\n    wsNewReport.Range(\"C8\").Value = dictClientData.Item(\"LoanAmount\")\n    wsNewReport.Range(\"C9\").Value = dictClientData.Item(\"CurrentBalance\")\n    wsNewReport.Range(\"C10\").Value = Format(dictClientData.Item(\"MaturityDate\"), \"yyyy-mm-dd\")\n    ' ... and so on for all extracted data points, mapping them to specific cells in wsNewReport.\n    ' Example for financial data (if placeholders exist):\n    If dictClientData.Exists(\"LatestFinReportPeriod\") Then wsNewReport.Range(\"D12\").Value = Format(dictClientData(\"LatestFinReportPeriod\"),\"yyyy-mm-dd\") \n    If dictClientData.Exists(\"Fin_TotalAssets\") Then wsNewReport.Range(\"D13\").Value = dictClientData(\"Fin_TotalAssets\")\n    If dictClientData.Exists(\"Fin_NetProfit\") Then wsNewReport.Range(\"D14\").Value = dictClientData(\"Fin_NetProfit\")\n    If dictClientData.Exists(\"Fin_DebtToEquity\") Then wsNewReport.Range(\"D15\").Value = Format(dictClientData(\"Fin_DebtToEquity\"), \"0.00%\")\n    \n    ' Example for visit log summary:\n    If dictClientData.Exists(\"LastVisitDate\") Then wsNewReport.Range(\"B18\").Value = Format(dictClientData(\"LastVisitDate\"),\"yyyy-mm-dd\")\n    If dictClientData.Exists(\"LastVisitKeyRisks\") Then wsNewReport.Range(\"B19\").Value = dictClientData(\"LastVisitKeyRisks\")\n    ' If dictClientData.Exists(\"CurrentAlertLevel\") Then wsNewReport.Range(\"F22\").Value = dictClientData(\"CurrentAlertLevel\")\n\n    wsNewReport.Activate\n    MsgBox \"客戶 '\" & targetClientID & \"' 的貸後抽查報告已生成！\", vbInformation\n\nCleanUp:\n    Application.ScreenUpdating = True\n    Set wsPortfolio = Nothing: Set wsFinancials = Nothing: Set wsVisits = Nothing: Set wsRules = Nothing\n    Set wsReportTemplate = Nothing: Set wsNewReport = Nothing: Set dictClientData = Nothing: Set clientPortfolioRow = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.ScreenUpdating = True\n    MsgBox \"生成抽查報告時發生錯誤 (客戶ID: \" & targetClientID & \"): \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub\n\n' Helper function to get a specific financial metric for a client and period\n' This needs to be adapted to the actual structure of FinancialDataInput sheet\nFunction GetSpecificFinancial(ByVal finSheet As Worksheet, ByVal clientID As String, ByVal reportPeriod As Date, ByVal metric As String) As Variant\n    Dim lRow As Long, i As Long\n    GetSpecificFinancial = \"N/A\" ' Default\n    If finSheet Is Nothing Or clientID = \"\" Or Not IsDate(reportPeriod) Or metric = \"\" Then Exit Function\n    lRow = finSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n    For i = lRow To 2 Step -1 ' Search backwards for latest entry for the period\n        If CStr(finSheet.Cells(i, \"A\").Value) = clientID And _\n           CDate(finSheet.Cells(i, \"B\").Value) = reportPeriod And _ ' Assuming Col B is ReportPeriod\n           CStr(finSheet.Cells(i, \"C\").Value) = metric Then    ' Assuming Col C is MetricName\n            GetSpecificFinancial = finSheet.Cells(i, \"D\").Value ' Assuming Col D is MetricValue\n            Exit Function\n        End If\n    Next i\nEnd Function\n\n' (Reuse GetColumnIndex and CreateValidSheetName functions from previous examples)\nPrivate Function CreateValidSheetName(ByVal name As String) As String\n    Dim invalidChars As String, i As Integer, char As String\n    invalidChars = \"[]*/\\?:\"\n    CreateValidSheetName = name\n    For i = 1 To Len(invalidChars)\n        char = Mid(invalidChars, i, 1)\n        CreateValidSheetName = Replace(CreateValidSheetName, char, \"_\")\n    Next i\n    If Len(CreateValidSheetName) > 31 Then CreateValidSheetName = Left(CreateValidSheetName, 31)\n    CreateValidSheetName = Trim(CreateValidSheetName)\n    If CreateValidSheetName = \"\" Then CreateValidSheetName = \"Report\"\nEnd Function\n", "explanation": "此案例描述了一個為銀行授信審批部門或貸後監控部門設計的Excel自動化工具，用於生成單個客戶的貸後抽查報告。**系統組成**：1. **多個Excel數據源表**：  a. `ClientPortfolio`：包含客戶基本信息、貸款合同細節、主要財務契約等。  b. `FinancialDataInput`：存儲客戶定期提交的財務報表中的關鍵指標（例如，總資產、淨利潤、資產負債率）。  c. `VisitLog`：記錄客戶經理實地查訪的摘要信息，特別是風險點和結論。  d. （可選）`MonitoringRules`：用於評估客戶當前預警級別的規則。2. **Excel抽查報告模板 (`SpotCheckReportTemplate`)**：一個預先設計好佈局和固定文本的Excel工作表。其中包含用於填充從各數據源提取的客戶特定數據的儲存格位置（占位符儲存格）。3. **客戶選擇機制**：可以通過一個簡單的UserForm (`ufSpotCheckSelection`) 讓用戶輸入或選擇目標客戶的ID，或者在某個工作表上觸發宏來指定客戶ID。4. **VBA報告生成引擎 (`GenerateSpotCheckReportForClient`)**：  a. **數據聚合**：當指定一個客戶ID後，VBA會：    i. 從 `ClientPortfolio` 表中查找並加載該客戶的基本信息和貸款詳情。    ii. 從 `FinancialDataInput` 表中查找並提取該客戶最新報告期的主要財務指標。    iii. 從 `VisitLog` 表中查找並提取該客戶最近一次查訪報告的關鍵摘要。    iv. （可選）根據 `MonitoringRules` 和最新財務數據，評估客戶當前的風險預警級別。  b. **填充報告**：    i. 複製 `SpotCheckReportTemplate` 工作表，並以客戶ID和當前日期為新工作表命名。    ii. 將聚合到的所有數據點（客戶信息、貸款信息、財務指標、查訪摘要、風險評估等）精確地填充到新複製的報告工作表中預設好的儲存格位置。    iii. （可選）根據提取的數據，動態生成一些簡單的比較分析或提示文本。例如，如果某財務指標超過契約閾值，則在報告中高亮顯示。  c. **完成與輸出**：報告生成後，激活該報告工作表，並通知用戶。生成的報告是一個獨立的Excel工作表，可以直接查看、打印或另存。**核心價值**：此工具通過自動從多個分散的數據源收集和整合特定客戶的貸後信息，並將其呈現在一個標準化的報告格式中，極大地提高了貸後抽查的效率和一致性。審批人員無需手動查找和複製粘貼數據，可以更快地獲得對客戶狀況的全面了解。輔助函數 `GetSpecificFinancial` 用於從財務數據表中提取特定指標，`GetColumnIndex` 和 `CreateValidSheetName` 是通用的輔助功能。"}
                ],
                "keywords": ["vba excel spot check report automation", "credit post-loan review tool excel", "automate client data aggregation excel", "generate standardized report vba", "banking credit monitoring excel", "Excel貸後抽查報告自動化", "VBA客戶數據彙總報告", "授信貸後監控工具"]
            },
            {
                "name": "自動校驗Excel數據並在註釋或日誌中提示明顯錯誤", "category": "Excel VBA 開發與表單",
                "syntax": "Scenario: An Excel worksheet contains data that needs to be checked for common, obvious errors before further processing or submission. VBA iterates through specified columns, applies a set of validation rules (e.g., checking for empty cells in required fields, data type mismatches, values outside expected ranges, or text length limits), and if errors are found, it either adds a comment to the problematic cell, highlights the cell, and/or logs the error details to a separate 'Error Log' sheet.",
                "description": "此案例演示了如何使用VBA對Excel工作表中的數據執行自動化校驗，並對發現的明顯錯誤進行標記和記錄。腳本會：1. **定義校驗規則**：在VBA代碼中或從一個配置工作表中讀取針對特定列的校驗規則。例如：a. **必填欄位** (A欄不能為空)。b. **數據類型** (B欄必須是數字，C欄必須是有效日期)。c. **數值範圍** (D欄的值必須介於1和100之間)。d. **文本長度** (E欄的文本長度不能超過50個字符)。e. **特定格式** (F欄必須是有效的郵件格式，可使用簡單的 `InStr` 或正則表達式)。f. **列表選擇** (G欄的值必須來自一個預定義的有效值列表，例如 \"是\", \"否\", \"不適用\")。2. **遍歷數據**：指定包含待校驗數據的工作表和數據範圍（通常從第二行開始，跳過表頭）。3. **應用規則與錯誤處理**：對於數據範圍內的每一行和每一列（根據規則定義）：a. 提取儲存格的值。b. 根據為該列定義的規則進行校驗。c. 如果發現錯誤：  i. **(選項1) 添加註釋**：在錯誤儲存格上添加一個註釋 (`Cell.AddComment Text:=...`)，說明錯誤的具體原因。  ii. **(選項2) 高亮儲存格**：將錯誤儲存格的背景色更改為醒目的顏色 (例如，淺紅色)。  iii. **(選項3) 記錄到日誌表**：在一個單獨的“錯誤日誌”工作表中，記錄錯誤的行號、列名（或表頭名）、錯誤值以及錯誤描述。4. **校驗總結**：在所有數據校驗完畢後，可以彈出一個消息框，總結發現的錯誤數量，並提示用戶查看註釋或錯誤日誌表。這個自動化過程有助於快速識別和定位數據中的常見錄入錯誤或格式問題，提高數據質量。",
                "parameters": [
                    {"name": "Data Sheet and Range", "description": "包含待校驗數據的Excel工作表和範圍。"},
                    {"name": "Validation Rules", "description": "一個規則集合，每條規則針對特定列定義校驗邏輯和錯誤消息。"},
                    {"name": "Error Indication Method", "description": "選擇如何指示錯誤：添加儲存格註釋、高亮儲存格背景，或兩者兼有。"},
                    {"name": "Error Log Sheet (Optional)", "description": "如果選擇記錄日誌，則指定用於存放錯誤詳情的工作表。"}
                ],
                "examples": [
                    {"code": "Sub ValidateExcelDataAndFlagErrors()\n    Dim dataSheet As Worksheet, logSheet As Worksheet\n    Dim lastRow As Long, lastCol As Long\n    Dim i As Long, j As Long, errorCount As Long, logNextRow As Long\n    Dim cellValue As Variant, headerName As String\n    Dim validationMsg As String\n\n    ' --- Configuration ---\n    Set dataSheet = ThisWorkbook.Sheets(\"RawDataInput\") ' 待校驗的數據工作表\n    Const HIGHLIGHT_ERRORS As Boolean = True\n    Const ADD_COMMENTS_TO_ERRORS As Boolean = True\n    Const LOG_ERRORS_TO_SHEET As Boolean = True\n\n    If LOG_ERRORS_TO_SHEET Then\n        On Error Resume Next\n        Set logSheet = ThisWorkbook.Sheets(\"ErrorValidationLog\")\n        If logSheet Is Nothing Then\n            Set logSheet = ThisWorkbook.Sheets.Add(After:=dataSheet)\n            logSheet.Name = \"ErrorValidationLog\"\n        End If\n        On Error GoTo ErrorHandler ' Restore error handling\n        logSheet.Cells.ClearContents\n        logSheet.Range(\"A1:E1\").Value = Array(\"錯誤行\", \"欄位表頭\", \"錯誤值\", \"校驗規則\", \"錯誤描述\") ' CHINESE\n        logSheet.Rows(1).Font.Bold = True\n        logNextRow = 2\n    End If\n\n    errorCount = 0\n    Application.ScreenUpdating = False\n\n    If dataSheet.FilterMode Then dataSheet.ShowAllData ' 清除已有篩選\n\n    lastRow = dataSheet.Cells(Rows.Count, 1).End(xlUp).Row ' 假設數據從A列開始\n    If lastRow < 2 Then MsgBox \"數據表 '\" & dataSheet.Name & \"' 為空或只有表頭。\", vbInformation: GoTo CleanUp\n    lastCol = dataSheet.Cells(1, Columns.Count).End(xlToLeft).Column ' 獲取表頭行的最後一列\n\n    ' --- Loop through data rows (assuming row 1 is header) ---\n    For i = 2 To lastRow\n        ' --- Loop through relevant columns to validate ---\n        ' Example: Validate Column B (Product Name - Required, Max Length 50)\n        '          Validate Column C (Quantity - Numeric, > 0)\n        '          Validate Column D (Entry Date - Valid Date, Not in future)\n        '          Validate Column E (Status - Must be \"Active\" or \"Inactive\" or \"Pending\")\n\n        ' Column B: Product Name (假設為第2列)\n        j = 2 ' Column B index\n        headerName = CStr(dataSheet.Cells(1, j).Value)\n        cellValue = dataSheet.Cells(i, j).Value\n        validationMsg = \"\"\n        dataSheet.Cells(i, j).ClearComments ' Clear previous comment\n        If HIGHLIGHT_ERRORS Then dataSheet.Cells(i, j).Interior.ColorIndex = xlNone ' Reset color\n        ' Rule 1: Required\n        If IsEmpty(cellValue) Or Trim(CStr(cellValue)) = \"\" Then\n            validationMsg = headerName & \" 是必填項。\"\n        ' Rule 2: Max Length 50\n        ElseIf Len(Trim(CStr(cellValue))) > 50 Then\n            validationMsg = headerName & \" 長度不能超過50個字符。當前長度: \" & Len(Trim(CStr(cellValue))) & \"。\"\n        End If\n        Call HandleValidationError(dataSheet.Cells(i, j), validationMsg, i, headerName, CStr(cellValue), \"Required/MaxLength\", errorCount, logSheet, logNextRow, ADD_COMMENTS_TO_ERRORS, HIGHLIGHT_ERRORS, LOG_ERRORS_TO_SHEET)\n\n        ' Column C: Quantity (假設為第3列)\n        j = 3 ' Column C index\n        headerName = CStr(dataSheet.Cells(1, j).Value)\n        cellValue = dataSheet.Cells(i, j).Value\n        validationMsg = \"\"\n        dataSheet.Cells(i, j).ClearComments\n        If HIGHLIGHT_ERRORS Then dataSheet.Cells(i, j).Interior.ColorIndex = xlNone\n        ' Rule 1: Must be Numeric\n        If Not IsNumeric(cellValue) Then\n            validationMsg = headerName & \" 必須是數字。\"\n        ' Rule 2: Must be > 0\n        ElseIf CDbl(cellValue) <= 0 Then\n            validationMsg = headerName & \" 必須大於0。\"\n        End If\n        Call HandleValidationError(dataSheet.Cells(i, j), validationMsg, i, headerName, CStr(cellValue), \"Numeric/Positive\", errorCount, logSheet, logNextRow, ADD_COMMENTS_TO_ERRORS, HIGHLIGHT_ERRORS, LOG_ERRORS_TO_SHEET)\n\n        ' Column D: Entry Date (假設為第4列)\n        j = 4 ' Column D index\n        headerName = CStr(dataSheet.Cells(1, j).Value)\n        cellValue = dataSheet.Cells(i, j).Value\n        validationMsg = \"\"\n        dataSheet.Cells(i, j).ClearComments\n        If HIGHLIGHT_ERRORS Then dataSheet.Cells(i, j).Interior.ColorIndex = xlNone\n        ' Rule 1: Must be a valid date\n        If Not IsDate(cellValue) Then\n            validationMsg = headerName & \" 必須是有效日期格式。\"\n        ' Rule 2: Date cannot be in the future\n        ElseIf CDate(cellValue) > Date Then\n            validationMsg = headerName & \" 不能是未來日期。\"\n        End If\n        Call HandleValidationError(dataSheet.Cells(i, j), validationMsg, i, headerName, CStr(cellValue), \"ValidDate/NotFuture\", errorCount, logSheet, logNextRow, ADD_COMMENTS_TO_ERRORS, HIGHLIGHT_ERRORS, LOG_ERRORS_TO_SHEET)\n\n        ' Column E: Status (假設為第5列)\n        j = 5 ' Column E index\n        headerName = CStr(dataSheet.Cells(1, j).Value)\n        cellValue = Trim(LCase(CStr(dataSheet.Cells(i, j).Value)))\n        validationMsg = \"\"\n        dataSheet.Cells(i, j).ClearComments\n        If HIGHLIGHT_ERRORS Then dataSheet.Cells(i, j).Interior.ColorIndex = xlNone\n        Select Case cellValue\n            Case \"active\", \"inactive\", \"pending\"\n                ' Valid\n            Case Else\n                validationMsg = headerName & \" 的值無效。允許的值為: Active, Inactive, Pending。\"\n        End Select\n        Call HandleValidationError(dataSheet.Cells(i, j), validationMsg, i, headerName, CStr(dataSheet.Cells(i, j).Value), \"AllowedList\", errorCount, logSheet, logNextRow, ADD_COMMENTS_TO_ERRORS, HIGHLIGHT_ERRORS, LOG_ERRORS_TO_SHEET)\n\n        If i Mod 20 = 0 Then Application.StatusBar = \"正在校驗第 \" & i & \" / \" & lastRow & \" 行...\"\n    Next i\n\n    If LOG_ERRORS_TO_SHEET And errorCount > 0 Then logSheet.Columns.AutoFit\n    Application.StatusBar = \"\"\n    If errorCount > 0 Then\n        MsgBox errorCount & \" 個數據校驗錯誤已找到。\" & vbCrLf & _\n               IIf(ADD_COMMENTS_TO_ERRORS, \"錯誤儲存格已添加註釋。\", \"\") & vbCrLf & _\n               IIf(HIGHLIGHT_ERRORS, \"錯誤儲存格已高亮顯示。\", \"\") & vbCrLf & _\n               IIf(LOG_ERRORS_TO_SHEET, \"錯誤詳情已記錄在 'ErrorValidationLog' 工作表。\", \"\"), vbExclamation\n        If LOG_ERRORS_TO_SHEET Then logSheet.Activate\n    Else\n        MsgBox \"數據校驗完成，所有檢查的欄位均未發現明顯錯誤！\", vbInformation\n    End If\n\nCleanUp:\n    Application.ScreenUpdating = True\n    Application.StatusBar = \"\"\n    Set dataSheet = Nothing: Set logSheet = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.ScreenUpdating = True\n    Application.StatusBar = \"\"\n    MsgBox \"執行數據校驗時發生嚴重錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub\n\nPrivate Sub HandleValidationError(ByVal targetCell As Range, ByVal msg As String, _\n                                  ByVal errorRowNum As Long, ByVal colHeader As String, ByVal errorVal As String, ByVal ruleDesc As String, _\n                                  ByRef currentErrorCount As Long, ByVal errLogSheet As Worksheet, ByRef currentLogNextRow As Long, _\n                                  ByVal addComment As Boolean, ByVal highlightCell As Boolean, ByVal logError As Boolean)\n    If msg <> \"\" Then\n        currentErrorCount = currentErrorCount + 1\n        If addComment Then\n            targetCell.ClearComments\n            targetCell.AddComment msg\n            targetCell.Comment.Shape.TextFrame.AutoSize = True\n        End If\n        If highlightCell Then\n            targetCell.Interior.Color = RGB(255, 199, 206) ' Light red\n        End If\n        If logError And Not errLogSheet Is Nothing Then\n            errLogSheet.Cells(currentLogNextRow, \"A\").Value = errorRowNum\n            errLogSheet.Cells(currentLogNextRow, \"B\").Value = colHeader\n            errLogSheet.Cells(currentLogNextRow, \"C\").Value = errorVal\n            errLogSheet.Cells(currentLogNextRow, \"D\").Value = ruleDesc\n            errLogSheet.Cells(currentLogNextRow, \"E\").Value = msg\n            currentLogNextRow = currentLogNextRow + 1\n        End If\n    End If\nEnd Sub", "explanation": "此VBA解決方案包含兩個子程序：`ValidateExcelDataAndFlagErrors` 是主程序，`HandleValidationError` 是用於處理單個校驗錯誤的輔助程序。**主程序邏輯**：1. **配置**：設置包含原始數據的工作表 (\"RawDataInput\")，並通過常量決定是否高亮錯誤、是否為錯誤添加註釋、以及是否將錯誤記錄到日誌表 (\"ErrorValidationLog\")。2. **初始化**：如果選擇記錄日誌，則準備日誌工作表並寫入表頭。清除數據表上可能存在的舊篩選。3. **遍歷與校驗**：  a. 腳本逐行遍歷數據表（跳過表頭）。  b. 在內部，它針對預定義的列（此範例中硬編碼為B、C、D、E列）執行特定的校驗規則：    - **B列 (產品名稱)**：檢查是否為空，以及長度是否超過50。    - **C列 (數量)**：檢查是否為數字，以及是否大於0。    - **D列 (錄入日期)**：檢查是否為有效日期，以及日期是否為未來日期。    - **E列 (狀態)**：檢查值是否為預定義列表（\"active\", \"inactive\", \"pending\"）中的一個。  c. 對於每個校驗，如果失敗，則調用 `HandleValidationError`。4. **錯誤處理 (HandleValidationError)**：  a. 如果校驗消息不為空（表示有錯誤），則錯誤計數器增加。  b. 根據配置，為目標儲存格添加註釋，並/或將其背景高亮為淺紅色。  c. 如果配置了日誌記錄，則將錯誤的詳細信息（行號、列標題、錯誤值、規則描述、錯誤消息）寫入日誌表。5. **總結**：所有數據行處理完畢後，顯示一個消息框，告知用戶發現的錯誤總數以及如何查看錯誤（註釋、高亮、日誌表）。**改進建議**：此範例中的校驗規則是硬編碼在循環中的。一個更靈活的設計是將校驗規則（列名、校驗類型、參數等）存儲在一個單獨的配置工作表中，然後讓VBA動態讀取這些規則來執行校驗，類似於“進階數據驗證與清理自動化”案例中的規則表概念。"}
                ],
                "keywords": ["vba excel data validation automation", "excel check data errors vba", "validate excel sheet vba", "excel error highlighting comments vba", "excel data quality vba", "Excel數據自動校驗", "VBA檢查數據錯誤", "Excel錯誤提示與日誌"]
            },

            // --- 外部互動與API (Web, DB, OS) ---
            {
                "name": "Environ", "category": "外部互動與API (Web, DB, OS)", "syntax": "Environ({envstring | number})",
                "description": "返回與操作系統環境變數相關聯的 String。在 Macintosh 上不可用。",
                "parameters": [
                    {"name": "envstring", "description": "可選。環境變數名的字串表達式 (例如 \"PATH\", \"USERNAME\")。"},
                    {"name": "number", "description": "可選。環境字串表中的數值順序（從1開始）。"}
                ],
                "examples": [
                    {"code": "Dim UserName As String\nUserName = Environ(\"USERNAME\")\nMsgBox \"Current User: \" & UserName", "explanation": "獲取當前登錄用戶的操作系統用戶名。"},
                    {"code": "Dim TempPath As String\nTempPath = Environ(\"TEMP\")\nMsgBox \"Temporary Folder Path: \" & TempPath", "explanation": "獲取操作系統臨時文件夾的路徑。"},
                    {"code": "Dim PathVar As String\nPathVar = Environ(\"PATH\")\n' Debug.Print PathVar ' PATH 環境變數通常很長，適合在立即窗口查看", "explanation": "獲取系統的 PATH 環境變數。"}
                ],
                "keywords": ["環境變數", "系統", "os", "environment variable", "system info"]
            },
            {
                "name": "Shell", "category": "外部互動與API (Web, DB, OS)", "syntax": "Shell(pathname[, windowstyle As VbAppWinStyle = vbMinimizedFocus])",
                "description": "執行一個可執行程序並返回一個 Variant (Double)，如果成功則代表程序的任務 ID，否則返回零。",
                "parameters": [
                    {"name": "pathname", "description": "必需。要執行的程序名，以及任何必需的參數或命令列開關。"},
                    {"name": "windowstyle", "description": "可選。指示程序運行時窗口樣式的數字 (例如 vbNormalFocus, vbMinimizedFocus, vbHide)。"}
                ],
                "examples": [
                    {"code": "Dim RetVal As Variant\nRetVal = Shell(\"CALC.EXE\", vbNormalFocus)\nIf RetVal = 0 Then MsgBox \"無法啟動計算器\"", "explanation": "以正常焦點方式啟動 Windows 計算器程序。"},
                    {"code": "Dim TaskID As Variant\n' 確保 Notepad.exe 在系統路徑中或提供完整路徑\nTaskID = Shell(\"NOTEPAD.EXE C:\\MyTextFile.txt\", vbNormalFocus)\n' 這會嘗試用記事本打開 C:\\MyTextFile.txt", "explanation": "嘗試使用記事本程序打開一個指定的文本文件。"}
                ],
                "keywords": ["執行程序", "運行", "外部程序", "execute", "run", "program", "application"]
            },
            {
                "name": "Declare Statement (API)", "category": "外部互動與API (Web, DB, OS)", "syntax": "[Public | Private] Declare Sub name Lib \"libname\" [Alias \"aliasname\"] [(arglist)]\n[Public | Private] Declare Function name Lib \"libname\" [Alias \"aliasname\"] [(arglist)] [As type]",
                "description": "在模塊級別聲明對外部過程中包含的過程的引用，例如 Windows API 函數。",
                "parameters": [
                    {"name": "name", "description": "必需。要調用的外部過程的名稱。"},
                    {"name": "libname", "description": "必需。包含外部過程的庫的名稱。"},
                    {"name": "Alias \"aliasname\"", "description": "可選。指示正在調用的外部過程在 DLL 中具有另一個名稱。"},
                    {"name": "arglist", "description": "可選。表示傳遞給外部過程的參數的變數列表。"}
                ],
                "examples": [
                    {"code": "#If VBA7 Then ' For 64-bit Office\n  Private Declare PtrSafe Sub Sleep Lib \"kernel32\" (ByVal dwMilliseconds As Long)\n#Else ' For 32-bit Office\n  Private Declare Sub Sleep Lib \"kernel32\" (ByVal dwMilliseconds As Long)\n#End If\n\nSub PauseForASecond()\n  Debug.Print \"Pausing...\" & Time\n  Sleep 1000 ' Pause for 1000 milliseconds (1 second)\n  Debug.Print \"Resumed.\" & Time\nEnd Sub", "explanation": "聲明並使用 Windows API 中的 Sleep 函數來暫停宏的執行。注意 PtrSafe 用於64位系統的兼容性。"}
                ],
                "keywords": ["API調用", "外部函數", "Windows API", "declare function", "declare sub", "dll", "external procedure"]
            },
            {
                "name": "AddressOf Operator", "category": "外部互動與API (Web, DB, OS)", "syntax": "AddressOf procedurename",
                "description": "返回一個指向由 procedurename 指定的過程的地址的指針。通常與需要回調函數地址的 Windows API 函數一起使用。",
                "parameters": [{"name": "procedurename", "description": "必需。要獲取其地址的 Sub 或 Function 過程的名稱。"}],
                "examples": [
                    {"code": "' Example for EnumWindows API (requires callback)\n#If VBA7 Then\n  Public Declare PtrSafe Function EnumWindows Lib \"user32\" (ByVal lpEnumFunc As LongPtr, ByVal lParam As LongPtr) As Long\n#Else\n  Public Declare Function EnumWindows Lib \"user32\" (ByVal lpEnumFunc As Long, ByVal lParam As Long) As Long\n#End If\n\nPublic Function EnumWindowsProc(ByVal hwnd As LongPtr, ByVal lParam As LongPtr) As Boolean\n  Debug.Print \"Window Handle: \" & hwnd\n  EnumWindowsProc = True ' Continue enumeration\n  Exit Function\nEnd Function\n\nSub ListAllWindows()\n  EnumWindows AddressOf EnumWindowsProc, 0\nEnd Sub", "explanation": "演示如何使用 AddressOf 將 EnumWindowsProc 函數的地址傳遞給 EnumWindows API 函數作為回調。"}
                ],
                "keywords": ["回調函數", "函數指針", "API回調", "callback function", "function pointer", "procedure address"]
            },
            {
                "name": "GetUserName (Windows API)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Private Declare Function GetUserName Lib \"advapi32.dll\" Alias \"GetUserNameA\" (ByVal lpBuffer As String, nSize As Long) As Long",
                "description": "使用 Windows API 函數 GetUserNameA (或 GetUserNameW Unicode 版本) 獲取目前登入使用者的名稱。",
                "parameters": [
                    {"name": "lpBuffer", "description": "一個字串緩衝區，用於接收使用者名稱。"},
                    {"name": "nSize", "description": "lpBuffer 的大小 (字元數)。應傳入緩衝區的長度作為指標。"}
                ],
                "examples": [
                    {"code": "#If VBA7 And Win64 Then\n  Private Declare PtrSafe Function GetUserName Lib \"advapi32.dll\" Alias \"GetUserNameA\" (ByVal lpBuffer As String, ByRef nSize As Long) As Long\n#Else\n  Private Declare Function GetUserName Lib \"advapi32.dll\" Alias \"GetUserNameA\" (ByVal lpBuffer As String, ByRef nSize As Long) As Long\n#End If\n\nFunction GetCurrentUserLoginName() As String\n  Dim buffer As String * 255 ' Create a string buffer\n  Dim bufferSize As Long\n  bufferSize = Len(buffer)\n  If GetUserName(buffer, bufferSize) <> 0 Then\n    GetCurrentUserLoginName = Left(buffer, bufferSize - 1) ' Trim null character\n  Else\n    GetCurrentUserLoginName = \"(Unknown)\"\n  End If\nEnd Function\n\nSub ShowUserName()\n  MsgBox \"目前登入的使用者是: \" & GetCurrentUserLoginName()\nEnd Sub", "explanation": "此範例定義了一個 Declare 語句 (兼容32位和64位VBA7+) 來調用 advapi32.dll 中的 GetUserNameA 函數。GetCurrentUserLoginName 函數準備一個緩衝區，調用API，然後從緩衝區提取使用者名稱。ShowUserName 子程序調用此函數並顯示結果。"}
                ],
                "keywords": ["windows api getusername", "vba get current user", "username api", "advapi32", "declare function api", "獲取使用者名稱API", "目前使用者"]
            },
            {
                "name": "MessageBox (Windows API)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Private Declare Function MessageBox Lib \"user32\" Alias \"MessageBoxA\" (ByVal hWnd As Long, ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Long) As Long",
                "description": "使用 Windows API 函數 MessageBoxA (或 MessageBoxW) 顯示一個更可自訂的訊息框，相比 VBA 內建的 MsgBox，它可以指定父視窗控制代碼 (hWnd) 和更多樣式的按鈕/圖示組合。",
                "parameters": [
                    {"name": "hWnd", "description": "父視窗的控制代碼。如果為0或 Null，則訊息框沒有擁有者視窗。"},
                    {"name": "lpText", "description": "要在訊息框中顯示的訊息。"},
                    {"name": "lpCaption", "description": "訊息框的標題。"},
                    {"name": "uType", "description": "指定訊息框的內容和行為的常數組合 (例如，MB_OKCANCEL, MB_ICONINFORMATION)。"}
                ],
                "examples": [
                    {"code": "#If VBA7 And Win64 Then\n    Private Declare PtrSafe Function MessageBox Lib \"user32\" Alias \"MessageBoxA\" (ByVal hWnd As LongPtr, ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Long) As Long\n#Else\n    Private Declare Function MessageBox Lib \"user32\" Alias \"MessageBoxA\" (ByVal hWnd As Long, ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Long) As Long\n#End If\n\n' MessageBox uType Constants (subset)\nConst MB_OK As Long = &H0\nConst MB_OKCANCEL As Long = &H1\nConst MB_YESNOCANCEL As Long = &H3\nConst MB_ICONINFORMATION As Long = &H40\nConst MB_ICONQUESTION As Long = &H20\nConst MB_ICONEXCLAMATION As Long = &H30\nConst MB_ICONERROR As Long = &H10\n\n' MessageBox Return Values (subset)\nConst IDOK As Long = 1\nConst IDCANCEL As Long = 2\nConst IDYES As Long = 6\nConst IDNO As Long = 7\n\nSub ShowApiMessageBox()\n  Dim response As Long\n  Dim hwndApp As LongPtr ' For Application.hWnd\n  #If VBA7 Then\n    hwndApp = Application.hWnd\n  #Else\n    ' For older Office, might need different way or use 0\n    ' hwndApp = FindWindow(\"XLMAIN\", Application.Caption) ' Example for older Excel\n    hwndApp = 0 ' Default if no specific hWnd needed\n  #End If\n\n  response = MessageBox(hwndApp, \"您想儲存變更嗎？\", \"API 訊息框確認\", MB_YESNOCANCEL + MB_ICONQUESTION)\n  Select Case response\n    Case IDYES\n      MsgBox \"使用者選擇了 [是]。\"\n    Case IDNO\n      MsgBox \"使用者選擇了 [否]。\"\n    Case IDCANCEL\n      MsgBox \"使用者選擇了 [取消]。\"\n    Case Else\n      MsgBox \"訊息框關閉或發生未知回應。\"\n  End Select\nEnd Sub", "explanation": "此範例演示如何使用 user32.dll 中的 MessageBoxA API 函數。它定義了一些常用的 uType (樣式) 和返回值常數，並顯示一個帶有“是/否/取消”按鈕和問題圖標的訊息框。它還嘗試獲取主應用程式視窗的控制代碼 (Application.hWnd 在現代Office中通常可用) 作為父視窗。"}
                ],
                "keywords": ["windows api messagebox", "custom messagebox vba", "user32 messagebox", "api dialog box", "進階訊息框", "API對話框"]
            },
            {
                "name": "FindWindow (Windows API)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Private Declare Function FindWindow Lib \"user32\" Alias \"FindWindowA\" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long",
                "description": "使用 Windows API 函數 FindWindowA (或 FindWindowW) 尋找頂層視窗，其類別名稱和/或視窗名稱符合指定字串。傳回找到視窗的控制代碼 (HWND)，如果失敗則傳回0。",
                "parameters": [
                    {"name": "lpClassName", "description": "指向包含類別名稱的空結尾字串的指標，或一個原子。如果為 vbNullString，則接受任何類別。"},
                    {"name": "lpWindowName", "description": "指向包含視窗名稱 (標題) 的空結尾字串的指標。如果為 vbNullString，則接受任何視窗名稱。"}
                ],
                "examples": [
                    {"code": "#If VBA7 And Win64 Then\n  Private Declare PtrSafe Function FindWindow Lib \"user32\" Alias \"FindWindowA\" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr\n#Else\n  Private Declare Function FindWindow Lib \"user32\" Alias \"FindWindowA\" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long\n#End If\n\nSub CheckIfNotepadIsOpen()\n  Dim notepadHwnd As LongPtr\n  ' 尋找類別名稱為 \"Notepad\" 的視窗 (記事本的類別名稱)\n  notepadHwnd = FindWindow(\"Notepad\", vbNullString) ' vbNullString 表示忽略視窗標題\n  \n  If notepadHwnd <> 0 Then\n    MsgBox \"記事本正在執行！控制代碼: \" & notepadHwnd\n    ' 可以進一步使用此控制代碼操作記事本視窗 (例如，SendMessage API)\n  Else\n    MsgBox \"記事本未執行或找不到。\"\n  End If\nEnd Sub\n\nSub FindSpecificExcelWindow()\n    Dim specificWorkbookTitle As String\n    Dim excelHwnd As LongPtr\n    ' 假設要尋找的Excel活頁簿標題是 \"SalesData.xlsx - Excel\"\n    specificWorkbookTitle = \"SalesData.xlsx - Excel\" ' 實際標題可能因語言和版本而異\n    \n    ' Excel 主應用程式視窗的類別名稱通常是 \"XLMAIN\"\n    excelHwnd = FindWindow(\"XLMAIN\", specificWorkbookTitle)\n    \n    If excelHwnd <> 0 Then\n        MsgBox \"找到名為 '\" & specificWorkbookTitle & \"' 的Excel視窗。控制代碼: \" & excelHwnd\n    Else\n        MsgBox \"未找到名為 '\" & specificWorkbookTitle & \"' 的Excel視窗。\"\n    End If\nEnd Sub", "explanation": "第一個範例 CheckIfNotepadIsOpen 演示如何使用 FindWindow 透過類別名稱 \"Notepad\" 來檢查記事本應用程式是否正在執行。第二個範例 FindSpecificExcelWindow 嘗試尋找具有特定標題的Excel視窗 (例如，已開啟的特定活頁簿)。注意：視窗標題可能因應用程式版本和語言設定而異。"}
                ],
                "keywords": ["windows api findwindow", "get window handle vba", "check if application running api", "hwnd", "user32 findwindow", "尋找視窗API", "獲取視窗控制代碼", "檢查程式是否執行"]
            },
            {
                "name": "SendMessage (Windows API)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Private Declare Function SendMessage Lib \"user32\" Alias \"SendMessageA\" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long",
                "description": "將指定的訊息傳送到一個或多個視窗。此函數會呼叫指定視窗的視窗程序，並且在視窗程序處理完訊息之前不會傳回。",
                "parameters": [
                    {"name": "hWnd", "description": "要接收訊息的視窗的控制代碼。"},
                    {"name": "wMsg", "description": "要傳送的訊息 (例如，WM_CLOSE, WM_SETTEXT)。"},
                    {"name": "wParam", "description": "第一個訊息特定的附加資訊。"},
                    {"name": "lParam", "description": "第二個訊息特定的附加資訊 (可以是數值或字串指標等，視訊息而定，故宣告為 Any)。"}
                ],
                "examples": [
                    {"code": "#If VBA7 And Win64 Then\n  Private Declare PtrSafe Function FindWindow Lib \"user32\" Alias \"FindWindowA\" (ByVal lpClassName As String, ByVal lpWindowName As String) As LongPtr\n  Private Declare PtrSafe Function SendMessage Lib \"user32\" Alias \"SendMessageA\" (ByVal hWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As Any) As LongPtr\n  Private Declare PtrSafe Function SendMessageTimeout Lib \"user32\" Alias \"SendMessageTimeoutA\" (ByVal hWnd As LongPtr, ByVal Msg As Long, ByVal wParam As LongPtr, ByVal lParam As Any, ByVal fuFlags As Long, ByVal uTimeout As Long, ByRef lpdwResult As LongPtr) As LongPtr\n#Else\n  Private Declare Function FindWindow Lib \"user32\" Alias \"FindWindowA\" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long\n  Private Declare Function SendMessage Lib \"user32\" Alias \"SendMessageA\" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Any) As Long\n  Private Declare Function SendMessageTimeout Lib \"user32\" Alias \"SendMessageTimeoutA\" (ByVal hWnd As Long, ByVal Msg As Long, ByVal wParam As Long, ByVal lParam As Any, ByVal fuFlags As Long, ByVal uTimeout As Long, ByRef lpdwResult As Long) As Long\n#End If\n\nConst WM_SETTEXT As Long = &HC\nConst WM_CLOSE As Long = &H10\nConst SMTO_NORMAL As Long = &H0\nConst SMTO_BLOCK As Long = &H1\nConst SMTO_ABORTIFHUNG As Long = &H2\n\nSub ChangeNotepadTitleAndClose()\n  Dim notepadHwnd As LongPtr\n  Dim res As LongPtr\n  Dim dummyResult As LongPtr\n\n  notepadHwnd = FindWindow(\"Notepad\", vbNullString)\n  If notepadHwnd = 0 Then\n    MsgBox \"記事本未執行。請先開啟記事本。\"\n    Exit Sub\n  End If\n\n  ' 更改記事本標題 (使用 SendMessageTimeout 以避免卡死)\n  ' lParam 傳遞字串時，需要傳遞字串的指標，vbNullString 作為 wParam\n  res = SendMessageTimeout(notepadHwnd, WM_SETTEXT, 0, ByVal \"VBA控制中!\", SMTO_NORMAL Or SMTO_ABORTIFHUNG, 1000, dummyResult)\n  If res = 0 Then\n    Debug.Print \"SendMessageTimeout WM_SETTEXT failed or timed out. LastError: \" & Err.LastDllError\n  Else\n    MsgBox \"記事本標題已嘗試更改為 'VBA控制中!'\"\n  End If\n\n  Application.Wait (Now + TimeValue(\"0:00:02\")) ' 等待2秒讓使用者看到變化\n\n  ' 關閉記事本視窗\n  If MsgBox(\"是否要關閉記事本？\", vbYesNo) = vbYes Then\n    res = SendMessage(notepadHwnd, WM_CLOSE, 0, 0&)\n    ' 注意: SendMessage WM_CLOSE 可能不會立即關閉，它會觸發正常的關閉流程 (如提示儲存)\n    If res = 0 Then ' SendMessage 通常在成功時返回0，除非有特定返回值\n        MsgBox \"WM_CLOSE 訊息已傳送至記事本。\"\n    Else\n        Debug.Print \"SendMessage WM_CLOSE returned: \" & res\n    End If\n  End If\nEnd Sub", "explanation": "此範例首先使用 FindWindow 尋找記事本視窗。如果找到，它會嘗試使用 SendMessageTimeout (一個更安全的 SendMessage 版本，可以防止應用程式因目標視窗無響應而卡死) 和 WM_SETTEXT 訊息來更改記事本的標題。然後，它會提示使用者是否要關閉記事本，如果選擇是，則使用 SendMessage 和 WM_CLOSE 訊息來嘗試關閉記事本視窗。對於傳遞字串給 lParam 的 WM_SETTEXT，通常需要使用 ByVal 來傳遞字串本身 (API 會處理指標)。WM_CLOSE 的 wParam 和 lParam 通常為0。"}
                ],
                "keywords": ["windows api sendmessage", "control window vba", "wm_settext", "wm_close", "user32 sendmessage", "傳送視窗訊息", "控制外部應用程式"]
            },
            {
                "name": "ShellExecute (Windows API)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Private Declare Function ShellExecute Lib \"shell32.dll\" Alias \"ShellExecuteA\" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long",
                "description": "執行對指定檔案的操作。操作可以是 \"open\"（開啟）、\"print\"（列印）、\"explore\"（瀏覽）等。比 VBA 內建的 Shell 函數功能更強大，可以開啟文件、URL、執行檔等。",
                "parameters": [
                    {"name": "hWnd", "description": "父視窗的控制代碼。"},
                    {"name": "lpOperation", "description": "要執行的操作，例如 \"open\", \"print\", \"explore\"。如果為 vbNullString，則預設為 \"open\"。"},
                    {"name": "lpFile", "description": "要操作的檔案或資料夾的名稱，或 URL。"},
                    {"name": "lpParameters", "description": "如果 lpFile 是執行檔，則為傳遞給該執行檔的參數。"},
                    {"name": "lpDirectory", "description": "操作的預設目錄。"},
                    {"name": "nShowCmd", "description": "指定應用程式啟動時如何顯示的常數 (例如 SW_SHOWNORMAL=1, SW_SHOWMAXIMIZED=3, SW_HIDE=0)。"}
                ],
                "examples": [
                    {"code": "#If VBA7 And Win64 Then\n  Private Declare PtrSafe Function ShellExecute Lib \"shell32.dll\" Alias \"ShellExecuteA\" (ByVal hwnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As LongPtr\n#Else\n  Private Declare Function ShellExecute Lib \"shell32.dll\" Alias \"ShellExecuteA\" (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long\n#End If\n\nConst SW_SHOWNORMAL As Long = 1\nConst SW_SHOWMAXIMIZED As Long = 3\nConst SW_HIDE As Long = 0\n\nSub OpenWebsiteWithShellExecute()\n  Dim result As LongPtr\n  result = ShellExecute(0, \"open\", \"https://www.google.com\", vbNullString, vbNullString, SW_SHOWNORMAL)\n  If result <= 32 Then ' 如果返回值小於等於32，表示發生錯誤\n    MsgBox \"無法開啟網站。錯誤碼: \" & result\n  Else\n    MsgBox \"網站已嘗試開啟。\"\n  End If\nEnd Sub\n\nSub OpenTextFileWithShellExecute()\n  Dim filePath As String\n  filePath = \"C:\\Temp\\MyTextFile.txt\" ' 確保此文件存在\n  ' 先創建一個示例文件\n  ' Dim fso As Object: Set fso = CreateObject(\"Scripting.FileSystemObject\")\n  ' If Not fso.FileExists(filePath) Then fso.CreateTextFile(filePath).Write \"Hello via ShellExecute!\" : Set fso = Nothing\n\n  Dim result As LongPtr\n  result = ShellExecute(0, \"open\", filePath, vbNullString, \"C:\\Temp\\\", SW_SHOWNORMAL)\n  If result <= 32 Then MsgBox \"無法開啟文件。錯誤碼: \" & result\nEnd Sub\n\nSub PrintDocumentWithShellExecute()\n  Dim docPath As String\n  docPath = \"C:\\Path\\To\\YourDocument.docx\" ' 替換為實際文件路徑\n  ' Dim result As LongPtr\n  ' result = ShellExecute(0, \"print\", docPath, vbNullString, vbNullString, SW_HIDE) ' SW_HIDE 通常用於背景列印\n  ' If result <= 32 Then MsgBox \"無法列印文件。錯誤碼: \" & result Else MsgBox \"文件已傳送至印表機。\"\nEnd Sub", "explanation": "此範例包含三個子程序：OpenWebsiteWithShellExecute 使用 ShellExecute 開啟一個網址；OpenTextFileWithShellExecute 開啟一個本地文字檔案；PrintDocumentWithShellExecute (註解狀態) 演示如何使用 \"print\" 操作來列印文件。ShellExecute 的返回值如果大於32，通常表示成功啟動。"}
                ],
                "keywords": ["windows api shellexecute", "open file api", "open url api", "print file api", "shell32 shellexecute", "執行檔案API", "開啟網址API", "列印文件API"]
            },
            {
                "name": "InternetExplorer.Application (CreateObject)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set ie = CreateObject(\"InternetExplorer.Application\")",
                "description": "建立一個 Internet Explorer 應用程式物件的執行個體，可用於自動化網頁瀏覽、表單提交和資料擷取。注意：由於 IE 已停止支援，此方法可能不再可靠或推薦用於新的開發，Edge (IE 模式) 或 Selenium/WebDriver可能是更現代的選擇。",
                "parameters": [
                    {"name": "Visible", "description": "屬性：True 使 IE 視窗可見，False (預設) 隱藏它。"},
                    {"name": "Navigate(URL)", "description": "方法：導覽至指定的 URL。"},
                    {"name": "Document", "description": "屬性：傳回代表目前載入 HTML 文件的 HTMLDocument 物件。"},
                    {"name": "Busy", "description": "屬性：True 表示 IE 正在載入頁面或執行其他操作。"},
                    {"name": "ReadyState", "description": "屬性：指示 IE 的載入狀態 (例如，READYSTATE_COMPLETE = 4)。"},
                    {"name": "Quit()", "description": "方法：關閉 IE 應用程式。"}
                ],
                "examples": [
                    {"code": "Dim ie As Object ' InternetExplorer.Application\nDim htmlDoc As Object ' MSHTML.HTMLDocument\n' On Error Resume Next ' Handle cases where IE might not be available or automation is blocked\n' Set ie = CreateObject(\"InternetExplorer.Application\")\n' If ie Is Nothing Then\n'   MsgBox \"無法建立 Internet Explorer 物件。\", vbCritical\n'   Exit Sub\n' End If\n' On Error GoTo 0\n\n' ie.Visible = True ' 使視窗可見以便觀察\n' ie.Navigate \"http://example.com\"\n\n' Wait for page to load\n' Do While ie.Busy Or ie.ReadyState <> 4 ' 4 = READYSTATE_COMPLETE\n'   DoEvents\n' Loop\n\n' Set htmlDoc = ie.Document\n' If Not htmlDoc Is Nothing Then\n'   MsgBox \"頁面標題: \" & htmlDoc.Title\n'   ' --- 在此處可以操作 htmlDoc 來擷取資料或與元素互動 ---\n'   ' 例如: Dim firstHeader As Object ' MSHTML.IHTMLElement\n'   ' Set firstHeader = htmlDoc.getElementsByTagName(\"h1\")(0)\n'   ' If Not firstHeader Is Nothing Then MsgBox \"第一個 H1 標籤內容: \" & firstHeader.innerText\n' Else\n'   MsgBox \"無法取得 HTML 文件物件。\"\n' End If\n\n' ie.Quit\n' Set ie = Nothing\n' Set htmlDoc = Nothing", "explanation": "演示如何建立 IE 物件、導覽至網頁、等待頁面完全載入、獲取 HTML 文件物件，並示範如何讀取頁面標題和第一個 H1 標籤的內容。最後關閉 IE。"}
                ],
                "keywords": ["internet explorer automation", "web scraping vba", "ie automation", "navigate web page", "get html document", "網頁自動化", "網頁資料擷取", "IE控制"]
            },
            {
                "name": "HTMLDocument.getElementById (MSHTML)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set htmlElement = htmlDoc.getElementById(IdAsString)",
                "description": "從 HTML 文件中傳回具有指定 ID 屬性的元素。這是定位特定 HTML 元素的常用方法。",
                "parameters": [{"name": "IdAsString", "description": "必需。元素 ID (字串)。"}],
                "examples": [
                    {"code": "Dim ie As Object, htmlDoc As Object, searchInput As Object ' MSHTML.IHTMLElement\n' Set ie = ... ' Assume IE is created and navigated\n' Set htmlDoc = ie.Document\n' ' 假設網頁上有一個 ID 為 \"searchInputField\" 的輸入框\n' Set searchInput = htmlDoc.getElementById(\"searchInputField\")\n' If Not searchInput Is Nothing Then\n'   searchInput.Value = \"VBA Web Automation\"\n'   MsgBox \"已在 ID 為 'searchInputField' 的輸入框中填入文字。\"\n' Else\n'   MsgBox \"未找到 ID 為 'searchInputField' 的元素。\"\n' End If", "explanation": "演示如何透過元素的 ID 獲取 HTML 輸入框元素，然後設定其值。"}
                ],
                "keywords": ["getelementbyid", "html dom access", "find html element by id", "mshtml", "web automation", "依ID獲取元素", "HTML DOM"]
            },
            {
                "name": "HTMLDocument.getElementsByTagName (MSHTML)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set htmlCollection = htmlDoc.getElementsByTagName(TagNameAsString)",
                "description": "傳回一個 HTML 元素集合 (IHTMLElementCollection)，其中包含文件中所有具有指定標籤名稱的元素。",
                "parameters": [{"name": "TagNameAsString", "description": "必需。HTML 標籤名稱 (例如 \"a\", \"table\", \"input\")。"}],
                "examples": [
                    {"code": "Dim ie As Object, htmlDoc As Object, links As Object, link As Object ' MSHTML.IHTMLElement\n' Set ie = ... ' Assume IE is created and navigated\n' Set htmlDoc = ie.Document\n' Set links = htmlDoc.getElementsByTagName(\"a\") ' 獲取所有超連結元素\n' Debug.Print \"找到 \" & links.Length & \" 個超連結。\"\n' For Each link In links\n'   Debug.Print \"連結文字: \" & link.innerText & \" - URL: \" & link.getAttribute(\"href\")\n' Next link", "explanation": "演示如何獲取頁面上所有超連結 (<a> 標籤) 的集合，並遍歷它們以列印其文字和 href 屬性。"}
                ],
                "keywords": ["getelementsbytagname", "html collection", "find html elements by tag", "mshtml", "web scraping", "依標籤名稱獲取元素集合"]
            },
            {
                "name": "HTMLDocument.getElementsByClassName (MSHTML)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set htmlCollection = htmlDoc.getElementsByClassName(ClassNameAsString)",
                "description": "傳回一個 HTML 元素集合，其中包含文件中所有具有指定類別名稱的元素。",
                "parameters": [{"name": "ClassNameAsString", "description": "必需。元素的 class 屬性值。"}],
                "examples": [
                    {"code": "Dim ie As Object, htmlDoc As Object, articles As Object, article As Object ' MSHTML.IHTMLElement\n' Set ie = ... ' Assume IE is created and navigated\n' Set htmlDoc = ie.Document\n' Set articles = htmlDoc.getElementsByClassName(\"news-article\") ' 獲取所有 class 為 \"news-article\" 的元素\n' Debug.Print \"找到 \" & articles.Length & \" 篇文章。\"\n' For Each article In articles\n'   Dim titleElement As Object\n'   On Error Resume Next ' Assuming title is a child h2 tag\n'   Set titleElement = article.getElementsByTagName(\"h2\")(0)\n'   If Not titleElement Is Nothing Then Debug.Print \"文章標題: \" & titleElement.innerText\n'   On Error GoTo 0\n' Next article", "explanation": "演示如何獲取頁面上所有 class 為 \"news-article\" 的元素集合，並嘗試提取每個元素內的 H2 標籤作為標題。"}
                ],
                "keywords": ["getelementsbyclassname", "find html elements by class", "mshtml", "web scraping", "依類別名稱獲取元素集合"]
            },
            {
                "name": "IHTMLElement.innerText / .outerText (MSHTML)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "strText = htmlElement.innerText\nstrHtml = htmlElement.outerText ' (or .outerHTML)",
                "description": "innerText 屬性設定或取得物件的開始和結束標籤之間的文字。outerText (或更常用的 outerHTML) 屬性設定或取得物件及其內容 (包括 HTML 標籤)。",
                "parameters": [],
                "examples": [
                    {"code": "Dim divElement As Object ' MSHTML.IHTMLElement, assume it points to a <div>\n' ' <div id=\"sampleDiv\"><p>Some <b>bold</b> text.</p></div>'\n' Set divElement = htmlDoc.getElementById(\"sampleDiv\")\n' If Not divElement Is Nothing Then\n'   Debug.Print \"innerText: \" & divElement.innerText ' Output: Some bold text.\n'   Debug.Print \"outerHTML: \" & divElement.outerHTML ' Output: <DIV id=sampleDiv><P>Some <B>bold</B> text.</P></DIV>\n' End If", "explanation": "演示 innerText 和 outerHTML (outerText 行為類似但 outerHTML 更明確) 之間的區別。innerText 只獲取純文字，而 outerHTML 包含元素本身的 HTML 標籤及其內容。"}
                ],
                "keywords": ["innertext", "outertext", "outerhtml", "get element text", "get element html", "mshtml", "獲取元素文字", "獲取元素HTML"]
            },
            {
                "name": "IHTMLElement.getAttribute (MSHTML)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "attributeValue = htmlElement.getAttribute(AttributeNameAsString, [Flags])",
                "description": "取得 HTML 元素上指定屬性的值。",
                "parameters": [
                    {"name": "AttributeNameAsString", "description": "必需。要獲取其值的屬性名稱 (例如 \"href\", \"src\", \"class\")。"},
                    {"name": "Flags", "description": "可選。指定如何傳回屬性值 (通常省略或設為 0 或 2，0表示按原樣，2表示不區分大小寫)。"}
                ],
                "examples": [
                    {"code": "Dim imgElement As Object ' MSHTML.IHTMLImgElement, assume it points to an <img> tag\nDim imgSrc As String\n' Set imgElement = htmlDoc.getElementsByTagName(\"img\")(0) ' Get first image\n' If Not imgElement Is Nothing Then\n'   imgSrc = imgElement.getAttribute(\"src\")\n'   Debug.Print \"圖片來源 (src): \" & imgSrc\n'   Dim altText As String\n'   altText = imgElement.getAttribute(\"alt\")\n'   Debug.Print \"圖片替代文字 (alt): \" & altText\n' End If", "explanation": "演示如何獲取圖片元素 (<img>) 的 'src' (來源) 和 'alt' (替代文字) 屬性值。"}
                ],
                "keywords": ["getattribute", "html element attribute", "get href", "get src", "mshtml", "獲取元素屬性"]
            },
            {
                "name": "IHTMLElement.setAttribute (MSHTML)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "htmlElement.setAttribute AttributeNameAsString, Value, [CaseSensitive As Long = 1]",
                "description": "設定 HTML 元素上指定屬性的值。如果屬性不存在，則會建立它。",
                "parameters": [
                    {"name": "AttributeNameAsString", "description": "必需。要設定的屬性名稱。"},
                    {"name": "Value", "description": "必需。要設定給屬性的值。"},
                    {"name": "CaseSensitive", "description": "可選。通常為 1 (不區分大小寫) 或 0 (區分大小寫)。對於 HTML，通常不區分大小寫。"}
                ],
                "examples": [
                    {"code": "Dim inputElement As Object ' MSHTML.IHTMLInputElement, assume it points to an <input type='text'>\n' Set inputElement = htmlDoc.getElementById(\"myTextField\")\n' If Not inputElement Is Nothing Then\n'   inputElement.setAttribute \"value\", \"New Text Value\"\n'   inputElement.setAttribute \"disabled\", True ' Disable the input field\n'   inputElement.setAttribute \"data-custom-attr\", \"MyData123\" ' Add a custom attribute\n'   MsgBox \"輸入欄位的值和屬性已設定。\"\n' End If", "explanation": "演示如何設定輸入欄位的 'value'、'disabled' 屬性，以及如何新增一個自訂的 'data-custom-attr' 屬性。"}
                ],
                "keywords": ["setattribute", "modify html attribute", "change element property", "mshtml", "設定元素屬性"]
            },
            {
                "name": "IHTMLElement.Click (MSHTML)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "htmlElement.Click",
                "description": "模擬對 HTML 元素的滑鼠點擊事件。常用於觸發按鈕、連結或提交表單。",
                "parameters": [],
                "examples": [
                    {"code": "Dim submitButton As Object ' MSHTML.IHTMLElement\n' Set submitButton = htmlDoc.getElementById(\"submitBtn\")\n' If Not submitButton Is Nothing Then\n'   submitButton.Click ' 模擬點擊提交按鈕\n'   ' Need to add wait logic for page to respond/navigate after click\n'   MsgBox \"已模擬點擊提交按鈕。\"\n' Else\n'   MsgBox \"未找到提交按鈕。\"\n' End If", "explanation": "演示如何找到一個 ID 為 \"submitBtn\" 的按鈕元素，然後模擬對其的點擊操作。"}
                ],
                "keywords": ["element click", "simulate click vba", "click button programmatically", "mshtml", "web automation click", "模擬點擊", "觸發按鈕"]
            },
            {
                "name": "WinHttpRequest (MSXML2.XMLHTTP or Microsoft.XMLHTTP)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set httpReq = CreateObject(\"MSXML2.XMLHTTP.6.0\") \n' or Set httpReq = CreateObject(\"Microsoft.XMLHTTP\") ' Older version\n' or Set httpReq = CreateObject(\"WinHttp.WinHttpRequest.5.1\") ' WinHTTP (often preferred for server-side or more robust scenarios)",
                "description": "提供用戶端 HTTP 協定功能，用於在 VBA 和 HTTP 伺服器之間傳送 HTTP 要求 (GET, POST 等) 並接收回應。對於直接 API 呼叫或不需完整瀏覽器呈現的網頁內容擷取很有用。",
                "parameters": [
                    {"name": "Open(Method, URL, [Async])", "description": "方法：初始化一個 HTTP 要求。Method (例如 \"GET\", \"POST\")，URL，Async (True/False)。"},
                    {"name": "Send([Body])", "description": "方法：傳送 HTTP 要求到伺服器。Body 是用於 POST 要求的資料。"},
                    {"name": "Status", "description": "屬性：傳回 HTTP 狀態碼 (例如 200 表示成功, 404 表示未找到)。"},
                    {"name": "StatusText", "description": "屬性：傳回 HTTP 狀態文字 (例如 \"OK\", \"Not Found\")。"},
                    {"name": "ResponseText", "description": "屬性：以字串形式傳回伺服器的回應內容。"},
                    {"name": "ResponseBody", "description": "屬性：以位元組陣列形式傳回伺服器的回應內容。"},
                    {"name": "ResponseXML", "description": "屬性：如果回應是有效的 XML/HTML，則傳回一個 MSXML2.DOMDocument 物件。"},
                    {"name": "SetRequestHeader(Header, Value)", "description": "方法：設定 HTTP 要求的標頭。"}
                ],
                "examples": [
                    {"code": "Dim http As Object\nDim url As String, response As String\n\n' Using MSXML2.XMLHTTP (common for general web requests)\nSet http = CreateObject(\"MSXML2.XMLHTTP.6.0\")\nurl = \"https://jsonplaceholder.typicode.com/todos/1\" ' Example public API\n\n' http.Open \"GET\", url, False ' False for synchronous request\n' http.Send\n\n' If http.Status = 200 Then\n'   response = http.ResponseText\n'   Debug.Print \"Response Text:\"\n'   Debug.Print response\n   ' If response is JSON, you'd need a JSON parser to work with it easily\n' Else\n'   Debug.Print \"Request failed. Status: \" & http.Status & \" - \" & http.StatusText\n' End If\n\n' --- Example using WinHttp.WinHttpRequest.5.1 (often more robust) ---\n' Dim winHttpReq As Object\n' Set winHttpReq = CreateObject(\"WinHttp.WinHttpRequest.5.1\")\n' winHttpReq.Open \"GET\", url, False\n' winHttpReq.Send\n' If winHttpReq.Status = 200 Then\n'   Debug.Print \"WinHTTP Response Text:\"\n'   Debug.Print winHttpReq.ResponseText\n' Else\n'   Debug.Print \"WinHTTP Request failed. Status: \" & winHttpReq.Status & \" - \" & winHttpReq.StatusText\n' End If\n\n' Set http = Nothing\n' Set winHttpReq = Nothing", "explanation": "演示如何使用 MSXML2.XMLHTTP 和 WinHttp.WinHttpRequest.5.1 物件發送 HTTP GET 要求到一個公共 API 端點，並獲取回應文字。同步模式 (Async=False) 用於簡化，回應會在 Send() 方法完成後立即獲得。"}
                ],
                "keywords": ["xmlhttp", "winhttprequest", "http get", "http post", "api call vba", "web request", "rest api", "HTTP請求", "API調用", "獲取網頁內容"]
            },
            {
                "name": "Parsing JSON with VBA (using a helper function or library)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "' Requires a JSON parsing library/module (e.g., VBA-JSON by Tim Hall, or custom parser)\n' parsedData = JsonConverter.ParseJson(jsonString)",
                "description": "VBA 本身沒有內建的 JSON 解析器。要處理從 API 或網頁服務收到的 JSON 回應，通常需要引用外部函式庫 (例如 VBA-JSON 專案) 或編寫自訂的解析函數。解析後的 JSON 資料通常會轉換為 VBA 的 Dictionary 和 Collection 物件以便存取。",
                "parameters": [
                    {"name": "jsonString", "description": "包含 JSON 資料的字串。"},
                    {"name": "Parsed Data", "description": "解析後產生的 VBA 物件 (通常是 Dictionary 代表 JSON 物件，Collection 代表 JSON 陣列)。"}
                ],
                "examples": [
                    {"code": "' --- This example assumes you have a JSON parsing function/library ---\n' --- For instance, using a conceptual 'JsonParser.Parse' function ---\n\n' Function GetJsonData() As Object ' Returns a Dictionary or Collection\n'   Dim http As Object, jsonResponse As String, jsonData As Object\n'   Set http = CreateObject(\"MSXML2.XMLHTTP.6.0\")\n'   http.Open \"GET\", \"https://jsonplaceholder.typicode.com/users/1\", False\n'   http.Send\n'   If http.Status = 200 Then\n'     jsonResponse = http.ResponseText\n'     ' --- Assume JsonParser.Parse function exists ---\n'     ' Set jsonData = JsonParser.Parse(jsonResponse)\n'     ' If Not jsonData Is Nothing Then\n'     '   Debug.Print \"User Name: \" & jsonData(\"name\")\n'     '   Debug.Print \"Email: \" & jsonData(\"email\")\n'     '   Debug.Print \"City: \" & jsonData(\"address\")(\"city\") ' Access nested object\n'     ' End If\n'   Else\n'     Debug.Print \"Failed to get JSON data. Status: \" & http.Status\n'   End If\n'   Set http = Nothing\n'   Set GetJsonData = jsonData ' Return the parsed object\n' End Function\n\n' Sub TestJsonParsing()\n'   Dim userInfo As Object\n'   Set userInfo = GetJsonData()\n'   If Not userInfo Is Nothing Then\n'      MsgBox \"User's company name: \" & userInfo(\"company\")(\"name\")\n'   End If\n'   Set userInfo = Nothing\n' End Sub", "explanation": "概念性地演示了如何獲取 JSON 字串回應，然後使用一個假設的 JSON 解析器 (例如來自 VBA-JSON 函式庫的 JsonConverter.ParseJson) 將其轉換為 VBA 的 Dictionary/Collection 物件，以便輕鬆存取巢狀資料。實際使用時，你需要整合一個 JSON 解析方案。"}
                ],
                "keywords": ["vba parse json", "json to dictionary vba", "json to collection vba", "handle json response", "api data parsing", "JSON解析", "處理JSON資料"]
            },
            {
                "name": "ADODB.Connection", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set conn = CreateObject(\"ADODB.Connection\")",
                "description": "建立一個 ADODB Connection 物件，用於建立與資料來源的連接。",
                "parameters": [
                    {"name": "ConnectionString", "description": "屬性：包含用於建立連接的資訊的字串。"},
                    {"name": "Open()", "description": "方法：開啟到資料來源的連接。"},
                    {"name": "Close()", "description": "方法：關閉到資料來源的連接。"},
                    {"name": "Execute(CommandText, [RecordsAffected], [Options])", "description": "方法：執行指定的查詢、SQL 語句、預存程序或提供者特定的文字。"},
                    {"name": "State", "description": "屬性：指示連接目前是開啟 (adStateOpen) 還是關閉 (adStateClosed)。"}
                ],
                "examples": [
                    {"code": "Dim conn As Object ' ADODB.Connection\nDim strConn As String\nSet conn = CreateObject(\"ADODB.Connection\")\n\n' Example for Access database (ACE OLEDB Provider for .accdb)\n' strConn = \"Provider=Microsoft.ACE.OLEDB.12.0;Data Source=C:\\Path\\To\\YourDatabase.accdb;Persist Security Info=False;\"\n\n' Example for SQL Server (SQLOLEDB Provider - older, or MSOLEDBSQL for newer)\n' strConn = \"Provider=SQLOLEDB;Data Source=YourServerName;Initial Catalog=YourDatabaseName;User ID=YourUserID;Password=YourPassword;\"\n\n' On Error Resume Next\n' conn.Open strConn\n' If conn.State = 1 Then ' 1 = adStateOpen\n'   MsgBox \"成功連接到資料庫!\"\n'   ' ... 執行資料庫操作 ...\n'   conn.Close\n'   MsgBox \"資料庫連接已關閉。\"\n' Else\n'   MsgBox \"連接失敗: \" & Err.Description\n' End If\n' On Error GoTo 0\n' Set conn = Nothing", "explanation": "演示如何建立 ADODB 連接物件、設定連接字串 (範例為 Access 和 SQL Server)，以及開啟和關閉資料庫連接。實際使用時需替換為有效的連接字串和檔案路徑。"}
                ],
                "keywords": ["adodb connection", "database connection", "connect to database", "sql connection", "access connection", "ado", "資料庫連接", "ADO連線"]
            },
            {
                "name": "ADODB.Recordset", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set rs = CreateObject(\"ADODB.Recordset\")",
                "description": "建立一個 ADODB Recordset 物件，代表來自基底資料表或命令執行結果的一組記錄。",
                "parameters": [
                    {"name": "Open(Source, [ActiveConnection], [CursorType], [LockType], [Options])", "description": "方法：開啟一個資料指標，指向資料錄集中的記錄。"},
                    {"name": "Close()", "description": "方法：關閉開啟的資料錄集。"},
                    {"name": "Fields(IndexOrName)", "description": "屬性/集合：存取資料錄集中特定欄位的值。"},
                    {"name": "MoveNext()", "description": "方法：將目前記錄位置移至下一筆記錄。"},
                    {"name": "MoveFirst()", "description": "方法：將目前記錄位置移至第一筆記錄。"},
                    {"name": "EOF", "description": "屬性：如果目前記錄位置在最後一筆記錄之後，則傳回 True (End Of File)。"},
                    {"name": "BOF", "description": "屬性：如果目前記錄位置在第一筆記錄之前，則傳回 True (Beginning Of File)。"},
                    {"name": "RecordCount", "description": "屬性：傳回資料錄集中的記錄數 (可能因 CursorType 而異)。"},
                    {"name": "AddNew()", "description": "方法：建立一個新的空白記錄以便新增資料。"},
                    {"name": "Update()", "description": "方法：儲存對目前記錄所做的任何變更。"},
                    {"name": "Delete()", "description": "方法：刪除目前記錄或一組記錄。"},
                    {"name": "Filter", "description": "屬性：設定或傳回資料錄集的篩選條件。"}
                ],
                "examples": [
                    {"code": "Dim conn As Object ' ADODB.Connection\nDim rs As Object   ' ADODB.Recordset\nDim strSQL As String\n' Set conn = ... (Assume connection is established, see ADODB.Connection example)\n' Set rs = CreateObject(\"ADODB.Recordset\")\n' strSQL = \"SELECT ProductName, UnitPrice FROM Products WHERE CategoryID = 1;\"\n\n' On Error Resume Next\n' rs.Open strSQL, conn, 3, 3 ' adOpenStatic, adLockOptimistic (CursorType=3, LockType=3)\n' If Err.Number = 0 Then\n'   If Not rs.EOF Then\n'     Do While Not rs.EOF\n'       Debug.Print \"Product: \" & rs.Fields(\"ProductName\").Value & \", Price: \" & rs.Fields(\"UnitPrice\").Value\n'       rs.MoveNext\n'     Loop\n'   Else\n'     MsgBox \"找不到符合條件的產品。\"\n'   End If\n'   rs.Close\n' Else\n'   MsgBox \"執行查詢時發生錯誤: \" & Err.Description\n' End If\n' On Error GoTo 0\n' ' conn.Close ' (If opened here)\n' Set rs = Nothing: Set conn = Nothing", "explanation": "演示如何建立 Recordset 物件、使用 SQL 查詢開啟它、遍歷記錄並讀取欄位值，然後關閉 Recordset。假設連接物件 'conn' 已成功開啟。"}
                ],
                "keywords": ["adodb recordset", "database query", "fetch data", "sql query vba", "ado recordset", "資料錄集", "查詢資料", "讀取資料庫"]
            },
            {
                "name": "Recordset.Open Options (CursorType, LockType)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "rs.Open SQL, Connection, CursorType, LockType, Options",
                "description": "Recordset 的 Open 方法中的 CursorType 和 LockType 參數決定了資料指標的行為和資料鎖定機制。",
                "parameters": [
                    {"name": "CursorType (adOpenForwardOnly = 0)", "description": "僅向前資料指標。預設。只能向前移動。最快。"},
                    {"name": "CursorType (adOpenKeyset = 1)", "description": "鍵集資料指標。可以看到其他使用者對資料的變更，但看不到新增的記錄或已刪除的記錄。允許所有方向的移動。"},
                    {"name": "CursorType (adOpenDynamic = 2)", "description": "動態資料指標。可以看到其他使用者所做的所有變更，包括新增和刪除的記錄。允許所有方向的移動。資源消耗較大。"},
                    {"name": "CursorType (adOpenStatic = 3)", "description": "靜態資料指標。提供資料的靜態副本，在資料指標開啟時固定不變。看不到其他使用者的變更。允許所有方向的移動。"},
                    {"name": "LockType (adLockReadOnly = 1)", "description": "唯讀。無法變更資料。預設。"},
                    {"name": "LockType (adLockPessimistic = 2)", "description": "悲觀鎖定。提供者會在編輯記錄時立即鎖定記錄，以確保成功編輯。"},
                    {"name": "LockType (adLockOptimistic = 3)", "description": "樂觀鎖定。提供者僅在呼叫 Update 方法時才鎖定記錄。"},
                    {"name": "LockType (adLockBatchOptimistic = 4)", "description": "樂觀批次更新。用於批次更新模式。"}
                ],
                "examples": [
                    {"code": "Dim rs As Object\nSet rs = CreateObject(\"ADODB.Recordset\")\n' Open for read-only, forward-only access (fastest for just reading data)\n' rs.Open \"SELECT * FROM Customers\", conn, 0, 1 ' adOpenForwardOnly, adLockReadOnly\n\n' Open for updates, allowing full navigation and seeing others' changes (keyset)\n' rs.Open \"SELECT * FROM Orders\", conn, 1, 3 ' adOpenKeyset, adLockOptimistic", "explanation": "展示 CursorType 和 LockType 的常用組合。adOpenForwardOnly (0) 和 adLockReadOnly (1) 適用於僅讀取資料的快速操作。adOpenStatic (3) 和 adLockOptimistic (3) 適用於可更新的靜態資料副本。"}
                ],
                "keywords": ["adodb cursortype", "adodb locktype", "recordset options", "database cursor", "database locking", "資料指標類型", "鎖定類型"]
            },
            {
                "name": "Recordset.Fields Collection", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "value = rs.Fields(IndexOrName).Value\n' or\nvalue = rs(IndexOrName) ' Default property is Fields",
                "description": "Fields 集合包含 Recordset 物件中所有 Field 物件。每個 Field 物件對應於 Recordset 中的一欄資料。",
                "parameters": [
                    {"name": "IndexOrName", "description": "欄位的索引 (從零開始的數字) 或欄位名稱 (字串)。"},
                    {"name": "Field.Value", "description": "屬性：取得或設定欄位的值。"},
                    {"name": "Field.Name", "description": "屬性：傳回欄位的名稱。"},
                    {"name": "Field.Type", "description": "屬性：傳回欄位的資料類型 (DataTypeEnum 常數)。"},
                    {"name": "Field.ActualSize", "description": "屬性：傳回欄位值的實際長度。"},
                    {"name": "Field.DefinedSize", "description": "屬性：傳回欄位的定義大小。"}
                ],
                "examples": [
                    {"code": "Dim rs As Object ' ADODB.Recordset, assume it's open\nDim fld As Object  ' ADODB.Field\n' If Not rs.EOF Then\n'   ' Access by field name\n'   Debug.Print \"Customer Name: \" & rs.Fields(\"CustomerName\").Value\n'   ' Access by index (0-based)\n'   Debug.Print \"Order ID: \" & rs.Fields(0).Value\n'\n'   ' Iterate through all fields in the current record\n'   For Each fld In rs.Fields\n'     Debug.Print fld.Name & \" (\" & fld.Type & \") = \" & fld.Value\n'   Next fld\n' End If", "explanation": "演示如何透過欄位名稱或索引來存取 Recordset 中目前記錄的欄位值，以及如何遍歷目前記錄的所有欄位。"}
                ],
                "keywords": ["adodb fields", "recordset columns", "get field value", "database column", "欄位集合", "讀取欄位值", "資料庫欄"]
            },
            {
                "name": "Connection.Execute (ADO)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set rs = conn.Execute(CommandText, [RecordsAffected], [Options])\n' or for action queries:\nconn.Execute CommandText, [RecordsAffected], [Options]",
                "description": "執行 SQL 命令 (例如 SELECT、INSERT、UPDATE、DELETE) 或預存程序。對於 SELECT 查詢，它會傳回一個 Recordset 物件。對於動作查詢 (INSERT, UPDATE, DELETE)，它不會傳回 Recordset，但可以透過 RecordsAffected 參數取得受影響的記錄數。",
                "parameters": [
                    {"name": "CommandText", "description": "必需。要執行的 SQL 語句或命令。"},
                    {"name": "RecordsAffected", "description": "可選。一個長整型變數，提供者會在此傳回作業所影響的記錄數。"},
                    {"name": "Options", "description": "可選。CommandTypeEnum 值，指定如何評估 CommandText (例如，adCmdText, adCmdStoredProc)。預設為 adCmdText。"}
                ],
                "examples": [
                    {"code": "Dim conn As Object ' ADODB.Connection (assume open)\nDim rsCustomers As Object ' ADODB.Recordset\nDim strSQLSelect As String\nstrSQLSelect = \"SELECT CustomerID, CompanyName FROM Customers WHERE Country = 'Germany';\"\n' Execute a SELECT query\n' Set rsCustomers = conn.Execute(strSQLSelect)\n' If Not rsCustomers.EOF Then\n'   Do While Not rsCustomers.EOF\n'     Debug.Print rsCustomers!CustomerID & \" - \" & rsCustomers!CompanyName\n'     rsCustomers.MoveNext\n'   Loop\n' End If\n' rsCustomers.Close\n' Set rsCustomers = Nothing\n\nDim strSQLUpdate As String, recsAffected As Long\nstrSQLUpdate = \"UPDATE Products SET UnitPrice = UnitPrice * 1.1 WHERE CategoryID = 1;\"\n' Execute an UPDATE query (action query)\n' conn.Execute strSQLUpdate, recsAffected, 1 ' 1 = adCmdText\n' MsgBox recsAffected & \" 個產品的價格已更新。\"", "explanation": "第一個範例演示如何使用 Connection.Execute 執行 SELECT 查詢並處理傳回的 Recordset。第二個範例演示如何執行 UPDATE 動作查詢，並獲取受影響的記錄數。"}
                ],
                "keywords": ["adodb execute", "run sql query vba", "execute sql command", "action query ado", "執行SQL查詢", "執行動作查詢"]
            },
            {
                "name": "ADODB.Command", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set cmd = CreateObject(\"ADODB.Command\")",
                "description": "建立一個 ADODB Command 物件，用於定義要對資料來源執行的特定命令，例如 SQL 查詢、預存程序或資料表名稱。",
                "parameters": [
                    {"name": "ActiveConnection", "description": "屬性：設定或傳回與此 Command 物件關聯的 Connection 物件。"},
                    {"name": "CommandText", "description": "屬性：設定或傳回要執行的命令文字 (例如 SQL 語句)。"},
                    {"name": "CommandType", "description": "屬性：指示 CommandText 屬性的類型 (例如，adCmdText, adCmdStoredProc, adCmdTableDirect)。"},
                    {"name": "Parameters", "description": "集合：存取與 Command 物件關聯的 Parameter 物件。"},
                    {"name": "Execute([RecordsAffected], [Parameters], [Options])", "description": "方法：執行 CommandText 中指定的查詢、SQL 語句或預存程序。"}
                ],
                "examples": [
                    {"code": "Dim conn As Object ' ADODB.Connection (assume open)\nDim cmd As Object  ' ADODB.Command\nDim rs As Object   ' ADODB.Recordset\nDim paramCountry As Object ' ADODB.Parameter\n\n' Set cmd = CreateObject(\"ADODB.Command\")\n' Set cmd.ActiveConnection = conn\n' cmd.CommandText = \"SELECT CustomerID, CompanyName FROM Customers WHERE Country = ?;\"\n' cmd.CommandType = 1 ' adCmdText\n\n' Create and append parameter\n' Set paramCountry = cmd.CreateParameter(\"CountryParam\", 200, 1, 50, \"Germany\") ' adVarChar, adParamInput, size 50\n' cmd.Parameters.Append paramCountry\n\n' Execute command and get recordset\n' Set rs = cmd.Execute\n' If Not rs.EOF Then\n'   Do While Not rs.EOF\n'     Debug.Print rs!CustomerID & \" - \" & rs!CompanyName\n'     rs.MoveNext\n'   Loop\n' End If\n' rs.Close\n' Set rs = Nothing: Set cmd = Nothing: Set paramCountry = Nothing", "explanation": "演示如何使用 Command 物件執行帶參數的 SQL 查詢。首先設定 Command 物件的屬性，然後建立、設定並附加 Parameter 物件，最後執行命令以獲取 Recordset。"}
                ],
                "keywords": ["adodb command", "parameterized query ado", "sql command object", "stored procedure ado", "命令物件", "參數化查詢", "預存程序"]
            },
            {
                "name": "Command.Parameters Collection (ADO)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set param = cmd.CreateParameter(Name, Type, Direction, Size, [Value])\ncmd.Parameters.Append param\n' or cmd.Parameters.Refresh (for stored procedures)",
                "description": "Parameters 集合包含與 Command 物件關聯的所有 Parameter 物件。Parameter 物件代表查詢或預存程序中的參數。",
                "parameters": [
                    {"name": "CreateParameter(Name, Type, Direction, Size, [Value])", "description": "方法 (Command 的)：建立一個新的 Parameter 物件。"},
                    {"name": "Append(Object)", "description": "方法 (Parameters 的)：將 Parameter 物件新增到集合中。"},
                    {"name": "Refresh()", "description": "方法 (Parameters 的)：從提供者更新 Parameters 集合。對於預存程序，這可以自動填充參數資訊。"},
                    {"name": "Parameter.Name", "description": "屬性：參數的名稱。"},
                    {"name": "Parameter.Type", "description": "屬性：參數的資料類型 (DataTypeEnum)。"},
                    {"name": "Parameter.Direction", "description": "屬性：參數的方向 (ParameterDirectionEnum，例如 adParamInput, adParamOutput, adParamReturnValue)。"},
                    {"name": "Parameter.Size", "description": "屬性：參數的最大大小 (以字元或位元組為單位)。"},
                    {"name": "Parameter.Value", "description": "屬性：參數的值。"}
                ],
                "examples": [
                    {"code": "Dim cmd As Object ' ADODB.Command (assume ActiveConnection is set)\nDim paramStartDate As Object, paramEndDate As Object\n' cmd.CommandText = \"sp_GetOrdersByDateRange\"\n' cmd.CommandType = 4 ' adCmdStoredProc\n\n' Parameter for StartDate\n' Set paramStartDate = cmd.CreateParameter(\"@StartDate\", 7, 1, , \"2023-01-01\") ' adDate, adParamInput\n' cmd.Parameters.Append paramStartDate\n\n' Parameter for EndDate (another way to set value)\n' Set paramEndDate = cmd.CreateParameter(\"@EndDate\", adDate, adParamInput)\n' paramEndDate.Value = \"2023-03-31\"\n' cmd.Parameters.Append paramEndDate\n\n' Dim rs As Object\n' Set rs = cmd.Execute\n' ' ... process recordset ...\n' rs.Close\n' Set rs = Nothing", "explanation": "演示如何為預存程序建立和附加兩個日期參數。一個參數在建立時賦值，另一個在建立後賦值。"}
                ],
                "keywords": ["adodb parameters", "sql parameters vba", "command parameters ado", "stored procedure parameters", "參數集合", "SQL參數"]
            },
            {
                "name": "Transactions (ADO Connection)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "conn.BeginTrans\nconn.CommitTrans\nconn.RollbackTrans",
                "description": "ADO Connection 物件支援交易處理，允許將一組資料庫操作視為單一的原子單元。所有操作要麼全部成功提交，要麼在發生錯誤時全部回復。",
                "parameters": [
                    {"name": "BeginTrans()", "description": "方法：開始一個新的交易。"},
                    {"name": "CommitTrans()", "description": "方法：儲存自上次 BeginTrans 以來對資料庫所做的所有變更，並結束目前交易。"},
                    {"name": "RollbackTrans()", "description": "方法：取消自上次 BeginTrans 以來對資料庫所做的所有變更，並結束目前交易。"}
                ],
                "examples": [
                    {"code": "Dim conn As Object ' ADODB.Connection (assume open)\n' On Error GoTo ErrorHandler_Transaction\n' conn.BeginTrans\n' ' SQL statement 1 (e.g., insert into Orders)\n' conn.Execute \"INSERT INTO Orders (CustomerID, OrderDate) VALUES ('ALFKI', Date());\", , 1 ' adCmdText\n' ' SQL statement 2 (e.g., insert into Order Details)\n' conn.Execute \"INSERT INTO [Order Details] (OrderID, ProductID, Quantity) VALUES (SCOPE_IDENTITY(), 1, 5);\", , 1 ' SCOPE_IDENTITY() might be DB specific\n' conn.CommitTrans\n' MsgBox \"交易成功提交！\"\n' Exit Sub\n'ErrorHandler_Transaction:\n' If conn.State = 1 Then ' adStateOpen\n'   conn.RollbackTrans\n'   MsgBox \"交易已回復。錯誤: \" & Err.Description\n' Else\n'   MsgBox \"發生錯誤，且連接已關閉。錯誤: \" & Err.Description\n' End If", "explanation": "演示如何使用交易。它開始一個交易，嘗試執行兩個 INSERT 語句。如果兩個語句都成功，則提交交易。如果任何一個語句失敗，則跳轉到錯誤處理程序並回復交易。SCOPE_IDENTITY() 用於獲取第一個 INSERT 產生的訂單 ID，這是 SQL Server 的語法；其他資料庫可能有不同的方法。"}
                ],
                "keywords": ["ado transaction", "database transaction", "begintrans", "committrans", "rollbacktrans", "atomic operation", "資料庫交易", "交易處理"]
            },
            {
                "name": "Recordset.GetString (ADO)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "strData = rs.GetString(StringFormat, NumRows, ColumnDelimiter, RowDelimiter, NullExpr)",
                "description": "從 Recordset 傳回一個字串，該字串包含轉換後的記錄資料。這對於快速將資料錄集內容轉換為可用於顯示或匯出的單一字串非常有用。",
                "parameters": [
                    {"name": "StringFormat", "description": "可選。StringFormatEnum，通常為 adClipString (2)。"},
                    {"name": "NumRows", "description": "可選。要轉換的列數。如果省略或 -1，則轉換所有列。"},
                    {"name": "ColumnDelimiter", "description": "可選。欄之間使用的分隔符，例如 vbTab 或 \",\"。"},
                    {"name": "RowDelimiter", "description": "可選。列之間使用的分隔符，例如 vbCrLf。"},
                    {"name": "NullExpr", "description": "可選。用於取代 Null 值的表達式，例如 \"(NULL)\" 或 \"\"。"}
                ],
                "examples": [
                    {"code": "Dim rs As Object ' ADODB.Recordset (assume open and contains data)\nDim recordsetString As String\n' If Not rs.EOF Then\n'   rs.MoveFirst ' Ensure we are at the beginning to get all rows\n'   recordsetString = rs.GetString(2, -1, vbTab, vbCrLf, \"[NULL]\") ' adClipString, all rows, tab delimited\n'   Debug.Print recordsetString\n  \n'   ' Example: Output to a text file using FileSystemObject\n'   Dim fso As Object, ts As Object\n'   Set fso = CreateObject(\"Scripting.FileSystemObject\")\n'   Set ts = fso.CreateTextFile(\"C:\\Temp\\RecordsetData.txt\", True)\n'   ts.Write recordsetString\n'   ts.Close\n'   MsgBox \"資料已寫入 C:\\Temp\\RecordsetData.txt\"\n' End If", "explanation": "演示如何使用 GetString 將整個 Recordset 內容轉換為一個以 Tab 分隔欄位、以換行符分隔列的字串，然後將此字串寫入文字檔案。"}
                ],
                "keywords": ["adodb getstring", "recordset to string", "export recordset", "convert data to text", "資料錄集轉字串", "匯出資料"]
            },
            {
                "name": "MSXML2.DOMDocument (CreateObject)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\") ' Or .3.0 for older compatibility",
                "description": "建立一個 Microsoft XML Core Services (MSXML) DOMDocument 物件。此物件用於載入、解析、查詢 (使用 XPath) 和操作 XML 文件。",
                "parameters": [
                    {"name": "async", "description": "屬性 (Boolean)：設定或取得是否以非同步方式載入 XML 文件。預設為 True，但 VBA 中通常設為 False 以便同步處理。"},
                    {"name": "load(xmlSource)", "description": "方法 (Boolean)：從指定的來源 (檔案路徑或 URL) 載入 XML 文件。如果成功則傳回 True。"},
                    {"name": "loadXML(xmlString)", "description": "方法 (Boolean)：從字串載入 XML。如果成功則傳回 True。"},
                    {"name": "parseError", "description": "屬性 (IXMLDOMParseError)：傳回一個物件，提供有關上次解析錯誤的詳細資訊 (如果發生錯誤)。"},
                    {"name": "documentElement", "description": "屬性 (IXMLDOMElement)：傳回 XML 文件的根元素。"},
                    {"name": "selectNodes(xpathString)", "description": "方法 (IXMLDOMNodeList)：使用 XPath 表達式選取符合條件的節點列表。"},
                    {"name": "selectSingleNode(xpathString)", "description": "方法 (IXMLDOMNode)：使用 XPath 表達式選取第一個符合條件的節點。"},
                    {"name": "createElement(tagName)", "description": "方法 (IXMLDOMElement)：建立一個新的元素節點。"},
                    {"name": "createTextNode(text)", "description": "方法 (IXMLDOMText)：建立一個新的文字節點。"},
                    {"name": "appendChild(newChild)", "description": "方法 (IXMLDOMNode)：將指定的節點新增到目前節點的子節點列表的末尾。"},
                    {"name": "xml", "description": "屬性 (String)：傳回節點及其所有子節點的 XML 字串表示。"},
                    {"name": "save(destination)", "description": "方法：將 XML 文件儲存到指定的目的地 (檔案路徑或物件)。"}
                ],
                "examples": [
                    {"code": "Dim xmlDoc As Object ' MSXML2.DOMDocument60\nDim xmlFilePath As String\nDim loadSuccess As Boolean\n\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False ' Use synchronous loading in VBA\nxmlDoc.validateOnParse = False ' Optional: set to True if DTD/Schema validation is needed\n\n' --- Example 1: Load XML from a file ---\nxmlFilePath = \"C:\\Path\\To\\YourFile.xml\" ' **替換為實際XML檔案路徑**\n' loadSuccess = xmlDoc.Load(xmlFilePath)\n\n' If loadSuccess Then\n'   MsgBox \"XML 檔案 '\" & xmlFilePath & \"' 載入成功!\"\n'   Dim rootElement As Object ' IXMLDOMElement\n'   Set rootElement = xmlDoc.documentElement\n'   Debug.Print \"根元素名稱: \" & rootElement.nodeName\n'   ' --- Query nodes using XPath ---\n'   Dim nodes As Object ' IXMLDOMNodeList\n'   Dim node As Object  ' IXMLDOMNode\n'   Set nodes = xmlDoc.selectNodes(\"//book/title\") ' Example: select all <title> elements under <book>\n'   For Each node In nodes\n'     Debug.Print \"書名: \" & node.Text\n'   Next node\n' Else\n'   MsgBox \"載入 XML 檔案失敗!\" & vbCrLf & \"錯誤碼: \" & xmlDoc.parseError.errorCode & vbCrLf & _\n'          \"原因: \" & xmlDoc.parseError.reason & vbCrLf & _\n'          \"行: \" & xmlDoc.parseError.Line & \", 位置: \" & xmlDoc.parseError.linepos\n' End If\n\n' --- Example 2: Load XML from a string ---\nDim xmlStr As String\nxmlStr = \"<inventory><item type='book'><title>VBA Bible</title><author>John Walkenbach</author></item></inventory>\"\n' loadSuccess = xmlDoc.loadXML(xmlStr)\n' If loadSuccess Then\n'   Debug.Print \"從字串載入XML成功。根元素: \" & xmlDoc.documentElement.nodeName\n'   Dim authorNode As Object\n'   Set authorNode = xmlDoc.selectSingleNode(\"/inventory/item/author\")\n'   If Not authorNode Is Nothing Then Debug.Print \"作者: \" & authorNode.Text\n' End If\n\n' --- Example 3: Creating a new XML document ---\n' Set xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\n' Dim pi As Object ' IXMLDOMProcessingInstruction\n' Set pi = xmlDoc.createProcessingInstruction(\"xml\", \"version='1.0' encoding='UTF-8'\")\n' xmlDoc.appendChild pi\n' Dim newRoot As Object, newElem As Object, newText As Object\n' Set newRoot = xmlDoc.createElement(\"Orders\")\n' xmlDoc.appendChild newRoot\n' Set newElem = xmlDoc.createElement(\"Order\")\n' newElem.setAttribute \"ID\", \"1001\"\n' newRoot.appendChild newElem\n' Set newText = xmlDoc.createTextNode(\"Sample Order Content\")\n' newElem.appendChild newText\n' Debug.Print xmlDoc.XML ' Display the created XML string\n' ' xmlDoc.save \"C:\\Path\\To\\NewOrders.xml\"\n\nSet xmlDoc = Nothing", "explanation": "此範例演示了使用 MSXML2.DOMDocument 物件的三種主要操作：1. 從檔案載入XML並使用XPath查詢節點。2. 從字串載入XML並查詢單個節點。3. 以程式設計方式建立一個新的XML文件結構，包括處理指令、元素、屬性和文字節點，然後顯示其XML內容或將其儲存到檔案。請確保將檔案路徑替換為實際路徑。"}
                ],
                "keywords": ["msxml2 domdocument", "vba xml parsing", "load xml file vba", "create xml vba", "xpath query vba", "xml manipulation", "XML文件處理", "解析XML", "建立XML", "XPath查詢"]
            },
            {
                "name": "IXMLDOMNode.selectNodes / .selectSingleNode (XPath)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set nodeList = xmlDomNodeOrDoc.selectNodes(xpathExpression)\nSet singleNode = xmlDomNodeOrDoc.selectSingleNode(xpathExpression)",
                "description": "這些方法在 IXMLDOMNode (包括 IXMLDOMDocument 和 IXMLDOMElement) 介面上可用，允許使用 XPath (XML Path Language) 表達式來選取節點集或單個節點。",
                "parameters": [
                    {"name": "xpathExpression", "description": "必需。一個字串，包含要執行的 XPath 查詢。"},
                    {"name": "nodeList (selectNodes)", "description": "傳回一個 IXMLDOMNodeList 集合，其中包含所有符合 XPath 表達式的節點。"},
                    {"name": "singleNode (selectSingleNode)", "description": "傳回第一個符合 XPath 表達式的 IXMLDOMNode。如果找不到，則傳回 Nothing。"}
                ],
                "examples": [
                    {"code": "Dim xmlDoc As Object ' MSXML2.DOMDocument60, assume it's loaded with XML\n' Dim books As Object ' IXMLDOMNodeList\n' Dim firstBookTitle As String\n' Dim specificBookAuthor As Object ' IXMLDOMNode\n\n' ' --- XML Structure Example ---\n' ' <library>\n' '   <book category=\"FICTION\">\n' '     <title lang=\"en\">The Great Gatsby</title>\n' '     <author>F. Scott Fitzgerald</author>\n' '   </book>\n' '   <book category=\"SCIENCE\">\n' '     <title lang=\"en\">Cosmos</title>\n' '     <author>Carl Sagan</author>\n' '   </book>\n' ' </library>\n\n' ' Load or create xmlDoc here...\n' ' xmlDoc.loadXML(\"<library>...</library>\") ' (using the structure above)\n\n' ' 1. Select all <book> elements\n' Set books = xmlDoc.selectNodes(\"//book\") ' or \"/library/book\"\n' Debug.Print \"找到 \" & books.Length & \" 本書。\"\n\n' ' 2. Get the title of the first book\n' If books.Length > 0 Then\n'   firstBookTitle = books.Item(0).selectSingleNode(\"title\").Text ' Relative XPath from book node\n'   ' Or absolute from document: xmlDoc.selectSingleNode(\"/library/book[1]/title\").Text\n'   Debug.Print \"第一本書的標題: \" & firstBookTitle\n' End If\n\n' ' 3. Select the author of a book with a specific title (e.g., \"Cosmos\")\n' Set specificBookAuthor = xmlDoc.selectSingleNode(\"//book[title='Cosmos']/author\")\n' If Not specificBookAuthor Is Nothing Then\n'   Debug.Print \"'Cosmos' 的作者是: \" & specificBookAuthor.Text\n' End If\n\n' ' 4. Select all book titles with a 'category' attribute equal to 'FICTION'\n' Dim fictionTitles As Object ' IXMLDOMNodeList\n' Set fictionTitles = xmlDoc.selectNodes(\"//book[@category='FICTION']/title\")\n' Dim titleNode As Object\n' Debug.Print \"小說類書名:\"\n' For Each titleNode In fictionTitles\n'   Debug.Print \"  - \" & titleNode.Text\n' Next titleNode", "explanation": "演示如何使用 selectNodes 和 selectSingleNode 配合不同的 XPath 表達式來查詢 XML 文件：1. 選取所有 <book> 元素。2. 獲取第一本書的 <title>。3. 根據書名選取特定書的 <author>。4. 根據屬性值選取所有符合條件的書的 <title>。假設 xmlDoc 物件已載入範例 XML 結構。"}
                ],
                "keywords": ["xpath vba", "xml selectnodes", "xml selectsinglenode", "query xml", "msxml xpath", "XPath查詢XML", "選取XML節點"]
            },
            {
                "name": "IXMLDOMNode Properties (.nodeName, .nodeType, .nodeValue, .text, .xml, .parentNode, .childNodes, .attributes)", "category": "外部互動與API (Web, DB, OS)",
                "description": "IXMLDOMNode 物件及其派生物件 (如 IXMLDOMElement, IXMLDOMAttribute, IXMLDOMText) 提供多種屬性來存取節點的資訊和結構。",
                "parameters": [
                    {"name": "nodeName", "description": "傳回節點的名稱 (例如，元素標籤名、屬性名)。"},
                    {"name": "nodeType", "description": "傳回節點的類型 (NodeType (IXMLDOMNodeType) 列舉，例如 NODE_ELEMENT (1), NODE_ATTRIBUTE (2), NODE_TEXT (3))。"},
                    {"name": "nodeValue", "description": "設定或取得節點的值。對於元素節點，通常為 Null。對於文字節點，是文字內容。對於屬性節點，是屬性值。"},
                    {"name": "text", "description": "設定或取得節點及其所有子節點的串連文字內容。"},
                    {"name": "xml", "description": "傳回代表節點及其所有子節點的 XML 字串。"},
                    {"name": "parentNode", "description": "傳回目前節點的父節點。"},
                    {"name": "childNodes", "description": "傳回一個 IXMLDOMNodeList，包含目前節點的所有子節點。"},
                    {"name": "attributes", "description": "對於元素節點，傳回一個 IXMLDOMNamedNodeMap，包含其所有屬性。"}
                ],
                "examples": [
                    {"code": "Dim xmlDoc As Object ' MSXML2.DOMDocument60\nDim root As Object ' IXMLDOMElement\nDim firstChild As Object ' IXMLDOMNode\nDim attr As Object ' IXMLDOMAttribute\n\n' Set xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\n' xmlDoc.async = False\n' xmlDoc.loadXML(\"<rootNode id='123'><childNode type='A'>Child Text</childNode><anotherChild/></rootNode>\")\n\n' If xmlDoc.parseError.errorCode = 0 Then\n'   Set root = xmlDoc.documentElement\n'   Debug.Print \"根節點 - 名稱: \" & root.nodeName & \", 類型: \" & root.nodeType ' Output: rootNode, 1\n'   Debug.Print \"根節點XML: \" & root.xml\n'\n'   ' 子節點\n'   If root.hasChildNodes Then\n'     Set firstChild = root.childNodes(0) ' 第一個子節點 (childNode)\n'     Debug.Print \"第一個子節點 - 名稱: \" & firstChild.nodeName & \", 文字內容: \" & firstChild.Text\n'     If firstChild.nodeType = 1 Then ' NODE_ELEMENT\n'        Dim elemFirstChild As Object ' IXMLDOMElement\n'        Set elemFirstChild = firstChild\n        ' 屬性\n'        If elemFirstChild.Attributes.Length > 0 Then\n'           Set attr = elemFirstChild.Attributes.getNamedItem(\"type\")\n'           Debug.Print \"  屬性 'type': \" & attr.nodeName & \" = \" & attr.nodeValue ' Output: type = A\n'        End If\n'     End If\n'     Debug.Print \"  父節點名稱: \" & firstChild.parentNode.nodeName ' Output: rootNode\n'   End If\n' Else\n'   Debug.Print \"XML 解析錯誤: \" & xmlDoc.parseError.reason\n' End If\n' Set xmlDoc = Nothing: Set root = Nothing: Set firstChild = Nothing: Set attr = Nothing", "explanation": "演示如何存取 XML 節點的各種屬性，例如節點名稱、類型、文字內容、XML表示、父節點、子節點集合以及元素的屬性集合。使用了一個簡單的 XML 字串作為範例。"}
                ],
                "keywords": ["ixmldomnode properties", "xml node info", "get node name", "get node value", "xml attributes", "xml childnodes", "XML節點屬性", "讀取節點資訊"]
            },
            {
                "name": "PowerShell Automation from VBA", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Set wshShell = CreateObject(\"WScript.Shell\")\nexitCode = wshShell.Run(\"powershell.exe -ExecutionPolicy Bypass -File C:\\Path\\To\\Script.ps1 Param1 Param2\", windowStyle, waitOnReturn)",
                "description": "從 VBA 中執行 PowerShell 腳本。這允許 VBA 利用 PowerShell 的強大功能來執行更複雜的系統管理任務、與 .NET Framework 深度互動、或使用 PowerShell 特有的 Cmdlet。VBA 可以啟動 PowerShell.exe，傳遞腳本檔案路徑和參數，並可選擇等待腳本完成並獲取其輸出或結束代碼。",
                "parameters": [
                    {"name": "WScript.Shell Object", "description": "用於執行外部程式。"},
                    {"name": "powershell.exe", "description": "PowerShell 執行檔。"},
                    {"name": "-ExecutionPolicy Bypass", "description": "暫時繞過執行策略以允許執行腳本 (需要相應權限)。"},
                    {"name": "-File scriptPath.ps1", "description": "指定要執行的 PowerShell 腳本檔案。"},
                    {"name": "Parameters (Optional)", "description": "傳遞給 PowerShell 腳本的參數。"},
                    {"name": "windowStyle (Run method)", "description": "PowerShell 視窗的顯示樣式 (例如 0=隱藏, 1=正常)。"},
                    {"name": "waitOnReturn (Run method)", "description": "True 表示 VBA 等待 PowerShell 腳本完成後再繼續，False 表示立即返回。"}
                ],
                "examples": [
                    {"code": "Sub RunPowerShellScriptWithParams()\n    Dim wshShell As Object\n    Dim psScriptPath As String\n    Dim paramValue1 As String, paramValue2 As String\n    Dim command As String\n    Dim exitCode As Long\n    Dim outputFilePath As String\n    Dim fso As Object, ts As Object, outputText As String\n\n    Set wshShell = CreateObject(\"WScript.Shell\")\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    \n    ' --- 準備 PowerShell 腳本 (示例: MyScript.ps1) ---\n    ' # MyScript.ps1 內容示例:\n    ' param (\n    '   [string]$User,\n    '   [string]$Action\n    ' )\n    ' $Output = \"User: $User, Action: $Action, Timestamp: $(Get-Date)\"\n    ' Write-Host $Output\n    ' $Output | Out-File -FilePath \"C:\\Temp\\ps_output.txt\" -Encoding UTF8 ' 將輸出寫入檔案\n    ' exit 0 # 表示成功\n    \n    psScriptPath = \"C:\\Scripts\\MyPSScript.ps1\" ' **替換為您的 PowerShell 腳本路徑**\n    outputFilePath = \"C:\\Temp\\ps_output.txt\"\n    paramValue1 = \"VBA_User\"\n    paramValue2 = \"GetData\"\n\n    ' 刪除舊的輸出檔案 (如果存在)\n    If fso.FileExists(outputFilePath) Then fso.DeleteFile outputFilePath\n\n    ' 構建 PowerShell 命令\n    ' 使用 -NoProfile 可以加快啟動速度\n    ' 使用 -EncodedCommand 可以傳遞複雜的命令或避免引號問題，但這裡用 -File 較簡單\n    command = \"powershell.exe -ExecutionPolicy Bypass -NoProfile -File \"\"\" & psScriptPath & \"\"\"\" & _\n              \" -User \"\"\" & paramValue1 & \"\"\" -Action \"\"\" & paramValue2 & \"\"\"\"\n    \n    Debug.Print \"Executing: \" & command\n    ' 執行 PowerShell 腳本，隱藏視窗 (0)，並等待其完成 (True)\n    exitCode = wshShell.Run(command, 0, True)\n\n    If exitCode = 0 Then\n        MsgBox \"PowerShell 腳本成功執行！\"\n        ' 讀取 PowerShell 腳本生成的輸出檔案\n        If fso.FileExists(outputFilePath) Then\n            Set ts = fso.OpenTextFile(outputFilePath, 1) ' ForReading\n            outputText = ts.ReadAll\n            ts.Close\n            MsgBox \"腳本輸出: \" & vbCrLf & outputText\n        Else\n            MsgBox \"找不到 PowerShell 腳本的輸出檔案。\"\n        End If\n    Else\n        MsgBox \"PowerShell 腳本執行失敗。結束代碼: \" & exitCode & vbCrLf & _\n               \"請檢查PowerShell腳本的錯誤輸出 (如果有的話)。\"\n    End If\n\n    Set wshShell = Nothing\n    Set fso = Nothing\n    Set ts = Nothing\nEnd Sub", "explanation": "此 VBA 子程序演示如何執行一個名為 \"MyPSScript.ps1\" 的 PowerShell 腳本。它向腳本傳遞兩個參數 (`-User` 和 `-Action`)。PowerShell 腳本（此處提供了一個內容示例）接收這些參數，執行一些操作，並將其輸出寫入一個臨時檔案 `C:\\Temp\\ps_output.txt`。VBA 腳本隨後讀取此輸出檔案的內容並顯示。VBA 的 `Run` 方法會等待 PowerShell 腳本完成，然後返回其結束代碼。**重要：**您需要在 `C:\\Scripts\\` (或您選擇的路徑) 中創建 `MyPSScript.ps1` 文件，並填入示例或您自己的 PowerShell 代碼。"}
                ],
                "keywords": ["vba powershell automation", "run powershell script from vba", "wscript.shell powershell", "execute ps1 vba", "system administration vba", "PowerShell自動化", "VBA執行PS1", "系統管理"]
            },
            {
                "name": "整合 Microsoft Teams 訊息通知 (透過 PowerShell 或 Graph API)", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Scenario: After a long-running VBA process completes (e.g., complex report generation), send a notification message to a specific Microsoft Teams channel or user.",
                "description": "此案例探討了兩種從VBA向Microsoft Teams發送訊息的方法：1. **透過PowerShell**：VBA可以調用一個PowerShell腳本，該腳本使用`Send-MSTeamsMessage` Cmdlet (來自非官方的 `MSTeams` 模組，需要預先安裝) 或直接調用Teams的Webhook URL (如果頻道配置了Webhook傳入)。2. **透過Microsoft Graph API**：這是一種更強大和官方支援的方法。VBA可以使用`MSXML2.XMLHTTP`或`WinHttp.WinHttpRequest`物件向Graph API的 `/chat/messages` 或 `/teams/{team-id}/channels/{channel-id}/messages` 端點發送POST請求。這需要進行Azure AD應用程式註冊以獲取身份驗證權杖 (通常是OAuth 2.0流程)。此方法更安全且功能更全面，但設置也更複雜。下面的示例將概念性地概述PowerShell Webhook方法，因其相對簡單。",
                "parameters": [
                    {"name": "Teams Channel Webhook URL (For PowerShell Webhook)", "description": "在Teams頻道中配置的傳入Webhook URL。"},
                    {"name": "Message Content", "description": "要發送到Teams的訊息文本，可以是簡單文本或Markdown格式的卡片。"},
                    {"name": "PowerShell Script (If using PS)", "description": "一個.ps1腳本，用於接收訊息內容和Webhook URL作為參數，並執行POST請求。"},
                    {"name": "Graph API Authentication (If using Graph API)", "description": "包括應用程式ID、租戶ID、客戶端密鑰或憑證，以及獲取訪問權杖的邏輯。"}
                ],
                "examples": [
                    {"code": "' --- Conceptual VBA code to call a PowerShell script for Teams notification via Webhook ---\nSub SendTeamsNotificationViaPowerShellWebhook(ByVal channelWebhookUrl As String, ByVal messageTitle As String, ByVal messageText As String)\n    Dim wshShell As Object\n    Dim psScriptPath As String\n    Dim psCommand As String\n    Dim exitCode As Long\n\n    ' --- PowerShell Script (e.g., Send-TeamsNotification.ps1) --- \n    ' param (\n    '   [string]$WebhookUri,\n    '   [string]$Title,\n    '   [string]$Text\n    ' )\n    ' $Payload = @{\n    '   \"@type\" = \"MessageCard\";\n    '   \"@context\" = \"http://schema.org/extensions\";\n    '   \"themeColor\" = \"0076D7\"; # Blue\n    '   \"summary\" = $Title;\n    '   \"sections\" = @(\n    '     @{\n    '       \"activityTitle\" = $Title;\n    '       \"activitySubtitle\" = \"Notification from VBA Automation\";\n    '       \"activityImage\" = \"\"; # Optional: URL to an image\n    '       \"facts\" = @(\n    '         @{\n    '           \"name\" = \"Status\";\n    '           \"value\" = \"Completed Successfully\"\n    '         },\n    '         @{\n    '           \"name\" = \"Details\";\n    '           \"value\" = $Text\n    '         }\n    '       );\n    '       \"markdown\" = $true\n    '     }\n    '   )\n    ' }\n    ' Invoke-RestMethod -Uri $WebhookUri -Method Post -Body ($Payload | ConvertTo-Json) -ContentType 'application/json'\n    ' ------------------------------------------------------------------\n    \n    Set wshShell = CreateObject(\"WScript.Shell\")\n    psScriptPath = \"C:\\Scripts\\Send-TeamsNotification.ps1\" ' **替換為您的PS1腳本路徑**\n\n    If Dir(psScriptPath) = \"\" Then\n        MsgBox \"PowerShell 腳本未找到: \" & psScriptPath, vbCritical\n        Exit Sub\n    End If\n\n    ' Construct the PowerShell command. Escape quotes in parameters carefully.\n    ' Using single quotes for PowerShell string literals where possible, or backticks for escaping within double quotes.\n    psCommand = \"powershell.exe -ExecutionPolicy Bypass -NoProfile -File \"\"\" & psScriptPath & \"\"\"\" & _\n                \" -WebhookUri '\" & Replace(channelWebhookUrl, \"'\", \"''\") & \"'\" & _ ' PS single quote escape\n                \" -Title '\" & Replace(messageTitle, \"'\", \"''\") & \"'\" & _\n                \" -Text '\" & Replace(messageText, \"'\", \"''\") & \"'\"\n    \n    Debug.Print \"Executing Teams Notification: \" & psCommand\n    exitCode = wshShell.Run(psCommand, 0, True) ' Run hidden, wait for completion\n\n    If exitCode = 0 Then\n        Debug.Print \"Teams 通知已嘗試傳送。\"\n    Else\n        Debug.Print \"傳送 Teams 通知時，PowerShell 腳本傳回錯誤代碼: \" & exitCode\n    End If\n    Set wshShell = Nothing\nEnd Sub\n\n' Example Usage:\nSub TestTeamsNotification()\n    Dim webhook As String\n    webhook = \"YOUR_ACTUAL_TEAMS_CHANNEL_WEBHOOK_URL\" ' **替換為您的 Webhook URL**\n    If webhook = \"YOUR_ACTUAL_TEAMS_CHANNEL_WEBHOOK_URL\" Then\n        MsgBox \"請先設定有效的 Teams Webhook URL！\", vbExclamation\n        Exit Sub\n    End If\n    Call SendTeamsNotificationViaPowerShellWebhook(webhook, \"VBA 報告狀態\", \"月度銷售報告已成功生成並儲存於共享磁碟機。\")\nEnd Sub", "explanation": "此VBA代碼 `SendTeamsNotificationViaPowerShellWebhook` 調用一個外部PowerShell腳本 (`Send-TeamsNotification.ps1`) 來向指定的Teams頻道Webhook URL發送訊息。PowerShell腳本（此處提供了其內容的概念性示例）會構建一個JSON負載 (MessageCard格式) 並使用`Invoke-RestMethod`將其POST到Webhook URL。VBA負責構建命令行以執行PowerShell並傳遞Webhook URL、標題和訊息文本作為參數。**重要提示：** 1. 您需要在Teams頻道中設定一個傳入Webhook並獲取其URL。2. 您需要將 `Send-TeamsNotification.ps1` 的示例內容保存到一個實際的.ps1檔案中，並更新VBA中的 `psScriptPath`。3. 參數傳遞給PowerShell時，對字串中的單引號進行了簡單的PS轉義處理。Graph API方法更為強健但設置複雜，涉及OAuth身份驗證和直接HTTP請求到Graph API端點。"}
                ],
                "keywords": ["vba microsoft teams notification", "send message to teams vba", "powershell teams webhook", "graph api teams message", "office automation teams", "Teams訊息通知", "VBA整合Teams"]
            },
            {
                "name": "從多個網頁擷取表格數據並彙整到Excel", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Scenario: Navigate to a list of URLs (e.g., from an Excel sheet), find specific HTML tables on each page, extract the table data (rows and cells), and consolidate it into a single Excel worksheet.",
                "description": "此案例演示了如何自動化從多個網頁中提取表格數據的過程。腳本會：1. 從Excel工作表或其他來源讀取一個URL列表。2. 對於列表中的每個URL： a. 使用Internet Explorer (或WinHttpRequest，如果頁面簡單且不需要JavaScript執行) 導航到該網頁並等待其完全加載。 b. 在HTML文檔中定位目標HTML表格（例如，通過表格的ID、索引、或周圍的特定元素）。 c. 遍歷表格的行 (<tr>) 和儲存格 (<td> 或 <th>)。 d. 提取每個儲存格的文本內容。 e. 將提取的數據逐行寫入Excel中一個指定的“彙整”工作表。3. 可以在每次成功處理一個網頁後更新狀態，或在結束時提供一個總結。這個方法對於從結構相似的多個產品頁面、報告頁面或列表頁面收集數據非常有用。",
                "parameters": [
                    {"name": "URL List Source", "description": "包含要處理的網頁URL的來源 (例如，Excel的某一列)。"},
                    {"name": "Table Identifier", "description": "如何在每個頁面上定位目標HTML表格的方法 (例如，表格的ID、第n個表格、具有特定class的表格)。"},
                    {"name": "Excel Output Sheet", "description": "用於存放彙整數據的Excel工作表。"},
                    {"name": "Data Mapping (Optional)", "description": "如果需要，定義網頁表格的列如何對應到Excel工作表的列。"}
                ],
                "examples": [
                    {"code": "Sub ExtractTableDataFromMultiplePages()\n    Dim ie As Object ' InternetExplorer.Application\n    Dim htmlDoc As Object ' MSHTML.HTMLDocument\n    Dim urlSheet As Worksheet, outputSheet As Worksheet\n    Dim lastRowURLs As Long, i As Long, outputRow As Long\n    Dim targetTable As Object ' MSHTML.IHTMLTable\n    Dim tblRow As Object ' MSHTML.IHTMLTableRow\n    Dim tblCell As Object ' MSHTML.IHTMLTableCell\n    Dim currentURL As String\n\n    ' --- Configuration ---\n    Set urlSheet = ThisWorkbook.Sheets(\"URLList\") ' Assume URLs are in Column A, starting Row 2\n    Set outputSheet = ThisWorkbook.Sheets(\"ConsolidatedData\")\n    outputSheet.Cells.ClearContents ' Clear previous data\n    outputRow = 1 ' Start writing data from row 1 in output sheet\n\n    On Error GoTo ErrorHandler\n    Set ie = CreateObject(\"InternetExplorer.Application\")\n    ' ie.Visible = True ' Optional: make it visible for debugging\n\n    lastRowURLs = urlSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    For i = 2 To lastRowURLs\n        currentURL = Trim(CStr(urlSheet.Cells(i, \"A\").Value))\n        If currentURL = \"\" Or Not (Left(currentURL, 7) = \"http://\" Or Left(currentURL, 8) = \"https://\") Then\n            Debug.Print \"Skipping invalid URL: \" & currentURL\n            GoTo NextURL\n        End If\n\n        Debug.Print \"Processing URL: \" & currentURL\n        ie.Navigate currentURL\n        Do While ie.Busy Or ie.ReadyState <> 4: DoEvents: Loop\n        Application.Wait (Now + TimeValue(\"0:00:02\")) ' Extra wait for dynamic content\n        Set htmlDoc = ie.Document\n\n        ' --- Locate the target table (example: first table on the page) ---\n        If htmlDoc.getElementsByTagName(\"table\").Length > 0 Then\n            Set targetTable = htmlDoc.getElementsByTagName(\"table\")(0) ' Get the first table\n            ' More specific selection might be needed: e.g., htmlDoc.getElementById(\"myTableId\")\n        Else\n            Debug.Print \"No tables found on page: \" & currentURL\n            GoTo NextURL\n        End If\n        \n        If targetTable Is Nothing Then\n             Debug.Print \"Target table not found specifically on page: \" & currentURL\n             GoTo NextURL\n        End If\n\n        ' --- Extract data from table ---\n        outputSheet.Cells(outputRow, 1).Value = \"Data from: \" & currentURL ' Add source URL as a header for this data block\n        outputRow = outputRow + 1\n        Dim colOffset As Long\n\n        For Each tblRow In targetTable.Rows\n            colOffset = 0\n            For Each tblCell In tblRow.Cells\n                outputSheet.Cells(outputRow, colOffset + 1).Value = Trim(tblCell.innerText)\n                colOffset = colOffset + 1\n            Next tblCell\n            outputRow = outputRow + 1\n        Next tblRow\n        outputRow = outputRow + 1 ' Add a blank row between data from different URLs\n        Debug.Print \"Data extracted from: \" & currentURL\nNextURL:\n    Next i\n\n    MsgBox \"表格數據提取完成！\"\n\nCleanExit:\n    If Not ie Is Nothing Then ie.Quit\n    Set ie = Nothing: Set htmlDoc = Nothing: Set targetTable = Nothing\n    Set urlSheet = Nothing: Set outputSheet = Nothing\n    Application.ScreenUpdating = True\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"發生錯誤: \" & Err.Number & \" - \" & Err.Description & vbCrLf & \"在處理 URL: \" & currentURL, vbCritical\n    Resume CleanExit\nEnd Sub", "explanation": "此腳本首先從名為 \"URLList\" 的Excel工作表的A列讀取URL列表。然後，它會逐個導航到這些URL。在每個頁面上，它嘗試定位第一個HTML表格。如果找到表格，它會遍歷表格的每一行和每個儲存格，提取其文本內容，並將這些數據寫入名為 \"ConsolidatedData\" 的工作表中。每個URL提取的數據塊之間會以來源URL和一個空行分隔。包含基本的錯誤處理和IE物件的清理。請注意，對於複雜的、依賴大量JavaScript的現代網頁，此IE自動化方法可能不夠穩定，可能需要更進階的工具如Selenium。"}
                ],
                "keywords": ["vba web scraping tables", "extract html table to excel", "ie automation get table data", "loop through web pages vba", "data mining web tables", "網頁表格提取", "批量抓取表格", "IE自動化擷取"]
            },
            {
                "name": "向網頁表單自動填寫數據並提交", "category": "外部互動與API (Web, DB, OS)",
                "syntax": "Scenario: Read data from an Excel sheet (e.g., names, addresses, product selections), navigate to a web form, populate the form fields with the Excel data, and then simulate a click on the submit button.",
                "description": "此案例演示了如何使用VBA自動填充並提交網頁表單。腳本會：1. 從Excel工作表中讀取需要填寫到表單的數據行。2. 對於每一行數據： a. 啟動Internet Explorer並導航到目標網頁表單的URL。 b. 等待頁面完全加載。 c. 使用HTML元素的ID、名稱或其他選擇器（如TagName或ClassName）來定位表單中的各個輸入欄位（文本框、下拉列表、複選框、單選按鈕等）。 d. 將從Excel讀取的相應數據設置到這些表單欄位的值。 e. 定位提交按鈕並模擬點擊 (.Click) 以提交表單。 f. 可選地，在提交後檢查頁面響應或導航到新頁面以確認成功。這個過程對於批量提交數據、自動化註冊或重複性的數據錄入任務非常有用。",
                "parameters": [
                    {"name": "Excel Data Source", "description": "包含要提交到表單的數據的Excel工作表。"},
                    {"name": "Web Form URL", "description": "目標網頁表單的URL。"},
                    {"name": "HTML Element Identifiers", "description": "表單中各個輸入欄位和提交按鈕的HTML ID、名稱或其他識別符。"},
                    {"name": "Submission Confirmation Logic (Optional)", "description": "用於驗證表單是否成功提交的方法。"}
                ],
                "examples": [
                    {"code": "Sub AutoFillAndSubmitWebForm()\n    Dim ie As Object ' InternetExplorer.Application\n    Dim htmlDoc As Object ' MSHTML.HTMLDocument\n    Dim dataSheet As Worksheet\n    Dim lastRow As Long, i As Long\n    Dim firstName As String, lastName As String, emailAddr As String\n\n    ' --- Configuration ---\n    Const FORM_URL As String = \"https://www.example.com/myformpage\" ' **替換為實際的表單URL**\n    Set dataSheet = ThisWorkbook.Sheets(\"FormData\") ' Assume data: Col A=FirstName, B=LastName, C=Email\n\n    On Error GoTo ErrorHandler\n    Set ie = CreateObject(\"InternetExplorer.Application\")\n    ie.Visible = True ' Make it visible for observation\n\n    lastRow = dataSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    For i = 2 To lastRow ' Assuming row 1 is header\n        firstName = Trim(CStr(dataSheet.Cells(i, \"A\").Value))\n        lastName = Trim(CStr(dataSheet.Cells(i, \"B\").Value))\n        emailAddr = Trim(CStr(dataSheet.Cells(i, \"C\").Value))\n\n        If firstName = \"\" Or emailAddr = \"\" Then\n            Debug.Print \"Skipping row \" & i & \": Missing required data.\"\n            GoTo NextRecord\n        End If\n\n        Debug.Print \"Processing record for: \" & firstName & \" \" & lastName\n        ie.Navigate FORM_URL\n        Do While ie.Busy Or ie.ReadyState <> 4: DoEvents: Loop\n        Application.Wait (Now + TimeValue(\"0:00:03\")) ' Wait for JS if any\n        Set htmlDoc = ie.Document\n\n        ' --- Fill Form Fields (IDs are examples, inspect actual form for correct IDs/Names) ---\n        Dim fieldFirstName As Object, fieldLastName As Object, fieldEmail As Object, submitButton As Object\n        \n        Set fieldFirstName = htmlDoc.getElementById(\"firstname_field_id\") ' **替換實際ID**\n        If Not fieldFirstName Is Nothing Then fieldFirstName.Value = firstName Else Debug.Print \"First name field not found.\"\n\n        Set fieldLastName = htmlDoc.getElementById(\"lastname_field_id\") ' **替換實際ID**\n        If Not fieldLastName Is Nothing Then fieldLastName.Value = lastName Else Debug.Print \"Last name field not found.\"\n        \n        Set fieldEmail = htmlDoc.getElementById(\"email_field_id\") ' **替換實際ID**\n        If Not fieldEmail Is Nothing Then fieldEmail.Value = emailAddr Else Debug.Print \"Email field not found.\"\n\n        ' Handle other field types (dropdowns, checkboxes) if necessary\n        ' For dropdown: htmlDoc.getElementById(\"country_dropdown_id\").Value = \"US\"\n        ' For checkbox: htmlDoc.getElementById(\"agree_checkbox_id\").Checked = True\n\n        Set submitButton = htmlDoc.getElementById(\"submit_button_id\") ' **替換實際ID**\n        ' Alternative: htmlDoc.getElementsByName(\"submit_button_name\")(0)\n        ' Or: For Each btn In htmlDoc.getElementsByTagName(\"input\") If btn.Type = \"submit\" Then Set submitButton = btn: Exit For\n\n        If Not submitButton Is Nothing Then\n            submitButton.Click\n            Debug.Print \"Form submitted for \" & firstName\n            ' Wait for submission processing/next page load\n            Do While ie.Busy Or ie.ReadyState <> 4: DoEvents: Loop\n            Application.Wait (Now + TimeValue(\"0:00:05\")) ' Wait for server response page\n            ' Add logic here to check for success message on the new page if needed\n            ' If InStr(ie.Document.Body.innerText, \"Submission Successful\") > 0 Then ...\n        Else\n            Debug.Print \"Submit button not found for \" & firstName\n        End If\n        \n        Debug.Print \"--- Finished processing row \" & i & \" ---\"\n        ' Optional: Add a small delay between submissions if necessary\n        ' Application.Wait (Now + TimeValue(\"0:00:02\"))\nNextRecord:\n    Next i\n\n    MsgBox \"網頁表單自動填充和提交完成！\"\n\nCleanExit:\n    If Not ie Is Nothing Then ie.Quit\n    Set ie = Nothing: Set htmlDoc = Nothing: Set dataSheet = Nothing\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"發生錯誤: \" & Err.Number & \" - \" & Err.Description & vbCrLf & \"在處理第 \" & i & \" 行記錄時。\", vbCritical\n    Resume CleanExit\nEnd Sub", "explanation": "此腳本從名為 \"FormData\" 的Excel工作表讀取記錄（假設包含名字、姓氏和郵箱）。對於每一條記錄，它會導航到一個指定的網頁表單URL，然後嘗試使用HTML元素的ID來定位表單欄位並填充數據。最後，它定位提交按鈕並模擬點擊。**非常重要：** 腳本中的URL (`FORM_URL`) 和HTML元素ID (`firstname_field_id`, `lastname_field_id`, `email_field_id`, `submit_button_id`) 都需要根據實際目標網頁進行替換。在實際應用中，可能還需要處理更複雜的表單元素（如下拉框、複選框）、驗證碼（通常無法簡單自動化）以及提交後的頁面導航和響應驗證。"}
                ],
                "keywords": ["vba web form automation", "autofill web form excel", "submit web form vba", "ie automation form fill", "data entry automation web", "網頁表單自動化", "Excel數據填表", "自動提交表單"]
            },

            // --- 綜合應用案例與技巧 (Integrated Application Cases & Tips) ---
            {
                "name": "MsgBox", "category": "綜合應用案例與技巧", "syntax": "MsgBox(prompt, [buttons As VbMsgBoxStyle = vbOKOnly], [title], [helpfile], [context])",
                "description": "在對話框中顯示消息，等待用戶單擊按鈕，並返回一個表示所單擊按鈕的值。",
                "parameters": [{"name": "prompt", "description": "必需。消息文本。"}, {"name": "buttons", "description": "可選。按鈕和圖標配置。"}, {"name": "title", "description": "可選。對話框標題。"}],
                "examples": [
                    {"code": "MsgBox \"操作完成！\"", "explanation": "顯示一個包含 \"操作完成！\" 消息和 \"確定\" 按鈕的簡單消息框。"},
                    {"code": "Dim Response As VbMsgBoxResult\nResponse = MsgBox(\"是否保存更改?\", vbYesNoCancel + vbQuestion, \"保存確認\")\nIf Response = vbYes Then MsgBox \"已選擇是\" ElseIf Response = vbNo Then MsgBox \"已選擇否\" Else MsgBox \"已選擇取消\"", "explanation": "顯示一個帶有「是」、「否」、「取消」按鈕及問題圖標的消息框，並根據用戶的選擇執行不同操作。"}
                ],
                "keywords": ["消息框", "提示", "對話框", "互動", "message box", "dialog", "prompt", "alert"]
            },
            {
                "name": "InputBox", "category": "綜合應用案例與技巧", "syntax": "InputBox(prompt, [title], [default], [xpos], [ypos], [helpfile], [context])",
                "description": "顯示一個提示，讓用戶在對話框中輸入文本或單擊按鈕，並返回文本框的內容。",
                "parameters": [{"name": "prompt", "description": "必需。消息文本。"}, {"name": "title", "description": "可選。對話框標題。"}, {"name": "default", "description": "可選。預設輸入文本。"}],
                "examples": [
                    {"code": "Dim UserName As String\nUserName = InputBox(\"請輸入您的姓名：\", \"用戶輸入\", \"匿名\")\nIf UserName <> \"\" Then MsgBox \"您好, \" & UserName Else MsgBox \"未輸入姓名\"", "explanation": "彈出一個輸入框，提示用戶輸入姓名，並提供預設值 \"匿名\"。"}
                ],
                "keywords": ["輸入框", "獲取輸入", "對話框", "互動", "input box", "dialog", "prompt", "ask"]
            },
            {
                "name": "Application.Wait", "category": "綜合應用案例與技巧", "syntax": "Application.Wait(Time)",
                "description": "暫停宏的執行，直到指定的時間。",
                "parameters": [{"name": "Time", "description": "必需。希望宏繼續執行的時間。"}],
                "examples": [
                    {"code": "MsgBox \"程式將暫停 3 秒鐘。\"\nApplication.Wait (Now + TimeValue(\"0:00:03\"))\nMsgBox \"3 秒鐘已過！\"", "explanation": "使宏暫停執行 3 秒鐘。"}
                ],
                "keywords": ["等待", "暫停", "延遲", "wait", "pause", "delay", "sleep", "application object"]
            },
            {
                "name": "Randomize", "category": "綜合應用案例與技巧",
                "syntax": "Randomize [number]",
                "description": "初始化隨機數生成器。",
                "parameters": [
                    {"name": "number", "description": "可選。任何有效的數值表達式，用作新的種子值。如果省略，則使用系統計時器的值作為種子。"}
                ],
                "examples": [
                    {"code": "Randomize ' 使用系統計時器作為種子，確保每次運行 Rnd() 序列不同\nDim MyValue1 As Single\nMyValue1 = Rnd()\nMsgBox \"Random number 1: \" & MyValue1", "explanation": "使用系統時間作為種子來初始化隨機數生成器，這樣每次運行程序時 Rnd() 函數產生的隨機數序列都會不同。"},
                    {"code": "Randomize 123 ' 使用固定的種子值\nDim MyValue2 As Single, MyValue3 As Single\nMyValue2 = Rnd()\nMyValue3 = Rnd()\n' 如果再次以 Randomize 123 開頭運行，MyValue2 和 MyValue3 將會是相同的序列\nMsgBox \"Fixed seed random 1: \" & MyValue2 & vbCrLf & \"Fixed seed random 2: \" & MyValue3", "explanation": "使用一個固定的數字（123）作為種子。如果程序以相同的固定種子重新運行，Rnd() 將產生相同的隨機數序列，這對於測試和調試很有用。"}
                ],
                "keywords": ["隨機數種子", "初始化", "random", "seed", "initialize", "rnd", "其他"]
            },
            {
                "name": "RGB", "category": "綜合應用案例與技巧",
                "syntax": "RGB(red, green, blue)",
                "description": "返回一個 Long 整數，表示 RGB 顏色值。",
                "parameters": [
                    {"name": "red", "description": "必需。介於 0 和 255 之間的數字，表示紅色的強度。"},
                    {"name": "green", "description": "必需。介於 0 和 255 之間的數字，表示綠色的強度。"},
                    {"name": "blue", "description": "必需。介於 0 和 255 之間的數字，表示藍色的強度。"}
                ],
                "examples": [
                    {"code": "Dim RedColor As Long\nRedColor = RGB(255, 0, 0)\n' ActiveSheet.Tab.Color = RedColor ' 例如，在 Excel 中設置工作表標籤顏色為紅色", "explanation": "創建一個表示純紅色的顏色值。"},
                    {"code": "Dim LightBlueColor As Long\nLightBlueColor = RGB(173, 216, 230)\n' UserForm1.BackColor = LightBlueColor ' 例如，設置用戶窗體的背景色為淺藍色", "explanation": "創建一個表示淺藍色的顏色值。"}
                ],
                "keywords": ["顏色", "RGB值", "color", "red green blue", "graphics", "其他"]
            },
            {
                "name": "QBColor", "category": "綜合應用案例與技巧",
                "syntax": "QBColor(color)",
                "description": "返回一個 Long 整數，表示與指定顏色號碼對應的 RGB 顏色代碼。",
                "parameters": [
                    {"name": "color", "description": "必需。介於 0 和 15 之間的整數。"}
                ],
                "examples": [
                    {"code": "Dim BlueColor As Long\nBlueColor = QBColor(1) ' 1 對應藍色\n' ActiveCell.Font.Color = BlueColor ' 例如，在 Excel 中設置活動單元格字體顏色為藍色", "explanation": "使用 QBColor 函數獲取預定義的藍色顏色值。"},
                    {"code": "Dim BrightRed As Long\nBrightRed = QBColor(12) ' 12 對應亮紅色\n' Debug.Print BrightRed ' 打印出亮紅色的 Long 型顏色值", "explanation": "使用 QBColor 函數獲取預定義的亮紅色顏色值。"}
                ],
                "keywords": ["顏色", "QBasic顏色", "color", "quickbasic", "legacy color", "其他"]
            },
            {
                "name": "Beep", "category": "綜合應用案例與技巧",
                "syntax": "Beep",
                "description": "通過計算機的揚聲器發出聲音。",
                "parameters": [],
                "examples": [
                    {"code": "MsgBox \"處理完成！\"\nBeep ' 在消息框之後發出一聲提示音", "explanation": "在執行完某個操作後，通過計算機揚聲器發出一聲短促的蜂鳴聲作為提示。"}
                ],
                "keywords": ["聲音", "蜂鳴", "sound", "alert", "notification", "其他"]
            },
            {
                "name": "vbConstants (MsgBox)", "category": "綜合應用案例與技巧", "syntax": "vbOKOnly, vbOKCancel, vbAbortRetryIgnore, vbYesNoCancel, vbYesNo, vbRetryCancel, vbCritical, vbQuestion, vbExclamation, vbInformation, vbDefaultButton1, ...",
                "description": "MsgBox 函數中用於指定按鈕和圖標樣式的內建常數。",
                "parameters": [],
                "examples": [
                    {"code": "Dim userChoice As VbMsgBoxResult\nuserChoice = MsgBox(\"儲存檔案?\", vbYesNoCancel + vbQuestion + vbDefaultButton1, \"確認\")\nIf userChoice = vbYes Then Debug.Print \"使用者選擇了是\"\nIf userChoice = vbNo Then Debug.Print \"使用者選擇了否\"\nIf userChoice = vbCancel Then Debug.Print \"使用者選擇了取消\"", "explanation": "使用 MsgBox 常數來定義對話框的按鈕、圖標和預設按鈕。"}
                ],
                "keywords": ["常數", "消息框按鈕", "圖標", "msgbox constants", "buttons", "icons", "vbOK", "vbCancel", "vbYes", "vbNo"]
            },
            {
                "name": "Excel數據匯總並生成Word報告", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Consolidate data from multiple Excel sheets, perform calculations, and generate a summary report in a Word document.",
                "description": "此案例演示了如何從Excel的多個工作表中讀取數據，進行簡單的匯總計算（例如總和、平均值），然後啟動Word應用程式，創建一個新文檔，並將計算結果和格式化文本寫入Word文檔中，形成一份摘要報告。",
                "parameters": [
                {"name": "Excel Workbook Structure", "description": "假設Excel活頁簿中有多個包含相似結構數據的工作表 (例如，每月銷售數據)。"},
                {"name": "Word Report Template", "description": "可選地，可以基於一個Word範本文件來創建報告。"}
                ],
                "examples": [
                {"code": "Sub GenerateWordReportFromExcel()\n  Dim wdApp As Object, wdDoc As Object\n  Dim xlSheet As Worksheet, lastRow As Long, totalSales As Double, avgSales As Double\n  Dim salesCount As Long, reportText As String, i As Long\n\n  ' --- 1. Excel Data Processing ---\n  totalSales = 0\n  salesCount = 0\n  reportText = \"銷售報告摘要:\" & vbCrLf & vbCrLf\n\n  On Error Resume Next ' Handle potential errors like sheet not found\n  For Each xlSheet In ThisWorkbook.Worksheets\n    ' Example: Assuming sales data is in column B, starting from row 2\n    If Left(xlSheet.Name, 5) = \"Sales\" Then ' Process sheets named like \"SalesJan\", \"SalesFeb\"\n      lastRow = xlSheet.Cells(Rows.Count, \"B\").End(xlUp).Row\n      If lastRow >= 2 Then\n        reportText = reportText & \"工作表: \" & xlSheet.Name & vbCrLf\n        Dim currentSheetTotal As Double: currentSheetTotal = 0\n        Dim currentSheetCount As Long: currentSheetCount = 0\n        For i = 2 To lastRow\n          If IsNumeric(xlSheet.Cells(i, \"B\").Value) And Not IsEmpty(xlSheet.Cells(i, \"B\").Value) Then\n            totalSales = totalSales + xlSheet.Cells(i, \"B\").Value\n            currentSheetTotal = currentSheetTotal + xlSheet.Cells(i, \"B\").Value\n            salesCount = salesCount + 1\n            currentSheetCount = currentSheetCount + 1\n          End If\n        Next i\n        reportText = reportText & \"  本月銷售總額: \" & Format(currentSheetTotal, \"#,##0.00\") & vbCrLf\n        If currentSheetCount > 0 Then\n          reportText = reportText & \"  本月平均銷售: \" & Format(currentSheetTotal / currentSheetCount, \"#,##0.00\") & vbCrLf\n        End If\n        reportText = reportText & vbCrLf\n      End If\n    End If\n  Next xlSheet\n  On Error GoTo 0\n\n  If salesCount > 0 Then\n    avgSales = totalSales / salesCount\n    reportText = reportText & \"--- 總體概覽 ---\" & vbCrLf ' Changed to Traditional Chinese\n    reportText = reportText & \"總銷售額 (所有月份): \" & Format(totalSales, \"#,##0.00\") & vbCrLf\n    reportText = reportText & \"平均銷售額 (所有月份): \" & Format(avgSales, \"#,##0.00\") & vbCrLf\n  Else\n    reportText = reportText & \"未找到銷售數據。\"\n  End If\n\n  ' --- 2. Word Document Generation ---\n  On Error Resume Next\n  Set wdApp = GetObject(, \"Word.Application\")\n  If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n  If wdApp Is Nothing Then\n    MsgBox \"無法啟動Word應用程式。\", vbCritical\n    Exit Sub\n  End If\n  On Error GoTo 0\n\n  wdApp.Visible = True\n  Set wdDoc = wdApp.Documents.Add\n\n  With wdDoc.Content\n    .Text = reportText\n    ' Optional: Apply some formatting\n    With .Font\n      .Name = \"Arial\"\n      .Size = 12\n    End With\n    ' Example: Bold the main title\n    Dim titleRange As Object ' Word.Range\n    Set titleRange = wdDoc.Paragraphs(1).Range\n    titleRange.Font.Bold = True\n    titleRange.Font.Size = 16\n  End With\n\n  ' Optional: Save the Word document\n  ' wdDoc.SaveAs2 \"C:\\Reports\\ExcelSummaryReport.docx\"\n\n  MsgBox \"Word報告已生成！\"\n\n  Set wdDoc = Nothing\n  Set wdApp = Nothing ' Consider if you want to close Word or leave it open\nEnd Sub", "explanation": "此腳本遍歷Excel中以\"Sales\"開頭的工作表，匯總B列的銷售數據，然後創建一個新的Word文檔來顯示摘要，包括總銷售額和平均銷售額。腳本中包含錯誤處理和基本格式化。"}
                ],
                "keywords": ["excel to word report", "vba data export word", "automate report generation", "word automation from excel", "office integration", "資料匯總", "報告自動化", "Word文件生成"]
            },
            {
                "name": "Outlook郵件附件批量下載並整理", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Scan Outlook Inbox for emails matching criteria, download attachments, and save them to specific folders based on sender or subject.",
                "description": "此案例演示如何使用VBA自動化Outlook郵件處理。腳本會掃描收件匣（或其他指定資料夾），根據發件人郵箱或郵件主旨中的關鍵詞篩選郵件。對於符合條件的郵件，它會下載所有附件，並根據郵件的某些屬性（如發件人域名或主旨內容）將附件保存到預先定義好的本地文件夾結構中。",
                "parameters": [
                {"name": "Outlook Folder", "description": "指定要掃描的Outlook資料夾 (例如，收件匣)。"},
                {"name": "Filter Criteria", "description": "定義篩選郵件的條件 (例如，特定發件人、主旨包含特定文字、特定接收日期範圍)。"},
                {"name": "Save Path Logic", "description": "定義附件保存路徑的規則 (例如，按發件人創建子資料夾，或按月份創建子資料夾)。"}
                ],
                "examples": [
                {"code": "Sub DownloadAndOrganizeAttachments()\n  Dim olApp As Object ' Outlook.Application\n  Dim olNS As Object  ' Outlook.Namespace\n  Dim olFolder As Object ' Outlook.MAPIFolder\n  Dim olMail As Object ' Outlook.MailItem\n  Dim olAttachment As Object ' Outlook.Attachment\n  Dim fso As Object ' Scripting.FileSystemObject\n  Dim saveFolderBase As String, subFolder As String, fileName As String\n  Dim itemCount As Long, attachmentsSaved As Long\n\n  ' --- Configuration ---\n  saveFolderBase = \"C:\\EmailAttachments\\\" ' 主保存路徑，確保此路徑存在\n  Const TARGET_SENDER_DOMAIN As String = \"@partnerdomain.com\"\n  Const SUBJECT_KEYWORD As String = \"Monthly Report\"\n\n  On Error GoTo ErrorHandler\n  Set olApp = CreateObject(\"Outlook.Application\")\n  Set olNS = olApp.GetNamespace(\"MAPI\")\n  Set olFolder = olNS.GetDefaultFolder(6) ' 6 = olFolderInbox\n  Set fso = CreateObject(\"Scripting.FileSystemObject\")\n\n  If Not fso.FolderExists(saveFolderBase) Then fso.CreateFolder saveFolderBase\n\n  itemCount = 0\n  attachmentsSaved = 0\n\n  ' --- Process Emails ---\n  If olFolder.Items.Count > 0 Then\n    For Each olMail In olFolder.Items\n      ' Ensure it's a MailItem\n      If TypeName(olMail) = \"MailItem\" Then\n        itemCount = itemCount + 1\n        ' Filter logic (example)\n        If InStr(1, olMail.SenderEmailAddress, TARGET_SENDER_DOMAIN, vbTextCompare) > 0 And \n           InStr(1, olMail.Subject, SUBJECT_KEYWORD, vbTextCompare) > 0 Then\n\n          If olMail.Attachments.Count > 0 Then\n            ' Create subfolder based on sender name (simple example)\n            Dim senderNameClean As String\n            senderNameClean = Replace(olMail.SenderName, \" \", \"\") ' Clean sender name for folder\n            senderNameClean = Left(senderNameClean, InStr(senderNameClean, \"@\") -1) ' if email, take part before @\n            If InStr(senderNameClean, \"@\") > 0 Then senderNameClean = Left(senderNameClean, InStr(senderNameClean, \"@\") -1)\n            senderNameClean = CreateValidFolderName(senderNameClean)\n            \n            subFolder = saveFolderBase & senderNameClean & \"\\\"\n            If Not fso.FolderExists(subFolder) Then fso.CreateFolder subFolder\n\n            For Each olAttachment In olMail.Attachments\n              fileName = subFolder & CreateValidFileName(olAttachment.fileName)\n              ' Avoid overwriting: check if file exists and append number if so\n              Dim counter As Integer: counter = 1\n              Dim tempFileName As String: tempFileName = fileName\n              Do While fso.FileExists(tempFileName)\n                tempFileName = subFolder & fso.GetBaseName(fileName) & \"\" & counter & \".\" & fso.GetExtensionName(fileName)\n                counter = counter + 1\n              Loop\n              fileName = tempFileName\n\n              olAttachment.SaveAsFile fileName\n              attachmentsSaved = attachmentsSaved + 1\n              Debug.Print \"已儲存: \" & fileName\n            Next olAttachment\n          End If\n        End If\n      End If\n      If itemCount Mod 50 = 0 Then DoEvents ' Yield to OS for long loops\n    Next olMail\n  End If\n\n  MsgBox attachmentsSaved & \" 個附件已下載並整理完畢。\" & vbCrLf & \n         \"共掃描 \" & itemCount & \" 封郵件。\"\n\nExitSubRoutine:\n  Set olAttachment = Nothing\n  Set olMail = Nothing\n  Set olFolder = Nothing\n  Set olNS = Nothing\n  Set olApp = Nothing\n  Set fso = Nothing\n  Exit Sub\n\nErrorHandler:\n  MsgBox \"發生錯誤: \" & Err.Number & \" - \" & Err.Description, vbCritical\n  Resume ExitSubRoutine\n\nEnd Sub\n\nPrivate Function CreateValidFolderName(ByVal name As String) As String\n    Dim invalidChars As String, i As Integer, char As String\n    invalidChars = \"\\/:*?\"\"<>|\"\n    CreateValidFolderName = name\n    For i = 1 To Len(invalidChars)\n        char = Mid(invalidChars, i, 1)\n        CreateValidFolderName = Replace(CreateValidFolderName, char, \"\")\n    Next i\n    If Len(CreateValidFolderName) > 100 Then CreateValidFolderName = Left(CreateValidFolderName, 100) ' Max length\nEnd Function\n\nPrivate Function CreateValidFileName(ByVal name As String) As String\n    ' Similar to CreateValidFolderName, but can be more restrictive\n    CreateValidFileName = CreateValidFolderName(name)\n    ' Additional checks for filenames if needed\nEnd Function", "explanation": "此腳本連接到Outlook，遍歷收件匣中的郵件。如果郵件來自特定域名且主旨包含關鍵字，則會下載其附件。附件保存在基礎路徑下，子資料夾以發件人名稱（清理後）命名，並處理潛在的檔名衝突。包含輔助函數用於創建有效的文件夾和文件名。"}
                ],
                "keywords": ["outlook attachment download", "automate email attachments", "vba save attachments", "organize emails", "office automation", "郵件附件下載", "郵件整理", "Outlook自動化"]
            },
            {
                "name": "Excel模板批量填充並生成多個PDF文件", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Use an Excel template with placeholders, populate it with data from a list (e.g., another Excel sheet), and save each populated version as a separate PDF file.",
                "description": "此案例演示了如何將Excel用作數據源和模板引擎來批量生成個性化文檔（如此處的PDF）。腳本首先從一個主數據列表（例如，“數據源”工作表）讀取記錄。對於每一條記錄，它會打開一個預設的Excel模板文件，將記錄中的特定數據填充到模板中預定義的儲存格（占位符）。然後，填充好的模板將被另存為PDF文件，文件名通常基於記錄中的唯一標識符。這個過程會為數據列表中的每一行重複執行。",
                "parameters": [
                {"name": "Excel Data Source", "description": "一個包含多行記錄的工作表，每行代表一個要生成的文檔。"},
                {"name": "Excel Template File", "description": "一個.xltx或.xlsx文件，其中包含占位符儲存格，這些儲存格將被數據源中的數據填充。"},
                {"name": "PDF Output Folder", "description": "指定生成的PDF文件保存的資料夾。"}
                ],
                "examples": [
                {"code": "Sub BatchGeneratePDFsFromTemplate()\n  Dim dataSourceSheet As Worksheet, templateSheet As Worksheet\n  Dim templateWorkbook As Workbook, outputWorkbook As Workbook\n  Dim lastRowData As Long, i As Long\n  Dim pdfPath As String, pdfBaseName As String, fullPdfName As String\n  Dim fso As Object\n\n  ' --- Configuration ---\n  Const TEMPLATE_FILE_PATH As String = \"C:\\Templates\\MyReportTemplate.xlsx\" ' 模板路徑\n  Const PDF_OUTPUT_FOLDER As String = \"C:\\GeneratedPDFs\\\"                 ' PDF輸出路徑\n  Set dataSourceSheet = ThisWorkbook.Sheets(\"DataSource\") ' 數據源工作表\n  ' 假設數據源: A列=ID (用於文件名), B列=姓名, C列=數值\n  ' 假設模板中: B1=姓名占位符, B2=數值占位符\n\n  On Error GoTo ErrorHandler\n  Set fso = CreateObject(\"Scripting.FileSystemObject\")\n  If Not fso.FolderExists(PDF_OUTPUT_FOLDER) Then fso.CreateFolder PDF_OUTPUT_FOLDER\n  If Not fso.FileExists(TEMPLATE_FILE_PATH) Then\n    MsgBox \"模板文件未找到: \" & TEMPLATE_FILE_PATH, vbCritical\n    Exit Sub\n  End If\n\n  Application.ScreenUpdating = False\n  Application.DisplayAlerts = False\n\n  lastRowData = dataSourceSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n  For i = 2 To lastRowData ' Assuming row 1 is header\n    pdfBaseName = dataSourceSheet.Cells(i, \"A\").Value ' Get ID for PDF name\n    If IsEmpty(pdfBaseName) Or Trim(pdfBaseName) = \"\" Then pdfBaseName = \"Report\" & i\n    pdfBaseName = CreateValidFileName(CStr(pdfBaseName)) ' Clean the name\n\n    ' Open the template as a new workbook (copy)\n    Set outputWorkbook = Workbooks.Open(TEMPLATE_FILE_PATH)\n    Set templateSheet = outputWorkbook.Sheets(1) ' Assuming template data is on the first sheet\n\n    ' --- Populate Template ---\n    templateSheet.Range(\"B1\").Value = dataSourceSheet.Cells(i, \"B\").Value ' Populate Name\n    templateSheet.Range(\"B2\").Value = dataSourceSheet.Cells(i, \"C\").Value ' Populate Value\n    ' Add more fields as needed\n\n    ' --- Save as PDF ---\n    fullPdfName = PDF_OUTPUT_FOLDER & pdfBaseName & \".pdf\"\n    \n    ' Ensure print area is set if needed, or specific sheet/range is exported\n    ' templateSheet.PageSetup.PrintArea = templateSheet.UsedRange.Address ' Optional: Define print area\n\n    outputWorkbook.ExportAsFixedFormat Type:=xlTypePDF, Filename:=fullPdfName, _\n                                     Quality:=xlQualityStandard, IncludeDocProperties:=True, _\n                                     IgnorePrintAreas:=False, OpenAfterPublish:=False\n    \n    outputWorkbook.Close SaveChanges:=False ' Close the populated template without saving changes to it\n    Set outputWorkbook = Nothing\n    Set templateSheet = Nothing\n    \n    Debug.Print \"已生成 PDF: \" & fullPdfName\n    DoEvents\n  Next i\n\n  MsgBox \"批量PDF生成完成！ \" & (lastRowData - 1) & \" 個文件已創建。\"\n\nExitRoutine:\n  Application.ScreenUpdating = True\n  Application.DisplayAlerts = True\n  Set dataSourceSheet = Nothing\n  Set templateWorkbook = Nothing\n  Set outputWorkbook = Nothing\n  Set templateSheet = Nothing\n  Set fso = Nothing\n  Exit Sub\n\nErrorHandler:\n  MsgBox \"發生錯誤: \" & Err.Number & \" - \" & Err.Description, vbCritical\n  Resume ExitRoutine\n\nEnd Sub\n\n' (Reuse CreateValidFileName function from previous example or define here)\nPrivate Function CreateValidFileName(ByVal name As String) As String\n    Dim invalidChars As String, i As Integer, char As String\n    invalidChars = \"\\/:*?\"\"<>|\"\n    CreateValidFileName = name\n    For i = 1 To Len(invalidChars)\n        char = Mid(invalidChars, i, 1)\n        CreateValidFileName = Replace(CreateValidFileName, char, \"_\") ' Replace invalid chars with underscore\n    Next i\n    CreateValidFileName = Replace(CreateValidFileName, \".\", \"_\") ' Avoid issues with multiple dots before extension\n    If Len(CreateValidFileName) > 100 Then CreateValidFileName = Left(CreateValidFileName, 100)\n    CreateValidFileName = Trim(CreateValidFileName)\n    If CreateValidFileName = \"\" Then CreateValidFileName = \"DefaultFileName\"\n    CreateValidFileName = Replace(CreateValidFileName, \"__\", \"_\") \nEnd Function", "explanation": "此腳本從\"DataSource\"工作表讀取數據。對於每一行數據，它會打開指定的Excel模板，將數據填充到模板的第一個工作表的B1和B2儲存格，然後將該工作簿另存為PDF到指定的輸出文件夾。PDF文件名基於數據源A列的ID。輔助函數CreateValidFileName被改進以更好地處理無效字符。"}
                ],
                "keywords": ["excel to pdf batch", "mail merge to pdf vba", "vba populate template save pdf", "automate pdf generation", "office automation", "批量生成PDF", "模板填充", "Excel轉PDF"]
            },
            {
                "name": "監控文件夾新文件並自動處理 (Excel)", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Periodically check a specific folder for new files (e.g., .csv or .xlsx). When new files appear, import their data into a master Excel sheet or perform other predefined actions.",
                "description": "此案例構建了一個簡單的文件夾監控系統。VBA腳本會使用Application.OnTime來安排定期檢查。在每次檢查時，它會列出指定文件夾中的所有文件，並將其與上次檢查時已知的文件列表進行比較（通常存儲在一個隱藏的工作表或全局變量中）。如果檢測到新文件，腳本可以執行諸如打開文件、複製其內容到主數據表、移動已處理文件到存檔文件夾等操作。這對於自動化日常數據導入任務非常有用。",
                "parameters": [
                {"name": "Monitored Folder Path", "description": "要監控新文件的文件夾路徑。"},
                {"name": "File Type to Monitor", "description": "指定要處理的文件擴展名 (例如 \".csv\", \".xlsx\")。"},
                {"name": "Check Interval", "description": "檢查文件夾的頻率 (例如，每5分鐘)。"},
                {"name": "Processed Files Log", "description": "用於記錄已處理文件列表的方法，以避免重複處理。"}
                ],
                "examples": [
                {"code": "Private processedFilesList As Collection ' Stores names of already processed files\nPrivate Const MONITOR_FOLDER_PATH As String = \"C:\\IncomingData\\\" ' TRAILING SLASH IS IMPORTANT\nPrivate Const PROCESSED_FOLDER_PATH As String = \"C:\\ProcessedData\\\" ' TRAILING SLASH\nPrivate Const CHECK_INTERVAL_SECONDS As Long = 300 ' 5 minutes\nPrivate nextCheckTime As Date\n\nSub StartFolderMonitoring()\n    If processedFilesList Is Nothing Then\n        Set processedFilesList = New Collection\n        ' Optional: Load already processed files from a log or hidden sheet\n        ' LoadProcessedFilesLog\n    End If\n    \n    If Dir(MONITOR_FOLDER_PATH, vbDirectory) = \"\" Then\n        MsgBox \"監控文件夾不存在: \" & MONITOR_FOLDER_PATH, vbCritical\n        Exit Sub\n    End If\n    If Dir(PROCESSED_FOLDER_PATH, vbDirectory) = \"\" Then\n        On Error Resume Next\n        MkDir PROCESSED_FOLDER_PATH\n        If Err.Number <> 0 Then\n            MsgBox \"無法創建已處理文件夾: \" & PROCESSED_FOLDER_PATH, vbCritical\n            Exit Sub\n        End If\n        On Error GoTo 0\n    End If\n\n    MsgBox \"文件夾監控已啟動。每 \" & CHECK_INTERVAL_SECONDS & \" 秒檢查一次。\"\n    ScheduleNextCheck\nEnd Sub\n\nSub StopFolderMonitoring()\n    On Error Resume Next ' In case no schedule is pending\n    Application.OnTime EarliestTime:=nextCheckTime, Procedure:=\"CheckForNewFiles\", Schedule:=False\n    On Error GoTo 0\n    Set processedFilesList = Nothing\n    MsgBox \"文件夾監控已停止。\"\nEnd Sub\n\nPrivate Sub ScheduleNextCheck()\n    nextCheckTime = Now + TimeSerial(0, 0, CHECK_INTERVAL_SECONDS)\n    Application.OnTime EarliestTime:=nextCheckTime, Procedure:=\"CheckForNewFiles\"\n    Debug.Print \"下次檢查已安排於: \" & nextCheckTime\nEnd Sub\n\nSub CheckForNewFiles()\n    Dim fileName As String\n    Dim fso As Object\n    Dim newFileFound As Boolean: newFileFound = False\n\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n\n    fileName = Dir(MONITOR_FOLDER_PATH & \"*.csv\") ' Example: Monitor for CSV files\n\n    Do While fileName <> \"\"\n        If Not IsFileProcessed(MONITOR_FOLDER_PATH & fileName) Then\n            Debug.Print \"發現新檔案: \" & fileName\n            ProcessFile MONITOR_FOLDER_PATH & fileName\n            AddToProcessedList MONITOR_FOLDER_PATH & fileName\n            \n            ' Move processed file\n            On Error Resume Next\n            fso.MoveFile MONITOR_FOLDER_PATH & fileName, PROCESSED_FOLDER_PATH & fileName\n            If Err.Number <> 0 Then\n                Debug.Print \"移動檔案時發生錯誤 \" & fileName & \": \" & Err.Description\n                ' Handle error, e.g. log it, try renaming before move\n            Else\n                Debug.Print \"已移動 \" & fileName & \" 至已處理文件夾。\"\n            End If\n            On Error GoTo 0\n            newFileFound = True\n        End If\n        fileName = Dir ' Get next file\n    Loop\n\n    If newFileFound Then\n        ' Optional: Notify user or trigger further actions\n        Application.StatusBar = \"新檔案已於 \" & Format(Now, \"hh:mm:ss\") & \" 處理完畢\"\n    Else\n        Application.StatusBar = \"於 \" & Format(Now, \"hh:mm:ss\") & \" 未發現新檔案\"\n    End If\n    \n    Set fso = Nothing\n    ScheduleNextCheck ' Reschedule for the next check\nEnd Sub\n\nPrivate Sub ProcessFile(filePath As String)\n    ' --- Actual file processing logic goes here ---\n    ' Example: Import CSV data into ThisWorkbook.Sheets(\"MasterData\")\n    Dim wb As Workbook, ws As Worksheet\n    Dim masterSheet As Worksheet, nextMasterRow As Long\n\n    On Error GoTo ProcessFileError\n    Set masterSheet = ThisWorkbook.Sheets(\"MasterData\") ' Ensure this sheet exists\n    nextMasterRow = masterSheet.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n\n    ' Open the CSV file\n    ' For CSVs, using QueryTables or TextToColumns might be more robust than direct open/copy\n    Set wb = Workbooks.Open(filePath)\n    Set ws = wb.Sheets(1)\n    \n    ' Simple copy example - adjust based on CSV structure\n    ws.UsedRange.Copy masterSheet.Cells(nextMasterRow, \"A\")\n    \n    wb.Close SaveChanges:=False\n    Debug.Print \"已處理並導入數據來源: \" & filePath\n    Exit Sub\n\nProcessFileError:\n    Debug.Print \"處理檔案時發生錯誤 \" & filePath & \": \" & Err.Description\n    If Not wb Is Nothing Then wb.Close SaveChanges:=False\nEnd Sub\n\nPrivate Sub AddToProcessedList(filePath As String)\n    On Error Resume Next ' Ignore if already exists (shouldn't happen with IsFileProcessed check)\n    processedFilesList.Add Item:=LCase(filePath), Key:=LCase(filePath)\n    ' Optional: Save processedFilesList to a log/sheet for persistence across sessions\nEnd Sub\n\nPrivate Function IsFileProcessed(filePath As String) As Boolean\n    IsFileProcessed = False\n    On Error Resume Next\n    Dim item As Variant\n    item = processedFilesList(LCase(filePath)) ' Check if key exists\n    If Err.Number = 0 And Not IsEmpty(item) Then IsFileProcessed = True ' Check if key actually returned an item\n    On Error GoTo 0\nEnd Function\n\n' Optional: Call StartFolderMonitoring from Workbook_Open event\n' Optional: Call StopFolderMonitoring from Workbook_BeforeClose event", "explanation": "此VBA解決方案設置了一個定時器 (Application.OnTime) 來定期執行 CheckForNewFiles。CheckForNewFiles 會掃描指定文件夾中的新CSV文件（與已處理文件列表比較）。找到新文件後，ProcessFile 子程序會打開它，將其內容複製到名為“MasterData”的工作表中，然後將已處理的CSV文件移動到另一個文件夾。已處理的文件名會添加到一個集合中以避免重複處理。包含啟動和停止監控的子程序。注意：對於長時間運行的監控，需要仔細考慮錯誤處理和資源管理。"}
                ],
                "keywords": ["vba folder monitor", "automate file import excel", "excel watch folder", "new file detection vba", "office automation", "文件夾監控", "自動導入數據", "定時任務"]
            },
            {
                "name": "從Excel生成多封個性化Outlook郵件", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Read data from an Excel list (names, email addresses, specific details) and send a personalized email to each recipient using Outlook.",
                "description": "此案例演示了如何從Excel工作表讀取收件人列表和個性化信息，然後為列表中的每個人自動創建並可選擇性地發送Outlook郵件。腳本會遍歷Excel中的每一行數據，提取如收件人郵箱、姓名和郵件正文中需要插入的特定數據點（例如，客戶名稱、訂單號、到期日等）。它會為每條記錄創建一個新的MailItem對象，使用提取的數據填充郵件的“收件人”、“主旨”和“正文”字段。郵件正文可以使用字符串替換或HTMLBody來實現個性化。用戶可以選擇是直接發送郵件還是先顯示它們以供預覽。",
                "parameters": [
                {"name": "Excel Data Source", "description": "包含郵件信息的Excel工作表 (例如，A列=郵箱，B列=姓名，C列=個性化內容1，D列=個性化內容2)。"},
                {"name": "Email Template", "description": "郵件主旨和正文的基礎模板，其中包含將被Excel數據替換的占位符。"},
                {"name": "Send Action", "description": "決定是直接發送郵件 (.Send) 還是顯示郵件供審閱 (.Display)。"}
                ],
                "examples": [
                {"code": "Sub SendPersonalizedEmailsFromExcel()\n  Dim olApp As Object ' Outlook.Application\n  Dim olMail As Object ' Outlook.MailItem\n  Dim dataSheet As Worksheet\n  Dim lastRow As Long, i As Long\n  Dim recipientEmail As String, recipientName As String, customField1 As String, emailBody As String\n\n  ' --- Configuration ---\n  Set dataSheet = ThisWorkbook.Sheets(\"EmailList\") ' Data source sheet\n  ' Assume: Col A = Email, Col B = Name, Col C = Product Name\n  Const EMAIL_SUBJECT_TEMPLATE As String = \"專屬於您的產品更新: {ProductName}\"\n  Const EMAIL_BODY_TEMPLATE As String = \"親愛的 {RecipientName}，<br><br>\" & _\n                                      \"感謝您對我們產品 <strong>{ProductName}</strong> 的關注。<br>\" & _\n                                      \"我們很高興通知您最新的功能...<br><br>\" & _\n                                      \"順頌商祺，<br>我們的團隊\"\n  Const SEND_DIRECTLY As Boolean = False ' False to .Display, True to .Send\n\n  On Error GoTo ErrorHandler\n  Set olApp = CreateObject(\"Outlook.Application\")\n\n  lastRow = dataSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n  For i = 2 To lastRow ' Assuming row 1 is header\n    recipientEmail = Trim(CStr(dataSheet.Cells(i, \"A\").Value))\n    recipientName = Trim(CStr(dataSheet.Cells(i, \"B\").Value))\n    customField1 = Trim(CStr(dataSheet.Cells(i, \"C\").Value)) ' e.g., ProductName\n\n    If recipientEmail = \"\" Or InStr(recipientEmail, \"@\") = 0 Then\n      Debug.Print \"略過列 \" & i & \": 電郵地址無效或為空。\"\n      GoTo NextRecipient\n    End If\n    If recipientName = \"\" Then recipientName = \"客戶\" ' Default if name is blank\n\n    Set olMail = olApp.CreateItem(0) ' olMailItem\n\n    With olMail\n      .To = recipientEmail\n      .Subject = Replace(EMAIL_SUBJECT_TEMPLATE, \"{ProductName}\", customField1)\n      \n      emailBody = EMAIL_BODY_TEMPLATE\n      emailBody = Replace(emailBody, \"{RecipientName}\", recipientName)\n      emailBody = Replace(emailBody, \"{ProductName}\", customField1)\n      .HTMLBody = emailBody\n      \n      ' Optional: Add attachments\n      ' .Attachments.Add \"C:\\Path\\To\\Brochure.pdf\"\n\n      If SEND_DIRECTLY Then\n        .Send\n        Debug.Print \"郵件已傳送至: \" & recipientEmail\n      Else\n        .Display\n        Debug.Print \"郵件已顯示給: \" & recipientEmail\n        ' Optional: Add a pause or prompt if displaying many emails\n        ' If MsgBox(\"Continue with next email?\", vbYesNo) = vbNo Then Exit For\n      End If\n    End With\n    Set olMail = Nothing\n    DoEvents ' Allow Outlook to process\nNextRecipient:\n  Next i\n\n  MsgBox \"郵件處理完成！\"\n\nExitRoutine:\n  Set olMail = Nothing\n  Set olApp = Nothing\n  Set dataSheet = Nothing\n  Exit Sub\n\nErrorHandler:\n  MsgBox \"發生錯誤: \" & Err.Number & \" - \" & Err.Description, vbCritical\n  Resume ExitRoutine\nEnd Sub", "explanation": "此腳本從名為 \"EmailList\" 的Excel工作表讀取數據，該工作表應包含郵箱地址、姓名和一個自定義字段（例如產品名稱）。它會為列表中的每一行創建一封個性化的HTML郵件，使用模板中的占位符並用Excel數據替換它們。根據 SEND_DIRECTLY 常量的值，郵件將被直接發送或顯示供用戶預覽。"}
                ],
                "keywords": ["excel to outlook mail merge", "vba send multiple emails", "personalized email automation", "outlook automation from excel", "office automation", "批量郵件", "個性化郵件", "郵件合併"]
            },
            {
                "name": "自動化月度報告彙整與通知", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Consolidate data from multiple regional Excel report files, generate a summary Excel workbook, create a Word summary document with embedded charts, and draft an Outlook email notification with attachments.",
                "description": "此案例演示了一個端到端的月度報告自動化流程。腳本會：1. 掃描指定文件夾中特定命名模式的月度Excel報告文件（例如，各分部提交的銷售報告）。2. 打開每個報告文件，從中提取關鍵數據（例如，總銷售額、利潤、達成率等）。3. 將提取的數據彙整到一個主Excel活頁簿的“彙總表”工作表中。4. 在彙總表上創建一個摘要圖表（例如，各分部銷售額比較）。5. 創建一個新的Word文檔，撰寫報告摘要，並將Excel中的摘要圖表複製並粘貼為圖片到Word文檔中。6. 保存彙總Excel活頁簿和Word報告。7. 創建一個Outlook郵件草稿，將彙總Excel和Word報告作為附件，並填寫預設的收件人、主旨和郵件正文，以便發送給管理層。8. 可選地，將已處理的原始報告文件移動到存檔文件夾。",
                "parameters": [
                {"name": "Source Reports Folder", "description": "包含各分部月度Excel報告文件的文件夾路徑。"},
                {"name": "Report File Naming Convention", "description": "報告文件的命名規則，例如 'Sales_RegionA_YYYYMM.xlsx'。"},
                {"name": "Master Summary Workbook", "description": "一個Excel活頁簿，用於存儲彙總數據和生成主圖表。"},
                {"name": "Word Report Output Path", "description": "生成的Word摘要報告的保存路徑。"},
                {"name": "Outlook Recipients", "description": "通知郵件的收件人列表。"}
                ],
                "examples": [
                {"code": "Option Explicit\n\nPrivate Const SOURCE_REPORTS_FOLDER As String = \"C:\\MonthlyReports\\Source\\\" ' 原始報告文件夾\nPrivate Const ARCHIVE_REPORTS_FOLDER As String = \"C:\\MonthlyReports\\Archive\\\" ' 存檔文件夾\nPrivate Const MASTER_SUMMARY_FILE As String = \"C:\\MonthlyReports\\MasterSummaryReport.xlsx\" ' 彙總Excel文件\nPrivate Const WORD_REPORT_FILE As String = \"C:\\MonthlyReports\\MonthlySummaryDoc.docx\" ' Word報告文件\nPrivate Const REPORT_MONTH As String = \"202310\" ' 示例報告月份 YYYYMM\n\nSub GenerateFullMonthlyReportAutomation()\n    Dim fso As Object ' FileSystemObject\n    Dim sourceFolder As Object ' Folder\n    Dim fileItem As Object ' File\n    Dim xlApp As Object ' Excel.Application (can use ThisApplication if running from Excel)\n    Dim masterWB As Workbook, summarySheet As Worksheet\n    Dim sourceWB As Workbook, sourceSheet As Worksheet\n    Dim wdApp As Object ' Word.Application\n    Dim wdDoc As Object ' Word.Document\n    Dim olApp As Object ' Outlook.Application\n    Dim olMail As Object ' Outlook.MailItem\n    Dim reportChart As ChartObject\n    Dim nextSummaryRow As Long\n    Dim dataExtracted As Boolean\n\n    On Error GoTo ErrorHandler\n    Application.ScreenUpdating = False\n    Application.DisplayAlerts = False\n\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    Set xlApp = Application ' Assuming this macro runs from Excel\n\n    ' --- 1. Prepare Master Summary Workbook ---\n    If fso.FileExists(MASTER_SUMMARY_FILE) Then\n        Set masterWB = xlApp.Workbooks.Open(MASTER_SUMMARY_FILE)\n    Else\n        Set masterWB = xlApp.Workbooks.Add\n        masterWB.SaveAs MASTER_SUMMARY_FILE\n    End If\n    On Error Resume Next ' Check if SummarySheet exists, create if not\n    Set summarySheet = masterWB.Sheets(\"Summary_\" & REPORT_MONTH)\n    If summarySheet Is Nothing Then\n        Set summarySheet = masterWB.Sheets.Add\n        summarySheet.Name = \"Summary_\" & REPORT_MONTH\n    End If\n    On Error GoTo ErrorHandler ' Reset error handling\n    summarySheet.Cells.ClearContents\n    summarySheet.Range(\"A1:E1\").Value = Array(\"報告檔案\", \"區域\", \"總銷售額\", \"利潤\", \"目標達成率 %\") ' CHINESE\n    nextSummaryRow = 2\n    dataExtracted = False\n\n    ' --- 2. Process Source Report Files ---\n    If Not fso.FolderExists(SOURCE_REPORTS_FOLDER) Then\n        MsgBox \"源報告文件夾未找到: \" & SOURCE_REPORTS_FOLDER, vbCritical\n        GoTo CleanUp\n    End If\n    If Not fso.FolderExists(ARCHIVE_REPORTS_FOLDER) Then fso.CreateFolder ARCHIVE_REPORTS_FOLDER\n\n    Set sourceFolder = fso.GetFolder(SOURCE_REPORTS_FOLDER)\n    For Each fileItem In sourceFolder.Files\n        If InStr(1, fileItem.Name, REPORT_MONTH, vbTextCompare) > 0 And _\n           (LCase(fso.GetExtensionName(fileItem.Name)) = \"xlsx\" Or LCase(fso.GetExtensionName(fileItem.Name)) = \"xls\") Then\n            \n            Debug.Print \"正在處理檔案: \" & fileItem.Path\n            Set sourceWB = xlApp.Workbooks.Open(fileItem.Path, ReadOnly:=True)\n            ' Assuming data is on the first sheet, and in specific cells\n            Set sourceSheet = sourceWB.Sheets(1)\n            \n            summarySheet.Cells(nextSummaryRow, \"A\").Value = fileItem.Name\n            summarySheet.Cells(nextSummaryRow, \"B\").Value = sourceSheet.Range(\"B1\").Value ' Example: Region Name in B1\n            summarySheet.Cells(nextSummaryRow, \"C\").Value = sourceSheet.Range(\"B5\").Value ' Example: Total Sales in B5\n            summarySheet.Cells(nextSummaryRow, \"D\").Value = sourceSheet.Range(\"B6\").Value ' Example: Profit in B6\n            summarySheet.Cells(nextSummaryRow, \"E\").Value = sourceSheet.Range(\"B7\").Value ' Example: Target % in B7\n            nextSummaryRow = nextSummaryRow + 1\n            dataExtracted = True\n\n            sourceWB.Close False\n            Set sourceWB = Nothing\n            Set sourceSheet = Nothing\n            \n            ' Move to archive\n            fso.MoveFile fileItem.Path, ARCHIVE_REPORTS_FOLDER & fileItem.Name\n            Debug.Print \"已移動 \" & fileItem.Name & \" 至存檔區。\"\n        End If\n    Next fileItem\n\n    If Not dataExtracted Then\n        MsgBox \"在 \" & REPORT_MONTH & \" 未找到符合條件的報告文件。\", vbInformation\n        ' GoTo CleanUp ' Decide if to proceed if no files found\n    End If\n\n    ' --- 3. Create Summary Chart in Master Excel ---\n    summarySheet.Columns(\"A:E\").AutoFit\n    Dim chartDataRange As Range, chartTitle As String\n    chartTitle = \"月度銷售額比較 (\" & REPORT_MONTH & \")\"\n    If nextSummaryRow > 2 Then ' If data was added\n        Set chartDataRange = summarySheet.Range(\"B1:C\" & nextSummaryRow - 1)\n        \n        ' Delete old chart if exists with the same name to avoid error\n        On Error Resume Next\n        summarySheet.ChartObjects(chartTitle).Delete\n        On Error GoTo ErrorHandler\n\n        Set reportChart = summarySheet.ChartObjects.Add(Left:=summarySheet.Columns(\"G\").Left, _\n                                                        Width:=350, _\n                                                        Top:=summarySheet.Rows(2).Top, _\n                                                        Height:=250)\n        With reportChart.Chart\n            .SetSourceData Source:=chartDataRange\n            .ChartType = xlColumnClustered\n            .HasTitle = True\n            .ChartTitle.Text = chartTitle\n            .Legend.Position = xlLegendPositionBottom\n        End With\n    End If\n    masterWB.Save\n\n    ' --- 4. Generate Word Report ---\n    On Error Resume Next\n    Set wdApp = GetObject(, \"Word.Application\")\n    If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    If wdApp Is Nothing Then MsgBox \"無法啟動Word.\": GoTo CleanUp\n    On Error GoTo ErrorHandler\n    wdApp.Visible = True\n    Set wdDoc = wdApp.Documents.Add\n\n    With wdDoc\n        .Content.InsertAfter \"月度報告摘要 - \" & REPORT_MONTH & vbCrLf & vbCrLf\n        .Paragraphs(1).Range.Font.Bold = True\n        .Paragraphs(1).Range.Font.Size = 16\n\n        .Content.InsertParagraphAfter\n        .Content.InsertAfter \"本月各分部關鍵績效指標 (KPIs) 如下：\" & vbCrLf\n        ' Copy Excel data as table to Word (optional)\n        If nextSummaryRow > 2 Then\n            summarySheet.Range(\"A1:E\" & nextSummaryRow - 1).Copy\n            .Paragraphs.Last.Range.InsertParagraphAfter ' Ensure new para for table\n            .Paragraphs.Last.Range.PasteExcelTable False, False, False\n            .Content.InsertParagraphAfter\n            .Content.InsertAfter vbCrLf & \"銷售額圖表分析：\" & vbCrLf\n        End If\n        \n        ' Copy chart to Word\n        If Not reportChart Is Nothing Then\n            reportChart.CopyPicture Appearance:=xlScreen, Format:=xlBitmap\n            .Paragraphs.Last.Range.InsertParagraphAfter ' Ensure new para for chart\n            .Paragraphs.Last.Range.PasteSpecial DataType:=wdPasteBitmap ' wdPasteEnhancedMetafile might be better\n        Else\n            .Content.InsertAfter \"(圖表未能生成)\"\n        End If\n        \n        .Content.InsertParagraphAfter\n        .Content.InsertAfter vbCrLf & \"報告生成日期: \" & Format(Now, \"yyyy-mm-dd hh:nn:ss\")\n        .SaveAs2 WORD_REPORT_FILE\n    End With\n\n    ' --- 5. Draft Outlook Email ---\n    On Error Resume Next\n    Set olApp = GetObject(, \"Outlook.Application\")\n    If olApp Is Nothing Then Set olApp = CreateObject(\"Outlook.Application\")\n    If olApp Is Nothing Then MsgBox \"無法啟動Outlook.\": GoTo CleanUp\n    On Error GoTo ErrorHandler\n    \n    Set olMail = olApp.CreateItem(0) ' olMailItem\n    With olMail\n        .To = \"management@example.com; supervisor@example.com\" ' Change recipients\n        .Subject = \"月度報告已生成 - \" & REPORT_MONTH\n        .HTMLBody = \"<p>尊敬的管理層，</p>\" & _\n                    \"<p>\" & REPORT_MONTH & \" 的月度報告已彙整完畢。詳情請參閱附件。</p>\" & _\n                    \"<p>附件包含：<br>1. 彙總Excel數據表<br>2. Word格式摘要報告</p>\" & _\n                    \"<p>順頌商祺</p>\"\n        .Attachments.Add MASTER_SUMMARY_FILE\n        .Attachments.Add WORD_REPORT_FILE\n        .Display ' Display for review before sending\n        ' .Send ' To send directly\n    End With\n\n    MsgBox \"月度報告自動化流程完成！彙總文件、Word報告已生成，Outlook郵件已準備好。\"\n\nCleanUp:\n    Application.ScreenUpdating = True\n    Application.DisplayAlerts = True\n    If Not sourceWB Is Nothing Then sourceWB.Close False\n    If Not masterWB Is Nothing Then masterWB.Close SaveChanges:=True ' Save master summary\n    If Not wdDoc Is Nothing Then wdDoc.Close SaveChanges:=False ' Word doc already saved\n    ' Decide whether to quit Word/Outlook or leave them open\n    ' If Not wdApp Is Nothing And wdApp.Documents.Count = 0 Then wdApp.Quit\n    ' Set olMail = Nothing: Set olApp = Nothing: Set wdDoc = Nothing: Set wdApp = Nothing\n    ' Set summarySheet = Nothing: Set masterWB = Nothing: Set sourceWB = Nothing: Set sourceSheet = Nothing\n    ' Set fileItem = Nothing: Set sourceFolder = Nothing: Set fso = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.ScreenUpdating = True\n    Application.DisplayAlerts = True\n    MsgBox \"處理過程中發生錯誤：\" & vbCrLf & \"錯誤號碼: \" & Err.Number & vbCrLf & _\n           \"錯誤描述: \" & Err.Description & vbCrLf & _\n           \"錯誤來源: \" & Err.Source, vbCritical\n    Resume CleanUp\nEnd Sub", "explanation": "此VBA腳本執行一個完整的月度報告自動化流程。它掃描指定文件夾中的Excel報告文件，提取數據到一個主彙總Excel文件中，在彙總文件中創建圖表，然後生成一個Word文檔包含摘要信息和嵌入的圖表。最後，它會準備一封Outlook郵件，附上生成的Excel和Word報告，供用戶審查和發送。已處理的文件會被移動到存檔文件夾。腳本包含了基本的錯誤處理和對象清理建議。常量部分（如文件夾路徑、報告月份）需要根據實際情況進行配置。"}
                ],
                "keywords": ["vba end to end reporting", "excel data consolidation", "word report automation", "outlook email automation", "automate monthly reports", "office integration project", "月度報告自動化", "數據彙總", "Word報告生成", "Outlook郵件通知", "多應用整合"]
            },
            {
                "name": "動態合同/提案文檔智能組裝系統", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: A UserForm collects key parameters for a new contract/proposal. Based on these parameters, VBA dynamically pulls relevant clauses from a 'clause library' (Excel or structured Word docs), assembles them into a new Word document, and populates client-specific placeholders.",
                "description": "此案例創建了一個用於生成定制化合同或提案的系統。它解決了需要根據客戶需求或項目類型組合不同法律條款或服務描述的複雜任務。流程如下：1. 啟動時顯示一個Excel UserForm，用戶在其中輸入關鍵信息，例如客戶名稱、項目類型（例如，“標準服務”，“高級解決方案”，“短期諮詢”）、合同有效期、特定服務選項（可通過複選框選擇）等。2. 一個“條款庫”存儲在Excel工作表中，每行包含條款ID、條款文本、適用項目類型、以及可能的條件標籤。3. 當用戶提交UserForm後，VBA腳本會根據UserForm的輸入（特別是項目類型和選中的服務選項）查詢條款庫。4. 腳本會篩選出所有適用的條款。5. 啟動Word，可以基於一個包含基本頁眉頁腳和占位符（例如，[ClientName], [StartDate]）的範本創建新文檔。6. 將篩選出的條款按預定順序（或條款庫中定義的順序）插入到Word文檔的主體部分。7. 將UserForm中收集的客戶特定信息填充到文檔中的占位符位置。8. 生成的文檔可以立即顯示給用戶預覽，或直接保存到指定位置。此系統大大減少了手動查找、複製、粘貼和編輯標準條款所需的時間，同時提高了文檔的一致性和準確性。",
                "parameters": [
                {"name": "UserForm Inputs", "description": "定義UserForm需要收集的數據字段。"},
                {"name": "Clause Library (Excel)", "description": "一個結構化的Excel表格，包含條款文本及其元數據（如適用性、順序）。列可能包括：ClauseID, ClauseText, AppliesToProjectType (e.g., 'Standard,Premium'), ServiceOptionTag (e.g., 'SvcOptA'), OrderInCategory。"},
                {"name": "Word Template", "description": "一個Word範本文件 (.dotx)，包含文檔的基本結構、樣式以及用於客戶特定數據的占位符 (例如，使用Content Controls 或 Bookmarks)。"},
                {"name": "Output Document Path", "description": "生成的合同/提案的保存路徑。"}
                ],
                "examples": [
                {"code": "' --- This code would be extensive and involve UserForm design and its event code. ---\n' --- Below is a conceptual outline of the core logic AFTER UserForm submission. ---\n\n' --- UserForm Code (Conceptual - in UserForm's 'Generate Document' button click event) ---\n' Private Sub cmdGenerate_Click()\n'   Dim clientName As String, projectType As String, contractStart As Date\n'   Dim selectedServiceOptions As Collection ' Collection of strings for selected service tags\n'\n'   clientName = Me.txtClientName.Value\n'   projectType = Me.cboProjectType.Value\n'   contractStart = CDate(Me.txtStartDate.Value)\n'   ' Populate selectedServiceOptions from checkboxes on UserForm\n'   Set selectedServiceOptions = New Collection\n'   If Me.chkServiceA.Value = True Then selectedServiceOptions.Add \"SvcOptA\"\n'   If Me.chkServiceB.Value = True Then selectedServiceOptions.Add \"SvcOptB\"\n'\n'   Call AssembleDocument(clientName, projectType, contractStart, selectedServiceOptions)\n'   Unload Me\n' End Sub\n\n' --- Main Module Code (Called from UserForm) ---\nSub AssembleDocument(ByVal clientName As String, ByVal projectType As String, \n                     ByVal contractStart As Date, ByVal serviceOptions As Collection)\n\n    Dim clauseSheet As Worksheet\n    Dim clauseLibRow As Long, lastClauseRow As Long\n    Dim clauseText As String, appliesTo As String, serviceTag As String\n    Dim selectedClauses As Collection ' Store actual clause text to insert\n    Dim currentClauseData As Variant\n    Dim sortableClauses() As Variant ' Array to hold [Order, Text] for sorting\n    Dim clauseCounter As Long\n\n    Dim wdApp As Object, wdDoc As Object, wdTemplatePath As String\n    Dim placeholderMap As Object ' Scripting.Dictionary for placeholders\n\n    Const CLAUSE_LIB_SHEET_NAME As String = \"ClauseLibrary\"\n    Const WORD_TEMPLATE_NAME As String = \"C:\\Templates\\ContractTemplate.dotx\"\n    Const OUTPUT_DOC_PATH As String = \"C:\\GeneratedContracts\\\"\n\n    On Error GoTo ErrorHandler\n    Application.ScreenUpdating = False\n\n    Set clauseSheet = ThisWorkbook.Sheets(CLAUSE_LIB_SHEET_NAME)\n    lastClauseRow = clauseSheet.Cells(Rows.Count, \"A\").End(xlUp).Row ' Col A = ClauseID or Order\n    Set selectedClauses = New Collection\n    clauseCounter = 0\n\n    ' --- 1. Filter Relevant Clauses from Library ---\n    ' Assume Clause Library: Col A=Order, Col B=ClauseText, Col C=AppliesToProjectType (comma sep), Col D=ServiceOptionTag\n    ReDim sortableClauses(1 To lastClauseRow, 1 To 2) ' Max possible, will shrink\n\n    For clauseLibRow = 2 To lastClauseRow ' Assuming row 1 is header\n        clauseText = clauseSheet.Cells(clauseLibRow, \"B\").Value\n        appliesTo = LCase(CStr(clauseSheet.Cells(clauseLibRow, \"C\").Value))\n        serviceTag = CStr(clauseSheet.Cells(clauseLibRow, \"D\").Value)\n        Dim clauseOrder As Long\n        On Error Resume Next\n        clauseOrder = CLng(clauseSheet.Cells(clauseLibRow, \"A\").Value)\n        If Err.Number <> 0 Then clauseOrder = 9999 ' Default large order if not specified or invalid\n        On Error GoTo ErrorHandler\n\n        Dim typeMatch As Boolean: typeMatch = False\n        If InStr(appliesTo, \"all\") > 0 Or InStr(appliesTo, LCase(projectType)) > 0 Then\n            typeMatch = True\n        End If\n\n        Dim serviceMatch As Boolean: serviceMatch = False\n        If Trim(serviceTag) = \"\" Then ' Clause applies regardless of service options\n            serviceMatch = True\n        Else\n            Dim opt As Variant\n            For Each opt In serviceOptions\n                If LCase(opt) = LCase(serviceTag) Then\n                    serviceMatch = True\n                    Exit For\n                End If\n            Next opt\n        End If\n\n        If typeMatch And serviceMatch Then\n            clauseCounter = clauseCounter + 1\n            sortableClauses(clauseCounter, 1) = clauseOrder\n            sortableClauses(clauseCounter, 2) = clauseText\n        End If\n    Next clauseLibRow\n\n    ' Shrink and Sort clauses by Order\n    If clauseCounter > 0 Then\n        ReDim Preserve sortableClauses(1 To clauseCounter, 1 To 2)\n        QuickSort2DArray sortableClauses, 1, clauseCounter, 1 ' Sort by first column (Order)\n        For clauseLibRow = 1 To clauseCounter\n            selectedClauses.Add sortableClauses(clauseLibRow, 2)\n        Next\n    Else\n        MsgBox \"未找到適用於所選參數的條款。\", vbInformation\n        GoTo CleanExit\n    End If\n\n    ' --- 2. Create and Populate Word Document ---\n    Set placeholderMap = CreateObject(\"Scripting.Dictionary\")\n    placeholderMap(\"[ClientName]\") = clientName\n    placeholderMap(\"[ProjectName]\") = \"專案 - \" & clientName ' Example\n    placeholderMap(\"[StartDate]\") = Format(contractStart, \"yyyy年m月d日\")\n    placeholderMap(\"[EndDate]\") = Format(DateAdd(\"m\", 6, contractStart), \"yyyy年m月d日\") ' Example: 6 month contract\n    ' Add other placeholders from UserForm as needed\n\n    On Error Resume Next\n    Set wdApp = GetObject(, \"Word.Application\")\n    If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    If wdApp Is Nothing Then MsgBox \"無法啟動Word.\", vbCritical: GoTo CleanExit\n    On Error GoTo ErrorHandler\n    wdApp.Visible = True\n\n    If Dir(WORD_TEMPLATE_NAME) <> \"\" Then\n        Set wdDoc = wdApp.Documents.Add(Template:=WORD_TEMPLATE_NAME)\n    Else\n        Set wdDoc = wdApp.Documents.Add ' No template\n    End If\n\n    ' Replace placeholders in the entire document (headers, footers, body)\n    Dim key As Variant\n    For Each key In placeholderMap.Keys\n        With wdDoc.Content.Find\n            .ClearFormatting\n            .Replacement.ClearFormatting\n            .Text = key\n            .Replacement.Text = placeholderMap(key)\n            .Forward = True\n            .Wrap = 1 ' wdFindContinue\n            .Format = False\n            .MatchCase = False\n            .MatchWholeWord = False\n            .Execute Replace:=2 ' wdReplaceAll\n        End With\n    Next key\n\n    ' Insert selected clauses (e.g., at a specific bookmark or end of document)\n    Dim clausesRange As Object ' Word.Range\n    On Error Resume Next\n    Set clausesRange = wdDoc.Bookmarks(\"ClausesSection\").Range\n    If clausesRange Is Nothing Then ' If bookmark doesn't exist, append to end\n        Set clausesRange = wdDoc.Content\n        clausesRange.Collapse Direction:=0 ' wdCollapseEnd\n        clausesRange.InsertParagraphAfter\n    End If\n    On Error GoTo ErrorHandler\n    \n    Dim clauseItem As Variant\n    For Each clauseItem In selectedClauses\n        clausesRange.InsertAfter CStr(clauseItem) & vbCrLf & vbCrLf ' Add two newlines after each clause\n        clausesRange.Collapse Direction:=0 ' wdCollapseEnd\n    Next clauseItem\n    \n    wdDoc.SaveAs2 OUTPUT_DOC_PATH & \"Contract_\" & CreateValidFileName(clientName) & \"_\" & Format(Date, \"yyyymmdd\") & \".docx\"\n\n    MsgBox \"合同文檔已為客戶 '\" & clientName & \"' 生成並保存！\", vbInformation\n\nCleanExit:\n    Application.ScreenUpdating = True\n    Set clauseSheet = Nothing: Set selectedClauses = Nothing: Set placeholderMap = Nothing\n    ' If Not wdApp Is Nothing And wdApp.Documents.Count = 0 Then wdApp.Quit\n    ' Set wdDoc = Nothing: Set wdApp = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.ScreenUpdating = True\n    MsgBox \"組裝文檔過程中發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & _\n           \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanExit\nEnd Sub\n\n' Helper: Simple QuickSort for 2D Array (Sorts based on first column of the passed array segment)\nPrivate Sub QuickSort2DArray(ByRef arr() As Variant, ByVal LBound As Long, ByVal UBound As Long, ByVal sortColIndex As Long)\n    Dim PValue As Variant, TempRow() As Variant, i As Long, j As Long, p As Long\n    If LBound >= UBound Then Exit Sub ' Added to prevent infinite loop on small arrays\n    ReDim TempRow(LBound(arr, 2) To UBound(arr, 2)) ' Corrected ReDim for TempRow\n    p = (LBound + UBound) \\ 2\n    PValue = arr(p, sortColIndex)\n    i = LBound: j = UBound\n    Do While i <= j\n        Do While arr(i, sortColIndex) < PValue And i < UBound: i = i + 1: Loop\n        Do While PValue < arr(j, sortColIndex) And j > LBound: j = j - 1: Loop\n        If i <= j Then\n            ' Swap rows\n            Dim k As Long\n            For k = LBound(arr, 2) To UBound(arr, 2)\n                TempRow(k) = arr(i, k)\n                arr(i, k) = arr(j, k)\n                arr(j, k) = TempRow(k)\n            Next k\n            i = i + 1: j = j - 1\n        End If\n    Loop\n    If LBound < j Then QuickSort2DArray arr, LBound, j, sortColIndex\n    If i < UBound Then QuickSort2DArray arr, i, UBound, sortColIndex\nEnd Sub", "explanation": "此解決方案的核心依賴於一個Excel UserForm（用戶界面，此處未完整展示其設計代碼）來收集參數，以及一個名為 \"ClauseLibrary\" 的Excel工作表作為條款數據庫。當用戶在UserForm中填寫信息並點擊生成按鈕時，AssembleDocument 子程序會被調用。該子程序會：1. 根據用戶選擇的項目類型和服務選項從 \"ClauseLibrary\" 中篩選相關條款。2. 對篩選出的條款按預設順序進行排序。3. 創建一個Scripting.Dictionary來管理占位符及其替換值。4. 打開指定的Word範本（或創建新文檔），並遍歷文檔內容（包括頁眉頁腳）以替換所有定義的占位符。5. 將排序後的條款插入到Word文檔中預定義的書籤位置（或文檔末尾）。6. 將生成的Word文檔以客戶名和日期命名保存。包含了一個簡單的二維數組快速排序輔助函數，並修正了其 ReDim 語句。"}
                ],
                "keywords": ["vba dynamic document assembly", "word contract automation", "excel clause library", "userform document generation", "intelligent document creation", "office automation suite", "動態文檔生成", "合同自動化", "條款庫", "UserForm驅動"]
            },
            {
                "name": "從Outlook郵件中提取特定信息到Excel工作表", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Scan a specific Outlook folder (e.g., Inbox or a subfolder) for emails matching certain criteria (e.g., specific sender, subject line keywords, received within a date range). Extract predefined information from the body or subject of these emails (e.g., Order ID, Customer Name, Product Code, Quantity) and populate this data into an Excel worksheet.",
                "description": "此案例演示了如何自動化從Outlook郵件中提取結構化或半結構化信息並將其記錄到Excel中的過程。腳本會：1. 連接到Outlook應用程式。2. 訪問指定的郵件資料夾（例如，收件匣或一個名為“訂單郵件”的子資料夾）。3. 遍歷資料夾中的郵件項目。4. 對於每封郵件，應用篩選條件，例如檢查發件人郵箱是否來自特定域名，或者郵件主旨是否包含“訂單確認”等關鍵詞。5. 如果郵件符合條件，則分析郵件正文（純文本或HTMLBody）以提取所需的數據片段。這通常涉及字符串操作函數（如 `InStr`, `Mid`, `Split`）或正則表達式 (VBScript.RegExp) 來定位和提取模式化的數據（例如，“訂單號：XXXXX”，“客戶：YYYYY”）。6. 將提取到的多個數據點（如訂單號、客戶名、產品、數量）寫入到Excel工作表的新行中，每個數據點對應一個指定的列。7. (可選) 處理完郵件後，可以將其移動到“已處理”資料夾，或對其進行標記，以避免重複處理。8. 在結束時，向用戶報告處理的郵件數量和提取的記錄數量。",
                "parameters": [
                    {"name": "Outlook Folder Path", "description": "要掃描的Outlook資料夾的完整路徑 (例如，\"收件匣\\子資料夾\") 或使用 GetDefaultFolder。"},
                    {"name": "Email Filter Criteria", "description": "用於篩選相關郵件的條件 (發件人、主旨、日期等)。"},
                    {"name": "Data Extraction Logic", "description": "從郵件正文或主旨中提取特定信息的規則和方法 (字符串函數或正則表達式)。"},
                    {"name": "Excel Output Sheet and Columns", "description": "指定用於存放提取數據的Excel工作表和列對應關係。"}
                ],
                "examples": [
                    {"code": "Sub ExtractOrderInfoFromEmailsToExcel()\n    Dim olApp As Object ' Outlook.Application\n    Dim olNS As Object  ' Outlook.Namespace\n    Dim olFolder As Object ' Outlook.MAPIFolder\n    Dim olMail As Object ' Outlook.MailItem (or Object if iterating mixed items)\n    Dim xlSheet As Worksheet\n    Dim nextRow As Long\n    Dim mailBody As String\n    Dim orderID As String, customerName As String, product As String, quantity As String\n    Dim processedCount As Long, extractedCount As Long\n\n    ' --- Configuration ---\n    Const TARGET_FOLDER_PATH As String = \"Inbox/OrderEmails\" ' **替換為實際的Outlook資料夾路徑**\n    Const SUBJECT_KEYWORD As String = \"New Order Received\"\n    Set xlSheet = ThisWorkbook.Sheets(\"ExtractedOrders\") ' Excel輸出工作表\n    ' 確保Excel工作表有表頭: OrderID, CustomerName, Product, Quantity, ReceivedDate\n    xlSheet.Cells.ClearContents ' Clear previous data for fresh extraction\n    xlSheet.Range(\"A1:E1\").Value = Array(\"OrderID\", \"CustomerName\", \"Product\", \"Quantity\", \"ReceivedDate\")\n    xlSheet.Rows(1).Font.Bold = True\n    nextRow = 2\n    processedCount = 0\n    extractedCount = 0\n\n    On Error GoTo ErrorHandler\n    Set olApp = CreateObject(\"Outlook.Application\")\n    Set olNS = olApp.GetNamespace(\"MAPI\")\n\n    ' --- Access Target Outlook Folder ---\n    Dim arrFolders As Variant, i As Long\n    Dim currentFolder As Object: Set currentFolder = olNS.GetDefaultFolder(6) ' olFolderInbox\n    If InStr(TARGET_FOLDER_PATH, \"/\") > 0 Then\n        arrFolders = Split(TARGET_FOLDER_PATH, \"/\")\n        If LCase(arrFolders(0)) = \"inbox\" Or LCase(arrFolders(0)) = \"收件匣\" Then\n            ' Handled by GetDefaultFolder if it's the root inbox\n        Else ' If it's a subfolder of inbox not directly accessible by constant\n            Set currentFolder = olNS.Folders(olApp.Session.CurrentUser.Name) ' Or specific account store if not default\n            Set currentFolder = currentFolder.Folders(arrFolders(0))\n        End If\n        For i = 1 To UBound(arrFolders)\n            Set currentFolder = currentFolder.Folders(arrFolders(i))\n        Next i\n    End If\n    Set olFolder = currentFolder\n    If olFolder Is Nothing Then\n        MsgBox \"找不到Outlook資料夾: \" & TARGET_FOLDER_PATH, vbCritical\n        GoTo CleanUp\n    End If\n    Debug.Print \"正在掃描資料夾: \" & olFolder.FolderPath\n\n    ' --- Loop through emails in the folder ---\n    If olFolder.Items.Count = 0 Then\n        MsgBox \"資料夾 '\" & olFolder.Name & \"' 中沒有郵件。\", vbInformation\n        GoTo CleanUp\n    End If\n\n    For Each olMail In olFolder.Items\n        If TypeName(olMail) = \"MailItem\" Then ' Process only MailItem objects\n            processedCount = processedCount + 1\n            ' Apply filters\n            If InStr(1, olMail.Subject, SUBJECT_KEYWORD, vbTextCompare) > 0 Then\n                mailBody = olMail.Body ' Or olMail.HTMLBody and parse HTML\n                \n                ' --- Data Extraction Logic (Example using InStr and Mid) ---\n                ' This part is highly dependent on the email's content structure.\n                ' Regular expressions would be more robust for complex patterns.\n                orderID = ExtractValue(mailBody, \"Order ID:\", vbCrLf) ' vbCrLf or another delimiter\n                customerName = ExtractValue(mailBody, \"Customer Name:\", vbCrLf)\n                product = ExtractValue(mailBody, \"Product:\", vbCrLf)\n                quantity = ExtractValue(mailBody, \"Quantity:\", vbCrLf)\n                \n                If orderID <> \"\" Or customerName <> \"\" Then ' If at least some data found\n                    xlSheet.Cells(nextRow, \"A\").Value = orderID\n                    xlSheet.Cells(nextRow, \"B\").Value = customerName\n                    xlSheet.Cells(nextRow, \"C\").Value = product\n                    xlSheet.Cells(nextRow, \"D\").Value = quantity\n                    xlSheet.Cells(nextRow, \"E\").Value = olMail.ReceivedTime\n                    nextRow = nextRow + 1\n                    extractedCount = extractedCount + 1\n                    \n                    ' Optional: Move or mark email as processed\n                    ' olMail.UnRead = False\n                    ' olMail.Move olFolder.Folders(\"ProcessedOrders\") ' Ensure \"ProcessedOrders\" subfolder exists\n                End If\n            End If\n        End If\n        If processedCount Mod 20 = 0 Then DoEvents ' Yield for large folders\n    Next olMail\n\n    xlSheet.Columns.AutoFit\n    MsgBox extractedCount & \" 條記錄已從 \" & processedCount & \" 封掃描郵件中提取到Excel。\", vbInformation\n\nCleanUp:\n    Set olMail = Nothing: Set olFolder = Nothing: Set olNS = Nothing: Set olApp = Nothing\n    Set xlSheet = Nothing\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"處理郵件時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub\n\n' Helper function to extract value based on a start string and an end delimiter\nPrivate Function ExtractValue(ByVal searchText As String, ByVal startDelimiter As String, ByVal endDelimiter As String) As String\n    Dim posStart As Long, posEnd As Long, tempStr As String\n    ExtractValue = \"\" ' Default to empty string\n    posStart = InStr(1, searchText, startDelimiter, vbTextCompare)\n    If posStart > 0 Then\n        posStart = posStart + Len(startDelimiter)\n        posEnd = InStr(posStart, searchText, endDelimiter, vbTextCompare)\n        If posEnd > 0 Then\n            tempStr = Trim(Mid(searchText, posStart, posEnd - posStart))\n        Else ' If end delimiter not found, take rest of string (or up to a certain length)\n            tempStr = Trim(Mid(searchText, posStart))\n            If Len(tempStr) > 100 Then tempStr = Left(tempStr, 100) ' Limit length if no end found\n        End If\n        ExtractValue = tempStr\n    End If\nEnd Function", "explanation": "此VBA子程序 `ExtractOrderInfoFromEmailsToExcel` 會連接到Outlook，並掃描指定子資料夾（例如 \"Inbox/OrderEmails\"）中的郵件。它會篩選主旨行包含特定關鍵詞（例如 \"New Order Received\"）的郵件。對於符合條件的郵件，它會使用一個輔助函數 `ExtractValue` 從郵件正文中提取“Order ID:”、“Customer Name:”、“Product:”和“Quantity:”後面的文本。提取到的數據以及郵件接收日期會被寫入到名為“ExtractedOrders”的Excel工作表中。**重要：** `TARGET_FOLDER_PATH` 需要被修改為實際的Outlook文件夾路徑（相對於根郵箱或收件箱）。`ExtractValue` 函數的提取邏輯非常基礎，對於結構更複雜或多變的郵件內容，建議使用正則表達式或更高級的HTML解析技術。"}
                ],
                "keywords": ["vba outlook email to excel", "extract data from outlook email body", "excel import email data", "outlook automation vba excel", "parse email content vba", "Outlook郵件提取到Excel", "解析郵件內容", "自動化郵件數據導入"]
            },
            {
                "name": "追蹤Outlook郵件回覆並自動更新Excel狀態", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: After sending out a batch of emails (e.g., surveys, information requests) tracked in an Excel sheet, VBA monitors a specific Outlook folder for replies. When a reply related to a tracked email is found (e.g., by matching subject line or a unique ID in the body), the Excel sheet is updated to reflect that a reply has been received, and optionally, extract key information from the reply.",
                "description": "此案例演示了如何自動化追蹤Outlook郵件回覆並更新Excel表格中的狀態。這個過程通常比較複雜，因為可靠地將回覆與原始郵件匹配可能具有挑戰性。腳本通常會：1. **準備階段 (原始郵件發送時)**：a. 在Excel工作表中記錄已發送郵件的關鍵信息，包括唯一的追蹤ID (可以生成並插入到原始郵件的主旨或正文中，例如 `[TrackID:XYZ123]`)、收件人、發送日期和一個“回覆狀態”列（初始為“未回覆”）。b. (可選) 將已發送郵件的 `EntryID` 或 `ConversationID` (如果適用) 存儲在Excel中，以便後續匹配。2. **監控與更新階段 (定期執行或手動觸發)**：a. 連接到Outlook應用程式並訪問存放回覆的資料夾 (例如，收件匣或特定子資料夾)。b. 遍歷資料夾中的郵件。c. 對於每封郵件，嘗試將其與Excel中記錄的已發送郵件進行匹配。匹配邏輯可以基於：  i. 郵件主旨：檢查回覆郵件的主旨是否包含原始郵件的主旨或追蹤ID (例如，`RE: [TrackID:XYZ123] Original Subject`)。  ii. 對話ID (`ConversationID` 或 `ConversationTopic`): 如果原始郵件的 `ConversationID` 已記錄，則檢查回覆郵件是否屬於同一個對話。  iii. 郵件正文中的追蹤ID：搜索回覆郵件正文中是否存在原始郵件中嵌入的唯一追蹤ID。d. 如果找到匹配項：  i. 更新Excel工作表中對應行的“回覆狀態”為“已回覆”和“回覆日期”。  ii. (可選) 從回覆郵件的正文中提取特定信息（例如，客戶的反饋、確認信息）並記錄到Excel的其他列中。  iii. (可選) 將已處理的回覆郵件移動到“已處理回覆”資料夾。3. 提供處理摘要。**挑戰與考量**：主旨行可能被修改。`ConversationID` 在某些郵件系統交互中可能不可靠。正文解析可能很複雜。錯誤處理和避免重複更新至關重要。",
                "parameters": [
                    {"name": "Excel Tracking Sheet", "description": "包含已發送郵件信息和回覆狀態的Excel工作表。"},
                    {"name": "Outlook Replies Folder", "description": "存放回覆郵件的Outlook資料夾。"},
                    {"name": "Matching Logic", "description": "用於將回覆郵件與原始已發送郵件關聯起來的規則 (基於追蹤ID、主旨、ConversationID等)。"},
                    {"name": "Information to Extract from Reply (Optional)", "description": "如果需要，定義從回覆中提取哪些數據。"}
                ],
                "examples": [
                    {"code": "' --- THIS IS A COMPLEX SCENARIO AND THE CODE BELOW IS A SIMPLIFIED CONCEPTUAL OUTLINE --- \n' --- Robust implementation requires careful error handling and more sophisticated matching logic. ---\n\nSub TrackEmailRepliesAndUpdateExcel()\n    Dim olApp As Object ' Outlook.Application\n    Dim olNS As Object  ' Outlook.Namespace\n    Dim olRepliesFolder As Object ' Outlook.MAPIFolder\n    Dim olReplyMail As Object ' Outlook.MailItem (or Object)\n    Dim xlTrackSheet As Worksheet\n    Dim trackLastRow As Long, i As Long\n    Dim originalTrackID As String, originalSubject As String\n    Dim replySubject As String, replyBody As String, replySender As String\n    Dim foundMatchAndUpdate As Boolean\n\n    ' --- Configuration ---\n    Set xlTrackSheet = ThisWorkbook.Sheets(\"EmailTracking\")\n    ' Excel Tracking Sheet Columns (Example):\n    ' A: TrackID (Unique ID sent in original email, e.g., in subject or body)\n    ' B: RecipientEmail\n    ' C: OriginalSubject\n    ' D: SentDate\n    ' E: ReplyStatus (e.g., \"Pending Reply\", \"Replied\", \"Error\")\n    ' F: ReplyDate\n    ' G: ExtractedReplyInfo (Optional)\n\n    Const REPLIES_FOLDER_PATH As String = \"Inbox\" ' Or a specific subfolder\n    Const TRACK_ID_PREFIX As String = \"[TrackID:\"\n    Const TRACK_ID_SUFFIX As String = \"]\"\n\n    On Error GoTo ErrorHandler\n    Set olApp = CreateObject(\"Outlook.Application\")\n    Set olNS = olApp.GetNamespace(\"MAPI\")\n    ' Access replies folder (simplified - assumes Inbox, robust path needed for subfolders)\n    Set olRepliesFolder = olNS.GetDefaultFolder(6) ' olFolderInbox\n    If InStr(REPLIES_FOLDER_PATH, \"/\") > 0 And LCase(REPLIES_FOLDER_PATH) <> \"inbox\" And LCase(REPLIES_FOLDER_PATH) <> \"收件匣\" Then\n        Dim arrFolders() As String, fIdx As Long\n        Dim currentFolder As Object: Set currentFolder = olNS.GetDefaultFolder(6)\n        arrFolders = Split(REPLIES_FOLDER_PATH, \"/\")\n        If LCase(arrFolders(0)) = \"inbox\" Or LCase(arrFolders(0)) = \"收件匣\" Then\n            ' Skip first element if it's 'inbox'\n            For fIdx = 1 To UBound(arrFolders)\n                Set currentFolder = currentFolder.Folders(arrFolders(fIdx))\n            Next fIdx\n        Else ' Path relative to mailbox root\n            Set currentFolder = olNS.Folders(olApp.Session.CurrentUser.Name)\n             For fIdx = 0 To UBound(arrFolders)\n                Set currentFolder = currentFolder.Folders(arrFolders(fIdx))\n            Next fIdx\n        End If\n        Set olRepliesFolder = currentFolder\n    End If\n\n    If olRepliesFolder Is Nothing Then\n        MsgBox \"找不到回覆資料夾: \" & REPLIES_FOLDER_PATH, vbCritical: GoTo CleanUp\n    End If\n\n    Debug.Print \"正在掃描資料夾 '\" & olRepliesFolder.FolderPath & \"' 中的回覆...\"\n    Application.StatusBar = \"正在掃描Outlook回覆...\"\n\n    ' --- Loop through untracked replies in Outlook ---\n    ' It's better to filter items if possible (e.g., unread, or received after last check)\n    For Each olReplyMail In olRepliesFolder.Items\n        If TypeName(olReplyMail) = \"MailItem\" Then\n            If olReplyMail.UnRead = True Or True Then ' Process unread or all for simplicity here\n                replySubject = olReplyMail.Subject\n                replyBody = olReplyMail.Body ' Or HTMLBody\n                replySender = olReplyMail.SenderEmailAddress\n                foundMatchAndUpdate = False\n\n                ' --- Attempt to match reply to tracked email --- \n                trackLastRow = xlTrackSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n                For i = 2 To trackLastRow ' Assuming row 1 is header\n                    If LCase(Trim(CStr(xlTrackSheet.Cells(i, \"E\").Value))) = \"pending reply\" Or _\n                       LCase(Trim(CStr(xlTrackSheet.Cells(i, \"E\").Value))) = \"\" Then ' Only check those awaiting reply\n                        \n                        originalTrackID = Trim(CStr(xlTrackSheet.Cells(i, \"A\").Value))\n                        originalSubject = Trim(CStr(xlTrackSheet.Cells(i, \"C\").Value))\n                        \n                        ' Matching Logic (Example: by TrackID in subject or original subject match)\n                        Dim matchFoundBy As String: matchFoundBy = \"\"\n                        If originalTrackID <> \"\" And InStr(1, replySubject, TRACK_ID_PREFIX & originalTrackID & TRACK_ID_SUFFIX, vbTextCompare) > 0 Then\n                            matchFoundBy = \"TrackID in Subject\"\n                        ElseIf originalTrackID <> \"\" And InStr(1, replyBody, TRACK_ID_PREFIX & originalTrackID & TRACK_ID_SUFFIX, vbTextCompare) > 0 Then\n                             matchFoundBy = \"TrackID in Body\"\n                        ElseIf InStr(1, replySubject, \"RE: \" & originalSubject, vbTextCompare) > 0 Or _\n                               InStr(1, replySubject, \"答覆: \" & originalSubject, vbTextCompare) > 0 Then\n                            ' And also check sender if subject is not unique enough\n                            If LCase(replySender) = LCase(Trim(CStr(xlTrackSheet.Cells(i, \"B\").Value))) Then\n                                matchFoundBy = \"RE: Subject and Sender\"\n                            End If\n                        End If\n\n                        If matchFoundBy <> \"\" Then\n                            xlTrackSheet.Cells(i, \"E\").Value = \"Replied (\" & matchFoundBy & \")\"\n                            xlTrackSheet.Cells(i, \"F\").Value = olReplyMail.ReceivedTime\n                            xlTrackSheet.Cells(i, \"F\").NumberFormat = \"yyyy-mm-dd hh:mm\"\n                            \n                            ' Optional: Extract info from reply body\n                            ' Dim extractedInfo As String\n                            ' extractedInfo = ExtractSpecificInfoFromReply(replyBody, \"Confirmation Code:\")\n                            ' xlTrackSheet.Cells(i, \"G\").Value = extractedInfo\n                            \n                            Debug.Print \"匹配找到! TrackID: \" & originalTrackID & \", 回覆來自: \" & replySender & \", 匹配方式: \" & matchFoundBy\n                            olReplyMail.UnRead = False ' Mark as read\n                            ' olReplyMail.Move olRepliesFolder.Folders(\"Processed Replies\") ' Move to subfolder\n                            foundMatchAndUpdate = True\n                            Exit For ' Exit inner loop once matched\n                        End If\n                    End If\n                Next i\n            End If\n        End If\n        If i Mod 10 = 0 Then DoEvents\n    Next olReplyMail\n\n    Application.StatusBar = \"\"\n    xlTrackSheet.Columns(\"A:G\").AutoFit\n    MsgBox \"郵件回覆追蹤和Excel更新完成！\", vbInformation\n\nCleanUp:\n    Application.StatusBar = \"\"\n    Set olReplyMail = Nothing: Set olRepliesFolder = Nothing: Set olNS = Nothing: Set olApp = Nothing\n    Set xlTrackSheet = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.StatusBar = \"\"\n    MsgBox \"處理回覆時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub\n\n' Placeholder for a more sophisticated extraction function\nFunction ExtractSpecificInfoFromReply(ByVal bodyText As String, ByVal keyword As String) As String\n    Dim pos As Long\n    pos = InStr(1, bodyText, keyword, vbTextCompare)\n    If pos > 0 Then\n        ' Simple extraction: take text after keyword up to next newline or fixed length\n        Dim startPos As Long: startPos = pos + Len(keyword)\n        Dim endPos As Long: endPos = InStr(startPos, bodyText, vbCrLf)\n        If endPos = 0 Then endPos = Len(bodyText) + 1\n        ExtractSpecificInfoFromReply = Trim(Mid(bodyText, startPos, endPos - startPos))\n        If Len(ExtractSpecificInfoFromReply) > 255 Then ExtractSpecificInfoFromReply = Left(ExtractSpecificInfoFromReply, 255)\n    Else\n        ExtractSpecificInfoFromReply = \"\"\n    End If\nEnd Function", "explanation": "此VBA子程序 `TrackEmailRepliesAndUpdateExcel` 嘗試自動化追蹤Outlook郵件回覆並更新Excel中的狀態。**前提**：在發送原始郵件時，應在Excel的 \"EmailTracking\" 工作表中記錄每封郵件的唯一追蹤ID (例如，`[TrackID:XYZ123]`)、收件人、原始主旨和發送日期，並將“回覆狀態”初始設為“待回覆”。**執行邏輯**：1. 腳本會掃描指定的Outlook回覆資料夾（默認為收件匣）。2. 對於每封（未讀）郵件，它會檢查其主旨或正文是否包含Excel中某條記錄的追蹤ID，或者主旨是否匹配原始主旨的典型回覆格式 (RE: ...) 且發件人匹配。3. 如果找到匹配項，它會在Excel中更新該記錄的“回覆狀態”為“已回覆”，記錄回覆日期，並可選擇性地從回覆正文中提取信息（通過 `ExtractSpecificInfoFromReply` 輔助函數）。4. 已處理的回覆郵件可以被標記為已讀或移動到其他資料夾。**重要考量**：此範例中的匹配邏輯相對簡單。實際應用中，需要更可靠的匹配機制，例如使用Outlook的 `ConversationID`（如果適用且可靠），或更複雜的追蹤ID嵌入和提取方法。錯誤處理和避免重複更新也非常關鍵。回覆郵件的格式千差萬別，從中穩定地提取特定信息通常需要強大的字符串處理或正則表達式知識。"}
                ],
                "keywords": ["vba outlook track email replies", "excel update from outlook reply", "automate email response tracking", "outlook vba match replies", "VBA追蹤郵件回覆", "Excel自動更新Outlook狀態", "郵件回覆處理"]
            },
            {
                "name": "基於Excel指令，自動處理Outlook郵件並根據內容觸發不同回覆", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Monitor an Outlook folder for incoming emails. For each new email, analyze its subject and/or body content against a set of rules defined in an Excel sheet. Based on keywords or patterns found, VBA automatically drafts and sends (or displays for review) different pre-defined reply emails, also potentially sourcing reply content or parameters from the Excel sheet.",
                "description": "此案例演示了一個更高級的自動化流程，VBA不僅讀取郵件，還能根據郵件內容和Excel中定義的規則來決定並執行不同的回覆動作。腳本會：1. **配置Excel規則表**：創建一個Excel工作表，每行定義一條處理規則。列可以包括：a. 觸發關鍵詞/模式 (在主旨或正文中查找)。b. 郵件來源條件 (例如，特定發件人域名)。c. 回覆類型 (例如，“標準答覆A”，“技術支持請求”，“產品諮詢回覆”)。d. 對應的回覆郵件主旨模板。e. 對應的回覆郵件正文模板 (可包含占位符，如 `{SenderName}`, `{OriginalSubject}`，或從原始郵件提取的 `{ExtractedInfo}`). f. (可選) 需要轉發給的內部郵箱。g. (可選) 是否自動發送 (True/False)。2. **監控Outlook資料夾**：VBA定期掃描指定的Outlook資料夾 (例如，收件匣或特定支援郵箱的收件匣) 中的新郵件 (例如，未讀郵件)。3. **內容分析與規則匹配**：對於每封新郵件：a. 提取其主旨、發件人和正文。b. 遍歷Excel規則表中的每一條規則。c. 檢查郵件內容是否符合某條規則的觸發關鍵詞/模式和來源條件。可以使用 `InStr` 或正則表達式進行匹配。4. **執行動作**：一旦找到匹配的規則：a. 根據規則表中定義的回覆類型，獲取相應的回覆主旨和正文模板。b. (可選) 從原始郵件中提取特定信息 (例如，提問的問題、客戶編號) 以便插入到回覆模板的占位符中。c. 創建一個新的Outlook `MailItem` 作為回覆。d. 填充回覆郵件的收件人 (原始郵件的發件人)、抄送 (可選)、主旨和正文。e. (可選) 根據規則，可能需要添加附件或將郵件轉發給內部特定人員。f. 根據規則表中的“是否自動發送”標誌，決定是直接 `.Send` 郵件還是 `.Display` 供人工審核。g. (可選) 將原始郵件標記為已處理或移動到特定資料夾。5. **日誌記錄**：將處理的郵件、應用的規則和執行結果記錄到Excel日誌表中。這種自動化對於處理大量常規查詢、初步客戶支持、郵件分流等場景非常有效。",
                "parameters": [
                    {"name": "Excel Rules Sheet", "description": "定義郵件處理規則和回覆模板的Excel工作表。"},
                    {"name": "Outlook Monitored Folder", "description": "要監控新郵件的Outlook資料夾。"},
                    {"name": "Content Analysis Logic", "description": "用於從郵件中提取信息並與規則匹配的邏輯。"},
                    {"name": "Reply Templates", "description": "存儲在Excel中或作為獨立文件，用於不同類型的回覆。"},
                    {"name": "Action Log Sheet", "description": "記錄VBA執行的操作和結果的Excel工作表。"}
                ],
                "examples": [
                    {"code": "' --- THIS IS A HIGHLY COMPLEX SCENARIO. THE CODE BELOW IS A VERY SIMPLIFIED CONCEPTUAL OUTLINE. --- \n' --- Robust implementation requires extensive error handling, sophisticated parsing, and careful state management. ---\n\n' --- Excel Sheets Setup ---\n' Sheet \"EmailProcessingRules\":\n' Col A: RuleID (e.g., RULE001)\n' Col B: TriggerKeyword (e.g., \"password reset\", \"product inquiry\", \"technical issue\")\n' Col C: SenderDomainFilter (e.g., \"@customer.com\", \"*\" for any)\n' Col D: ReplySubjectTemplate (e.g., \"RE: Your inquiry - {OriginalSubject}\")\n' Col E: ReplyBodyTemplatePath (Path to a .txt or .htm file containing the body, or direct text with placeholders)\n' Col F: AutoSend (TRUE/FALSE)\n' Col G: ForwardTo (Optional: internal email address)\n' Col H: ActionTaken (Log: e.g., \"Replied with Template A\", \"Forwarded to Support\")\n'\n' Sheet \"ActionLog\":\n' Col A: Timestamp, B: OriginalEmailSubject, C: Sender, D: AppliedRuleID, E: ActionSummary, F: Status\n\nSub AutoProcessAndReplyEmails()\n    Dim olApp As Object, olNS As Object, olInbox As Object, olMail As Object, olReply As Object\n    Dim rulesSheet As Worksheet, logSheet As Worksheet\n    Dim ruleLastRow As Long, logNextRow As Long, i As Long, r As Long\n    Dim mailSubject As String, mailBody As String, mailSenderDomain As String\n    Dim ruleKeyword As String, ruleSenderFilter As String, ruleReplySubj As String, ruleReplyBodyPath As String\n    Dim ruleAutoSend As Boolean, ruleForwardTo As String, ruleID As String\n    Dim ruleMatched As Boolean\n    Dim fso As Object, ts As Object\n\n    ' --- Configuration ---\n    Set rulesSheet = ThisWorkbook.Sheets(\"EmailProcessingRules\")\n    Set logSheet = ThisWorkbook.Sheets(\"ActionLog\")\n    logNextRow = logSheet.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n    ruleLastRow = rulesSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n\n    On Error GoTo ErrorHandler\n    Set olApp = CreateObject(\"Outlook.Application\")\n    Set olNS = olApp.GetNamespace(\"MAPI\")\n    Set olInbox = olNS.GetDefaultFolder(6) ' olFolderInbox\n\n    Application.StatusBar = \"正在檢查新郵件以進行自動處理...\"\n\n    ' --- Process Unread Emails (or emails matching certain criteria) ---\n    For i = olInbox.Items.Count To 1 Step -1 ' Loop backwards when deleting/moving items\n        Set olMail = olInbox.Items(i)\n        If TypeName(olMail) = \"MailItem\" And olMail.UnRead Then\n            mailSubject = Trim(olMail.Subject)\n            mailBody = Trim(olMail.Body) ' Or HTMLBody\n            mailSenderDomain = \"*\" ' Default to any sender\n            If InStr(olMail.SenderEmailAddress, \"@\") > 0 Then\n                mailSenderDomain = \"@\" & Split(olMail.SenderEmailAddress, \"@\")(1)\n            End If\n            ruleMatched = False\n\n            ' --- Match against rules in Excel ---\n            For r = 2 To ruleLastRow ' Assuming row 1 is header in rulesSheet\n                ruleID = CStr(rulesSheet.Cells(r, \"A\").Value)\n                ruleKeyword = LCase(Trim(CStr(rulesSheet.Cells(r, \"B\").Value)))\n                ruleSenderFilter = LCase(Trim(CStr(rulesSheet.Cells(r, \"C\").Value)))\n                ruleReplySubj = CStr(rulesSheet.Cells(r, \"D\").Value)\n                ruleReplyBodyPath = CStr(rulesSheet.Cells(r, \"E\").Value)\n                ruleAutoSend = CBool(rulesSheet.Cells(r, \"F\").Value)\n                ruleForwardTo = Trim(CStr(rulesSheet.Cells(r, \"G\").Value))\n\n                ' Keyword and Sender Matching Logic (Simplified)\n                If (InStr(1, LCase(mailSubject), ruleKeyword, vbTextCompare) > 0 Or _\n                    InStr(1, LCase(mailBody), ruleKeyword, vbTextCompare) > 0) And _\n                   (ruleSenderFilter = \"*\" Or LCase(mailSenderDomain) = ruleSenderFilter) Then\n                    \n                    ruleMatched = True\n                    Debug.Print \"Mail '\" & mailSubject & \"' matched RuleID: \" & ruleID\n                    Dim replyBodyContent As String\n                    If fso.FileExists(ruleReplyBodyPath) Then\n                        Set ts = fso.OpenTextFile(ruleReplyBodyPath, 1)\n                        replyBodyContent = ts.ReadAll\n                        ts.Close\n                    Else\n                        replyBodyContent = \"[Error: Reply template not found - \" & ruleReplyBodyPath & \"]\"\n                    End If\n                    \n                    ' Placeholder replacement (Example)\n                    replyBodyContent = Replace(replyBodyContent, \"{SenderName}\", olMail.SenderName)\n                    replyBodyContent = Replace(replyBodyContent, \"{OriginalSubject}\", mailSubject)\n                    ' Add more complex extraction and replacement if needed\n                    \n                    ' --- Create and Send/Display Reply ---\n                    Set olReply = olMail.ReplyAll ' Or olMail.Reply\n                    With olReply\n                        .Subject = Replace(ruleReplySubj, \"{OriginalSubject}\", mailSubject)\n                        .HTMLBody = replyBodyContent & vbCrLf & olReply.HTMLBody ' Prepend reply, keep original thread\n                        ' Or .Body for plain text\n                        \n                        If ruleAutoSend Then\n                            .Send\n                            LogAction olMail, ruleID, \"自動回覆已傳送\", \"成功\"\n                        Else\n                            .Display\n                            LogAction olMail, ruleID, \"回覆已準備供審查\", \"待處理\"\n                        End If\n                    End With\n                    \n                    ' --- Optional: Forward --- \n                    If ruleForwardTo <> \"\" Then\n                        Dim olForward As Object: Set olForward = olMail.Forward\n                        olForward.Recipients.Add ruleForwardTo\n                        olForward.Subject = \"FW: \" & mailSubject & \" [Rule: \" & ruleID & \"]\"\n                        If ruleAutoSend Then olForward.Send Else olForward.Display\n                        LogAction olMail, ruleID, \"已轉發至 \" & ruleForwardTo, \"成功\"\n                    End If\n                    \n                    olMail.UnRead = False ' Mark original as read\n                    ' olMail.Move olInbox.Folders(\"ProcessedAutoReply\") ' Move to subfolder\n                    Exit For ' Stop processing more rules for this email\n                End If ' End of rule match\n            Next r ' Next rule\n\n            If Not ruleMatched Then\n                LogAction olMail, \"N/A\", \"無匹配規則\", \"待手動處理\"\n                 ' olMail.Move olInbox.Folders(\"ManualReview\")\n            End If\n        End If ' End of MailItem check\n        Set olMail = Nothing: Set olReply = Nothing\n        If i Mod 5 = 0 Then DoEvents ' Yield periodically\n    Next i\n\n    Application.StatusBar = \"\"\n    MsgBox \"郵件自動處理和回覆檢查完成！\", vbInformation\n\nCleanUp:\n    Application.StatusBar = \"\"\n    Set olApp = Nothing: Set olNS = Nothing: Set olInbox = Nothing: Set olMail = Nothing: Set olReply = Nothing\n    Set rulesSheet = Nothing: Set logSheet = Nothing: Set fso = Nothing: Set ts = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.StatusBar = \"\"\n    Debug.Print \"Error during email processing: \" & Err.Number & \" - \" & Err.Description\n    LogAction Nothing, \"SYSTEM_ERROR\", \"VBA Error: \" & Err.Description, \"失敗\"\n    MsgBox \"郵件處理過程中發生錯誤: \" & vbCrLf & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub\n\nPrivate Sub LogAction(ByVal mailItem As Object, ByVal ruleIDApplied As String, ByVal summary As String, ByVal status As String)\n    Dim logSht As Worksheet, nextLgRw As Long\n    On Error Resume Next\n    Set logSht = ThisWorkbook.Sheets(\"ActionLog\")\n    If logSht Is Nothing Then Exit Sub\n    On Error GoTo 0\n    \n    nextLgRw = logSht.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n    logSht.Cells(nextLgRw, \"A\").Value = Now\n    If Not mailItem Is Nothing Then\n        logSht.Cells(nextLgRw, \"B\").Value = mailItem.Subject\n        logSht.Cells(nextLgRw, \"C\").Value = mailItem.SenderEmailAddress\n    Else\n        logSht.Cells(nextLgRw, \"B\").Value = \"N/A\"\n        logSht.Cells(nextLgRw, \"C\").Value = \"N/A\"\n    End If\n    logSht.Cells(nextLgRw, \"D\").Value = ruleIDApplied\n    logSht.Cells(nextLgRw, \"E\").Value = summary\n    logSht.Cells(nextLgRw, \"F\").Value = status\nEnd Sub", "explanation": "此VBA子程序 `AutoProcessAndReplyEmails` 旨在根據Excel工作表 \"EmailProcessingRules\" 中定義的規則自動處理Outlook收件匣中的未讀郵件。**規則表示例**：列出觸發關鍵詞、發件人域過濾、回覆主旨模板、回覆正文模板的路徑（可以是包含HTML或純文本的.txt或.htm文件）、是否自動發送的布爾值以及可選的轉發郵箱。**處理邏輯**：1. 腳本遍歷收件匣中的未讀郵件。2. 對於每封郵件，它會檢查其主旨和正文是否包含規則表中定義的關鍵詞，並檢查發件人域是否匹配。3. 如果找到匹配的規則，腳本會從指定路徑讀取回覆正文模板，並可選地替換其中的占位符（例如 `{SenderName}`, `{OriginalSubject}`）。4. 然後，它會創建一個回覆郵件 (`olMail.ReplyAll`)，填充主旨和正文。5. 根據規則，郵件會被直接發送或顯示供用戶審查。6. 同樣根據規則，原始郵件可能會被轉發。7. 原始郵件被標記為已讀，並可選擇移動到已處理文件夾。8. 所有操作都會記錄在 \"ActionLog\" 工作表中。**重要提示**：這是一個非常概念性的框架。實際部署需要：詳細規劃Excel規則表的結構。實現更強健的關鍵詞匹配邏輯（可能使用正則表達式）。為占位符替換開發更複雜的解析和數據提取機制。嚴格的錯誤處理，特別是文件I/O和Outlook對象操作。考慮併發問題（如果多個實例運行）和性能（對於大量郵件和規則）。管理郵件線程以確保回覆正確地附加到原始對話。"}
                ],
                "keywords": ["vba outlook auto reply rules", "excel based email automation", "outlook conditional autoresponder", "vba process incoming email excel", "intelligent email handling vba", "Outlook郵件自動回覆", "Excel定義郵件規則", "智能郵件處理"]
            },
            {
                "name": "使用唯一標識符追蹤Outlook調查問卷回覆並更新Excel", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: An Excel sheet is used to send out a batch of survey emails, each containing a unique survey ID in the subject or body. VBA then monitors an Outlook folder for replies. When a reply is identified (by its unique survey ID), VBA extracts specific answers or choices from the reply body and updates the corresponding record in the original Excel tracking sheet.",
                "description": "此案例專注於使用唯一ID來精確匹配調查問卷的回覆，並將回覆內容解析後更新到Excel。流程如下：1. **Excel發送列表準備**：a. 一個Excel工作表（“SurveyTracking”）包含每位潛在回覆者的信息：Email地址、姓名、以及一個為其生成的唯一SurveyID (例如，`SURVEY_XYZ_001`)。b. 其他列用於記錄發送狀態、發送日期、回覆狀態（初始為“未回覆”）、回覆日期，以及用於存放從回覆中提取的答案的列（例如，Q1Answer, Q2Rating, Q3Comments）。2. **發送帶有SurveyID的郵件** (可由另一個VBA過程完成)：發送郵件時，將對應的SurveyID嵌入到每封郵件的主旨行 (例如，`Subject: 請完成我們的調查問卷 [ID: SURVEY_XYZ_001]`) 或郵件正文中一個易於解析的位置。3. **監控與更新回覆** (此案例的核心)：a. VBA連接到Outlook並掃描指定的回覆資料夾。b. 對於每封新郵件，腳本會嘗試從主旨或正文中提取SurveyID。正則表達式對於從文本中可靠地提取特定模式的ID非常有用。c. 如果成功提取到SurveyID，腳本會在“SurveyTracking”Excel工作表中查找具有該SurveyID的行。d. 找到匹配行後：  i. 將該行的“回覆狀態”更新為“已回覆”，並記錄“回覆日期”。  ii. 解析回覆郵件的正文以提取答案。這可能涉及查找問題標籤（例如，“問題1答案：”，“您對X的評分是：”）後面的文本，或者解析更結構化的回覆（例如，如果用戶被要求以特定格式回覆）。  iii. 將提取到的答案填入Excel表中對應的答案列。  iv. (可選) 將已處理的回覆郵件標記或移動。4. 提供處理摘要。這種方法比僅依賴主旨行匹配更可靠，因為即使用戶修改了回覆主旨，只要SurveyID仍然存在（尤其是在郵件正文中），匹配仍然可能成功。",
                "parameters": [
                    {"name": "Excel Survey Tracking Sheet", "description": "包含SurveyID、收件人信息、發送狀態以及用於記錄回覆和答案的列。"},
                    {"name": "Outlook Replies Folder", "description": "存放調查問卷回覆郵件的Outlook資料夾。"},
                    {"name": "SurveyID Format and Location", "description": "定義SurveyID的格式以及它在原始郵件和回覆郵件中的預期位置（主旨或正文）。"},
                    {"name": "Answer Extraction Logic", "description": "從回覆郵件正文中提取各個問題答案的規則和方法。"}
                ],
                "examples": [
                    {"code": "' --- Conceptual Outline for Tracking Survey Replies with Unique IDs ---\n\nSub ProcessSurveyRepliesWithUniqueID()\n    Dim olApp As Object, olNS As Object, olRepliesFolder As Object, olReplyMail As Object\n    Dim surveyTrackSheet As Worksheet\n    Dim trackLastRow As Long, currentRow As Long\n    Dim mailBodyText As String, mailSubject As String\n    Dim extractedSurveyID As String, foundSurveyIDinExcel As String\n    Dim regexID As Object ' For extracting SurveyID\n    Dim processedCount As Long: processedCount = 0\n\n    ' --- Configuration ---\n    Set surveyTrackSheet = ThisWorkbook.Sheets(\"SurveyTracking\")\n    ' Excel Sheet Columns (Example):\n    ' A: SurveyID (e.g., SURVEY_PROJ1_001)\n    ' B: RecipientEmail\n    ' C: SentDate\n    ' D: ReplyStatus (e.g., \"Pending\", \"Replied\")\n    ' E: ReplyDate\n    ' F: Q1_Answer (e.g., Extracted answer to question 1)\n    ' G: Q2_Rating (e.g., Extracted rating for question 2)\n\n    Const REPLIES_FOLDER_NAME As String = \"Inbox/SurveyReplies\" ' **Adjust folder path**\n    Const SURVEY_ID_REGEX_PATTERN As String = \"\\[ID:\\s*(SURVEY_[A-Z0-9_]+)\\]\" ' Regex to find [ID: SURVEY_XXX_YYY]\n\n    On Error GoTo ErrorHandler\n    Set olApp = CreateObject(\"Outlook.Application\")\n    Set olNS = olApp.GetNamespace(\"MAPI\")\n    ' Access replies folder (robust path access as in previous examples)\n    Dim arrFolders As Variant, i As Long\n    Dim currentFolder As Object: Set currentFolder = olNS.GetDefaultFolder(6) ' olFolderInbox\n    If InStr(REPLIES_FOLDER_NAME, \"/\") > 0 Then\n        arrFolders = Split(REPLIES_FOLDER_NAME, \"/\")\n        If LCase(arrFolders(0)) = \"inbox\" Or LCase(arrFolders(0)) = \"收件匣\" Then\n            For i = 1 To UBound(arrFolders)\n                Set currentFolder = currentFolder.Folders(arrFolders(i))\n            Next i\n        Else\n            Set currentFolder = olNS.Folders(olApp.Session.CurrentUser.Name)\n            For i = 0 To UBound(arrFolders)\n                Set currentFolder = currentFolder.Folders(arrFolders(i))\n            Next i\n        End If\n    End If\n    Set olRepliesFolder = currentFolder\n    If olRepliesFolder Is Nothing Then MsgBox \"Survey replies folder not found!\", vbCritical: GoTo CleanUp\n\n    Set regexID = CreateObject(\"VBScript.RegExp\")\n    regexID.Global = False ' Expect only one SurveyID per email for this logic\n    regexID.IgnoreCase = True\n    regexID.Pattern = SURVEY_ID_REGEX_PATTERN\n\n    Debug.Print \"Processing replies in folder: \" & olRepliesFolder.FolderPath\n    Application.StatusBar = \"Processing survey replies...\"\n\n    ' --- Loop through UNREAD emails in the specified folder ---\n    Dim mailItemsToProcess As Object ' Outlook.Items\n    Set mailItemsToProcess = olRepliesFolder.Items.Restrict(\"[Unread]=true\")\n\n    If mailItemsToProcess.Count = 0 Then\n        MsgBox \"No unread survey replies found to process.\", vbInformation\n        GoTo CleanUp\n    End If\n\n    For Each olReplyMail In mailItemsToProcess\n        If TypeName(olReplyMail) = \"MailItem\" Then\n            mailSubject = olReplyMail.Subject\n            mailBodyText = olReplyMail.Body ' Or HTMLBody, then strip HTML for regex or use HTML-aware parsing\n            extractedSurveyID = \"\"\n\n            ' 1. Attempt to extract SurveyID from Subject OR Body using Regex\n            If regexID.Test(mailSubject) Then\n                extractedSurveyID = regexID.Execute(mailSubject)(0).SubMatches(0)\n            ElseIf regexID.Test(mailBodyText) Then\n                extractedSurveyID = regexID.Execute(mailBodyText)(0).SubMatches(0)\n            End If\n\n            If extractedSurveyID <> \"\" Then\n                Debug.Print \"Extracted SurveyID: \" & extractedSurveyID & \" from email: \" & mailSubject\n                ' 2. Find this SurveyID in the Excel Tracking Sheet\n                trackLastRow = surveyTrackSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n                foundSurveyIDinExcel = \"\"\n                For currentRow = 2 To trackLastRow ' Assume row 1 is header\n                    If Trim(CStr(surveyTrackSheet.Cells(currentRow, \"A\").Value)) = extractedSurveyID And _\n                       (LCase(Trim(CStr(surveyTrackSheet.Cells(currentRow, \"D\").Value))) = \"pending\" Or _\n                        LCase(Trim(CStr(surveyTrackSheet.Cells(currentRow, \"D\").Value))) = \"\") Then ' Check if already processed\n                        \n                        foundSurveyIDinExcel = extractedSurveyID\n                        surveyTrackSheet.Cells(currentRow, \"D\").Value = \"Replied\"\n                        surveyTrackSheet.Cells(currentRow, \"E\").Value = olReplyMail.ReceivedTime\n                        surveyTrackSheet.Cells(currentRow, \"E\").NumberFormat = \"yyyy-mm-dd hh:mm\"\n                        \n                        ' 3. Extract Answers (Example - very basic, needs robust parsing)\n                        '    This part is highly dependent on how users are asked to reply.\n                        Dim answerQ1 As String, answerQ2 As String\n                        answerQ1 = ExtractSurveyAnswer(mailBodyText, \"Q1Answer:\", vbCrLf)\n                        answerQ2 = ExtractSurveyAnswer(mailBodyText, \"Q2Rating:\", vbCrLf)\n                        \n                        surveyTrackSheet.Cells(currentRow, \"F\").Value = answerQ1\n                        surveyTrackSheet.Cells(currentRow, \"G\").Value = answerQ2\n                        \n                        Debug.Print \"Updated Excel for SurveyID: \" & extractedSurveyID & \" with Q1='\" & answerQ1 & \"', Q2='\" & answerQ2 & \"'\"\n                        processedCount = processedCount + 1\n                        olReplyMail.UnRead = False ' Mark as read\n                        ' Optional: Move email to a 'Processed Surveys' folder\n                        ' olReplyMail.Move olRepliesFolder.Folders(\"ProcessedSurveys\")\n                        Exit For ' Move to next email once matched and processed\n                    End If\n                Next currentRow\n                If foundSurveyIDinExcel = \"\" Then\n                    Debug.Print \"SurveyID '\" & extractedSurveyID & \"' found in email but not (or already processed) in Excel Tracker.\"\n                     ' Optionally log this or move email to a 'ManualReview' folder\n                End If\n            Else\n                Debug.Print \"No SurveyID found in email: \" & mailSubject\n                 ' Optionally move non-ID emails to a different folder\n            End If\n        End If\n        If processedCount Mod 5 = 0 Then DoEvents\n    Next olReplyMail\n\n    Application.StatusBar = \"\"\n    surveyTrackSheet.Columns(\"A:G\").AutoFit\n    MsgBox processedCount & \" survey replies processed and Excel sheet updated.\", vbInformation\n\nCleanUp:\n    Application.StatusBar = \"\"\n    Set olApp = Nothing: Set olNS = Nothing: Set olRepliesFolder = Nothing: Set olReplyMail = Nothing\n    Set surveyTrackSheet = Nothing: Set regexID = Nothing: Set mailItemsToProcess = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.StatusBar = \"\"\n    MsgBox \"Error processing survey replies: \" & vbCrLf & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub\n\n' Helper function to extract specific answer (very basic example)\nPrivate Function ExtractSurveyAnswer(ByVal body As String, ByVal answerLabel As String, ByVal endDelimiter As String) As String\n    Dim posLabel As Long, posStartValue As Long, posEndValue As Long\n    ExtractSurveyAnswer = \"\"\n    posLabel = InStr(1, body, answerLabel, vbTextCompare)\n    If posLabel > 0 Then\n        posStartValue = posLabel + Len(answerLabel)\n        posEndValue = InStr(posStartValue, body, endDelimiter)\n        If posEndValue = 0 Then ' If end delimiter not found, take up to 255 chars or end of line\n            Dim tempStr As String\n            tempStr = Trim(Mid(body, posStartValue))\n            If InStr(tempStr, vbCrLf) > 0 Then tempStr = Trim(Split(tempStr, vbCrLf)(0))\n            If InStr(tempStr, vbLf) > 0 Then tempStr = Trim(Split(tempStr, vbLf)(0))\n            If Len(tempStr) > 255 Then tempStr = Left(tempStr, 255)\n            ExtractSurveyAnswer = tempStr\n        Else\n            ExtractSurveyAnswer = Trim(Mid(body, posStartValue, posEndValue - startPosValue))\n        End If\n    End If\nEnd Function", "explanation": "此VBA子程序 `ProcessSurveyRepliesWithUniqueID` 旨在處理Outlook中收到的調查問卷回覆。**前提**：在Excel的“SurveyTracking”工作表中，A列存儲了發送給每個收件人的唯一SurveyID（例如 `SURVEY_PROJ1_001`），D列用於記錄回覆狀態。原始調查問卷郵件在發送時，應將此SurveyID嵌入主旨或正文中 (例如，`[ID: SURVEY_PROJ1_001]`)。**處理邏輯**：1. 腳本掃描指定的Outlook回覆資料夾中的未讀郵件。2. 它使用正則表達式 (`SURVEY_ID_REGEX_PATTERN`) 從每封郵件的主旨或正文中提取SurveyID。3. 如果提取到SurveyID，腳本會在Excel的“SurveyTracking”表中查找匹配的ID，並且該條記錄的回覆狀態應為“Pending”或空白。4. 找到匹配行後，更新Excel中的回覆狀態和日期。5. 接著，它調用一個輔助函數 `ExtractSurveyAnswer` (此處為非常基礎的示例) 來嘗試從回覆郵件正文中提取特定問題的答案（例如，查找“Q1Answer:”後面的文本）。提取的答案會記錄到Excel的相應列中。6. 處理完畢的回覆郵件被標記為已讀，並可選擇移動到其他文件夾。**重要提示**：`REPLIES_FOLDER_NAME` 和 `SURVEY_ID_REGEX_PATTERN` 需要根據實際情況配置。`ExtractSurveyAnswer` 函數的答案提取邏輯高度依賴於用戶被要求如何格式化他們的回覆；對於更複雜的回覆結構，需要更高級的解析技術。"}
                ],
                "keywords": ["vba outlook survey reply processing", "excel track email responses unique id", "parse outlook email answers to excel", "automate survey data collection vba", "Outlook問卷回覆處理", "Excel追蹤唯一ID回覆", "自動提取郵件答案"]
            },
            {
                "name": "從Word文檔中提取特定段落或表格數據到Excel", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: A folder contains multiple Word documents (e.g., monthly reports, product specifications) that follow a somewhat consistent structure. VBA iterates through these documents, extracts specific information (e.g., text from bookmarked paragraphs, data from specific tables, or content following certain headings), and consolidates this information into a structured Excel worksheet for analysis or reporting.",
                "description": "此案例演示了如何自動化從一批Word文檔中提取數據並彙整到Excel的過程。腳本會：1. 指定一個包含多個Word文檔的資料夾。2. (可選) 定義一個文件名篩選模式，只處理特定名稱或類型的Word文檔。3. 遍歷指定資料夾中的每個Word文檔。4. 對於每個文檔： a. 啟動Word應用程式（如果尚未啟動）並以唯讀方式打開文檔，以避免意外修改。 b. 根據預定義的規則從文檔中提取數據。提取方法可以基於：  i. **書籤 (Bookmarks)**：如果文檔使用書籤來標記關鍵數據區域，則直接讀取書籤的範圍文本。  ii. **特定樣式的段落 (Paragraph Styles)**：查找應用了特定樣式（例如，“標題1”，“數據點”）的段落，並提取其文本。  iii. **表格索引或標題 (Tables)**：定位文檔中的特定表格（例如，第一個表格，或標題包含特定文本的表格），然後遍歷其儲存格以提取數據。  iv. **關鍵詞後的文本 (Keyword Search)**：查找特定關鍵詞或短語，然後提取其後續的文本或段落。  v. **正則表達式 (Advanced)**：使用正則表達式從文檔內容中匹配和提取複雜模式的數據。 c. 將從當前Word文檔提取到的多個數據點（例如，報告名稱、日期、關鍵發現、表格數據行）寫入到Excel工作表的新行中，每個數據點對應一個指定的列。 d. 關閉Word文檔而不保存更改。5. 在所有Word文檔處理完畢後，通知用戶，Excel工作表中將包含所有彙整的數據。這個自動化對於從大量結構化或半結構化的Word報告中收集信息非常有用。",
                "parameters": [
                    {"name": "Source Word Documents Folder", "description": "包含Word文檔的資料夾路徑。"},
                    {"name": "Data Extraction Rules", "description": "定義如何從每個Word文檔中定位和提取所需信息的規則 (基於書籤、樣式、表格、關鍵詞等)。"},
                    {"name": "Excel Output Sheet and Columns", "description": "指定用於存放提取數據的Excel工作表和列對應關係。"},
                    {"name": "File Filter (Optional)", "description": "用於篩選要處理的Word文檔的文件名模式 (例如，\"MonthlyReport_*.docx\")。"}
                ],
                "examples": [
                    {"code": "Sub ExtractDataFromWordDocsToExcel()\n    Dim wdApp As Object ' Word.Application\n    Dim wdDoc As Object ' Word.Document\n    Dim xlSheet As Worksheet\n    Dim fso As Object ' Scripting.FileSystemObject\n    Dim sourceFolder As Object ' Folder\n    Dim fileItem As Object ' File\n    Dim nextRowExcel As Long\n    Dim extractedData1 As String, extractedData2 As String, extractedTableData As String\n    Dim filesProcessed As Long: filesProcessed = 0\n\n    ' --- Configuration ---\n    Const WORD_DOCS_FOLDER_PATH As String = \"C:\\WordReportsToProcess\\\" ' **替換為實際文件夾路徑**\n    Const FILE_PATTERN As String = \"*.docx\" ' Process only .docx files (or \"*.doc\")\n    Set xlSheet = ThisWorkbook.Sheets(\"WordDataExtract\")\n    ' Ensure Excel sheet has headers, e.g.: FileName, BookmarkText, Heading1Text, TableCell_1_1, TableCell_1_2\n    xlSheet.Cells.ClearContents ' Clear previous data\n    xlSheet.Range(\"A1:E1\").Value = Array(\"FileName\", \"IntroBookmarkText\", \"FirstHeadingText\", \"Table1_Cell(1,1)\", \"Table1_Cell(1,2)\")\n    xlSheet.Rows(1).Font.Bold = True\n    nextRowExcel = 2\n\n    On Error GoTo ErrorHandler\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    If Not fso.FolderExists(WORD_DOCS_FOLDER_PATH) Then\n        MsgBox \"指定的Word文檔資料夾未找到: \" & WORD_DOCS_FOLDER_PATH, vbCritical\n        Exit Sub\n    End If\n\n    On Error Resume Next ' Handle case where Word might not be installed or automation is blocked\n    Set wdApp = GetObject(, \"Word.Application\")\n    If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    If wdApp Is Nothing Then MsgBox \"無法啟動Word應用程式。\", vbCritical: Exit Sub\n    On Error GoTo ErrorHandler\n    ' wdApp.Visible = False ' Keep Word hidden during processing for speed\n\n    Application.StatusBar = \"正在處理Word文檔...\"\n\n    ' --- Iterate through Word documents in the folder ---\n    Set sourceFolder = fso.GetFolder(WORD_DOCS_FOLDER_PATH)\n    For Each fileItem In sourceFolder.Files\n        If LCase(fso.GetExtensionName(fileItem.Name)) = \"docx\" Or LCase(fso.GetExtensionName(fileItem.Name)) = \"doc\" Then\n            If (Not fileItem.Attributes And 16) And Left(fileItem.Name, 2) <> \"~$\" Then ' Not a directory and not a temp file\n                Debug.Print \"正在開啟文檔: \" & fileItem.Path\n                Set wdDoc = wdApp.Documents.Open(FileName:=fileItem.Path, ReadOnly:=True, Visible:=False)\n                \n                extractedData1 = \"\" ' Reset for each file\n                extractedData2 = \"\" \n                extractedTableData = \"\"\n                Dim cell1_1 As String: cell1_1 = \"N/A\"\n                Dim cell1_2 As String: cell1_2 = \"N/A\"\n\n                ' --- Extraction Logic Examples ---\n                ' 1. Extract text from a bookmark named \"Introduction\"\n                On Error Resume Next ' In case bookmark doesn't exist\n                If wdDoc.Bookmarks.Exists(\"Introduction\") Then\n                    extractedData1 = Trim(wdDoc.Bookmarks(\"Introduction\").Range.Text)\n                Else\n                    extractedData1 = \"[書籤 'Introduction' 未找到]\"\n                End If\n                Err.Clear\n                On Error GoTo ErrorHandler\n\n                ' 2. Extract text of the first paragraph styled as \"Heading 1\"\n                Dim para As Object ' Word.Paragraph\n                For Each para In wdDoc.Paragraphs\n                    If para.Style = \"標題 1\" Or para.Style = \"Heading 1\" Then ' Adjust style name as per document\n                        extractedData2 = Trim(para.Range.Text)\n                        Exit For ' Get only the first one\n                    End If\n                Next para\n                If extractedData2 = \"\" Then extractedData2 = \"[標題1樣式未找到]\"\n\n                ' 3. Extract data from the first table, first two cells of the first row\n                If wdDoc.Tables.Count > 0 Then\n                    On Error Resume Next ' Handle if table cells don't exist\n                    cell1_1 = Trim(wdDoc.Tables(1).Cell(1, 1).Range.Text)\n                    cell1_1 = Left(cell1_1, Len(cell1_1) - 2) ' Remove cell marker characters\n                    cell1_2 = Trim(wdDoc.Tables(1).Cell(1, 2).Range.Text)\n                    cell1_2 = Left(cell1_2, Len(cell1_2) - 2) ' Remove cell marker characters\n                    Err.Clear\n                    On Error GoTo ErrorHandler\n                End If\n\n                ' --- Write extracted data to Excel ---\n                xlSheet.Cells(nextRowExcel, \"A\").Value = fileItem.Name\n                xlSheet.Cells(nextRowExcel, \"B\").Value = extractedData1\n                xlSheet.Cells(nextRowExcel, \"C\").Value = Replace(extractedData2, vbCr, \"\") ' Remove paragraph mark from heading text\n                xlSheet.Cells(nextRowExcel, \"D\").Value = cell1_1\n                xlSheet.Cells(nextRowExcel, \"E\").Value = cell1_2\n                nextRowExcel = nextRowExcel + 1\n                filesProcessed = filesProcessed + 1\n                \n                wdDoc.Close SaveChanges:=False\n                Set wdDoc = Nothing\n                Debug.Print \"已處理: \" & fileItem.Name\n            End If\n        End If\n        If filesProcessed Mod 5 = 0 Then DoEvents\n    Next fileItem\n\n    xlSheet.Columns.AutoFit\n    Application.StatusBar = \"\"\n    MsgBox filesProcessed & \" 個Word文檔已處理完畢，數據已提取到Excel。\", vbInformation\n\nCleanUp:\n    Application.StatusBar = \"\"\n    If Not wdDoc Is Nothing Then wdDoc.Close SaveChanges:=False\n    ' Decide whether to quit Word app: if it was opened by this script and no other docs are open by user\n    ' If Not wdApp Is Nothing And wdApp.Documents.Count = 0 Then wdApp.Quit\n    Set wdApp = Nothing: Set wdDoc = Nothing: Set xlSheet = Nothing\n    Set fso = Nothing: Set sourceFolder = Nothing: Set fileItem = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.StatusBar = \"\"\n    Dim errorSource As String\n    If Not wdDoc Is Nothing Then errorSource = \"處理文檔 '\" & wdDoc.Name & \"' 時\" Else errorSource = \"初始化時\"\n    MsgBox errorSource & \"發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub", "explanation": "此VBA子程序 `ExtractDataFromWordDocsToExcel` 會遍歷指定資料夾 (`WORD_DOCS_FOLDER_PATH`) 中的所有 .docx (或 .doc) 文件。對於每個文件：1. 它會以唯讀、不可見的方式打開該文件。2. **提取書籤內容**：嘗試讀取名為 \"Introduction\" 的書籤範圍內的文本。如果書籤不存在，則記錄一條消息。3. **提取特定樣式段落**：查找第一個應用了 \"標題 1\" (或 \"Heading 1\") 樣式的段落，並提取其文本。如果找不到，則記錄。4. **提取表格數據**：如果文檔包含表格，它會嘗試提取第一個表格中第一行第一列和第一行第二列儲存格的文本，並移除儲存格結束符號。5. 將提取到的文件名、書籤文本、標題文本以及兩個表格儲存格的數據寫入到名為 \"WordDataExtract\" 的Excel工作表的一新行中。6. 關閉Word文檔而不保存更改。處理完資料夾中的所有符合條件的文件後，會顯示一條消息總結處理的文件數量。**重要提示**：`WORD_DOCS_FOLDER_PATH` 需要修改為實際路徑。書籤名稱 (\"Introduction\") 和樣式名稱 (\"標題 1\"/\"Heading 1\") 需要與您的Word文檔中的實際名稱匹配。提取表格數據的邏輯也非常基礎，實際應用中可能需要更精確的表格定位和儲存格遍歷邏輯。"}
                ],
                "keywords": ["vba extract data from word to excel", "word to excel automation", "read word document vba excel", "parse word table to excel", "get bookmark text vba word", "從Word提取數據到Excel", "Word轉Excel自動化", "讀取Word表格VBA"]
            },
            {
                "name": "從Excel讀取數據填充到Word文檔內的特定表格欄位", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: An Excel sheet contains structured data where each row represents a record (e.g., product details, employee information). A pre-designed Word document serves as a template, containing one or more tables with a fixed structure. For each record in Excel, VBA opens the Word template (or a copy), locates a specific table within the Word document, and populates specific cells within that table with data from the corresponding Excel row.",
                "description": "此案例演示了如何從Excel讀取數據並將其精確填充到Word文檔中預設表格的特定儲存格。腳本會：1. **準備Excel數據源**：一個Excel工作表包含需要填充到Word表格的數據，每行代表一組要填充的數據，每列對應Word表格中的一個或多個欄位。2. **準備Word模板**：一個Word文檔 (.docx 或 .dotx 範本文件) 包含一個或多個結構固定的表格。需要預先知道目標表格在文檔中的位置（例如，第幾個表格，或帶有特定標識的表格）以及數據應填入哪些儲存格 (行號和列號)。3. **VBA執行流程**：a. 讀取Excel工作表中的數據，逐行處理。b. 對於Excel中的每一行數據：  i. (可選) 創建Word模板的一個副本來進行填充，或者直接打開一個可修改的Word文檔。  ii. 在Word文檔中定位目標表格。這可以通過表格索引 (`wdDoc.Tables(index)`)，或者更可靠地，如果表格有唯一的標題行或前後有特定標識文本，則可以遍歷表格來查找。  iii. 一旦找到目標表格，根據Excel列與Word表格儲存格的預定義映射關係，將Excel當前行的數據逐個寫入到表格的指定儲存格 (`targetTable.Cell(row, column).Range.Text = excelValue`)。  iv. (可選) 處理完一行Excel數據後，Word文檔可以被保存（例如，以Excel記錄中的唯一ID命名）並關閉，或者保持開啟以填充更多記錄（如果Word表格有多行需要填充）。4. 提供處理完成的通知。這個方法適用於批量生成包含表格數據的個性化Word文檔，例如產品規格表、員工信息卡、訂單確認函中的明細表等。",
                "parameters": [
                    {"name": "Excel Data Source Sheet", "description": "包含源數據的Excel工作表。"},
                    {"name": "Word Template Document Path", "description": "包含目標表格的Word文檔範本的路徑。"},
                    {"name": "Table Identification in Word", "description": "如何在Word文檔中定位目標表格的邏輯 (例如，表格索引)。"},
                    {"name": "Excel Column to Word Table Cell Mapping", "description": "定義Excel中的哪些列的數據應填入Word表格中的哪些儲存格 (行號, 列號)。"},
                    {"name": "Output Word Document(s) Path (Optional)", "description": "如果為每條Excel記錄生成單獨的Word文檔，則指定保存路徑。"}
                ],
                "examples": [
                    {"code": "Sub PopulateWordTableFromExcelData()\n    Dim xlSheet As Worksheet\n    Dim wdApp As Object ' Word.Application\n    Dim wdDoc As Object ' Word.Document\n    Dim targetTable As Object ' Word.Table\n    Dim lastRowExcel As Long, excelRow As Long\n    Dim wordTableRow As Long\n    Dim fso As Object ' Scripting.FileSystemObject\n\n    ' --- Configuration ---\n    Set xlSheet = ThisWorkbook.Sheets(\"ProductDetails\") ' Excel數據源工作表\n    ' Assume Excel Sheet Columns:\n    ' A: ProductID (used for Word doc name if saving individually)\n    ' B: ProductName\n    ' C: Specification\n    ' D: UnitPrice\n    ' E: StockQuantity\n    Const WORD_TEMPLATE_PATH As String = \"C:\\Templates\\ProductSheetTemplate.docx\" ' **Word模板路徑**\n    Const TARGET_TABLE_INDEX_IN_WORD As Long = 1 ' 假設目標是Word文檔中的第一個表格\n    Const WORD_TABLE_START_ROW As Long = 2    ' Word表格中開始填充數據的行號 (跳過表頭)\n    Const OUTPUT_WORD_FOLDER As String = \"C:\\GeneratedProductSheets\\\" ' **輸出Word文件夾**\n\n    On Error GoTo ErrorHandler\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    If Not fso.FileExists(WORD_TEMPLATE_PATH) Then\n        MsgBox \"Word模板文件未找到: \" & WORD_TEMPLATE_PATH, vbCritical\n        Exit Sub\n    End If\n    If Not fso.FolderExists(OUTPUT_WORD_FOLDER) Then fso.CreateFolder OUTPUT_WORD_FOLDER\n\n    On Error Resume Next ' Handle if Word not running\n    Set wdApp = GetObject(, \"Word.Application\")\n    If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    If wdApp Is Nothing Then MsgBox \"無法啟動Word。\", vbCritical: Exit Sub\n    On Error GoTo ErrorHandler\n    ' wdApp.Visible = True ' Optional for debugging\n\n    Application.ScreenUpdating = False ' Excel screen updating\n\n    lastRowExcel = xlSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n    If lastRowExcel < 2 Then MsgBox \"Excel數據源為空或只有表頭。\", vbInformation: GoTo CleanUp\n\n    ' --- Loop through each row in Excel data sheet ---\n    For excelRow = 2 To lastRowExcel\n        Dim productID As String, productName As String, spec As String, price As Currency, stock As Long\n        productID = Trim(CStr(xlSheet.Cells(excelRow, \"A\").Value))\n        productName = Trim(CStr(xlSheet.Cells(excelRow, \"B\").Value))\n        spec = Trim(CStr(xlSheet.Cells(excelRow, \"C\").Value))\n        price = CDbl(xlSheet.Cells(excelRow, \"D\").Value)\n        stock = CLng(xlSheet.Cells(excelRow, \"E\").Value)\n\n        If productID = \"\" Then\n            Debug.Print \"Skipping Excel row \" & excelRow & \": ProductID is empty.\"\n            GoTo NextExcelRecord\n        End If\n\n        ' --- Open Word Template (or create a copy to work with) ---\n        Set wdDoc = wdApp.Documents.Add(Template:=WORD_TEMPLATE_PATH) ' Creates a new doc based on template\n        ' OR for modifying a single document repeatedly (less common for this specific scenario):\n        ' If excelRow = 2 Then ' Open template for the first record\n        '   Set wdDoc = wdApp.Documents.Open(WORD_TEMPLATE_PATH)\n        ' Else ' For subsequent records, ensure the document is active or re-open if needed\n        '   ' (Logic to ensure wdDoc is the correct, open document)\n        ' End If\n\n        Debug.Print \"正在處理ProductID: \" & productID\n\n        ' --- Locate the target table in Word ---\n        If wdDoc.Tables.Count >= TARGET_TABLE_INDEX_IN_WORD Then\n            Set targetTable = wdDoc.Tables(TARGET_TABLE_INDEX_IN_WORD)\n        Else\n            Debug.Print \"  在Word文檔中未找到目標表格 (索引 \" & TARGET_TABLE_INDEX_IN_WORD & \") for ProductID: \" & productID\n            wdDoc.Close SaveChanges:=False\n            Set wdDoc = Nothing\n            GoTo NextExcelRecord\n        End If\n\n        ' --- Populate Word table cells ---\n        ' This example assumes one Excel row populates one row in the Word table.\n        ' If Word table needs more rows than available, add them: targetTable.Rows.Add\n        wordTableRow = WORD_TABLE_START_ROW ' This might need to increment if appending to an existing table\n        \n        ' Check if the target row exists, if not, this logic needs adjustment (e.g. add rows)\n        If wordTableRow > targetTable.Rows.Count Then\n            Debug.Print \"  Word表格行號 \" & wordTableRow & \" 超出範圍 for ProductID: \" & productID\n            ' Optionally add rows: targetTable.Rows.Add\n            wdDoc.Close SaveChanges:=False\n            Set wdDoc = Nothing\n            GoTo NextExcelRecord\n        End If\n\n        ' Mapping Excel columns to Word table columns (Example)\n        ' Word Table Col 1: ProductName, Col 2: Specification, Col 3: UnitPrice, Col 4: Stock\n        On Error Resume Next ' Handle cell write errors\n        targetTable.Cell(wordTableRow, 1).Range.Text = productName\n        targetTable.Cell(wordTableRow, 2).Range.Text = spec\n        targetTable.Cell(wordTableRow, 3).Range.Text = Format(price, \"#,##0.00\")\n        targetTable.Cell(wordTableRow, 4).Range.Text = Format(stock, \"#,##0\")\n        If Err.Number <> 0 Then\n            Debug.Print \"  寫入Word表格儲存格時發生錯誤 for ProductID: \" & productID & \" - \" & Err.Description\n            Err.Clear\n        End If\n        On Error GoTo ErrorHandler\n\n        ' --- Save the populated Word document (e.g., one doc per Excel row) ---\n        Dim outputFileName As String\n        outputFileName = OUTPUT_WORD_FOLDER & \"ProductSheet_\" & CreateValidFileName(productID) & \".docx\"\n        wdDoc.SaveAs2 outputFileName\n        wdDoc.Close SaveChanges:=False ' Close without saving template changes\n        Set wdDoc = Nothing\n        Debug.Print \"  已生成Word文檔: \" & outputFileName\n\nNextExcelRecord:\n        DoEvents ' Yield to other processes\n    Next excelRow\n\n    MsgBox \"已從Excel數據填充Word表格並生成 \" & (lastRowExcel - 1) & \" 個文檔。\", vbInformation\n\nCleanUp:\n    Application.ScreenUpdating = True\n    If Not wdDoc Is Nothing Then wdDoc.Close SaveChanges:=False\n    ' If Not wdApp Is Nothing And wdApp.Documents.Count = 0 Then wdApp.Quit ' Consider app lifecycle\n    Set xlSheet = Nothing: Set wdApp = Nothing: Set wdDoc = Nothing: Set targetTable = Nothing: Set fso = Nothing\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"處理過程中發生錯誤: \" & vbCrLf & _\n           \"Excel 行號: \" & excelRow & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub\n\n' (Reuse CreateValidFileName function from previous examples or define here)\nPrivate Function CreateValidFileName(ByVal name As String) As String\n    Dim invalidChars As String, i As Integer, char As String\n    invalidChars = \"\\/:*?\"\"<>|\"\n    CreateValidFileName = name\n    For i = 1 To Len(invalidChars)\n        char = Mid(invalidChars, i, 1)\n        CreateValidFileName = Replace(CreateValidFileName, char, \"_\")\n    Next i\n    CreateValidFileName = Replace(CreateValidFileName, \".\", \"_\") \n    If Len(CreateValidFileName) > 100 Then CreateValidFileName = Left(CreateValidFileName, 100)\n    CreateValidFileName = Trim(CreateValidFileName)\n    If CreateValidFileName = \"\" Then CreateValidFileName = \"DefaultFileName\"\n    CreateValidFileName = Replace(CreateValidFileName, \"__\", \"_\") \nEnd Function", "explanation": "此VBA子程序 `PopulateWordTableFromExcelData` 從名為 \"ProductDetails\" 的Excel工作表讀取產品信息。對於Excel中的每一行數據：1. 它會基於指定的Word模板 (`WORD_TEMPLATE_PATH`) 創建一個新的Word文檔。2. 在新創建的Word文檔中，它會定位第一個表格 (`TARGET_TABLE_INDEX_IN_WORD = 1`)。3. 然後，它將Excel當前行的產品名稱、規格、單價和庫存數量等數據填充到該Word表格的第二行 (`WORD_TABLE_START_ROW = 2`) 的相應列中。4. 填充完畢後，該Word文檔會以產品ID命名並保存到指定的輸出文件夾 (`OUTPUT_WORD_FOLDER`)，然後關閉。這個過程會為Excel中的每一行數據重複執行，從而批量生成多個包含表格數據的Word文檔。**重要提示：** 您需要將 `WORD_TEMPLATE_PATH` 和 `OUTPUT_WORD_FOLDER` 修改為實際路徑。Word模板中的目標表格索引以及開始填充數據的行號也需要根據您的模板進行配置。`CreateValidFileName` 函數用於確保從ProductID生成的檔名是有效的。此範例假設Word表格中已存在足夠的行來接收數據；如果需要動態添加行到Word表格，則需要相應的 `targetTable.Rows.Add` 邏輯。"}
                ],
                "keywords": ["vba excel to word table", "populate word table from excel", "automate word document generation excel data", "mail merge table word vba", "Excel數據填充Word表格", "VBA批量生成Word表格"]
            },
            {
                "name": "根據Excel列表批量創建指定名稱和路徑的文件夾結構", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: An Excel sheet contains a list of items (e.g., project names, client codes, employee IDs) in one column, and optionally, subfolder names or desired root paths in other columns. VBA reads this list and, for each item, creates a corresponding folder (and potentially a nested subfolder structure) in a specified base directory. The new folders are named according to the Excel data.",
                "description": "此案例演示了如何使用VBA根據Excel列表中的數據批量創建文件夾。腳本會：1. **準備Excel列表**：一個Excel工作表包含用於創建文件夾的信息。例如：a. A列：主文件夾名稱 (例如，項目名稱或客戶ID)。b. (可選) B列：子文件夾名稱 (例如，“文檔”，“圖片”，“報告”；可以有多個子文件夾名稱，用分號分隔)。c. (可選) C列：指定該文件夾的根路徑 (如果每行可以有不同的基礎路徑)。如果為空，則使用一個預設的基礎路徑。2. **VBA執行流程**：a. 讀取Excel工作表中的數據，逐行處理。b. 對於Excel中的每一行：  i. 獲取主文件夾名稱。  ii. 確定基礎路徑（來自Excel列或使用預設值）。  iii. 組合完整的路徑：`BasePath & MainFolderName`。  iv. 使用 `FileSystemObject.FolderExists` 檢查該文件夾是否已存在。  v. 如果文件夾不存在，則使用 `FileSystemObject.CreateFolder` 創建它。  vi. (可選) 如果Excel中指定了子文件夾名稱，則在剛創建的主文件夾內，逐個創建這些子文件夾。需要處理多個子文件夾（例如，以分號分隔的列表）或巢狀子文件夾（例如，“Docs/Internal”）的情況。vii. (可選) 在Excel的狀態列中記錄每個文件夾的創建狀態（成功、已存在、失敗）。3. 提供處理完成的通知。這個自動化對於初始化項目文件結構、批量創建客戶檔案夾等任務非常有用。",
                "parameters": [
                    {"name": "Excel List Sheet", "description": "包含文件夾名稱和路徑信息的Excel工作表。"},
                    {"name": "Base Directory Path", "description": "創建新文件夾的預設根目錄。"},
                    {"name": "Folder Naming Convention", "description": "如何從Excel數據生成文件夾名稱的規則。"},
                    {"name": "Subfolder Structure (Optional)", "description": "如果需要，定義如何在主文件夾下創建子文件夾的邏輯。"}
                ],
                "examples": [
                    {"code": "Sub BatchCreateFoldersFromExcelList()\n    Dim xlSheet As Worksheet\n    Dim fso As Object ' Scripting.FileSystemObject\n    Dim lastRow As Long, i As Long\n    Dim baseFolderPath As String\n    Dim mainFolderName As String, subfolderNamesRaw As String, subfolderArray As Variant\n    Dim fullPathMain As String, fullPathSub As String\n    Dim statusCol As Long\n    Dim foldersCreated As Long: foldersCreated = 0\n    Dim foldersSkipped As Long: foldersSkipped = 0\n    Dim errorsEncountered As Long: errorsEncountered = 0\n\n    ' --- Configuration ---\n    Set xlSheet = ThisWorkbook.Sheets(\"FolderCreationList\")\n    ' Assume Excel Sheet Columns:\n    ' A: MainFolderName (Required)\n    ' B: SubfolderNames (Optional, comma or semicolon separated, e.g., \"Docs,Images,Reports\" or \"Source/Phase1,Source/Phase2\")\n    ' C: BasePath (Optional, if not provided, uses DEFAULT_BASE_PATH)\n    ' D: Status (will be updated by macro)\n    Const DEFAULT_BASE_PATH As String = \"C:\\Projects\\\" ' **替換為您的預設基礎路徑**\n    statusCol = 4 ' Column D for status\n\n    On Error GoTo ErrorHandler\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n\n    ' Ensure default base path exists, or create it\n    If Not fso.FolderExists(DEFAULT_BASE_PATH) Then\n        On Error Resume Next ' In case of permission issues\n        fso.CreateFolder DEFAULT_BASE_PATH\n        If Err.Number <> 0 Then\n            MsgBox \"無法創建預設基礎路徑: \" & DEFAULT_BASE_PATH & vbCrLf & Err.Description, vbCritical\n            Exit Sub\n        End If\n        On Error GoTo ErrorHandler\n    End If\n\n    lastRow = xlSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n    If lastRow < 2 Then MsgBox \"Excel列表為空或只有表頭。\", vbInformation: GoTo CleanUp\n\n    Application.ScreenUpdating = False\n    Application.StatusBar = \"正在批量創建文件夾...\"\n\n    ' Clear previous status\n    xlSheet.Range(xlSheet.Cells(2, statusCol), xlSheet.Cells(lastRow, statusCol)).ClearContents\n\n    ' --- Loop through each row in Excel list ---\n    For i = 2 To lastRow\n        mainFolderName = Trim(CStr(xlSheet.Cells(i, \"A\").Value))\n        mainFolderName = CreateValidFolderName(mainFolderName) ' Clean the folder name\n        subfolderNamesRaw = Trim(CStr(xlSheet.Cells(i, \"B\").Value))\n        baseFolderPath = Trim(CStr(xlSheet.Cells(i, \"C\").Value))\n\n        If mainFolderName = \"\" Then\n            xlSheet.Cells(i, statusCol).Value = \"錯誤：主文件夾名稱為空。\"\n            errorsEncountered = errorsEncountered + 1\n            GoTo NextFolderEntry\n        End If\n\n        If baseFolderPath = \"\" Then\n            baseFolderPath = DEFAULT_BASE_PATH\n        Else ' Ensure custom base path ends with a slash and exists\n            If Right(baseFolderPath, 1) <> \"\\\" Then baseFolderPath = baseFolderPath & \"\\\"\n            If Not fso.FolderExists(baseFolderPath) Then\n                On Error Resume Next\n                fso.CreateFolder baseFolderPath\n                If Err.Number <> 0 Then\n                    xlSheet.Cells(i, statusCol).Value = \"錯誤：無法創建基礎路徑 - \" & baseFolderPath\n                    errorsEncountered = errorsEncountered + 1\n                    Err.Clear\n                    GoTo NextFolderEntry\n                End If\n                On Error GoTo ErrorHandler\n            End If\n        End If\n\n        fullPathMain = baseFolderPath & mainFolderName\n\n        ' Create Main Folder\n        If Not fso.FolderExists(fullPathMain) Then\n            On Error Resume Next\n            fso.CreateFolder fullPathMain\n            If Err.Number <> 0 Then\n                xlSheet.Cells(i, statusCol).Value = \"錯誤：創建主文件夾失敗 - \" & Err.Description\n                errorsEncountered = errorsEncountered + 1\n                Err.Clear\n                GoTo NextFolderEntry ' Skip subfolders if main folder creation failed\n            Else\n                xlSheet.Cells(i, statusCol).Value = \"主文件夾已創建。\"\n                foldersCreated = foldersCreated + 1\n            End If\n            On Error GoTo ErrorHandler\n        Else\n            xlSheet.Cells(i, statusCol).Value = \"主文件夾已存在。\"\n            foldersSkipped = foldersSkipped + 1\n        End If\n\n        ' Create Subfolders (if specified)\n        If subfolderNamesRaw <> \"\" Then\n            Dim currentStatus As String: currentStatus = xlSheet.Cells(i, statusCol).Value\n            Dim subFolder As Variant\n            ' Allow comma or semicolon as delimiter for subfolders\n            subfolderNamesRaw = Replace(subfolderNamesRaw, \";\", \",\")\n            subfolderArray = Split(subfolderNamesRaw, \",\")\n            \n            For Each subFolder In subfolderArray\n                Dim cleanSubFolder As String: cleanSubFolder = CreateValidFolderName(Trim(CStr(subFolder)))\n                If cleanSubFolder <> \"\" Then\n                    ' Handle nested subfolders like \"Docs/Internal\" or \"Images\\HighRes\"\n                    Dim nestedPath As String: nestedPath = fullPathMain\n                    Dim pathPart As Variant\n                    Dim parts As Variant\n                    parts = Split(Replace(cleanSubFolder, \"/\", \"\\\"), \"\\\")\n                    Dim k As Long\n                    For k = LBound(parts) To UBound(parts)\n                        nestedPath = fso.BuildPath(nestedPath, parts(k))\n                        If Not fso.FolderExists(nestedPath) Then\n                            On Error Resume Next\n                            fso.CreateFolder nestedPath\n                            If Err.Number <> 0 Then\n                                currentStatus = currentStatus & \" 子文件夾 '\" & parts(k) & \"' 創建失敗;\"\n                                errorsEncountered = errorsEncountered + 1\n                                Err.Clear\n                                Exit For ' Stop creating further nested parts for this subfolder entry\n                            Else\n                                ' currentStatus = currentStatus & \" 子文件夾 '\" & parts(k) & \"' 已創建;\" ' Can be too verbose\n                            End If\n                            On Error GoTo ErrorHandler\n                        End If\n                    Next k\n                End If\n            Next subFolder\n            If InStr(currentStatus, \"失敗\") > 0 Then\n                 xlSheet.Cells(i, statusCol).Value = Trim(currentStatus)\n            ElseIf InStr(xlSheet.Cells(i, statusCol).Value, \"已創建\") > 0 Then\n                 xlSheet.Cells(i, statusCol).Value = \"主文件夾和 (部分) 子文件夾已創建。\"\n            Else ' Main folder existed, check if subfolders were meant to be created\n                 xlSheet.Cells(i, statusCol).Value = \"主文件夾已存在，(部分) 子文件夾已檢查/創建。\"\n            End If\n        End If\nNextFolderEntry:\n        If i Mod 10 = 0 Then DoEvents\n    Next i\n\n    xlSheet.Columns(statusCol).AutoFit\n    Application.StatusBar = \"\"\n    MsgBox \"文件夾創建過程完成！\" & vbCrLf & _\n           foldersCreated & \" 個主文件夾已創建。\" & vbCrLf & _\n           foldersSkipped & \" 個主文件夾已跳過 (已存在)。\" & vbCrLf & _\n           errorsEncountered & \" 次錯誤發生 (詳見狀態列)。\", vbInformation\n\nCleanUp:\n    Application.StatusBar = \"\"\n    Set xlSheet = Nothing: Set fso = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.StatusBar = \"\"\n    xlSheet.Cells(i, statusCol).Value = \"嚴重錯誤: \" & Err.Description\n    errorsEncountered = errorsEncountered + 1\n    MsgBox \"在處理Excel行 \" & i & \" (主文件夾名: '\" & mainFolderName & \"') 時發生嚴重錯誤: \" & vbCrLf & _\n           Err.Description, vbCritical\n    Resume NextFolderEntry ' Attempt to continue with the next Excel row\nEnd Sub\n\n' (Reuse CreateValidFolderName function from previous examples or define here, ensuring it handles empty strings)\nPrivate Function CreateValidFolderName(ByVal name As String) As String\n    Dim invalidChars As String, i As Integer, char As String\n    If Trim(name) = \"\" Then CreateValidFolderName = \"\": Exit Function ' Handle empty input\n    invalidChars = \"\\/:*?\"\"<>|\" & vbCrLf & vbTab & Chr(0) ' Add more if needed\n    CreateValidFolderName = name\n    For i = 1 To Len(invalidChars)\n        char = Mid(invalidChars, i, 1)\n        CreateValidFolderName = Replace(CreateValidFolderName, char, \"_\") ' Replace invalid chars with underscore\n    Next i\n    CreateValidFolderName = Trim(CreateValidFolderName)\n    ' Ensure name is not just dots or ends with a dot (problematic on Windows)\n    If CreateValidFolderName = \".\" Or CreateValidFolderName = \"..\" Then CreateValidFolderName = \"_folder\"\n    If Right(CreateValidFolderName, 1) = \".\" Then CreateValidFolderName = Left(CreateValidFolderName, Len(CreateValidFolderName) - 1) & \"_\"\n    If Len(CreateValidFolderName) > 200 Then CreateValidFolderName = Left(CreateValidFolderName, 200) ' Max length approx\n    If CreateValidFolderName = \"\" Then CreateValidFolderName = \"DefaultFolder\" ' If all chars were invalid\nEnd Function", "explanation": "此VBA子程序 `BatchCreateFoldersFromExcelList` 從名為 \"FolderCreationList\" 的Excel工作表讀取信息以批量創建文件夾。**Excel表格結構**：A列包含主文件夾名稱。B列（可選）包含要在此主文件夾下創建的子文件夾名稱，多個子文件夾可以用逗號或分號分隔，並且支持用正斜杠 `/` 或反斜杠 `\\` 表示巢狀結構 (例如, \"Docs/Reports, Images\\HighRes\")。C列（可選）可以為該行指定一個特定的基礎路徑；如果為空，則使用腳本中定義的 `DEFAULT_BASE_PATH`。D列用於記錄創建狀態。**處理邏輯**：1. 腳本遍歷Excel列表中的每一行。2. 它會清理主文件夾名稱和子文件夾名稱中的非法字符（使用 `CreateValidFolderName` 輔助函數）。3. 確定基礎路徑，並檢查/創建它。4. 創建主文件夾 (如果尚不存在)。5. 如果指定了子文件夾，則解析子文件夾字符串，並在主文件夾內逐個創建它們，包括處理巢狀路徑。6. 將操作結果（例如，“已創建”，“已存在”，“錯誤”）記錄回Excel的狀態列。7. 最後，顯示一個包含已創建/跳過文件夾數量和錯誤計數的摘要消息。**重要提示：** `DEFAULT_BASE_PATH` 需要根據您的環境進行修改。`CreateValidFolderName` 函數被增強以處理空輸入和一些Windows文件名限制。錯誤處理允許腳本在單個文件夾創建失敗時繼續處理列表中的其餘條目。"}
                ],
                "keywords": ["vba batch create folders from excel", "excel to folder structure automation", "create directories from excel list", "filesystemobject createfolder vba", "批量創建文件夾Excel", "VBA根據列表建目錄"]
            },
            {
                "name": "從Word文檔中提取帶有特定標籤的數據點並在Excel中生成摘要表", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Multiple Word documents contain semi-structured information where specific data points are preceded by known labels (e.g., 'Client Name:', 'Project ID:', 'Total Amount:'). VBA scans these documents, extracts the values associated with these labels, and creates a summary table in Excel where each row represents a document and each column represents an extracted data point.",
                "description": "此案例專注於從一組Word文檔中提取由特定文本標籤標識的數據點，並將其彙整到Excel中。腳本會：1. 指定一個包含多個Word文檔的資料夾。2. 定義一個需要在每個Word文檔中查找的數據標籤列表 (例如，`Array(\"Client Name:\", \"Project ID:\", \"Date:\", \"Total Amount:\")`)。3. 對於資料夾中的每個Word文檔： a. 以唯讀方式打開文檔。 b. 遍歷文檔的每個段落或整個文檔內容 (`Document.Content.Text`)。 c. 對於預定義的每個數據標籤，在文檔內容中搜索該標籤。 d. 如果找到標籤，則提取緊隨其後的數據值。提取邏輯可能需要處理標籤和值之間可能存在的空格、換行符，以及值的結束位置（例如，直到下一個換行符、特定分隔符或固定長度）。 e. 將從當前文檔提取到的所有數據點存儲起來（例如，使用一個Dictionary對象，鍵為標籤，值為提取到的數據）。 f. 關閉Word文檔。4. 在Excel工作表中，為每個處理過的Word文檔創建一行。第一列可以是文件名，後續列對應於每個數據標籤，填充從該文檔提取到的相應值。5. (可選) 對提取的數值數據（如“Total Amount”）在Excel中進行格式化或執行進一步的計算（例如，計算所有文檔的總金額）。這種方法適用於從格式相對一致但數據點位置可能不完全固定的報告、表單或信函中提取信息。",
                "parameters": [
                    {"name": "Source Word Documents Folder", "description": "包含Word文檔的資料夾路徑。"},
                    {"name": "Data Labels to Find", "description": "一個包含要在Word文檔中搜索的文本標籤的陣列或列表。"},
                    {"name": "Value Extraction Logic", "description": "找到標籤後，如何準確提取其對應值的規則（例如，提取到行尾、提取特定數量的字元、或使用正則表達式）。"},
                    {"name": "Excel Output Sheet", "description": "指定用於存放提取數據的Excel工作表。"}
                ],
                "examples": [
                    {"code": "Sub ExtractLabeledDataFromWordToExcel()\n    Dim wdApp As Object ' Word.Application\n    Dim wdDoc As Object ' Word.Document\n    Dim xlSheet As Worksheet\n    Dim fso As Object ' Scripting.FileSystemObject\n    Dim sourceFolder As Object, fileItem As Object\n    Dim nextRowExcel As Long\n    Dim dataLabels As Variant, extractedValues As Object ' Scripting.Dictionary\n    Dim i As Long, label As Variant\n    Dim docContent As String, searchPos As Long, valueStartPos As Long, valueEndPos As Long\n    Dim filesProcessed As Long: filesProcessed = 0\n\n    ' --- Configuration ---\n    Const WORD_DOCS_FOLDER As String = \"C:\\TaggedWordDocs\\\" ' **替換為實際文件夾路徑**\n    Set xlSheet = ThisWorkbook.Sheets(\"LabeledDataSummary\")\n    ' Define the labels to search for in Word documents\n    dataLabels = Array(\"Client Name:\", \"Project ID:\", \"Report Date:\", \"Total Value:\", \"Contact Email:\")\n    \n    xlSheet.Cells.ClearContents\n    ' Create headers in Excel based on FileName and dataLabels\n    xlSheet.Cells(1, 1).Value = \"FileName\"\n    For i = LBound(dataLabels) To UBound(dataLabels)\n        xlSheet.Cells(1, i + 2).Value = Replace(dataLabels(i), \":\", \"\") ' Header without colon\n    Next i\n    xlSheet.Rows(1).Font.Bold = True\n    nextRowExcel = 2\n\n    On Error GoTo ErrorHandler\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    If Not fso.FolderExists(WORD_DOCS_FOLDER) Then\n        MsgBox \"指定的Word文檔資料夾未找到: \" & WORD_DOCS_FOLDER, vbCritical\n        Exit Sub\n    End If\n\n    On Error Resume Next\n    Set wdApp = GetObject(, \"Word.Application\")\n    If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    If wdApp Is Nothing Then MsgBox \"無法啟動Word。\", vbCritical: Exit Sub\n    On Error GoTo ErrorHandler\n    ' wdApp.Visible = False ' Keep Word hidden\n\n    Application.StatusBar = \"正在從Word文檔中提取標籤數據...\"\n\n    Set sourceFolder = fso.GetFolder(WORD_DOCS_FOLDER)\n    For Each fileItem In sourceFolder.Files\n        If (LCase(fso.GetExtensionName(fileItem.Name)) = \"docx\" Or LCase(fso.GetExtensionName(fileItem.Name)) = \"doc\") And _\n           Left(fileItem.Name, 2) <> \"~$\" Then\n            \n            Debug.Print \"正在處理: \" & fileItem.Path\n            Set wdDoc = wdApp.Documents.Open(FileName:=fileItem.Path, ReadOnly:=True, Visible:=False)\n            docContent = wdDoc.Content.Text ' Get all document text\n            Set extractedValues = CreateObject(\"Scripting.Dictionary\")\n            extractedValues.CompareMode = vbTextCompare ' Case-insensitive for label storage\n\n            ' --- Extract data for each label ---\n            For Each label In dataLabels\n                Dim foundValue As String: foundValue = \"[未找到]\"\n                searchPos = InStr(1, docContent, CStr(label), vbTextCompare)\n                If searchPos > 0 Then\n                    valueStartPos = searchPos + Len(CStr(label))\n                    ' Find the end of the value (e.g., next newline, or a fixed number of chars, or next known label)\n                    ' This is a simple extraction to the next newline (vbLf in Content.Text)\n                    valueEndPos = InStr(valueStartPos, docContent, vbLf)\n                    If valueEndPos = 0 Then valueEndPos = Len(docContent) + 1 ' If no newline, take to end\n                    \n                    ' A more robust way would be to find the start of the *next* known label or paragraph end\n                    foundValue = Trim(Mid(docContent, valueStartPos, valueEndPos - valueStartPos))\n                    ' Clean up common issues like multiple spaces, or non-breaking spaces if needed\n                    foundValue = Replace(foundValue, vbCr, \"\") ' Remove CR if any from mixed newlines\n                    If Len(foundValue) > 255 Then foundValue = Left(foundValue, 252) & \"...\" ' Truncate long values for Excel cell\n                End If\n                extractedValues(Replace(CStr(label), \":\", \"\")) = foundValue ' Store with cleaned label as key\n            Next label\n\n            ' --- Write to Excel ---\n            xlSheet.Cells(nextRowExcel, 1).Value = fileItem.Name\n            For i = LBound(dataLabels) To UBound(dataLabels)\n                Dim cleanLabelKey As String: cleanLabelKey = Replace(dataLabels(i), \":\", \"\")\n                If extractedValues.Exists(cleanLabelKey) Then\n                    xlSheet.Cells(nextRowExcel, i + 2).Value = extractedValues(cleanLabelKey)\n                Else\n                    xlSheet.Cells(nextRowExcel, i + 2).Value = \"[標籤鍵錯誤]\"\n                End If\n            Next i\n            nextRowExcel = nextRowExcel + 1\n            filesProcessed = filesProcessed + 1\n            \n            wdDoc.Close SaveChanges:=False\n            Set wdDoc = Nothing\n            Set extractedValues = Nothing\n            Debug.Print \"已處理: \" & fileItem.Name\n        End If\n        If filesProcessed Mod 3 = 0 Then DoEvents\n    Next fileItem\n\n    xlSheet.Columns.AutoFit\n    Application.StatusBar = \"\"\n    MsgBox filesProcessed & \" 個Word文檔的標籤數據已提取完成！\", vbInformation\n\nCleanUp:\n    Application.StatusBar = \"\"\n    If Not wdDoc Is Nothing Then wdDoc.Close SaveChanges:=False\n    ' If Not wdApp Is Nothing And wdApp.Documents.Count = 0 Then wdApp.Quit\n    Set wdApp = Nothing: Set wdDoc = Nothing: Set xlSheet = Nothing\n    Set fso = Nothing: Set sourceFolder = Nothing: Set fileItem = Nothing: Set extractedValues = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.StatusBar = \"\"\n    Dim errSource As String\n    If Not fileItem Is Nothing Then errSource = \"處理文件 '\" & fileItem.Name & \"' 時\" Else errSource = \"初始化時\"\n    MsgBox errSource & \"發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub", "explanation": "此VBA子程序 `ExtractLabeledDataFromWordToExcel` 會遍歷指定資料夾 (`WORD_DOCS_FOLDER`) 中的Word文檔。它使用一個預定義的文本標籤陣列 (`dataLabels`)，例如 \"Client Name:\"、\"Project ID:\" 等。對於每個文檔：1. 獲取其全部文本內容 (`Document.Content.Text`)。2. 對於 `dataLabels` 中的每個標籤，在文檔內容中搜索該標籤。3. 如果找到標籤，則提取從標籤結束位置到該行末尾（或下一個換行符 `vbLf`）之間的文本作為對應的值。提取的值會進行簡單的清理（去除前後空格和回車符）。4. 將文件名和所有提取到的標籤值寫入到名為 \"LabeledDataSummary\" 的Excel工作表的一新行中，每個標籤對應一列。5. 處理完畢後關閉Word文檔。**重要提示：** `WORD_DOCS_FOLDER` 和 `dataLabels` 數組需要根據您的實際情況進行配置。提取值的邏輯（從標籤後到行尾）是一個簡化的示例；在實際應用中，可能需要更複雜的邏輯來處理多行值、不同格式或使用正則表達式來更精確地定位和提取數據。"}
                ],
                "keywords": ["vba extract labeled data word", "word to excel text parsing", "read specific text from word vba", "automate data extraction word", "Word文檔標籤數據提取", "VBA解析Word文本到Excel"]
            },
            {
                "name": "從Word文檔中的特定表格提取指定列數據到Excel", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Multiple Word documents contain one or more tables. For each document, VBA needs to locate a specific table (e.g., by its index, a caption keyword nearby, or based on the number of columns/rows). Once the table is identified, VBA extracts data only from specified columns within that table (e.g., columns 2, 4, and 5) and writes this data into corresponding columns in an Excel worksheet, with each row in Excel representing a row from the Word table.",
                "description": "此案例演示了如何從Word文檔中特定表格的指定列提取數據並彙整到Excel中。腳本會：1. 指定一個包含多個Word文檔的資料夾。2. 定義如何定位目標表格的方法（例如，文檔中的第N個表格，或者緊隨某個特定標題文本之後的表格，或者具有特定列數的表格）。3. 定義要從目標表格中提取哪些列的數據（例如，列索引的列表 `Array(2, 4, 5)` 或列標題的列表）。4. 對於資料夾中的每個Word文檔： a. 以唯讀方式打開文檔。 b. 定位目標表格。 c. 遍歷目標表格的每一行（可選擇跳過表頭行）。 d. 對於表格的每一行，僅提取預先定義的指定列中的儲存格文本。 e. 將從當前Word表格行提取到的數據點寫入到Excel工作表的新行中，每個提取的列對應Excel中的一個新列。第一列可以是Word文件名或表格來源標識。 f. 關閉Word文檔。5. Excel工作表最終會包含從所有Word文檔的目標表格的指定列中提取出來的數據，每行對應一個原始表格行。這個方法適用於從包含標準化表格的報告或記錄中批量提取特定欄位信息。",
                "parameters": [
                    {"name": "Source Word Documents Folder", "description": "包含Word文檔的資料夾路徑。"},
                    {"name": "Table Identification Logic", "description": "如何定位每個文檔中目標表格的規則。"},
                    {"name": "Columns to Extract from Table", "description": "一個包含要提取的列的索引號 (1-based) 或列標題的陣列/列表。"},
                    {"name": "Excel Output Sheet", "description": "指定用於存放提取數據的Excel工作表。"},
                    {"name": "Header Row Handling", "description": "是否跳過Word表格中的表頭行。"}
                ],
                "examples": [
                    {"code": "Sub ExtractSpecificTableColumnsFromWordToExcel()\n    Dim wdApp As Object ' Word.Application\n    Dim wdDoc As Object ' Word.Document\n    Dim xlSheet As Worksheet\n    Dim fso As Object ' Scripting.FileSystemObject\n    Dim sourceFolder As Object, fileItem As Object\n    Dim nextRowExcel As Long\n    Dim targetTable As Object ' Word.Table\n    Dim wordRow As Object ' Word.Row\n    Dim wordCell As Object ' Word.Cell\n    Dim i End If\n\n    On Error Resume Next\n    Set wdApp = GetObject(, \"Word.Application\")\n    If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    If wdApp Is Nothing Then MsgBox \"無法啟動Word。\", vbCritical: Exit Sub\n    On Error GoTo ErrorHandler\n    ' wdApp.Visible = False\n\n    Application.StatusBar = \"正在從Word表格中提取指定列數據...\"\n\n    Set sourceFolder = fso.GetFolder(WORD_DOCS_FOLDER_PATH)\n    For Each fileItem In sourceFolder.Files\n        If (LCase(fso.GetExtensionName(fileItem.Name)) = \"docx\" Or LCase(fso.GetExtensionName(fileItem.Name)) = \"doc\") And _\n           Left(fileItem.Name, 2) <> \"~$\" Then\n            \n            Debug.Print \"正在處理文件: \" & fileItem.Path\n            Set wdDoc = wdApp.Documents.Open(FileName:=fileItem.Path, ReadOnly:=True, Visible:=False)\n            foundTable = False\n\n            ' --- Locate the target table ---\n            If wdDoc.Tables.Count >= TARGET_TABLE_INDEX Then\n                Set targetTable = wdDoc.Tables(TARGET_TABLE_INDEX)\n                foundTable = True\n            Else\n                Debug.Print \"  在文件 '\" & fileItem.Name & \"' 中未找到目標表格 (索引 \" & TARGET_TABLE_INDEX & \")。\"\n            End If\n\n            If foundTable Then\n                ' --- Iterate through table rows, skipping headers ---\n                If targetTable.Rows.Count > SKIP_HEADER_ROWS Then\n                    For r = (1 + SKIP_HEADER_ROWS) To targetTable.Rows.Count\n                        Set wordRow = targetTable.Rows(r)\n                        xlSheet.Cells(nextRowExcel, 1).Value = fileItem.Name ' Source file name\n                        colIndex = 2 ' Start writing extracted data from Excel column B\n                        \n                        ' Extract data from specified columns\n                        For i = LBound(columnsToExtract) To UBound(columnsToExtract)\n                            Dim currentWordCol As Long: currentWordCol = columnsToExtract(i)\n                            If currentWordCol <= wordRow.Cells.Count Then\n                                On Error Resume Next ' Handle merged cells or other issues gracefully\n                                Set wordCell = wordRow.Cells(currentWordCol)\n                                Dim cellText As String: cellText = Trim(wordCell.Range.Text)\n                                ' Remove cell marker (common issue, a Chr(13) & Chr(7) or just Chr(7))\n                                If Len(cellText) > 0 Then\n                                    Do While Right(cellText, 1) = Chr(7) Or Right(cellText, 1) = Chr(13) Or Right(cellText, 1) = \" \"\n                                        cellText = Left(cellText, Len(cellText) - 1)\n                                        If Len(cellText) = 0 Then Exit Do\n                                    Loop\n                                End If\n                                xlSheet.Cells(nextRowExcel, colIndex).Value = cellText\n                                Err.Clear\n                                On Error GoTo ErrorHandler\n                            Else\n                                xlSheet.Cells(nextRowExcel, colIndex).Value = \"[欄位索引超出範圍]\"\n                            End If\n                            colIndex = colIndex + 1\n                        Next i\n                        nextRowExcel = nextRowExcel + 1\n                    Next r\n                Else\n                    Debug.Print \"  表格 '\" & TARGET_TABLE_INDEX & \"' 在文件 '\" & fileItem.Name & \"' 中的行數不足 (含表頭)。\"\n                End If\n            End If ' End if foundTable\n            \n            wdDoc.Close SaveChanges:=False\n            Set wdDoc = Nothing\n            filesProcessed = filesProcessed + 1\n            Debug.Print \"已處理: \" & fileItem.Name\n        End If\n        If filesProcessed Mod 2 = 0 Then DoEvents\n    Next fileItem\n\n    xlSheet.Columns.AutoFit\n    Application.StatusBar = \"\"\n    MsgBox filesProcessed & \" 個Word文檔的表格數據已提取完成！\", vbInformation\n\nCleanUp:\n    Application.StatusBar = \"\"\n    If Not wdDoc Is Nothing Then wdDoc.Close SaveChanges:=False\n    ' If Not wdApp Is Nothing And wdApp.Documents.Count = 0 Then wdApp.Quit\n    Set wdApp = Nothing: Set wdDoc = Nothing: Set xlSheet = Nothing\n    Set fso = Nothing: Set sourceFolder = Nothing: Set fileItem = Nothing\n    Set targetTable = Nothing: Set wordRow = Nothing: Set wordCell = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.StatusBar = \"\"\n    Dim errFile As String\n    If Not fileItem Is Nothing Then errFile = fileItem.Name Else errFile = \"N/A\"\n    MsgBox \"處理文件 '\" & errFile & \"' 時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp ' Or Resume Next if you want to try to continue with other files\nEnd Sub", "explanation": "此VBA子程序 `ExtractSpecificTableColumnsFromWordToExcel` 會遍歷指定資料夾 (`WORD_DOCS_FOLDER_PATH`) 中的Word文檔。對於每個文檔：1. 它會嘗試定位文檔中的第一個表格 (`TARGET_TABLE_INDEX = 1`)。2. 如果找到表格，並且表格行數大於要跳過的表頭行數 (`SKIP_HEADER_ROWS`)，它會遍歷表格的數據行。3. 對於每一數據行，它會從預定義的列索引列表 (`columnsToExtract`，例如第2、4、5列) 中提取儲存格的文本內容。提取時會嘗試移除儲存格末尾常見的特殊標記符號。4. 將文件名和提取到的各列數據寫入到名為 \"WordTableData\" 的Excel工作表的一新行中。5. 處理完畢後關閉Word文檔。**重要提示：** `WORD_DOCS_FOLDER_PATH`、`columnsToExtract`、`TARGET_TABLE_INDEX` 和 `SKIP_HEADER_ROWS` 常量需要根據您的實際需求進行配置。表格定位邏輯 (此處為簡單的按索引查找第一個表格) 可能需要根據文檔結構的複雜性進行調整，例如，可以基於表格前後的特定文本、表格的標題行內容或表格的總列數/行數來定位目標表格。儲存格內容的清理 (移除`Chr(7)`和`Chr(13)`) 是一個常見步驟，但可能需要根據實際數據進行調整。"}
                ],
                "keywords": ["vba extract specific columns from word table", "word table to excel selected columns", "parse word table data vba", "automate data extraction word tables", "Word表格指定列提取", "VBA讀取Word表格到Excel"]
            },
            {
                "name": "自動處理Outlook郵件附件(Word)，提取數據填入Excel", "category": "綜合應用案例與技巧",
                "syntax": "Scenario: Monitor a specific Outlook folder for new emails. If an email arrives with a specific subject line (or keyword) AND contains a Word document attachment with a specific name pattern, VBA automatically opens the attached Word document, extracts data from predefined locations (e.g., bookmarks, specific paragraphs, or tables), and populates this data into a new row in a designated Excel worksheet. The processed email can then be marked as read or moved.",
                "description": "此案例演示了一個完整的自動化工作流程：從Outlook接收特定郵件，處理其Word附件，並將數據記錄到Excel。腳本會：1. **監控Outlook資料夾**：定期掃描指定的Outlook資料夾（例如，“自動報告收件匣”）中的新郵件（例如，未讀郵件）。2. **篩選郵件**：對於每封新郵件，檢查其主旨是否包含特定關鍵詞（例如，“月度報告提交”）以及發件人是否符合要求（可選）。3. **檢查並處理附件**：a. 檢查郵件是否包含附件。b. 如果有附件，遍歷附件列表，查找文件名符合特定模式的Word文檔（例如，“Report_*.docx”）。c. 如果找到目標Word附件，則將其保存到一個臨時本地資料夾（以避免直接從Outlook臨時文件夾打開可能出現的問題）。4. **從Word附件中提取數據**：a. 啟動Word應用程式（如果需要）並以唯讀方式打開臨時保存的Word文檔。b. 使用預定義的邏輯從Word文檔中提取數據，這可能基於：  i. 書籤 (Bookmarks)。  ii. 表格中的特定儲存格位置（例如，第2個表格的第3行第2列）。  iii. 特定樣式或關鍵詞標識的段落內容。  iv. (高級) 正則表達式匹配文檔內容。c. 關閉Word文檔。5. **將數據寫入Excel**：a. 將從Word文檔提取到的各個數據點（例如，報告ID、總銷售額、完成日期等）寫入到指定的Excel工作表（“數據彙總表”）的新行中。b. 可以同時記錄郵件的接收日期、發件人等元數據。6. **後續處理**：a. 將已成功處理的Outlook郵件標記為已讀。b. (可選) 將郵件移動到“已處理報告”Outlook資料夾。c. (可選) 刪除本地臨時保存的Word附件。7. **日誌與通知**：記錄處理結果，並可在發生錯誤或成功處理一批郵件後發送通知。",
                "parameters": [
                    {"name": "Outlook Monitored Folder", "description": "要監控的Outlook資料夾。"},
                    {"name": "Email Subject Filter", "description": "用於識別目標郵件的主旨關鍵詞或模式。"},
                    {"name": "Attachment Name Pattern", "description": "目標Word附件的文件名模式 (例如，使用 `Like` 運算符或正則表達式)。"},
                    {"name": "Temporary Folder for Attachments", "description": "用於臨時保存Word附件的本地資料夾路徑。"},
                    {"name": "Data Extraction Rules for Word", "description": "如何從Word文檔中定位和提取數據的規則。"},
                    {"name": "Excel Output Sheet", "description": "指定用於存放提取數據的Excel工作表。"}
                ],
                "examples": [
                    {"code": "' --- THIS IS A COMPLEX, MULTI-APP SCENARIO. CODE IS A CONCEPTUAL OUTLINE. --- \n' --- Robust error handling, Word content parsing, and Outlook item management are crucial. ---\n\nSub ProcessWordAttachmentsFromOutlookToExcel()\n    Dim olApp As Object, olNS As Object, olTargetFolder As Object, olMail As Object, olAttachment As Object\n    Dim wdApp As Object, wdDoc As Object\n    Dim xlSheet As Object ' Excel.Worksheet\n    Dim fso As Object ' Scripting.FileSystemObject\n    Dim tempFolderPath As String, tempFilePath As String\n    Dim nextRowExcel As Long\n    Dim extractedReportID As String, extractedSales As String, extractedDate As String ' Example data points\n    Dim itemsProcessed As Long: itemsProcessed = 0\n\n    ' --- Configuration ---\n    Const OUTLOOK_FOLDER_TO_SCAN As String = \"Inbox/AutomatedReports\" ' **調整路徑**\n    Const EMAIL_SUBJECT_KEYWORD As String = \"Monthly Sales Report Submission\"\n    Const WORD_ATTACHMENT_PATTERN As String = \"SalesData_*.docx\" ' e.g., SalesData_RegionA_202310.docx\n    Const TEMP_SAVE_PATH As String = \"C:\\Temp\\OutlookAttachments\\\" ' **確保此文件夾存在**\n    Set xlSheet = ThisWorkbook.Sheets(\"WordImportLog\")\n    ' Excel Headers: ReceivedDate, Sender, AttachmentName, ReportID, TotalSales, SubmissionDate\n    xlSheet.Cells.ClearContents ' For fresh run, or append logic needed\n    xlSheet.Range(\"A1:F1\").Value = Array(\"Received Date\", \"Sender\", \"Attachment Name\", \"Report ID\", \"Total Sales\", \"Submission Date\")\n    xlSheet.Rows(1).Font.Bold = True\n    nextRowExcel = 2\n\n    On Error GoTo ErrorHandler\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    If Not fso.FolderExists(TEMP_SAVE_PATH) Then fso.CreateFolder TEMP_SAVE_PATH\n\n    Set olApp = CreateObject(\"Outlook.Application\")\n    Set olNS = olApp.GetNamespace(\"MAPI\")\n    ' Access target Outlook folder (robust path access needed here, simplified for example)\n    Dim arrFolders As Variant, i As Long\n    Dim currentFolder As Object: Set currentFolder = olNS.GetDefaultFolder(6) ' olFolderInbox\n    If InStr(OUTLOOK_FOLDER_TO_SCAN, \"/\") > 0 Then\n        arrFolders = Split(OUTLOOK_FOLDER_TO_SCAN, \"/\")\n        If LCase(arrFolders(0)) = \"inbox\" Or LCase(arrFolders(0)) = \"收件匣\" Then\n            For i = 1 To UBound(arrFolders)\n                Set currentFolder = currentFolder.Folders(arrFolders(i))\n            Next i\n        Else\n            Set currentFolder = olNS.Folders(olApp.Session.CurrentUser.Name)\n             For i = 0 To UBound(arrFolders)\n                Set currentFolder = currentFolder.Folders(arrFolders(i))\n            Next i\n        End If\n    End If\n    Set olTargetFolder = currentFolder\n    If olTargetFolder Is Nothing Then MsgBox \"Outlook folder not found: \" & OUTLOOK_FOLDER_TO_SCAN, vbCritical: GoTo CleanUp\n\n    Application.StatusBar = \"正在檢查Outlook中的報告郵件...\"\n\n    ' --- Process Unread Emails in Target Folder ---\n    Dim mailItems As Object: Set mailItems = olTargetFolder.Items.Restrict(\"[Unread]=true\")\n    If mailItems.Count = 0 Then MsgBox \"在 '\" & olTargetFolder.Name & \"' 中未找到新的未讀報告郵件。\", vbInformation: GoTo CleanUp\n\n    For Each olMail In mailItems\n        If TypeName(olMail) = \"MailItem\" Then\n            If InStr(1, olMail.Subject, EMAIL_SUBJECT_KEYWORD, vbTextCompare) > 0 And olMail.Attachments.Count > 0 Then\n                For Each olAttachment In olMail.Attachments\n                    If LCase(olAttachment.FileName) Like LCase(WORD_ATTACHMENT_PATTERN) And _\n                       (LCase(Right(olAttachment.FileName, 5)) = \".docx\" Or LCase(Right(olAttachment.FileName, 4)) = \".doc\") Then\n                        \n                        tempFilePath = TEMP_SAVE_PATH & olAttachment.FileName\n                        olAttachment.SaveAsFile tempFilePath ' Save to temp location\n                        Debug.Print \"附件已保存到: \" & tempFilePath\n\n                        ' --- Open Word and Extract Data ---\n                        On Error Resume Next ' Word related errors\n                        Set wdApp = GetObject(, \"Word.Application\")\n                        If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n                        If wdApp Is Nothing Then Debug.Print \"無法啟動Word.\": GoTo NextAttachment ' Skip this attachment\n                        On Error GoTo ErrorHandler ' Restore default error handling\n                        ' wdApp.Visible = False\n\n                        Set wdDoc = wdApp.Documents.Open(FileName:=tempFilePath, ReadOnly:=True, Visible:=False)\n                        If wdDoc Is Nothing Then Debug.Print \"無法開啟Word文檔: \" & tempFilePath: GoTo NextAttachment\n\n                        ' --- DATA EXTRACTION LOGIC FROM WORD DOC (Example) ---\n                        ' This part is highly dependent on the Word document's structure.\n                        ' Example 1: Using Bookmarks\n                        If wdDoc.Bookmarks.Exists(\"ReportID\") Then extractedReportID = Trim(wdDoc.Bookmarks(\"ReportID\").Range.Text) Else extractedReportID = \"[ID未找到]\"\n                        If wdDoc.Bookmarks.Exists(\"TotalSalesValue\") Then extractedSales = Trim(wdDoc.Bookmarks(\"TotalSalesValue\").Range.Text) Else extractedSales = \"[金額未找到]\"\n                        If wdDoc.Bookmarks.Exists(\"SubmissionDate\") Then extractedDate = Trim(wdDoc.Bookmarks(\"SubmissionDate\").Range.Text) Else extractedDate = \"[日期未找到]\"\n                        \n                        ' Example 2: From a specific table cell (e.g., first table, row 2, cell 1 for ID)\n                        ' If wdDoc.Tables.Count > 0 Then\n                        '    On Error Resume Next ' If cell doesn't exist\n                        '    extractedReportID = CleanWordTableCell(wdDoc.Tables(1).Cell(2, 1).Range.Text)\n                        '    extractedSales = CleanWordTableCell(wdDoc.Tables(1).Cell(2, 2).Range.Text)\n                        '    extractedDate = CleanWordTableCell(wdDoc.Tables(1).Cell(2, 3).Range.Text)\n                        '    On Error GoTo ErrorHandler\n                        ' End If\n                        ' ------------------------------------------------------------\n\n                        wdDoc.Close SaveChanges:=False\n                        If Not wdApp.Documents.Count > 0 And wdApp.Visible = False Then ' Quit if no other docs and was hidden\n                           ' wdApp.Quit ' Be careful with quitting shared instance\n                        End If\n                        Set wdDoc = Nothing: Set wdApp = Nothing ' Release Word objects per file\n\n                        ' Delete temp file\n                        On Error Resume Next: fso.DeleteFile tempFilePath: On Error GoTo ErrorHandler\n\n                        ' --- Write to Excel ---\n                        xlSheet.Cells(nextRowExcel, \"A\").Value = olMail.ReceivedTime\n                        xlSheet.Cells(nextRowExcel, \"B\").Value = olMail.SenderName & \" (\" & olMail.SenderEmailAddress & \")\"\n                        xlSheet.Cells(nextRowExcel, \"C\").Value = olAttachment.FileName\n                        xlSheet.Cells(nextRowExcel, \"D\").Value = extractedReportID\n                        xlSheet.Cells(nextRowExcel, \"E\").Value = extractedSales ' Convert to number if necessary CDbl(extractedSales)\n                        xlSheet.Cells(nextRowExcel, \"F\").Value = extractedDate  ' Convert to date if necessary CDate(extractedDate)\n                        nextRowExcel = nextRowExcel + 1\n                        itemsProcessed = itemsProcessed + 1\n                        Debug.Print \"數據已從 '\" & olAttachment.FileName & \"' 提取並寫入Excel。\"\n                        \n                        ' Mark email as read and move (optional)\n                        olMail.UnRead = False\n                        ' Dim processedFolder As Object\n                        ' Set processedFolder = olTargetFolder.Folders(\"ProcessedReports\") ' Ensure this subfolder exists\n                        ' If Not processedFolder Is Nothing Then olMail.Move processedFolder Else Debug.Print \"'ProcessedReports' folder not found.\"\n                        \n                        Exit For ' Assuming only one relevant Word attachment per email\n                    End If ' End if attachment name matches\nNextAttachment:\n                Next olAttachment\n            End If ' End if subject matches and has attachments\n        End If ' End if MailItem\n        If itemsProcessed > 0 And itemsProcessed Mod 3 = 0 Then DoEvents\n    Next olMail\n\n    xlSheet.Columns(\"A:F\").AutoFit\n    Application.StatusBar = \"\"\n    MsgBox itemsProcessed & \" 個Word附件已處理並將數據匯入Excel。\", vbInformation\n\nCleanUp:\n    Application.StatusBar = \"\"\n    If Not wdDoc Is Nothing Then wdDoc.Close False\n    If Not wdApp Is Nothing And wdApp.Documents.Count = 0 Then ' wdApp.Quit ' Consider implications\n    Set olMail = Nothing: Set olAttachment = Nothing: Set olTargetFolder = Nothing: Set olNS = Nothing: Set olApp = Nothing\n    Set wdDoc = Nothing: Set wdApp = Nothing: Set xlSheet = Nothing: Set fso = Nothing\n    Exit Sub\n\nErrorHandler:\n    Application.StatusBar = \"\"\n    Dim errContext As String: errContext = \"General error\"\n    If Not olMail Is Nothing Then errContext = \"Error processing email: \" & olMail.Subject\n    If Not wdDoc Is Nothing Then errContext = errContext & \" / Word Doc: \" & wdDoc.Name\n    MsgBox errContext & vbCrLf & \"錯誤 \" & Err.Number & \": \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub\n\n' Helper to clean Word table cell text (remove cell markers)\nFunction CleanWordTableCell(rawText As String) As String\n    Dim cleanStr As String\n    cleanStr = Trim(rawText)\n    If Len(cleanStr) > 0 Then\n        Do While Right(cleanStr, 1) = Chr(7) Or Right(cleanStr, 1) = Chr(13)\n            cleanStr = Left(cleanStr, Len(cleanStr) - 1)\n            If Len(cleanStr) = 0 Then Exit Do\n        Loop\n    End If\n    CleanWordTableCell = cleanStr\nEnd Function", "explanation": "此VBA子程序 `ProcessWordAttachmentsFromOutlookToExcel` 演示了一個複雜的工作流程：1. **監控Outlook**：它會檢查指定Outlook資料夾 (`OUTLOOK_FOLDER_TO_SCAN`) 中的未讀郵件。2. **郵件篩選**：如果郵件主旨包含特定關鍵詞 (`EMAIL_SUBJECT_KEYWORD`) 且包含附件。3. **附件處理**：它會查找文件名符合特定模式 (`WORD_ATTACHMENT_PATTERN`) 的Word文檔附件。找到後，將附件保存到本地臨時文件夾 (`TEMP_SAVE_PATH`)。4. **Word數據提取**：啟動Word應用程式，以唯讀、不可見的方式打開臨時保存的Word文檔。然後，它嘗試從文檔的預定義書籤（例如 \"ReportID\", \"TotalSalesValue\", \"SubmissionDate\"）中提取數據。此處也給出了從表格儲存格提取數據的註釋掉的範例邏輯。5. **寫入Excel**：將提取到的數據（報告ID、銷售額、提交日期）以及郵件的元數據（接收日期、發件人、附件名）寫入到名為 \"WordImportLog\" 的Excel工作表的新行中。6. **清理**：處理完畢後，關閉Word文檔，刪除臨時附件，並可選擇將Outlook郵件標記為已讀或移動。**重要提示：** 所有常量（文件夾路徑、關鍵詞、書籤名稱、Excel工作表名等）都需要根據您的實際環境進行配置。Word文檔中的數據提取邏輯（此處為書籤示例）必須與您的Word文檔結構緊密匹配。錯誤處理對於這種多應用程式交互的腳本至關重要。`CleanWordTableCell` 是一個用於清理從Word表格儲存格中提取的文本的輔助函數。"}
                ],
                "keywords": ["vba outlook word excel integration", "extract data from word attachment to excel", "automate email attachment processing vba", "outlook to excel data pipeline", "Outlook附件Word數據提取到Excel", "自動化郵件附件處理"]
            },
            {
                "name": "Application.InchesToPoints (Word/Excel/PowerPoint)", "category": "綜合應用案例與技巧",
                "syntax": "points = Application.InchesToPoints(Inches As Single)",
                "description": "將度量單位從英吋轉換為點 (1 英吋 = 72 點)。在設定 Word、Excel 或 PowerPoint 物件的大小和位置時很有用。",
                "parameters": [{"name": "Inches", "description": "必需。要轉換的英吋數值。"}],
                "examples": [
                    {"code": "Dim wdApp As Object ' Word.Application\nDim heightInPoints As Single\n' Set wdApp = CreateObject(\"Word.Application\")\n' heightInPoints = wdApp.InchesToPoints(1.5)\n' MsgBox \"1.5 英吋等於 \" & heightInPoints & \" 點。\"\n' ActiveDocument.Paragraphs(1).Format.SpaceBefore = wdApp.InchesToPoints(0.25)", "explanation": "將 1.5 英吋轉換為點，並將文件第一個段落的段前間距設為 0.25 英吋 (轉換為點)。"}
                ],
                "keywords": ["inches to points", "unit conversion", "measurement", "word", "excel", "powerpoint", "單位轉換", "英吋轉點", "通用"]
            },
            {
    "name": "Range.Address",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Address([RowAbsolute], [ColumnAbsolute], [ReferenceStyle], [External], [RelativeTo])",
    "description": "傳回代表儲存格範圍參照的字串。",
    "parameters": [
        {"name": "RowAbsolute", "description": "可選。True 表示傳回絕對列參照。預設為 True。"},
        {"name": "ColumnAbsolute", "description": "可選。True 表示傳回絕對欄參照。預設為 True。"},
        {"name": "ReferenceStyle", "description": "可選。XlReferenceStyle 常數 (xlA1 或 xlR1C1)。預設為 xlA1。"},
        {"name": "External", "description": "可選。True 表示傳回包含工作簿和工作表名稱的外部參照。預設為 False。"},
        {"name": "RelativeTo", "description": "可選。如果 ReferenceStyle 是 xlA1，則此引數是一個 Range 物件，指定傳回相對位址的左上角儲存格。"}
    ],
    "examples": [
        {"code": "MsgBox Range(\"A1\").Address ' 傳回 \"$A$1\"", "explanation": "取得儲存格 A1 的絕對位址。"},
        {"code": "MsgBox Range(\"B2:C3\").Address(RowAbsolute:=False, ColumnAbsolute:=False) ' 傳回 \"B2:C3\"", "explanation": "取得範圍 B2:C3 的相對位址。"},
        {"code": "MsgBox Range(\"D5\").Address(External:=True) ' 傳回類似 \"[Book1]Sheet1!$D$5\"", "explanation": "取得儲存格 D5 的外部參照位址。"}
    ],
    "keywords": ["位址", "儲存格參照", "excel", "cell address", "reference"]
},
{
    "name": "Range.Clear",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Clear",
    "description": "清除整個物件，包括其內容、格式和註解。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1:B5\").Clear", "explanation": "清除範圍 A1:B5 中的所有內容、格式和註解。"},
        {"code": "ActiveSheet.UsedRange.Clear ' 清除已使用範圍的所有內容和格式", "explanation": "清除活動工作表上已使用範圍的所有信息。"}
    ],
    "keywords": ["清除儲存格", "重設儲存格", "excel", "clear all", "reset cell"]
},
{
    "name": "Range.ClearFormats",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ClearFormats",
    "description": "清除物件的格式，但保留內容和註解。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1:C10\").ClearFormats", "explanation": "清除範圍 A1:C10 中儲存格的格式，但保留其值。"},
        {"code": "Selection.ClearFormats ' 清除目前選取範圍的格式", "explanation": "清除使用者目前選取範圍的格式設定。"}
    ],
    "keywords": ["清除格式", "移除格式", "excel", "remove formatting", "reset format"]
},
{
    "name": "Range.Font Property",
    "category": "Excel 核心操作",
    "syntax": "Set fontObject = rangeObject.Font\nfontObject.Name = \"Arial\"\nfontObject.Size = 12\nfontObject.Bold = True\nfontObject.Italic = False\nfontObject.Underline = xlUnderlineStyleSingle\nfontObject.Color = RGB(255, 0, 0)\nfontObject.ColorIndex = 3 ' (Red, depends on palette)",
    "description": "傳回代表指定範圍字型屬性的 Font 物件。您可以變更 Font 物件的屬性來格式化文字。",
    "parameters": [
        {"name": ".Name", "description": "字型名稱 (例如 \"Arial\", \"Calibri\")。"},
        {"name": ".Size", "description": "字型大小 (以點為單位)。"},
        {"name": ".Bold", "description": "True 表示粗體。"},
        {"name": ".Italic", "description": "True 表示斜體。"},
        {"name": ".Underline", "description": "XlUnderlineStyle 常數 (例如 xlUnderlineStyleNone, xlUnderlineStyleSingle)。"},
        {"name": ".Color", "description": "RGB 顏色值 (長整型)。"},
        {"name": ".ColorIndex", "description": "調色盤中的顏色索引。"}
    ],
    "examples": [
        {"code": "With Range(\"A1\").Font\n  .Name = \"Times New Roman\"\n  .Size = 14\n  .Bold = True\n  .Color = vbBlue\nEnd With", "explanation": "設定儲存格 A1 的字型為 Times New Roman、大小 14、粗體且顏色為藍色。"}
    ],
    "keywords": ["字型", "文字格式", "excel", "font properties", "text formatting", "bold", "italic", "color"]
},
{
    "name": "Range.Interior Property",
    "category": "Excel 核心操作",
    "syntax": "Set interiorObject = rangeObject.Interior\ninteriorObject.Color = RGB(0, 255, 0)\ninteriorObject.Pattern = xlSolid\ninteriorObject.ColorIndex = 4 ' (Green, depends on palette)",
    "description": "傳回代表指定範圍內部 (背景) 格式的 Interior 物件。",
    "parameters": [
        {"name": ".Color", "description": "設定背景色的 RGB 值。"},
        {"name": ".ColorIndex", "description": "設定背景色的調色盤索引。"},
        {"name": ".Pattern", "description": "XlPattern 常數，設定背景圖樣 (例如 xlSolid, xlGray25)。"},
        {"name": ".PatternColor", "description": "設定圖樣的顏色 (如果圖樣不是實心)。"}
    ],
    "examples": [
        {"code": "With Range(\"B2:D4\").Interior\n  .Color = RGB(255, 255, 0) ' Yellow background\n  .Pattern = xlSolid\nEnd With", "explanation": "將範圍 B2:D4 的背景設定為黃色實心填充。"}
    ],
    "keywords": ["背景色", "填充色", "儲存格格式", "excel", "background color", "fill color", "cell shading"]
},
{
    "name": "Range.Borders Property",
    "category": "Excel 核心操作",
    "syntax": "Set bordersObject = rangeObject.Borders\nbordersObject(XlBordersIndex).LineStyle = XlLineStyle\nbordersObject(XlBordersIndex).Color = RGBColor\nbordersObject(XlBordersIndex).Weight = XlBorderWeight",
    "description": "傳回代表範圍框線的 Borders 集合。您可以存取集合中的特定框線 (例如，xlEdgeLeft, xlEdgeTop, xlInsideVertical) 並設定其屬性。",
    "parameters": [
        {"name": "Borders(XlBordersIndex)", "description": "指定要格式化的框線 (例如，xlEdgeLeft, xlEdgeTop, xlEdgeRight, xlEdgeBottom, xlInsideVertical, xlInsideHorizontal)。"},
        {"name": ".LineStyle", "description": "XlLineStyle 常數 (例如 xlContinuous, xlDot, xlDouble, xlLineStyleNone)。"},
        {"name": ".Color", "description": "框線的 RGB 顏色值。"},
        {"name": ".ColorIndex", "description": "框線顏色的調色盤索引。"},
        {"name": ".Weight", "description": "XlBorderWeight 常數 (例如 xlHairline, xlThin, xlMedium, xlThick)。"}
    ],
    "examples": [
        {"code": "With Range(\"A1:C3\").Borders\n  .LineStyle = xlContinuous\n  .Color = RGB(0, 0, 255) ' Blue borders\n  .Weight = xlThin\nEnd With\nRange(\"A1:C3\").Borders(xlInsideVertical).LineStyle = xlNone ' Remove inside vertical borders", "explanation": "為範圍 A1:C3 設定藍色細實線外框線，並移除內部垂直框線。"}
    ],
    "keywords": ["框線", "儲存格框線", "格式化框線", "excel", "cell borders", "border formatting"]
},
{
    "name": "Range.NumberFormat",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.NumberFormat = formatString",
    "description": "設定或傳回物件的數字格式代碼 (字串)。",
    "parameters": [
        {"name": "formatString", "description": "表示數字格式的字串代碼 (例如 \"0.00\", \"#,##0\", \"yyyy-mm-dd\", \"@\" 表示文字)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 1234.5678\nRange(\"A1\").NumberFormat = \"#,##0.00\"", "explanation": "將儲存格 A1 的數字格式設定為帶千位分隔符且保留兩位小數。"},
        {"code": "Range(\"B1\").Value = Date\nRange(\"B1\").NumberFormat = \"dd-mmm-yyyy\"", "explanation": "將儲存格 B1 的日期格式設定為 \"日-月份縮寫-年\"。"},
        {"code": "Range(\"C1:C10\").NumberFormat = \"@\" ' Set as Text format", "explanation": "將C1到C10儲存格的格式設定為文字。"}
    ],
    "keywords": ["數字格式", "日期格式", "文字格式", "excel", "cell format", "number format", "date format"]
},
{
    "name": "Range.RowHeight",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.RowHeight [= points]",
    "description": "設定或傳回指定範圍中所有列的高度 (以點為單位)。",
    "parameters": [
        {"name": "points", "description": "列高 (以點為單位)。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A5\").RowHeight = 25 ' Set rows 1 to 5 height to 25 points", "explanation": "將第1到第5列的列高設定為25點。"},
        {"code": "MsgBox Rows(1).RowHeight ' Display height of the first row", "explanation": "顯示第一列的目前高度。"}
    ],
    "keywords": ["列高", "調整列高", "excel", "row height", "set row height"]
},
{
    "name": "Range.ColumnWidth",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ColumnWidth [= width]",
    "description": "設定或傳回指定範圍中所有欄的寬度 (以標準字元寬度為單位)。",
    "parameters": [
        {"name": "width", "description": "欄寬 (以標準字元數為單位)。"}
    ],
    "examples": [
        {"code": "Range(\"A:C\").ColumnWidth = 15 ' Set columns A to C width to 15 characters", "explanation": "將A到C欄的欄寬設定為15個標準字元寬度。"},
        {"code": "MsgBox Columns(\"B\").ColumnWidth ' Display width of column B", "explanation": "顯示B欄的目前寬度。"}
    ],
    "keywords": ["欄寬", "調整欄寬", "excel", "column width", "set column width"]
},
{
    "name": "Range.EntireRow",
    "category": "Excel 核心操作",
    "syntax": "Set entireRowRange = rangeObject.EntireRow",
    "description": "傳回一個代表包含指定範圍的整個列 (或多列) 的 Range 物件。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"B3\").EntireRow.Font.Bold = True", "explanation": "將包含儲存格 B3 的整列 (即第3列) 的字型設定為粗體。"},
        {"code": "Selection.EntireRow.Delete", "explanation": "刪除目前選取範圍所在的整列。"}
    ],
    "keywords": ["整列", "選擇整列", "excel", "entire row", "select row"]
},
{
    "name": "Range.EntireColumn",
    "category": "Excel 核心操作",
    "syntax": "Set entireColumnRange = rangeObject.EntireColumn",
    "description": "傳回一個代表包含指定範圍的整個欄 (或多欄) 的 Range 物件。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"C5\").EntireColumn.HorizontalAlignment = xlCenter", "explanation": "將包含儲存格 C5 的整欄 (即C欄) 的水平對齊方式設定為置中。"},
        {"code": "Range(\"A1:B2\").EntireColumn.Hidden = True", "explanation": "隱藏包含範圍 A1:B2 的所有欄 (即A欄和B欄)。"}
    ],
    "keywords": ["整欄", "選擇整欄", "excel", "entire column", "select column"]
},
{
    "name": "Range.Offset",
    "category": "Excel 核心操作",
    "syntax": "Set offsetRange = rangeObject.Offset([RowOffset], [ColumnOffset])",
    "description": "傳回一個相對於指定範圍偏移的 Range 物件。",
    "parameters": [
        {"name": "RowOffset", "description": "可選。範圍偏移的列數 (正數向下，負數向上)。"},
        {"name": "ColumnOffset", "description": "可選。範圍偏移的欄數 (正數向右，負數向左)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Offset(1, 2).Value = \"Cell C2\"", "explanation": "從 A1 儲存格向下偏移1列，向右偏移2欄 (即C2)，並在該儲存格中寫入值。"},
        {"code": "Dim myRange As Range\nSet myRange = Range(\"B2:C3\").Offset(3) ' Only row offset specified\nmyRange.Select ' Selects B5:C6", "explanation": "將範圍 B2:C3 向下偏移3列，並選取結果範圍 B5:C6。"}
    ],
    "keywords": ["偏移", "相對位置", "excel", "offset range", "relative cell"]
},
{
    "name": "Range.Resize",
    "category": "Excel 核心操作",
    "syntax": "Set resizedRange = rangeObject.Resize([RowSize], [ColumnSize])",
    "description": "調整指定範圍的大小。傳回一個代表調整大小後範圍的 Range 物件。",
    "parameters": [
        {"name": "RowSize", "description": "可選。新範圍的列數。"},
        {"name": "ColumnSize", "description": "可選。新範圍的欄數。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Resize(3, 4).Select ' Selects A1:D3", "explanation": "從 A1 儲存格開始，選取一個3列4欄的範圍。"},
        {"code": "Dim myData As Range\nSet myData = Range(\"B2\").Resize(ColumnSize:=5) ' Resizes to B2:F2\nmyData.Value = Array(1, 2, 3, 4, 5)", "explanation": "將 B2 儲存格調整為1列5欄的範圍 (B2:F2)，並填入一個陣列的值。"}
    ],
    "keywords": ["調整大小", "範圍大小", "excel", "resize range", "change range size"]
},
{
    "name": "Range.End",
    "category": "Excel 核心操作",
    "syntax": "Set endCell = rangeObject.End(Direction As XlDirection)",
    "description": "傳回一個 Range 物件，代表包含來源範圍之區域末端的儲存格。相當於按 END+方向鍵。",
    "parameters": [
        {"name": "Direction", "description": "必需。XlDirection 常數 (xlUp, xlDown, xlToLeft, xlToRight)。"}
    ],
    "examples": [
        {"code": "Dim lastCellInColA As Range\nSet lastCellInColA = Range(\"A1\").End(xlDown)\nMsgBox \"A欄最後一個非空儲存格是: \" & lastCellInColA.Address", "explanation": "從 A1 開始向下查找，找到A欄中包含資料的最後一個儲存格。"},
        {"code": "Dim dataRange As Range\nSet dataRange = Range(\"A1\", Range(\"A1\").End(xlDown).End(xlToRight))\ndataRange.Select ' Selects the contiguous data block starting at A1", "explanation": "選取從A1開始的連續資料區域。"}
    ],
    "keywords": ["結尾儲存格", "資料範圍末端", "excel", "end of range", "last cell", "xlUp", "xlDown"]
},
{
    "name": "Range.Find",
    "category": "Excel 核心操作",
    "syntax": "Set foundCell = rangeObject.Find(What, [After], [LookIn], [LookAt], [SearchOrder], [SearchDirection As XlSearchDirection = xlNext], [MatchCase], [MatchByte], [SearchFormat])",
    "description": "在範圍中尋找特定資訊。如果找到，則傳回代表第一個找到儲存格的 Range 物件；如果找不到，則傳回 Nothing。",
    "parameters": [
        {"name": "What", "description": "必需。要搜尋的資料。可以是字串或任何 Excel 資料類型。"},
        {"name": "After", "description": "可選。表示搜尋開始點的儲存格。搜尋從此儲存格之後開始。"},
        {"name": "LookIn", "description": "可選。XlFindLookIn 常數 (xlFormulas, xlValues, xlComments)。"},
        {"name": "LookAt", "description": "可選。XlLookAt 常數 (xlWhole, xlPart)。"},
        {"name": "SearchDirection", "description": "可選。XlSearchDirection 常數 (xlNext, xlPrevious)。"},
        {"name": "MatchCase", "description": "可選。True 表示區分大小寫。"}
    ],
    "examples": [
        {"code": "Dim searchVal As String: searchVal = \"Total\"\nDim foundRng As Range\nSet foundRng = Columns(\"A\").Find(What:=searchVal, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False)\nIf Not foundRng Is Nothing Then\n  MsgBox \"'\" & searchVal & \"' 在 \" & foundRng.Address & \" 找到。\"\n  foundRng.Activate\nElse\n  MsgBox \"'\" & searchVal & \"' 未找到。\"\nEnd If", "explanation": "在A欄中不區分大小寫地搜尋完整符合 \"Total\" 的儲存格。"}
    ],
    "keywords": ["尋找", "搜尋", "excel", "find value", "search cell", "lookup"]
},
{
    "name": "Range.Sort",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Sort(Key1, [Order1], [Key2], [Type], [Order2], [Key3], [Order3], [Header As XlYesNoGuess], [OrderCustom], [MatchCase], [Orientation As XlSortOrientation = xlSortColumns], [SortMethod As XlSortMethod = xlPinYin], [DataOption1], [DataOption2], [DataOption3])",
    "description": "對指定的範圍進行排序。",
    "parameters": [
        {"name": "Key1", "description": "必需。第一個排序欄位 (作為範圍內的 Range 物件或文字名稱)。"},
        {"name": "Order1", "description": "可選。XlSortOrder 常數 (xlAscending, xlDescending)。"},
        {"name": "Header", "description": "可選。XlYesNoGuess 常數，指定第一列是否包含標頭。"}
    ],
    "examples": [
        {"code": "Dim dataToSort As Range\nSet dataToSort = Range(\"A1:C10\")\n' Sort by Column A (first column in dataToSort) in ascending order, assuming headers\ndataToSort.Sort Key1:=dataToSort.Columns(1), Order1:=xlAscending, Header:=xlYes", "explanation": "對範圍 A1:C10 進行排序，以該範圍的第一欄 (A欄) 為主要鍵，升冪排列，並假設有表頭。"}
    ],
    "keywords": ["排序", "資料排序", "excel", "sort data", "arrange data"]
},
{
    "name": "Range.Merge",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Merge([Across As Boolean = False])",
    "description": "將指定的 Range 物件合併成一個儲存格。",
    "parameters": [
        {"name": "Across", "description": "可選。True 表示僅水平合併範圍中每一列的儲存格。預設為 False。"}
    ],
    "examples": [
        {"code": "Range(\"A1:C1\").Merge ' Merges cells A1, B1, C1 into a single cell", "explanation": "將儲存格 A1 到 C1 合併為一個儲存格。"},
        {"code": "Range(\"D1:F5\").Merge Across:=True ' Merges D1:F1, D2:F2, ..., D5:F5", "explanation": "對範圍 D1:F5 中的每一列分別進行水平合併。"}
    ],
    "keywords": ["合併儲存格", "excel", "merge cells", "combine cells"]
},
{
    "name": "Range.UnMerge",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.UnMerge",
    "description": "將一個已合併的區域分割成個別的儲存格。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").UnMerge ' If A1 is part of a merged area, unmerges it", "explanation": "如果儲存格 A1 是一個合併儲存格的一部分，則取消合併該區域。"}
    ],
    "keywords": ["取消合併", "分割儲存格", "excel", "unmerge cells", "split cells"]
},
{
    "name": "Range.AutoFilter",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AutoFilter([Field], [Criteria1], [Operator As XlAutoFilterOperator = xlAnd], [Criteria2], [VisibleDropDown])",
    "description": "篩選清單或啟用/停用範圍的自動篩選下拉箭頭。",
    "parameters": [
        {"name": "Field", "description": "可選。相對於範圍的欄位偏移量 (1-based)。"},
        {"name": "Criteria1", "description": "可選。篩選條件。"},
        {"name": "Operator", "description": "可選。XlAutoFilterOperator 常數 (例如 xlAnd, xlOr)。"},
        {"name": "VisibleDropDown", "description": "可選。True 表示顯示該欄位的自動篩選下拉箭頭。"}
    ],
    "examples": [
        {"code": "' Turn on AutoFilter for range A1:C100 (assuming A1 is part of it)\nRange(\"A1\").AutoFilter\n' Filter column 1 (within the AutoFilter range) for values equal to \"Apple\"\nRange(\"A1\").AutoFilter Field:=1, Criteria1:=\"Apple\"", "explanation": "為包含 A1 的區域啟用自動篩選，然後篩選第一欄中值為 \"Apple\" 的資料。"},
        {"code": "ActiveSheet.AutoFilterMode = False ' Turn off AutoFilter for the entire sheet", "explanation": "關閉活動工作表上的自動篩選模式。"}
    ],
    "keywords": ["自動篩選", "篩選資料", "excel", "autofilter", "filter data"]
},
{
    "name": "Range.CurrentRegion",
    "category": "Excel 核心操作",
    "syntax": "Set currentRegionRange = rangeObject.CurrentRegion",
    "description": "傳回一個 Range 物件，代表由空白列和空白欄所包圍的目前區域。",
    "parameters": [],
    "examples": [
        {"code": "Dim dataBlock As Range\nSet dataBlock = Range(\"A1\").CurrentRegion\ndataBlock.Select ' Selects the block of data around A1", "explanation": "選取以 A1 儲存格為起點的連續資料區域。"}
    ],
    "keywords": ["目前區域", "資料區塊", "excel", "current region", "data block"]
},
{
    "name": "WorksheetFunction Object",
    "category": "Excel 核心操作",
    "syntax": "result = Application.WorksheetFunction.FunctionName(Arg1, Arg2, ...)",
    "description": "提供從 VBA 中存取 Microsoft Excel 工作表函數的方法。",
    "parameters": [
        {"name": "FunctionName", "description": "要呼叫的 Excel 工作表函數的名稱 (例如 Sum, Average, VLookup)。"},
        {"name": "Arg1, Arg2, ...", "description": "函數所需的參數。"}
    ],
    "examples": [
        {"code": "Dim totalSum As Double\ntotalSum = Application.WorksheetFunction.Sum(Range(\"A1:A10\"))\nMsgBox \"A1:A10 的總和是: \" & totalSum", "explanation": "使用 Sum 工作表函數計算範圍 A1:A10 的總和。"},
        {"code": "Dim lookupResult As Variant\nOn Error Resume Next ' VLookup might cause an error if not found\nlookupResult = Application.WorksheetFunction.VLookup(\"Apple\", Range(\"D1:E10\"), 2, False)\nIf Err.Number = 0 Then\n  MsgBox \"查找到的值: \" & lookupResult\nElse\n  MsgBox \"未找到 'Apple'。\"\nEnd If\nOn Error GoTo 0", "explanation": "使用 VLookup 工作表函數在 D1:E10 範圍內查找 \"Apple\" 並傳回第二欄的值。"}
    ],
    "keywords": ["工作表函數", "excel函數", "vba公式", "worksheetfunction", "excel functions", "sum", "average", "vlookup"]
},
{
    "name": "Application.CutCopyMode",
    "category": "Excel 核心操作",
    "syntax": "Application.CutCopyMode = False | XlCutCopyMode",
    "description": "設定或傳回剪下或複製模式的狀態。將其設為 False 可以取消剪下/複製模式 (移除移動的選取框線)。",
    "parameters": [
        {"name": "False", "description": "取消剪下或複製模式。"},
        {"name": "XlCutCopyMode (Constant)", "description": "可以檢查狀態，例如 xlCopy (1), xlCut (2)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Copy\nRange(\"B1\").PasteSpecial xlPasteValues\nApplication.CutCopyMode = False ' Clear the moving border (marquee) after copying", "explanation": "複製儲存格 A1 並將其值貼到 B1 後，清除剪貼簿模式。"}
    ],
    "keywords": ["剪貼簿模式", "取消複製", "excel", "cutcopymode", "clipboard", "clear marquee"]
},
{
    "name": "Application.UserName",
    "category": "Excel 核心操作",
    "syntax": "userNameString = Application.UserName",
    "description": "傳回或設定目前 Microsoft Excel 使用者的名稱。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"目前的使用者名稱是: \" & Application.UserName", "explanation": "顯示在 Excel 選項中設定的使用者名稱。"},
        {"code": "Dim originalUserName As String\noriginalUserName = Application.UserName\n' Application.UserName = \"Automated Process\" ' Temporarily change user name (if needed for tracking)\n' Range(\"A1\").Value = \"Data entered by: \" & Application.UserName\n' Application.UserName = originalUserName ' Restore original", "explanation": "獲取目前使用者名稱，並示範如何暫時修改它 (不建議隨意修改全域設定)。"}
    ],
    "keywords": ["使用者名稱", "excel使用者", "application username", "current user"]
},
{
    "name": "Workbook.Protect",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.Protect([Password], [Structure As Boolean = True], [Windows As Boolean = True])",
    "description": "保護活頁簿，使其無法新增或刪除工作表 (Structure) 或移動/調整視窗大小 (Windows)。",
    "parameters": [
        {"name": "Password", "description": "可選。保護活頁簿的密碼。"},
        {"name": "Structure", "description": "可選。True (預設) 表示保護活頁簿的結構 (工作表的順序、新增、刪除)。"},
        {"name": "Windows", "description": "可選。True (預設) 表示保護活頁簿的視窗。"}
    ],
    "examples": [
        {"code": "ThisWorkbook.Protect Password:=\"secret123\", Structure:=True, Windows:=False", "explanation": "使用密碼保護目前活頁簿的結構，但不保護其視窗。"}
    ],
    "keywords": ["保護活頁簿", "鎖定結構", "excel", "protect workbook", "workbook structure", "password protect"]
},
{
    "name": "Workbook.Unprotect",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.Unprotect([Password])",
    "description": "移除對活頁簿的保護。",
    "parameters": [
        {"name": "Password", "description": "可選。如果活頁簿受密碼保護，則為取消保護所需的密碼。"}
    ],
    "examples": [
        {"code": "On Error Resume Next ' In case not protected or wrong password\nThisWorkbook.Unprotect Password:=\"secret123\"\nIf Err.Number <> 0 Then MsgBox \"無法取消保護活頁簿。\"\nOn Error GoTo 0", "explanation": "使用密碼取消對目前活頁簿的保護。"}
    ],
    "keywords": ["取消保護活頁簿", "解鎖結構", "excel", "unprotect workbook"]
},
{
    "name": "Range.SpecialCells",
    "category": "Excel 核心操作",
    "syntax": "Set specialCellsRange = rangeObject.SpecialCells(Type As XlCellType, [Value])",
    "description": "傳回一個 Range 物件，代表符合指定類型和值的所有儲存格。",
    "parameters": [
        {"name": "Type", "description": "必需。XlCellType 常數，指定要選取的儲存格類型 (例如，xlCellTypeConstants, xlCellTypeFormulas, xlCellTypeBlanks, xlCellTypeVisible)。"},
        {"name": "Value", "description": "可選。如果 Type 是 xlCellTypeConstants 或 xlCellTypeFormulas，則此引數用於確定結果中包含哪些類型的儲存格 (例如，xlNumbers, xlTextValues)。"}
    ],
    "examples": [
        {"code": "Dim blankCells As Range\nOn Error Resume Next ' If no blank cells found, SpecialCells raises an error\nSet blankCells = ActiveSheet.UsedRange.SpecialCells(xlCellTypeBlanks)\nOn Error GoTo 0\nIf Not blankCells Is Nothing Then\n  blankCells.Interior.Color = RGB(255, 200, 200) ' Highlight blank cells in light red\n  MsgBox blankCells.Count & \" 個空白儲存格已高亮顯示。\"\nElse\n  MsgBox \"未找到空白儲存格。\"\nEnd If", "explanation": "在已使用範圍內尋找所有空白儲存格並將其背景高亮顯示。"},
        {"code": "Dim formulaCells As Range\nSet formulaCells = Range(\"A1:D100\").SpecialCells(xlCellTypeFormulas, xlNumbers) ' Formulas that result in numbers\nIf Not formulaCells Is Nothing Then formulaCells.Font.Italic = True", "explanation": "在 A1:D100 範圍內尋找所有結果為數字的公式儲存格，並將其字型設為斜體。"}
    ],
    "keywords": ["特殊儲存格", "篩選儲存格類型", "excel", "special cells", "xlCellTypeBlanks", "xlCellTypeFormulas", "xlCellTypeVisible"]
},
{
    "name": "Range.Validation Property",
    "category": "Excel 核心操作",
    "syntax": "Set validationObject = rangeObject.Validation",
    "description": "傳回代表指定範圍資料驗證的 Validation 物件。",
    "parameters": [],
    "examples": [
        {"code": "With Range(\"A1\").Validation\n  .Delete ' Delete existing validation\n  .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:=\"Yes,No,Maybe\"\n  .InputTitle = \"Valid Entries\"\n  .InputMessage = \"Please select from the list.\"\n  .ErrorTitle = \"Invalid Entry\"\n  .ErrorMessage = \"You must choose an option from the dropdown list.\"\n  .ShowInput = True\n  .ShowError = True\nEnd With", "explanation": "為儲存格 A1 新增一個清單型資料驗證，允許的值為 \"Yes\", \"No\", \"Maybe\"。"}
    ],
    "keywords": ["資料驗證", "輸入限制", "excel", "data validation", "validation rules", "dropdown list"]
},
{
    "name": "Validation.Add",
    "category": "Excel 核心操作",
    "syntax": "validationObject.Add(Type, [AlertStyle], [Operator], [Formula1], [Formula2])",
    "description": "將資料驗證新增到指定的範圍。",
    "parameters": [
        {"name": "Type", "description": "必需。XlDVType 常數，指定驗證類型 (例如，xlValidateWholeNumber, xlValidateDecimal, xlValidateList, xlValidateDate, xlValidateTextLength, xlValidateCustom)。"},
        {"name": "AlertStyle", "description": "可選。XlDVAlertStyle 常數 (xlValidAlertStop, xlValidAlertWarning, xlValidAlertInformation)。"},
        {"name": "Operator", "description": "可選。XlFormatConditionOperator 常數 (例如，xlBetween, xlNotBetween, xlEqual, xlGreater)。"},
        {"name": "Formula1", "description": "可選。驗證的第一部分 (可以是值或公式字串)。"},
        {"name": "Formula2", "description": "可選。如果 Operator 是 xlBetween 或 xlNotBetween，則為驗證的第二部分。"}
    ],
    "examples": [
        {"code": "Range(\"B10\").Validation.Add Type:=xlValidateWholeNumber, _\n                            AlertStyle:=xlValidAlertStop, _\n                            Operator:=xlBetween, Formula1:=\"1\", Formula2:=\"100\"\nRange(\"B10\").Validation.ErrorMessage = \"請輸入介於1和100之間的整數。\"", "explanation": "為儲存格 B10 設定資料驗證，要求輸入介於1和100之間的整數。"}
    ],
    "keywords": ["新增資料驗證", "驗證規則", "excel", "add data validation", "validation criteria"]
},
{
    "name": "Range.Hyperlinks.Add",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Hyperlinks.Add(Anchor, Address, [SubAddress], [ScreenTip], [TextToDisplay])",
    "description": "將超連結新增到指定的範圍。",
    "parameters": [
        {"name": "Anchor", "description": "必需。Range 物件，超連結將附加到此儲存格。"},
        {"name": "Address", "description": "必需。連結的位址 (URL、檔案路徑或電子郵件地址)。"},
        {"name": "SubAddress", "description": "可選。文件內的位置 (例如，工作表和儲存格參照，或 Word 書籤)。"},
        {"name": "ScreenTip", "description": "可選。滑鼠懸停在超連結上時顯示的文字。"},
        {"name": "TextToDisplay", "description": "可選。儲存格中顯示的文字。如果省略，則顯示位址。"}
    ],
    "examples": [
        {"code": "ActiveSheet.Hyperlinks.Add Anchor:=Range(\"A1\"), _\n                             Address:=\"https://www.google.com\", _\n                             ScreenTip:=\"點擊前往 Google\", _\n                             TextToDisplay:=\"Google 搜尋\"", "explanation": "在儲存格 A1 中建立一個顯示為 \"Google 搜尋\" 的超連結，指向 www.google.com。"}
    ],
    "keywords": ["超連結", "新增連結", "excel", "hyperlink", "add link", "web link"]
},
{
    "name": "Range.Comment Property / .AddComment",
    "category": "Excel 核心操作",
    "syntax": "Set cmt = rangeObject.Comment ' Get comment object\ncmt.Text Text:=\"My comment text\"\nrangeObject.AddComment([Text])\nrangeObject.ClearComments",
    "description": "Comment 屬性傳回代表附加到儲存格的註解的 Comment 物件。AddComment 方法將註解新增到範圍。ClearComments 方法刪除範圍中的所有註解。",
    "parameters": [
        {"name": "Text (AddComment)", "description": "可選。註解的文字。"},
        {"name": "Text (Comment.Text method)", "description": "設定或取得註解文字。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").ClearComments ' Clear any existing comment\nRange(\"A1\").AddComment \"這是一個重要的儲存格。\"\nRange(\"A1\").Comment.Visible = True ' Make comment visible", "explanation": "清除 A1 儲存格的舊註解，新增一個新註解，並使其可見。"},
        {"code": "If Not Range(\"B2\").Comment Is Nothing Then\n  MsgBox \"B2 的註解: \" & Range(\"B2\").Comment.Text\nElse\n  MsgBox \"B2 沒有註解。\"\nEnd If", "explanation": "檢查 B2 儲存格是否有註解，如果有則顯示其內容。"}
    ],
    "keywords": ["註解", "儲存格註解", "新增註解", "excel", "cell comment", "add comment", "notes"]
},
{
    "name": "Shape Object (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set shp = ActiveSheet.Shapes(IndexOrName)\nshp.Left = value\nshp.Top = value\nshp.Width = value\nshp.Height = value\nshp.Name = \"MyShapeName\"\nshp.TextFrame.Characters.Text = \"Shape Text\"",
    "description": "代表工作表上的圖案，例如矩形、線條、文字方塊、圖片等。",
    "parameters": [
        {"name": ".Name", "description": "圖案的名稱。"},
        {"name": ".Left / .Top", "description": "圖案左上角的水平/垂直位置 (以點為單位)。"},
        {"name": ".Width / .Height", "description": "圖案的寬度/高度 (以點為單位)。"},
        {"name": ".Type", "description": "傳回 MsoShapeType 常數，表示圖案類型。"},
        {"name": ".TextFrame.Characters.Text", "description": "設定或取得圖案中的文字 (如果圖案支援文字)。"},
        {"name": ".Delete", "description": "方法：刪除圖案。"},
        {"name": ".Copy", "description": "方法：複製圖案到剪貼簿。"}
    ],
    "examples": [
        {"code": "Dim myShape As Shape\n' Add a rectangle\nSet myShape = ActiveSheet.Shapes.AddShape(msoShapeRectangle, 50, 50, 100, 75)\nmyShape.Name = \"InfoBox\"\nmyShape.TextFrame.Characters.Text = \"重要資訊\"\nmyShape.Fill.ForeColor.RGB = RGB(200, 220, 255) ' Light blue fill", "explanation": "在活動工作表上新增一個矩形圖案，命名它，加入文字，並設定其填充顏色。"}
    ],
    "keywords": ["圖案", "圖形", "文字方塊", "excel", "shape object", "drawing", "textbox", "picture"]
},
{
    "name": "ChartObject Object (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set chtObj = ActiveSheet.ChartObjects(IndexOrName)\nSet actualChart = chtObj.Chart",
    "description": "代表工作表上的嵌入式圖表。ChartObject 物件充當 Chart 物件的容器。",
    "parameters": [
        {"name": ".Chart", "description": "屬性：傳回代表 ChartObject 中所含圖表的 Chart 物件。"},
        {"name": ".Left / .Top / .Width / .Height", "description": "ChartObject 容器的位置和大小屬性。"},
        {"name": ".Activate", "description": "方法：啟用圖表容器。"},
        {"name": ".Delete", "description": "方法：刪除圖表容器及其中的圖表。"}
    ],
    "examples": [
        {"code": "Dim co As ChartObject, ch As Chart\n' Assume a chart named \"SalesChart\" exists on ActiveSheet\nOn Error Resume Next\nSet co = ActiveSheet.ChartObjects(\"SalesChart\")\nIf Not co Is Nothing Then\n  Set ch = co.Chart\n  ch.ChartTitle.Text = \"2023 年度銷售圖\"\n  co.Width = 400 ' Resize the container\nElse\n  MsgBox \"找不到名為 'SalesChart' 的圖表物件。\"\nEnd If\nOn Error GoTo 0", "explanation": "獲取名為 \"SalesChart\" 的嵌入式圖表物件，然後存取其 Chart 物件以修改圖表標題，並調整圖表容器的大小。"}
    ],
    "keywords": ["圖表物件", "嵌入式圖表", "excel", "chartobject", "embedded chart", "chart container"]
},
{
    "name": "Chart Object (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set ch = ActiveChart ' Or workbook.Charts(index), or chartObject.Chart\nch.ChartType = xlColumnClustered\nch.SetSourceData Source:=Range(\"A1:B5\")\nch.HasTitle = True\nch.ChartTitle.Text = \"My Chart Title\"",
    "description": "代表活頁簿中的圖表 (可以是嵌入式圖表或獨立的圖表工作表)。",
    "parameters": [
        {"name": ".ChartType", "description": "設定或傳回 XlChartType 常數，表示圖表類型。"},
        {"name": ".SetSourceData(Source, [PlotBy])", "description": "方法：設定圖表的來源資料。"},
        {"name": ".HasLegend / .Legend", "description": "控制圖例的顯示和存取 Legend 物件。"},
        {"name": ".HasTitle / .ChartTitle", "description": "控制圖表標題的顯示和存取 ChartTitle 物件。"},
        {"name": ".Axes(Type, [AxisGroup])", "description": "傳回代表圖表單一座標軸或座標軸集合的 Axes 集合。"},
        {"name": ".SeriesCollection([Index])", "description": "傳回代表圖表中所有數列的 SeriesCollection 集合或單個 Series 物件。"},
        {"name": ".Export(FileName, [FilterName], [Interactive])", "description": "方法：將圖表匯出為圖形檔案。"}
    ],
    "examples": [
        {"code": "Dim myChart As Chart\n' Create a new chart sheet and set its type and source data\nSet myChart = ThisWorkbook.Charts.Add\nWith myChart\n  .ChartType = xlLineMarkers\n  .SetSourceData Source:=ThisWorkbook.Sheets(\"DataSheet\").Range(\"A1:C10\")\n  .HasTitle = True\n  .ChartTitle.Text = \"月度趨勢\"\n  .Axes(xlCategory).HasTitle = True\n  .Axes(xlCategory).AxisTitle.Text = \"月份\"\n  .Axes(xlValue).HasTitle = True\n  .Axes(xlValue).AxisTitle.Text = \"數值\"\nEnd With", "explanation": "新增一個新的圖表工作表，設定其類型為帶標記的折線圖，指定資料來源，並新增圖表和座標軸標題。"}
    ],
    "keywords": ["圖表", "繪圖", "資料視覺化", "excel", "chart object", "graph", "data visualization"]
},
{
    "name": "Application.WindowState",
    "category": "Excel 核心操作",
    "syntax": "Application.WindowState = xlNormal | xlMinimized | xlMaximized",
    "description": "設定或傳回 Microsoft Excel 視窗的狀態。",
    "parameters": [
        {"name": "xlNormal", "description": "視窗為正常大小 (非最大化或最小化)。"},
        {"name": "xlMinimized", "description": "視窗最小化。"},
        {"name": "xlMaximized", "description": "視窗最大化。"}
    ],
    "examples": [
        {"code": "Application.WindowState = xlMaximized ' Maximize the Excel application window\nMsgBox \"Excel 視窗已最大化。\"\nApplication.WindowState = xlNormal ' Restore to normal", "explanation": "將 Excel 主應用程式視窗最大化，然後再還原為正常大小。"}
    ],
    "keywords": ["視窗狀態", "最大化", "最小化", "excel", "window state", "maximize", "minimize"]
},
{
    "name": "Application.OnKey",
    "category": "Excel VBA 開發與表單",
    "syntax": "Application.OnKey(Key As String, [Procedure])",
    "description": "當按下特定按鍵或按鍵組合時執行指定的程序。",
    "parameters": [
        {"name": "Key", "description": "必需。要攔截的按鍵字串 (例如 \"^c\" 代表 Ctrl+C, \"{F5}\", \"+{F5}\" 代表 Shift+F5)。"},
        {"name": "Procedure", "description": "可選。要執行的 Sub 程序的名稱 (字串)。如果省略或為空字串，則恢復 Key 的正常功能。"}
    ],
    "examples": [
        {"code": "Sub SetupShortcut()\n  Application.OnKey \"^+N\", \"MyCustomMacro\" ' Assign Ctrl+Shift+N to MyCustomMacro\n  MsgBox \"快捷鍵 Ctrl+Shift+N 已設定為執行 MyCustomMacro。\"\nEnd Sub\n\nSub DisableShortcut()\n  Application.OnKey \"^+N\", \"\" ' Disable the shortcut\n  MsgBox \"快捷鍵 Ctrl+Shift+N 已被禁用。\"\nEnd Sub\n\nSub MyCustomMacro()\n  MsgBox \"自訂宏已透過快捷鍵執行！\"\nEnd Sub", "explanation": "SetupShortcut 將 Ctrl+Shift+N 綁定到 MyCustomMacro。DisableShortcut 取消此綁定。MyCustomMacro 是實際執行的宏。"}
    ],
    "keywords": ["快捷鍵", "熱鍵", "自訂按鍵", "excel", "hotkey", "shortcut key", "custom key"]
},
{
    "name": "Application.Volatile",
    "category": "Excel VBA 開發與表單",
    "syntax": "Application.Volatile([Volatile As Boolean = True])",
    "description": "將使用者定義函數 (UDF) 標記為易失性。易失性函數會在工作簿中任何儲存格進行重新計算時都重新計算。應謹慎使用，因為它可能影響效能。",
    "parameters": [
        {"name": "Volatile", "description": "可選。True (預設) 使函數易失，False 使其非易失。"}
    ],
    "examples": [
        {"code": "Function GetCurrentTimestamp() As Date\n  Application.Volatile ' Mark this UDF as volatile\n  GetCurrentTimestamp = Now\nEnd Function\n' If you put =GetCurrentTimestamp() in a cell, it will update whenever any calculation occurs.", "explanation": "定義一個易失性的使用者定義函數 GetCurrentTimestamp，它會在工作表重新計算時更新其傳回的目前時間戳。"}
    ],
    "keywords": ["易失性函數", "UDF重新計算", "excel", "volatile function", "udf recalculation", "user defined function"]
},
{
    "name": "CVar",
    "category": "資料類型、轉換與驗證",
    "syntax": "CVar(expression)",
    "description": "傳回已轉換為 Variant 資料類型的 expression。",
    "parameters": [{"name": "expression", "description": "必需。任何有效的表達式。"}],
    "examples": [
        {"code": "Dim MyInt As Integer, MyVariant As Variant\nMyInt = 100\nMyVariant = CVar(MyInt)\nMsgBox \"Variant 的子類型是: \" & TypeName(MyVariant) & \", 值是: \" & MyVariant", "explanation": "將一個整數轉換為 Variant 類型。Variant 可以包含任何類型的數據。"}
    ],
    "keywords": ["轉換", "Variant", "類型轉換", "cast", "variant type", "conversion", "to variant"]
},
{
    "name": "Is Nothing (Object Check)",
    "category": "資料類型、轉換與驗證",
    "syntax": "If objectVariable Is Nothing Then ...",
    "description": "檢查物件變數是否已指派給一個有效的物件參考，或者是否為 Nothing (即未指向任何物件)。",
    "parameters": [
        {"name": "objectVariable", "description": "必需。一個物件變數。"}
    ],
    "examples": [
        {"code": "Dim mySheet As Worksheet\n' Set mySheet = ThisWorkbook.Sheets(\"Sheet1\") ' Try commenting this line\nIf mySheet Is Nothing Then\n  MsgBox \"mySheet 物件變數未被設定 (是 Nothing)。\"\nElse\n  MsgBox \"mySheet 指向: \" & mySheet.Name\nEnd If", "explanation": "演示如何檢查 Worksheet 物件變數 mySheet 是否已被賦予有效的物件參考。"}
    ],
    "keywords": ["物件檢查", "isnothing", "物件參考", "object check", "object reference", "unassigned object"]
},
{
    "name": "StrConv",
    "category": "字串與文本操作",
    "syntax": "StrConv(string, conversion As VbStrConv, [LCID As Long])",
    "description": "轉換字串的格式。例如，轉換為大寫、小寫、適當大小寫、Unicode、從 Unicode 轉換等。",
    "parameters": [
        {"name": "string", "description": "必需。要轉換的字串表達式。"},
        {"name": "conversion", "description": "必需。VbStrConv 列舉值，指定轉換類型 (例如 vbUpperCase, vbLowerCase, vbProperCase, vbUnicode, vbFromUnicode)。"},
        {"name": "LCID", "description": "可選。地區設定 ID (如果與系統地區設定不同)。"}
    ],
    "examples": [
        {"code": "Dim myText As String: myText = \"hello vba world\"\nMsgBox \"大寫: \" & StrConv(myText, vbUpperCase)\nMsgBox \"小寫: \" & StrConv(myText, vbLowerCase)\nMsgBox \"首字大寫: \" & StrConv(myText, vbProperCase)", "explanation": "演示如何使用 StrConv 將字串轉換為全大寫、全小寫和每個單詞首字母大寫 (適當大小寫)。"}
    ],
    "keywords": ["字串轉換", "大小寫轉換", "Unicode轉換", "string conversion", "case conversion", "vbProperCase"]
},
{
    "name": "Like Operator",
    "category": "字串與文本操作",
    "syntax": "result = string Like pattern",
    "description": "比較字串與模式。傳回一個布林值，指示字串是否符合模式。",
    "parameters": [
        {"name": "string", "description": "必需。要比較的字串表達式。"},
        {"name": "pattern", "description": "必需。包含萬用字元和/或字元列表的字串模式。"}
    ],
    "examples": [
        {"code": "Dim text1 As String: text1 = \"Apple Pie\"\nIf text1 Like \"A*e\" Then MsgBox \"'\" & text1 & \"' 符合 'A*e'\"", "explanation": "檢查字串是否以 'A' 開頭並以 'e' 結尾，中間可以是任意字元。"},
        {"code": "Dim text2 As String: text2 = \"Item_001\"\nIf text2 Like \"Item_[0-9][0-9][0-9]\" Then MsgBox \"'\" & text2 & \"' 符合編號模式\"", "explanation": "檢查字串是否符合 \"Item_\" 後面跟著三個數字的模式。"},
        {"code": "Dim text3 As String: text3 = \"Test?\"\nIf text3 Like \"*\\?\" Then MsgBox \"'\" & text3 & \"' 以問號結尾 (已轉義)。\"", "explanation": "檢查字串是否以問號結尾 (問號是萬用字元，需用方括號或反斜線轉義，但在 Like 中，方括號本身有特殊意義，所以通常用 `Like \"*[?]\"` 或 `Like \"*\\?\"` 視情況，但 `Like \"*[?]\"` 更標準)。此處 `*\\?` 可能不適用，`Like \"*[?]\"` 更為常見。"}
    ],
    "keywords": ["模式匹配", "萬用字元", "字串比較", "pattern matching", "wildcards", "string comparison", "regex lite"]
},
{
    "name": "While...Wend Statement",
    "category": "程式流程與結構控制",
    "syntax": "While condition\n  [statements]\nWend",
    "description": "當指定的條件為 True 時，重複執行一系列語句。",
    "parameters": [
        {"name": "condition", "description": "必需。一個評估為 True 或 False 的數值或字串表達式。"}
    ],
    "examples": [
        {"code": "Dim counter As Integer: counter = 1\nWhile counter <= 5\n  Debug.Print \"計數器值: \" & counter\n  counter = counter + 1\nWend", "explanation": "當 counter 變數小於或等於 5 時，重複打印其值並將其遞增。"}
    ],
    "keywords": ["while迴圈", "條件迴圈", "重複", "loop", "while wend", "conditional loop"]
},
{
    "name": "End Statement",
    "category": "程式流程與結構控制",
    "syntax": "End [Sub | Function | If | Select | Type | With | Enum]",
    "description": "立即終止程式執行，或結束一個區塊語句 (如 End Sub, End Function, End If)。單獨的 End 會終止整個應用程式的 VBA 執行。",
    "parameters": [],
    "examples": [
        {"code": "Sub CheckConditionAndEnd(val As Integer)\n  If val < 0 Then\n    MsgBox \"輸入無效，程式將終止。\"\n    End ' Terminates all VBA execution\n  End If\n  MsgBox \"值有效: \" & val\nEnd Sub\n' CheckConditionAndEnd -5 ' This will call End", "explanation": "如果傳入的值小於0，則顯示一條訊息並立即終止所有VBA腳本的執行。"}
    ],
    "keywords": ["終止執行", "結束程式", "terminate execution", "stop program", "exit vba"]
},
{
    "name": "Stop Statement",
    "category": "程式流程與結構控制",
    "syntax": "Stop",
    "description": "暫停程式執行。在開發環境中，執行到 Stop 語句時，程式會進入中斷模式，允許進行調試。",
    "parameters": [],
    "examples": [
        {"code": "Sub DebugExample()\n  Dim x As Integer: x = 10\n  Dim y As Integer: y = 20\n  Stop ' Execution pauses here when run from VBA editor\n  Dim z As Integer: z = x + y\n  MsgBox \"總和是: \" & z\nEnd Sub", "explanation": "當從VBA編輯器運行此宏時，執行到 Stop 語句處會暫停，允許開發者檢查變數 x 和 y 的值，然後可以繼續執行。"}
    ],
    "keywords": ["暫停執行", "調試斷點", "中斷模式", "pause execution", "debug breakpoint", "break mode"]
},
{
    "name": "MailItem.ReceivedTime",
    "category": "Outlook 郵件與項目管理",
    "syntax": "dtReceived = mailItemObject.ReceivedTime",
    "description": "傳回一個 Date，表示 Outlook 項目 (例如郵件) 的接收日期和時間。此屬性是唯讀的。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem, assume it's an existing email\n' ' Set olMail = Application.ActiveExplorer.Selection.Item(1) ' Get selected email\n' If TypeName(olMail) = \"MailItem\" Then\n'   MsgBox \"郵件接收於: \" & olMail.ReceivedTime\n' End If", "explanation": "獲取目前選取的 Outlook 郵件的接收日期和時間。"}
    ],
    "keywords": ["outlook", "接收時間", "郵件日期", "received date", "email timestamp"]
},
{
    "name": "MailItem.SenderName",
    "category": "Outlook 郵件與項目管理",
    "syntax": "strSenderName = mailItemObject.SenderName",
    "description": "傳回一個字串，表示 Outlook 項目的寄件者顯示名稱。此屬性是唯讀的。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' ' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   MsgBox \"寄件者: \" & olMail.SenderName\n' End If", "explanation": "獲取目前選取 Outlook 郵件的寄件者顯示名稱。"}
    ],
    "keywords": ["outlook", "寄件者名稱", "發件人", "sender name", "from field"]
},
{
    "name": "MailItem.SaveAs",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.SaveAs(Path As String, [Type As OlSaveAsType = olMSG])",
    "description": "將 Microsoft Outlook 項目儲存到指定的路徑和檔案格式。",
    "parameters": [
        {"name": "Path", "description": "必需。要儲存項目的完整檔案路徑。"},
        {"name": "Type", "description": "可選。OlSaveAsType 常數，指定儲存格式 (例如，olMSG, olTXT, olRTF, olHTML)。預設為 olMSG。"}
    ],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' ' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   Dim savePath As String\n'   savePath = \"C:\\EmailBackups\\\" & ReplaceCharsForFileName(olMail.Subject) & \".msg\"\n'   olMail.SaveAs savePath, 3 ' 3 = olMSG\n'   MsgBox \"郵件已儲存為: \" & savePath\n' End If\n' Function ReplaceCharsForFileName(strIn As String) As String\n'   ReplaceCharsForFileName = Replace(Replace(Replace(strIn, \":\", \"-\"), \"?\", \"\"), \"/\", \"-\")\n' End Function", "explanation": "將目前選取的 Outlook 郵件以 .msg 格式儲存到 C:\\EmailBackups\\ 資料夾，檔名基於郵件主旨 (並進行了簡單的非法字元替換)。"}
    ],
    "keywords": ["outlook", "儲存郵件", "另存郵件", "save email", "export email", "olMSG"]
},
{
    "name": "Folder.FolderPath (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "strFolderPath = outlookFolderObject.FolderPath",
    "description": "傳回一個字串，表示資料夾的完整路徑。此屬性是唯讀的。",
    "parameters": [],
    "examples": [
        {"code": "Dim olFolder As Object ' Outlook.MAPIFolder\n' Set olFolder = Application.ActiveExplorer.CurrentFolder\n' MsgBox \"目前資料夾的路徑是: \" & olFolder.FolderPath", "explanation": "顯示 Outlook 中目前活動瀏覽器中選定資料夾的完整路徑。"}
    ],
    "keywords": ["outlook", "資料夾路徑", "folder path", "mapi folder"]
},
{
    "name": "Document.BuiltInDocumentProperties (Word)",
    "category": "Word 文件處理",
    "syntax": "Set docProps = documentObject.BuiltInDocumentProperties",
    "description": "傳回一個 DocumentProperties 集合，代表 Word 文件的所有內建文件屬性 (例如，作者、標題、主旨)。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim prop As Object ' DocumentProperty\n' Set wdDoc = ActiveDocument ' Assuming in Word VBA context\n' For Each prop In wdDoc.BuiltInDocumentProperties\n'   On Error Resume Next ' Some properties might not have a value or cause error\n'   Debug.Print prop.Name & \": \" & prop.Value\n'   On Error GoTo 0\n' Next prop\n' MsgBox \"作者: \" & wdDoc.BuiltInDocumentProperties(\"Author\").Value", "explanation": "遍歷活動 Word 文件的所有內建文件屬性並將其名稱和值列印到立即視窗，然後顯示作者屬性。"}
    ],
    "keywords": ["word", "文件屬性", "元數據", "document properties", "metadata", "author", "title"]
},
{
    "name": "Document.CustomDocumentProperties (Word)",
    "category": "Word 文件處理",
    "syntax": "Set customProps = documentObject.CustomDocumentProperties\ncustomProps.Add Name:=\"MyCustomProp\", LinkToContent:=False, Type:=msoPropertyTypeString, Value:=\"Custom Value\"",
    "description": "傳回一個 DocumentProperties 集合，代表 Word 文件的所有自訂文件屬性。您可以新增、修改或刪除自訂屬性。",
    "parameters": [
        {"name": ".Add(Name, LinkToContent, Type, Value)", "description": "方法：新增一個自訂文件屬性。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' On Error Resume Next ' In case property already exists\n' wdDoc.CustomDocumentProperties.Add Name:=\"ProjectCode\", LinkToContent:=False, Type:=4, Value:=\"XYZ-123\" ' 4 = msoPropertyTypeString\n' If Err.Number <> 0 Then ' Property might exist, try updating\n'   Err.Clear\n'   wdDoc.CustomDocumentProperties(\"ProjectCode\").Value = \"XYZ-123-Updated\"\n' End If\n' On Error GoTo 0\n' MsgBox \"自訂屬性 'ProjectCode' 的值: \" & wdDoc.CustomDocumentProperties(\"ProjectCode\").Value", "explanation": "新增一個名為 \"ProjectCode\" 的自訂文件屬性，並設定其值。如果已存在，則嘗試更新其值。"}
    ],
    "keywords": ["word", "自訂屬性", "文件元數據", "custom document properties", "metadata"]
},
{
    "name": "Selection.TypeText (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.TypeText(Text As String)",
    "description": "在目前的選取範圍 (如果選取了內容則取代它) 或插入點處插入指定的文字。",
    "parameters": [
        {"name": "Text", "description": "必需。要插入的文字。"}
    ],
    "examples": [
        {"code": "Dim wdApp As Object ' Word.Application\n' ' Set wdApp = CreateObject(\"Word.Application\")\n' ' wdApp.Visible = True\n' ' wdApp.Documents.Add\n' wdApp.Selection.TypeText \"這是透過VBA插入的文字。\"\n' wdApp.Selection.TypeParagraph ' Insert a new paragraph", "explanation": "在 Word 文件的目前插入點輸入指定的文字，然後插入一個新段落。"}
    ],
    "keywords": ["word", "輸入文字", "插入文字", "type text", "insert text", "selection"]
},
{
    "name": "Selection.GoTo (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.GoTo(What As WdGoToItem, [Which As WdGoToDirection], [Count As Long], [Name As String]) As Range",
    "description": "將插入點移動到指定項目的緊接前面，並傳回一個代表該位置的 Range 物件。",
    "parameters": [
        {"name": "What", "description": "必需。WdGoToItem 常數，指定要移至的項目類型 (例如，wdGoToPage, wdGoToLine, wdGoToBookmark, wdGoToTable)。"},
        {"name": "Which", "description": "可選。WdGoToDirection 常數 (例如，wdGoToNext, wdGoToPrevious, wdGoToAbsolute)。"},
        {"name": "Count", "description": "可選。項目編號 (如果 Which 是 wdGoToAbsolute 或 wdGoToRelative)。"},
        {"name": "Name", "description": "可選。如果 What 是 wdGoToBookmark、wdGoToField 等，則為項目名稱。"}
    ],
    "examples": [
        {"code": "Dim wdApp As Object ' Word.Application\n' ' Assume wdApp is a running Word instance with an open document\n' ' Go to the beginning of the 3rd page\n' wdApp.Selection.GoTo What:=1, Which:=1, Count:=3 ' 1=wdGoToPage, 1=wdGoToAbsolute\n' wdApp.Selection.TypeText \"(這是第三頁的開頭)\"", "explanation": "將 Word 中的插入點移動到文件的第三頁開頭，並插入一些文字。"}
    ],
    "keywords": ["word", "跳至", "導航", "go to", "navigate document", "selection", "wdGoToPage"]
},
{
    "name": "Slide.Shapes.Title (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set titleShape = slideObject.Shapes.Title",
    "description": "傳回一個 Shape 物件，代表投影片版面配置中的標題預留位置。如果投影片沒有標題預留位置，則會產生錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide, assume it's the first slide\nDim titleShape As Object ' PowerPoint.Shape\n' ' Set pptSlide = ActivePresentation.Slides(1)\n' On Error Resume Next ' In case there is no title placeholder\n' Set titleShape = pptSlide.Shapes.Title\n' If Not titleShape Is Nothing Then\n'   titleShape.TextFrame.TextRange.Text = \"新的投影片標題\"\n'   MsgBox \"投影片標題已更新。\"\n' Else\n'   MsgBox \"此投影片沒有標題預留位置。\"\n' End If\n' On Error GoTo 0", "explanation": "嘗試獲取第一張投影片的標題圖案，並更新其文字內容。"}
    ],
    "keywords": ["powerpoint", "投影片標題", "標題圖案", "slide title", "title placeholder", "ppt"]
},
{
    "name": "Slide.SlideIndex (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "longIndex = slideObject.SlideIndex",
    "description": "傳回指定 Slide 物件在 Slides 集合中的索引編號。此屬性是唯讀的。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\n' ' Set pptSlide = ActiveWindow.View.Slide ' Get current slide in view\n' If Not pptSlide Is Nothing Then\n'   MsgBox \"目前投影片的索引號是: \" & pptSlide.SlideIndex\n' End If", "explanation": "顯示目前檢視中投影片的索引編號 (位置)。"}
    ],
    "keywords": ["powerpoint", "投影片索引", "幻燈片編號", "slide number", "slide position", "ppt"]
},
{
    "name": "TextFrame.TextRange Property (PowerPoint/Word/Excel Shape)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set txtRange = shapeObject.TextFrame.TextRange",
    "description": "傳回一個 TextRange 物件，代表指定圖案文字框內的文字。",
    "parameters": [],
    "examples": [
        {"code": "Dim shp As Object ' PowerPoint.Shape, Word.Shape, or Excel.Shape\nDim tr As Object  ' TextRange (PowerPoint) or Range (Word)\n' ' Assume shp is a shape object with text\n' If shp.HasTextFrame Then\n'   If shp.TextFrame.HasText Then\n'     Set tr = shp.TextFrame.TextRange ' For PowerPoint\n'     ' For Word (Shape): Set tr = shp.TextFrame.TextRange (this is a Word Range)\n'     ' For Excel (Shape): Set tr = shp.TextFrame.Characters (this is an Excel Characters object)\n'     tr.Font.Bold = True\n'     tr.Text = \"Updated Text in Shape\"\n'     MsgBox \"圖案文字已更新並設為粗體。\"\n'   End If\n' End If", "explanation": "獲取圖案文字框中的 TextRange (PowerPoint) 或等效物件，並修改其文字和格式。注意不同應用程式中 TextFrame 下的文字物件可能不同。"}
    ],
    "keywords": ["textframe", "textrange", "shape text", "文字框", "文字範圍", "圖案文字", "powerpoint", "word", "excel", "通用"]
},
{
    "name": "Application.ActiveWindow (Excel/Word/PowerPoint)",
    "category": "綜合應用案例與技巧",
    "syntax": "Set actWindow = Application.ActiveWindow",
    "description": "傳回一個代表前景 (活動) 視窗的 Window 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim currentWindow As Object\n' In Excel:\n' Set currentWindow = Application.ActiveWindow\n' If Not currentWindow Is Nothing Then MsgBox \"Excel 活動視窗標題: \" & currentWindow.Caption\n' In Word:\n' Set currentWindow = Application.ActiveWindow\n' If Not currentWindow Is Nothing Then MsgBox \"Word 活動視窗標題: \" & currentWindow.Caption\n' In PowerPoint:\n' Set currentWindow = Application.ActiveWindow\n' If Not currentWindow Is Nothing Then MsgBox \"PPT 活動視窗標題: \" & currentWindow.Caption", "explanation": "獲取目前 Office 應用程式的活動視窗物件，並顯示其標題。"}
    ],
    "keywords": ["活動視窗", "當前視窗", "active window", "current window", "excel", "word", "powerpoint", "通用"]
},
{
    "name": "Window.Activate (Excel/Word/PowerPoint)",
    "category": "綜合應用案例與技巧",
    "syntax": "windowObject.Activate",
    "description": "啟用指定的視窗，使其成為前景視窗。",
    "parameters": [],
    "examples": [
        {"code": "' In Excel, if multiple workbooks are open:\n' If Application.Windows.Count > 1 Then\n'   Application.Windows(2).Activate ' Activate the second window in the collection\n'   MsgBox Application.Windows(2).Caption & \" 已啟用。\"\n' End If", "explanation": "如果 Excel 中開啟了多個視窗，則啟用視窗集合中的第二個視窗。"}
    ],
    "keywords": ["啟用視窗", "切換視窗", "activate window", "switch window", "excel", "word", "powerpoint", "通用"]
},
{
    "name": "Window.WindowState (Excel/Word/PowerPoint)",
    "category": "綜合應用案例與技巧",
    "syntax": "windowObject.WindowState = xlNormal | xlMinimized | xlMaximized ' (Excel constants)\n' wdWindowStateNormal | wdWindowStateMinimize | wdWindowStateMaximize ' (Word constants)\n' ppWindowNormal | ppWindowMinimized | ppWindowMaximized ' (PowerPoint constants)",
    "description": "設定或傳回特定視窗的狀態 (正常、最小化、最大化)。",
    "parameters": [
        {"name": "Constants", "description": "特定於應用程式的視窗狀態常數。"}
    ],
    "examples": [
        {"code": "' In Excel:\n' Dim targetWindow As Window\n' Set targetWindow = Application.Windows(\"MyWorkbook.xlsx\") ' Get specific window by caption\n' If Not targetWindow Is Nothing Then\n'   If targetWindow.WindowState <> xlMaximized Then\n'     targetWindow.WindowState = xlMaximized\n'     MsgBox \"視窗 '\" & targetWindow.Caption & \"' 已最大化。\"\n'   End If\n' End If", "explanation": "如果名為 \"MyWorkbook.xlsx\" 的 Excel 視窗未最大化，則將其最大化。"}
    ],
    "keywords": ["視窗狀態", "文件視窗", "window state", "document window", "excel", "word", "powerpoint", "通用"]
},
{
    "name": "Application.Quit (Excel/Word/PowerPoint)",
    "category": "綜合應用案例與技巧",
    "syntax": "Application.Quit",
    "description": "關閉 Microsoft Office 應用程式。如果有關鍵文件未儲存，通常會提示使用者儲存。",
    "parameters": [],
    "examples": [
        {"code": "' Dim wdApp As Object\n' Set wdApp = CreateObject(\"Word.Application\")\n' ' ... do some work with wdApp ...\n' If wdApp.Documents.Count = 0 Then ' Only quit if no documents are open (or save them first)\n'   wdApp.Quit\n'   Set wdApp = Nothing\n'   MsgBox \"Word 應用程式已關閉 (如果沒有開啟的文件)。\"\n' Else\n'   MsgBox \"Word 中仍有開啟的文件，未自動關閉應用程式。\"\n' End If", "explanation": "演示如何安全地嘗試關閉 Word 應用程式，前提是沒有文件處於開啟狀態（或已處理儲存）。"}
    ],
    "keywords": ["關閉應用程式", "退出程式", "quit application", "exit program", "excel", "word", "powerpoint", "通用"]
},
{
    "name": "SendKeys Statement",
    "category": "綜合應用案例與技巧",
    "syntax": "SendKeys string, [wait As Boolean = False]",
    "description": "將一個或多個按鍵傳送到活動視窗，如同它們是從鍵盤輸入的一樣。應謹慎使用，因為它依賴於活動視窗的焦點，可能不可靠。",
    "parameters": [
        {"name": "string", "description": "必需。要傳送的按鍵字串。"},
        {"name": "wait", "description": "可選。True 表示 VBA 等待按鍵處理完畢後再繼續。"}
    ],
    "examples": [
        {"code": "' Example: Open Notepad and type something (USE WITH CAUTION)\n' Shell \"NOTEPAD.EXE\", vbNormalFocus\n' Application.Wait Now + TimeValue(\"00:00:01\") ' Wait for Notepad to open\n' SendKeys \"Hello from VBA!\", True\n' SendKeys \"%FA\" ' Send Alt+F, then A (File > Save As, assuming English Notepad)", "explanation": "啟動記事本，等待1秒，然後嘗試在其中輸入文字，並模擬按下 Alt+F (檔案菜單) 和 A (另存為)。SendKeys 非常依賴時序和視窗焦點，通常不是自動化的首選方法。"}
    ],
    "keywords": ["模擬按鍵", "鍵盤輸入", "sendkeys", "simulate keystrokes", "keyboard input", "automation caution", "其他"]
},
// Excel Core Operations
{
    "name": "Range.FormulaR1C1",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaR1C1 [= string]",
    "description": "讀取或設定儲存格的公式 (R1C1 參照樣式)。",
    "parameters": [{"name": "string", "description": "可選。要設定的 R1C1 樣式公式字串。"}],
    "examples": [
        {"code": "Range(\"C1\").FormulaR1C1 = \"=RC[-2]+RC[-1]\" ' Equivalent to =A1+B1 in C1", "explanation": "在 C1 儲存格中設定 R1C1 樣式的公式，表示同一列左邊兩格的值加上同一列左邊一格的值。"},
        {"code": "MsgBox Range(\"A2\").FormulaR1C1 ' Displays R1C1 formula of A2", "explanation": "顯示 A2 儲存格的 R1C1 樣式公式。"}
    ],
    "keywords": ["公式R1C1", "R1C1參照", "excel", "formula r1c1", "r1c1 reference"]
},
{
    "name": "Range.HasFormula",
    "category": "Excel 核心操作",
    "syntax": "booleanResult = rangeObject.HasFormula",
    "description": "如果範圍中的所有儲存格都包含公式，則傳回 True；如果沒有一個儲存格包含公式，則傳回 False；否則傳回 Null。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=1+1\"\nRange(\"A2\").Value = 10\nIf Range(\"A1\").HasFormula Then MsgBox \"A1 包含公式。\"\nIf Not Range(\"A2\").HasFormula Then MsgBox \"A2 不包含公式 (值為False)。\"", "explanation": "檢查儲存格是否包含公式。"}
    ],
    "keywords": ["檢查公式", "是否有公式", "excel", "hasformula", "cell formula check"]
},
{
    "name": "Range.Count",
    "category": "Excel 核心操作",
    "syntax": "longCount = rangeObject.Count",
    "description": "傳回指定範圍中的儲存格數量。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox Range(\"A1:C5\").Count ' 傳回 15 (3 欄 * 5 列)", "explanation": "計算範圍 A1:C5 中的儲存格總數。"}
    ],
    "keywords": ["儲存格計數", "範圍大小", "excel", "cell count", "range size"]
},
{
    "name": "Range.Rows.Count",
    "category": "Excel 核心操作",
    "syntax": "longRowCount = rangeObject.Rows.Count",
    "description": "傳回指定範圍中的列數。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox Range(\"A1:C5\").Rows.Count ' 傳回 5", "explanation": "計算範圍 A1:C5 中的列數。"}
    ],
    "keywords": ["列數", "範圍列數", "excel", "row count", "number of rows"]
},
{
    "name": "Range.Columns.Count",
    "category": "Excel 核心操作",
    "syntax": "longColumnCount = rangeObject.Columns.Count",
    "description": "傳回指定範圍中的欄數。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox Range(\"A1:C5\").Columns.Count ' 傳回 3", "explanation": "計算範圍 A1:C5 中的欄數。"}
    ],
    "keywords": ["欄數", "範圍欄數", "excel", "column count", "number of columns"]
},
{
    "name": "Range.Hidden",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Hidden = True | False",
    "description": "如果範圍的列或列 (或範圍本身) 是隱藏的，則為 True。通常用於檢查 Range.EntireRow.Hidden 或 Range.EntireColumn.Hidden。",
    "parameters": [],
    "examples": [
        {"code": "Columns(\"B\").Hidden = True\nIf Columns(\"B\").Hidden Then MsgBox \"B欄已隱藏。\"\nColumns(\"B\").Hidden = False", "explanation": "隱藏B欄，檢查其隱藏狀態，然後再取消隱藏。"}
    ],
    "keywords": ["隱藏欄", "隱藏列", "檢查隱藏", "excel", "hide column", "hide row", "is hidden"]
},
{
    "name": "Range.HorizontalAlignment",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.HorizontalAlignment = XlHAlignConstant",
    "description": "設定或傳回物件的水平對齊方式。",
    "parameters": [{"name": "XlHAlignConstant", "description": "例如 xlLeft, xlCenter, xlRight, xlJustify, xlDistributed。"}],
    "examples": [
        {"code": "Range(\"A1\").Value = \"置中文字\"\nRange(\"A1\").HorizontalAlignment = xlCenter", "explanation": "將儲存格A1中的文字設定為水平置中。"}
    ],
    "keywords": ["水平對齊", "儲存格對齊", "excel", "horizontal alignment", "text align"]
},
{
    "name": "Range.VerticalAlignment",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.VerticalAlignment = XlVAlignConstant",
    "description": "設定或傳回物件的垂直對齊方式。",
    "parameters": [{"name": "XlVAlignConstant", "description": "例如 xlTop, xlCenter, xlBottom, xlJustify, xlDistributed。"}],
    "examples": [
        {"code": "Range(\"A1\").RowHeight = 50\nRange(\"A1\").Value = \"垂直置中\"\nRange(\"A1\").VerticalAlignment = xlCenter", "explanation": "增加A1的列高並將其內容設定為垂直置中。"}
    ],
    "keywords": ["垂直對齊", "儲存格對齊", "excel", "vertical alignment", "text align"]
},
{
    "name": "Range.WrapText",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.WrapText = True | False",
    "description": "如果 Microsoft Excel 自動換行物件中的文字，則為 True。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").ColumnWidth = 10\nRange(\"A1\").Value = \"這是一段需要自動換行的長文字。\"\nRange(\"A1\").WrapText = True", "explanation": "在A1儲存格中啟用自動換行以顯示長文字。"}
    ],
    "keywords": ["自動換行", "儲存格文字", "excel", "wrap text", "cell text wrapping"]
},
{
    "name": "Range.MergeCells",
    "category": "Excel 核心操作",
    "syntax": "booleanResult = rangeObject.MergeCells",
    "description": "如果範圍包含合併儲存格，則為 True。讀取或設定。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1:B1\").Merge\nIf Range(\"A1\").MergeCells Then MsgBox \"A1是合併儲存格的一部分。\"\nRange(\"A1:B1\").UnMerge\nRange(\"A1\").MergeCells = True ' Another way to merge (if A1 is a multi-cell range variable)", "explanation": "合併A1:B1，然後檢查A1的MergeCells屬性。也可以直接設定此屬性來合併 (如果rangeObject已是多儲存格)。"}
    ],
    "keywords": ["是否合併", "檢查合併", "excel", "is merged", "check merged cells"]
},
{
    "name": "Worksheet.ProtectContents",
    "category": "Excel 核心操作",
    "syntax": "booleanResult = worksheetObject.ProtectContents",
    "description": "如果工作表的內容受保護，則為 True。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Protect Password:=\"pw\"\nIf ActiveSheet.ProtectContents Then MsgBox \"工作表內容已受保護。\"\nActiveSheet.Unprotect Password:=\"pw\"", "explanation": "保護工作表內容，然後檢查ProtectContents屬性。"}
    ],
    "keywords": ["內容保護", "檢查保護", "excel", "sheet protected", "is protected"]
},
{
    "name": "Workbook.ReadOnly",
    "category": "Excel 核心操作",
    "syntax": "booleanResult = workbookObject.ReadOnly",
    "description": "如果物件是以唯讀模式開啟的，則為 True。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim wb As Workbook\n' Set wb = Workbooks.Open(\"C:\\MyFile.xlsx\", ReadOnly:=True)\n' If wb.ReadOnly Then MsgBox wb.Name & \" 是以唯讀模式開啟的。\"", "explanation": "以唯讀模式開啟一個活頁簿，然後檢查其ReadOnly屬性。"}
    ],
    "keywords": ["唯讀", "檢查唯讀", "excel", "is readonly", "workbook readonly"]
},
{
    "name": "Application.ActivePrinter",
    "category": "Excel 核心操作",
    "syntax": "Application.ActivePrinter [= printerNameString]",
    "description": "設定或傳回作用中印表機的名稱。",
    "parameters": [{"name": "printerNameString", "description": "印表機的名稱，如 \"HP LaserJet on Ne01:\"。"}],
    "examples": [
        {"code": "Dim currentPrinter As String\ncurrentPrinter = Application.ActivePrinter\nMsgBox \"目前的作用中印表機是: \" & currentPrinter\n' Application.ActivePrinter = \"Microsoft Print to PDF on Ne02:\" ' Change active printer (requires exact name)", "explanation": "獲取目前作用中印表機的名稱，並示範如何更改它（需要印表機的確切系統名稱）。"}
    ],
    "keywords": ["作用中印表機", "印表機設定", "excel", "active printer", "set printer"]
},
{
    "name": "Workbook.FullName",
    "category": "Excel 核心操作",
    "syntax": "stringFullName = workbookObject.FullName",
    "description": "傳回物件的名稱，包括其在磁碟上的路徑。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox ThisWorkbook.FullName", "explanation": "顯示目前執行程式碼的活頁簿的完整路徑和名稱。"}
    ],
    "keywords": ["完整名稱", "檔案路徑", "excel", "workbook full name", "file path"]
},
{
    "name": "Workbook.Path",
    "category": "Excel 核心操作",
    "syntax": "stringPath = workbookObject.Path",
    "description": "傳回物件的路徑 (不含最後的分隔符號和物件本身的名稱)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "If ThisWorkbook.Path <> \"\" Then\n  MsgBox \"此活頁簿的路徑是: \" & ThisWorkbook.Path\nElse\n  MsgBox \"此活頁簿尚未儲存，沒有路徑。\"\nEnd If", "explanation": "顯示目前活頁簿的儲存路徑 (如果已儲存)。"}
    ],
    "keywords": ["路徑", "檔案目錄", "excel", "workbook path", "file directory"]
},
// String & Text Manipulation
{
    "name": "vbTab",
    "category": "字串與文本操作",
    "syntax": "vbTab",
    "description": "一個內建常數，代表定位字元 (ASCII 字元碼 9)。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"Name:\" & vbTab & \"John Doe\" & vbCrLf & \"Age:\" & vbTab & \"30\"", "explanation": "使用 vbTab 在訊息框中對齊文字。"},
        {"code": "Dim fileNum As Integer: fileNum = FreeFile\nOpen \"C:\\Temp\\TabbedData.txt\" For Output As #fileNum\nPrint #fileNum, \"Column1\" & vbTab & \"Column2\" & vbTab & \"Column3\"\nPrint #fileNum, \"Data1A\" & vbTab & \"Data1B\" & vbTab & \"Data1C\"\nClose #fileNum", "explanation": "寫入一個以 Tab 分隔的文字檔案。"}
    ],
    "keywords": ["定位字元", "製表符", "字串常數", "tab character", "vbconstants"]
},
{
    "name": "vbNullString",
    "category": "字串與文本操作",
    "syntax": "vbNullString",
    "description": "一個內建常數，代表空字串 \"\" 的特殊形式 (一個 null 指標字串)。在某些 API 呼叫中可能比 \"\" 更有效率。",
    "parameters": [],
    "examples": [
        {"code": "Dim s As String\ns = vbNullString\nIf s = \"\" Then MsgBox \"vbNullString 等同於空字串 \"\"\"。\n' 主要用於API調用時表示空字串指標", "explanation": "演示 vbNullString 等同於空字串 \"\"。它在傳遞給某些外部 API 函數時有特定的用途。"}
    ],
    "keywords": ["空字串", "null字串", "vbconstants", "empty string", "null string pointer"]
},
// Program Flow & Structure Control
{
    "name": "Rem Statement",
    "category": "程式流程與結構控制",
    "syntax": "Rem comment\n' comment",
    "description": "用於在程式碼中加入註解。以 Rem 或單引號 (') 開頭的該行後面的文字都會被視為註解，不會被執行。",
    "parameters": [{"name": "comment", "description": "要加入的註解文字。"}],
    "examples": [
        {"code": "Rem 這是一個使用 Rem 的註解。\nDim x As Integer ' 這是一個行尾註解，解釋變數 x。\nx = 10 ' 設定 x 的值", "explanation": "示範兩種加入註解的方式：使用 Rem 關鍵字和使用單引號。"}
    ],
    "keywords": ["註解", "說明", "程式碼註解", "comment", "remark", "documentation"]
},
{
    "name": "Resume Statement",
    "category": "錯誤處理與調試",
    "syntax": "Resume | Resume Next | Resume line",
    "description": "在錯誤處理常式完成後，繼續執行程式。",
    "parameters": [
        {"name": "Resume", "description": "從導致錯誤的語句重新開始執行。"},
        {"name": "Resume Next", "description": "從緊隨導致錯誤的語句之後的語句重新開始執行。"},
        {"name": "Resume line", "description": "在錯誤處理常式所在的過程中，於指定的行標籤或行號處重新開始執行。"}
    ],
    "examples": [
        {"code": "Sub ResumeExample()\n  On Error GoTo ErrorHandler\n  Dim x As Integer: x = 10\n  Dim y As Integer: y = 0\n  Dim z As Integer\nTryAgain:\n  z = x / y\n  MsgBox \"Result: \" & z\n  Exit Sub\nErrorHandler:\n  If Err.Number = 11 Then ' Division by zero\n    MsgBox \"除數為零。請修正。\"\n    y = CInt(InputBox(\"請輸入一個非零的 y 值:\"))\n    If y <> 0 Then Resume TryAgain ' 從 TryAgain 標籤重新開始\n    ' Resume ' 如果不修正，可以 Resume (會再次出錯) 或 Resume Next (可能會導致邏輯錯誤)\n  Else\n    MsgBox \"發生未預期的錯誤: \" & Err.Description\n  End If\nEnd Sub", "explanation": "演示如何使用 Resume line (TryAgain) 在錯誤處理後重新嘗試操作。Resume Next 應謹慎使用。"}
    ],
    "keywords": ["錯誤處理", "繼續執行", "resume statement", "error handling", "continue execution"]
},
// Outlook
{
    "name": "NameSpace.Logon (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "olNamespace.Logon([Profile], [Password], [ShowDialog As Boolean = True], [NewSession As Boolean = True])",
    "description": "登入到 MAPI，建立一個新的 MAPI 工作階段。如果 Outlook 已經在執行，Logon 通常不需要明確呼叫，因為 GetNamespace 會隱含地處理。",
    "parameters": [
        {"name": "Profile", "description": "可選。要使用的設定檔名稱 (字串)。"},
        {"name": "Password", "description": "可選。設定檔的密碼 (字串)。"},
        {"name": "ShowDialog", "description": "可選。True 表示顯示 Outlook 登入對話框。"},
        {"name": "NewSession", "description": "可選。True 表示建立新的 Outlook 工作階段。"}
    ],
    "examples": [
        {"code": "Dim olApp As Object, olNS As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olNS = olApp.GetNamespace(\"MAPI\")\n' olNS.Logon \"MyOutlookProfile\", \"MyPassword\", False, True ' Example, usually not needed if Outlook is configured\nMsgBox \"已登入到 MAPI 使用者: \" & olNS.CurrentUser.Name", "explanation": "獲取 MAPI 命名空間。通常情況下，如果 Outlook 設定檔已正確設定，則不需要明確呼叫 Logon 方法。CurrentUser 屬性可以用來確認登入的使用者。"}
    ],
    "keywords": ["outlook logon", "mapi session", "outlook profile", "登入Outlook", "MAPI工作階段"]
},
{
    "name": "NameSpace.Logoff (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "olNamespace.Logoff",
    "description": "結束目前的 MAPI 工作階段。呼叫 Logoff 後，通常需要將 Outlook Application 物件設為 Nothing 以完全釋放資源。",
    "parameters": [],
    "examples": [
        {"code": "Dim olApp As Object, olNS As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olNS = olApp.GetNamespace(\"MAPI\")\n' ... do work with Outlook objects ...\nMsgBox \"準備登出 MAPI 工作階段。\"\n' olNS.Logoff\n' Set olNS = Nothing\n' Set olApp = Nothing ' Important to release the application object\n' MsgBox \"MAPI 工作階段已登出，Outlook物件已釋放。\"", "explanation": "在完成所有 Outlook 操作後，呼叫 Logoff 結束 MAPI 會話，然後釋放相關的 Outlook 物件。"}
    ],
    "keywords": ["outlook logoff", "end mapi session", "登出Outlook", "結束MAPI會話"]
},
{
    "name": "MAPIFolder.Folders (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set subFoldersCollection = parentMAPIFolderObject.Folders",
    "description": "傳回一個 Folders 集合，代表指定 MAPIFolder 物件中包含的所有子資料夾。",
    "parameters": [],
    "examples": [
        {"code": "Dim olNS As Object, olInbox As Object, subFolder As Object\nSet olNS = CreateObject(\"Outlook.Application\").GetNamespace(\"MAPI\")\nSet olInbox = olNS.GetDefaultFolder(6) ' olFolderInbox\nIf olInbox.Folders.Count > 0 Then\n  MsgBox \"收件匣中的第一個子資料夾是: \" & olInbox.Folders(1).Name\n  For Each subFolder In olInbox.Folders\n    Debug.Print \"子資料夾: \" & subFolder.Name & \" (路徑: \" & subFolder.FolderPath & \")\"\n  Next subFolder\nElse\n  MsgBox \"收件匣沒有子資料夾。\"\nEnd If", "explanation": "獲取收件匣資料夾，然後遍歷並列印其所有直接子資料夾的名稱和路徑。"}
    ],
    "keywords": ["outlook subfolders", "list folders", "folder collection", "子資料夾", "資料夾列表"]
},
{
    "name": "Items.Sort (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "itemsCollection.Sort(Property As String, [Descending As Boolean = False])",
    "description": "依照指定的屬性對 Items 集合進行排序。",
    "parameters": [
        {"name": "Property", "description": "必需。要排序的項目屬性名稱 (字串，例如 \"ReceivedTime\", \"Subject\", \"SenderName\")。"},
        {"name": "Descending", "description": "可選。True 表示降冪排序，False (預設) 表示升冪排序。"}
    ],
    "examples": [
        {"code": "Dim olInbox As Object, sortedItems As Object, mail As Object\nSet olInbox = CreateObject(\"Outlook.Application\").GetNamespace(\"MAPI\").GetDefaultFolder(6)\nSet sortedItems = olInbox.Items\nsortedItems.Sort \"[ReceivedTime]\", True ' Sort by ReceivedTime, descending (newest first)\n' Display first 5 newest emails\nDim count As Integer: count = 0\nFor Each mail In sortedItems\n  If TypeName(mail) = \"MailItem\" Then\n    Debug.Print mail.Subject & \" - \" & mail.ReceivedTime\n    count = count + 1\n    If count >= 5 Then Exit For\n  End If\nNext mail", "explanation": "獲取收件匣項目，按接收時間降冪排序，然後列印最新的5封郵件的主旨和接收時間。"}
    ],
    "keywords": ["outlook sort items", "sort emails", "order items", "排序郵件", "項目排序"]
},
{
    "name": "MailItem.Importance",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.Importance = OlImportanceConstant\nlevel = mailItemObject.Importance",
    "description": "設定或傳回一個 OlImportance 常數，表示 Outlook 項目的相對重要性層級。",
    "parameters": [
        {"name": "OlImportanceConstant", "description": "olImportanceLow (0), olImportanceNormal (1), olImportanceHigh (2)。"}
    ],
    "examples": [
        {"code": "Dim olMail As Object\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0) ' olMailItem\nolMail.Subject = \"緊急通知\"\nolMail.Importance = 2 ' olImportanceHigh\nolMail.Display\nMsgBox \"郵件重要性已設為: \" & olMail.Importance", "explanation": "建立一封新郵件，將其重要性設定為高 (olImportanceHigh)，然後顯示該郵件。"}
    ],
    "keywords": ["outlook email importance", "priority", "high importance", "郵件重要性", "優先級"]
},
{
    "name": "MailItem.Sensitivity",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.Sensitivity = OlSensitivityConstant\nlevel = mailItemObject.Sensitivity",
    "description": "設定或傳回一個 OlSensitivity 常數，表示 Outlook 項目的敏感度。",
    "parameters": [
        {"name": "OlSensitivityConstant", "description": "olNormal (0), olPersonal (1), olPrivate (2), olConfidential (3)。"}
    ],
    "examples": [
        {"code": "Dim olMail As Object\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.Subject = \"機密文件\"\nolMail.Sensitivity = 3 ' olConfidential\nolMail.Display\nMsgBox \"郵件敏感度已設為: \" & olMail.Sensitivity", "explanation": "建立一封新郵件，將其敏感度設定為機密 (olConfidential)，然後顯示該郵件。"}
    ],
    "keywords": ["outlook email sensitivity", "confidential email", "private email", "郵件敏感度", "機密郵件"]
},
// Word
{
    "name": "Paragraphs.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newPara = documentOrRangeObject.Paragraphs.Add([Range])",
    "description": "在指定的範圍之前或集合的末尾新增一個新的空白段落，並傳回代表該新段落的 Paragraph 物件。",
    "parameters": [
        {"name": "Range", "description": "可選。Range 物件，新段落將新增於其前。如果省略，則新增到集合的末尾 (或文件/選取範圍的末尾)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, newP As Object ' Word.Paragraph\n' Set wdDoc = ActiveDocument\n' Set newP = wdDoc.Paragraphs.Add ' Adds a new paragraph at the end of the document\n' newP.Range.Text = \"這是一個新增加的段落。\"\n' newP.Range.Font.Italic = True", "explanation": "在活動文件的末尾新增一個新段落，設定其文字內容並將字型設為斜體。"}
    ],
    "keywords": ["word add paragraph", "new paragraph", "insert paragraph", "新增段落"]
},
{
    "name": "Paragraph.Alignment (Word)",
    "category": "Word 文件處理",
    "syntax": "paragraphObject.Alignment = WdParagraphAlignmentConstant",
    "description": "設定或傳回指定段落的對齊方式。",
    "parameters": [
        {"name": "WdParagraphAlignmentConstant", "description": "例如 wdAlignParagraphLeft (0), wdAlignParagraphCenter (1), wdAlignParagraphRight (2), wdAlignParagraphJustify (3)。"}
    ],
    "examples": [
        {"code": "Dim firstPara As Object ' Word.Paragraph\n' Set firstPara = ActiveDocument.Paragraphs(1)\n' firstPara.Alignment = 1 ' wdAlignParagraphCenter", "explanation": "將文件第一個段落的對齊方式設定為置中。"}
    ],
    "keywords": ["word paragraph alignment", "text align word", "段落對齊", "文字對齊"]
},
{
    "name": "Paragraph.Style (Word)",
    "category": "Word 文件處理",
    "syntax": "paragraphObject.Style = styleObjectOrName",
    "description": "設定或傳回指定物件的樣式。",
    "parameters": [
        {"name": "styleObjectOrName", "description": "Style 物件或樣式的名稱 (字串)。"}
    ],
    "examples": [
        {"code": "Dim para As Object ' Word.Paragraph\n' Set para = ActiveDocument.Content.Paragraphs.Add\n' para.Range.Text = \"我的標題\"\n' para.Style = \"標題 1\" ' Apply \"Heading 1\" style", "explanation": "新增一個段落，設定其文字，然後套用 \"標題 1\" 樣式。"}
    ],
    "keywords": ["word paragraph style", "apply style", "段落樣式", "套用樣式"]
},
// PowerPoint
{
    "name": "Slide.Layout (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideObject.Layout = PpSlideLayoutConstant",
    "description": "設定或傳回一個 PpSlideLayout 常數，代表投影片的版面配置。",
    "parameters": [
        {"name": "PpSlideLayoutConstant", "description": "例如 ppLayoutTitle (1), ppLayoutText (2), ppLayoutBlank (12)。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\n' Set pptSlide = ActivePresentation.Slides(1)\n' pptSlide.Layout = 1 ' ppLayoutTitle (set to Title Slide layout)\n' MsgBox \"第一張投影片的版面配置已設為標題版面。\"", "explanation": "將第一張投影片的版面配置更改為標題投影片版面。"}
    ],
    "keywords": ["powerpoint slide layout", "change layout", "投影片版面配置", "更改版面"]
},
{
    "name": "Slide.Shapes.Count (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "longCount = slideObject.Shapes.Count",
    "description": "傳回指定投影片上圖案的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\n' Set pptSlide = ActivePresentation.Slides(1)\n' MsgBox \"第一張投影片上有 \" & pptSlide.Shapes.Count & \" 個圖案。\"", "explanation": "顯示第一張投影片上圖案的總數。"}
    ],
    "keywords": ["powerpoint shape count", "number of shapes", "圖案數量"]
},
{
    "name": "Shape.Name Property (PowerPoint/Word/Excel)",
    "category": "PowerPoint 簡報製作",
    "syntax": "shapeObject.Name [= stringName]",
    "description": "設定或傳回圖案的名稱。",
    "parameters": [{"name": "stringName", "description": "圖案的新名稱。"}],
    "examples": [
        {"code": "Dim shp As Object ' PowerPoint.Shape\n' Set shp = ActivePresentation.Slides(1).Shapes.AddTextbox(1, 50, 50, 200, 30) ' 1=msoTextOrientationHorizontal\n' shp.Name = \"MyTextBox1\"\n' MsgBox \"新增的文字方塊名稱是: \" & shp.Name", "explanation": "在 PowerPoint 投影片上新增一個文字方塊並設定其名稱。"}
    ],
    "keywords": ["shape name", "object name", "圖案名稱", "物件命名", "powerpoint", "word", "excel", "通用"]
},
{
    "name": "Presentation.SlideMaster (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set sm = presentationObject.SlideMaster",
    "description": "傳回代表簡報投影片母片的 Master 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\nDim slideMaster As Object ' PowerPoint.Master\n' Set pptPres = ActivePresentation\n' Set slideMaster = pptPres.SlideMaster\n' ' Example: Add a footer text to the slide master\n' On Error Resume Next ' In case footer placeholder doesn't exist\n' slideMaster.HeadersFooters.Footer.Text = \"公司機密\"\n' slideMaster.HeadersFooters.Footer.Visible = msoTrue\n' On Error GoTo 0\n' MsgBox \"投影片母片頁尾已嘗試更新。\"", "explanation": "獲取簡報的投影片母片，並嘗試在其頁尾新增文字。"}
    ],
    "keywords": ["powerpoint slide master", "master slide", "投影片母片", "母片格式"]
},
// FSO
{
    "name": "FileSystemObject.GetDriveName",
    "category": "檔案與資料夾管理",
    "syntax": "driveNameString = fso.GetDriveName(Path)",
    "description": "從指定的路徑傳回磁碟機的名稱 (例如 \"C:\")。",
    "parameters": [{"name": "Path", "description": "必需。路徑規格。"}],
    "examples": [
        {"code": "Dim fso As Object, drive As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\ndrive = fso.GetDriveName(\"C:\\Windows\\System32\\notepad.exe\")\nMsgBox \"磁碟機名稱是: \" & drive ' 傳回 \"C:\"", "explanation": "從完整檔案路徑中提取磁碟機名稱。"}
    ],
    "keywords": ["fso", "獲取磁碟機名", "磁碟機字母", "get drive letter", "drive name"]
},
{
    "name": "TextStream.Write (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "textStreamObject.Write(String)",
    "description": "將指定的字串寫入 TextStream 檔案。不自動新增換行符。",
    "parameters": [{"name": "String", "description": "必需。要寫入檔案的文字。"}],
    "examples": [
        {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.CreateTextFile(\"C:\\Temp\\MyData.txt\", True)\nts.Write \"第一部分,\"\nts.Write \"第二部分.\"\nts.WriteBlankLines 1 ' Add a newline\nts.Write \"新的一行。\"\nts.Close", "explanation": "使用 Write 方法將多個字串片段寫入檔案的同一行，然後使用 WriteBlankLines 換行。"}
    ],
    "keywords": ["fso", "寫入文字", "文字檔案", "textstream write", "write string to file"]
},
// Math
{
    "name": "WorksheetFunction.Pi",
    "category": "數學、日期與時間",
    "syntax": "piValue = Application.WorksheetFunction.Pi()",
    "description": "傳回圓周率 PI (π) 的值，約為 3.14159265358979。",
    "parameters": [],
    "examples": [
        {"code": "Dim circleArea As Double, radius As Double\nradius = 5\ncircleArea = Application.WorksheetFunction.Pi() * radius ^ 2\nMsgBox \"半徑為 \" & radius & \" 的圓面積約為: \" & Format(circleArea, \"0.00\")", "explanation": "使用 Pi 函數計算圓的面積。"}
    ],
    "keywords": ["pi", "圓周率", "數學常數", "math constant", "circle"]
},
{
    "name": "WorksheetFunction.Degrees",
    "category": "數學、日期與時間",
    "syntax": "degreeValue = Application.WorksheetFunction.Degrees(Radians)",
    "description": "將弧度轉換為度。",
    "parameters": [{"name": "Radians", "description": "必需。要轉換為度的弧度值。"}],
    "examples": [
        {"code": "Dim radiansAngle As Double: radiansAngle = 1.5708 ' Approx Pi/2\nDim degreesAngle As Double\ndegreesAngle = Application.WorksheetFunction.Degrees(radiansAngle)\nMsgBox radiansAngle & \" 弧度約等於 \" & Format(degreesAngle, \"0.00\") & \" 度。\"", "explanation": "將弧度值 (約 Pi/2) 轉換為度 (約 90 度)。"}
    ],
    "keywords": ["弧度轉度", "角度轉換", "degrees conversion", "radians to degrees"]
},
{
    "name": "WorksheetFunction.Radians",
    "category": "數學、日期與時間",
    "syntax": "radianValue = Application.WorksheetFunction.Radians(Degrees)",
    "description": "將度轉換為弧度。",
    "parameters": [{"name": "Degrees", "description": "必需。要轉換為弧度的度數值。"}],
    "examples": [
        {"code": "Dim degreesAngle As Double: degreesAngle = 180\nDim radiansAngle As Double\nradiansAngle = Application.WorksheetFunction.Radians(degreesAngle)\nMsgBox degreesAngle & \" 度等於 \" & Format(radiansAngle, \"0.0000\") & \" 弧度 (約 Pi)。\"", "explanation": "將 180 度轉換為弧度 (約 Pi)。"}
    ],
    "keywords": ["度轉弧度", "角度轉換", "radians conversion", "degrees to radians"]
},
// Array
{
    "name": "IsArray Empty Check",
    "category": "陣列、集合與字典",
    "syntax": "If Not IsArray(arrName) Or UBound(arrName) < LBound(arrName) Then ...",
    "description": "檢查一個 Variant 變數是否為已宣告但未初始化 (即未 ReDim) 或空的陣列。對於未初始化的動態陣列，UBound 會產生錯誤，所以需要先 IsArray。",
    "parameters": [{"name": "arrName", "description": "要檢查的陣列變數名 (通常是 Variant 或動態陣列)。"}],
    "examples": [
        {"code": "Dim dynArray() As String ' Declared but not initialized\nDim initArray(1 To 5) As Integer\nDim emptyArray() As String: ReDim emptyArray(1 To 0) ' Initialized but UBound < LBound\n\nIf Not IsArrayInitialized(dynArray) Then Debug.Print \"dynArray 未初始化或為空。\"\nIf IsArrayInitialized(initArray) Then Debug.Print \"initArray 已初始化且非空。\"\nIf Not IsArrayInitialized(emptyArray) Then Debug.Print \"emptyArray (ReDim 1 To 0) 被視為空。\"\n\nFunction IsArrayInitialized(arr As Variant) As Boolean\n  IsArrayInitialized = False\n  If Not IsArray(arr) Then Exit Function ' Not even an array\n  On Error Resume Next ' To handle UBound on uninitialized array\n  IsArrayInitialized = (UBound(arr) >= LBound(arr))\n  On Error GoTo 0\nEnd Function", "explanation": "IsArrayInitialized 函數檢查傳入的 Variant 是否為一個已初始化且至少包含一個元素的陣列。對於剛宣告的動態陣列，UBound 會觸發錯誤，此函數會處理該情況。"}
    ],
    "keywords": ["檢查陣列空", "陣列初始化", "is array empty", "array initialized check", "ubound error"]
},
// More Excel Core
{
    "name": "Range.FormulaHidden",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaHidden [= True | False]",
    "description": "如果當工作表受保護時公式是隱藏的，則為 True。讀取/寫入。",
    "parameters": [{"name": "True | False", "description": "True 表示隱藏公式，False 表示顯示。"}],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=SUM(B1:B5)\"\nRange(\"A1\").FormulaHidden = True\nActiveSheet.Protect Password:=\"pass\"\n' Now, if Sheet1 is protected, the formula in A1 will not be visible in the formula bar.", "explanation": "設定A1儲存格的公式，將其FormulaHidden屬性設為True，然後保護工作表。"}
    ],
    "keywords": ["隱藏公式", "保護公式", "excel", "hide formula", "protect formula"]
},
{
    "name": "Range.Locked",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Locked [= True | False]",
    "description": "如果物件被鎖定，則為 True。當工作表受保護時，鎖定的儲存格無法修改。預設所有儲存格都是鎖定的。",
    "parameters": [{"name": "True | False", "description": "True 表示鎖定，False 表示解除鎖定。"}],
    "examples": [
        {"code": "Range(\"A1:A5\").Locked = False ' Unlock cells A1:A5\nRange(\"B1\").Locked = True ' Ensure B1 is locked (default)\nActiveSheet.Protect Password:=\"123\"\n' Now A1:A5 can be edited, but B1 cannot (if sheet is protected).", "explanation": "解除A1:A5儲存格的鎖定，然後保護工作表。這樣，A1:A5儲存格在工作表受保護時仍可編輯。"}
    ],
    "keywords": ["鎖定儲存格", "解除鎖定儲存格", "保護工作表", "excel", "lock cells", "unlock cells"]
},
{
    "name": "Range.Text",
    "category": "Excel 核心操作",
    "syntax": "stringResult = rangeObject.Text",
    "description": "傳回一個字串，代表儲存格中顯示的格式化文字。與 .Value 不同，.Text 傳回儲存格所顯示的內容，包括數字格式、日期格式等。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = 1234.5\nRange(\"A1\").NumberFormat = \"$#,##0.00\"\nMsgBox \"Value: \" & Range(\"A1\").Value ' Displays 1234.5\nMsgBox \"Text: \" & Range(\"A1\").Text   ' Displays \"$1,234.50\"", "explanation": "演示 .Value 和 .Text 屬性之間的差異，.Text 會反映儲存格的數字格式。"}
    ],
    "keywords": ["儲存格文字", "格式化值", "顯示文字", "excel", "cell text", "formatted value", "display text"]
},
{
    "name": "Application.DisplayFormulaBar",
    "category": "Excel 核心操作",
    "syntax": "Application.DisplayFormulaBar [= True | False]",
    "description": "如果顯示資料編輯列，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示，False 表示隱藏。"}],
    "examples": [
        {"code": "If Application.DisplayFormulaBar Then\n  MsgBox \"資料編輯列目前是可見的。\"\n  ' Application.DisplayFormulaBar = False ' To hide it\nElse\n  MsgBox \"資料編輯列目前是隱藏的。\"\n  ' Application.DisplayFormulaBar = True ' To show it\nEnd If", "explanation": "檢查資料編輯列的目前可見狀態，並示範如何切換它。"}
    ],
    "keywords": ["資料編輯列", "公式列", "excel", "formula bar", "show formula bar", "hide formula bar"]
},
{
    "name": "Application.Cursor",
    "category": "Excel 核心操作",
    "syntax": "Application.Cursor = XlMousePointerConstant",
    "description": "設定滑鼠游標的形狀。",
    "parameters": [{"name": "XlMousePointerConstant", "description": "例如 xlDefault (預設指標), xlWait (沙漏/忙碌指標), xlIBeam (I 型指標), xlNorthwestArrow (標準箭頭)。"}],
    "examples": [
        {"code": "Application.Cursor = xlWait ' Change cursor to hourglass\n' Perform a long operation...\nApplication.Wait Now + TimeValue(\"00:00:03\")\nApplication.Cursor = xlDefault ' Reset cursor to default", "explanation": "在執行耗時操作前將滑鼠游標變更為沙漏形狀，完成後再恢復預設。"}
    ],
    "keywords": ["滑鼠游標", "指標形狀", "excel", "mouse cursor", "pointer shape", "wait cursor", "hourglass"]
},
{
    "name": "Worksheet.StandardWidth",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.StandardWidth [= widthInChars]",
    "description": "設定或傳回工作表中所有欄的標準 (預設) 寬度，以字元為單位。",
    "parameters": [{"name": "widthInChars", "description": "標準欄寬。"}],
    "examples": [
        {"code": "MsgBox \"目前工作表的標準欄寬是: \" & ActiveSheet.StandardWidth\nActiveSheet.StandardWidth = 10 ' Set default column width to 10 characters", "explanation": "獲取並設定活動工作表的標準欄寬。"}
    ],
    "keywords": ["標準欄寬", "預設欄寬", "excel", "standard column width", "default column width"]
},
{
    "name": "TypeName (VBA Intrinsic)",
    "category": "資料類型、轉換與驗證",
    "syntax": "TypeName(varname)",
    "description": "傳回一個字串，提供有關變數的資料類型資訊。",
    "parameters": [{"name": "varname", "description": "必需。任何變數。"}],
    "examples": [
        {"code": "Dim myInteger As Integer: MsgBox TypeName(myInteger) ' 傳回 \"Integer\"", "explanation": "顯示整數變數的類型名稱。"},
        {"code": "Dim mySheet As Worksheet: Set mySheet = ThisWorkbook.Sheets(1): MsgBox TypeName(mySheet) ' 傳回 \"Worksheet\"", "explanation": "顯示 Worksheet 物件變數的類型名稱。"}
    ],
    "keywords": ["資料類型名稱", "變數類型", "vba", "data type name", "variable type"]
},
{
    "name": "CallByName Function",
    "category": "程式流程與結構控制",
    "syntax": "CallByName(Object, ProcName As String, CallType As VbCallType, [Args() As Variant])",
    "description": "在執行階段執行物件的方法、設定或取得物件的屬性。",
    "parameters": [
        {"name": "Object", "description": "必需。物件變數名稱。"},
        {"name": "ProcName", "description": "必需。包含要呼叫的屬性或方法名稱的字串。"},
        {"name": "CallType", "description": "必需。VbCallType 常數，表示程序類型 (vbMethod, vbGet, vbLet, vbSet)。"},
        {"name": "Args", "description": "可選。包含要傳遞給程序的參數的 Variant 陣列。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet\nSet ws = ThisWorkbook.Sheets(1)\n' Call a method\nCallByName ws, \"Activate\", vbMethod\n' Get a property\nMsgBox CallByName(ws, \"Name\", vbGet)\n' Set a property (if not read-only)\n' CallByName ws, \"Name\", vbLet, \"NewSheetName\"", "explanation": "演示如何使用 CallByName 來動態呼叫工作表物件的 Activate 方法，並獲取其 Name 屬性。"}
    ],
    "keywords": ["動態呼叫", "執行階段呼叫", "callbyname", "dynamic dispatch", "late binding"]
},
{
    "name": "Input # Statement",
    "category": "檔案與資料夾管理",
    "syntax": "Input #FileNumber, VarList",
    "description": "從以 Input 或 Binary 模式開啟的循序檔案中讀取資料，並將其指派給變數。",
    "parameters": [
        {"name": "FileNumber", "description": "必需。用於開啟檔案的檔案號碼。"},
        {"name": "VarList", "description": "必需。以逗號分隔的變數列表，用於儲存從檔案讀取的資料。"}
    ],
    "examples": [
        {"code": "Dim fileNum As Integer, myName As String, myAge As Integer\nfileNum = FreeFile\n' Assume \"C:\\Temp\\data.txt\" contains: \"John Doe\",30 (on one line)\n' Open \"C:\\Temp\\data.txt\" For Input As #fileNum\n' If Not EOF(fileNum) Then\n'   Input #fileNum, myName, myAge\n'   MsgBox \"姓名: \" & myName & \", 年齡: \" & myAge\n' End If\n' Close #fileNum", "explanation": "從文字檔案中讀取以逗號分隔的資料到不同的變數中。"}
    ],
    "keywords": ["讀取檔案", "循序檔", "檔案輸入", "fso", "file input", "sequential file", "read data"]
},
{
    "name": "Line Input # Statement",
    "category": "檔案與資料夾管理",
    "syntax": "Line Input #FileNumber, VariableName",
    "description": "從以 Input 模式開啟的循序檔案中讀取一整行文字 (直到但不包括換行符號)，並將其指派給字串變數。",
    "parameters": [
        {"name": "FileNumber", "description": "必需。用於開啟檔案的檔案號碼。"},
        {"name": "VariableName", "description": "必需。用於儲存讀取行的字串變數。"}
    ],
    "examples": [
        {"code": "Dim fileNum As Integer, textLine As String\nfileNum = FreeFile\n' Open \"C:\\Temp\\MyLog.txt\" For Input As #fileNum\n' Do While Not EOF(fileNum)\n'   Line Input #fileNum, textLine\n'   Debug.Print textLine\n' Loop\n' Close #fileNum", "explanation": "逐行讀取文字檔案的內容並將其列印到立即視窗。"}
    ],
    "keywords": ["讀取行", "檔案逐行讀取", "fso", "line input", "read line by line"]
},
{
    "name": "Option Compare Statement",
    "category": "程式流程與結構控制",
    "syntax": "Option Compare {Binary | Text | Database}",
    "description": "在模組層級宣告字串比較時使用的預設比較方法。",
    "parameters": [
        {"name": "Binary", "description": "字串比較基於內部二進制表示法 (區分大小寫，預設)。"},
        {"name": "Text", "description": "字串比較基於不區分大小寫的文字排序順序 (由系統地區設定決定)。"},
        {"name": "Database", "description": "(僅用於 Microsoft Access) 字串比較基於資料庫的排序順序。"}
    ],
    "examples": [
        {"code": "Option Compare Text ' Module level statement\nSub CompareStrings()\n  Dim str1 As String: str1 = \"Apple\"\n  Dim str2 As String: str2 = \"apple\"\n  If str1 = str2 Then\n    MsgBox \"'\" & str1 & \"' 和 '\" & str2 & \"' 相等 (不區分大小寫)。\"\n  End If\nEnd Sub", "explanation": "在模組頂部設定 Option Compare Text 後，該模組中的字串比較 (如使用 = 運算子) 將不區分大小寫。"}
    ],
    "keywords": ["字串比較模式", "區分大小寫", "option compare", "string comparison", "case sensitive"]
},
{
    "name": "DoEvents (Purpose and Caution)",
    "category": "綜合應用案例與技巧",
    "syntax": "DoEvents",
    "description": "暫時將控制權交給作業系統，以允許處理其他事件，如使用者介面更新或鍵盤/滑鼠輸入。在長時間執行的迴圈中使用 DoEvents 可以防止應用程式看起來『凍結』或無回應。但是，過度使用或在不當情況下使用 (例如，在事件處理程序中可能導致遞迴) 可能會產生非預期行為或效能問題。",
    "parameters": [],
    "examples": [
        {"code": "Sub LongProcessWithDoEvents()\n    Dim i As Long\n    Application.StatusBar = \"正在處理進度: 0%\"\n    For i = 1 To 50000 ' 模擬一個耗時的操作\n        If i Mod 1000 = 0 Then\n            Sheet1.Cells(1, 1).Value = i ' 更新UI (如果ScreenUpdating為True)\n            Application.StatusBar = \"正在處理進度: \" & Round((i / 50000) * 100, 0) & \"%\"\n            DoEvents ' 允許UI更新和處理其他系統事件\n        End If\n    Next i\n    Application.StatusBar = False\n    MsgBox \"處理完成！\"\nEnd Sub", "explanation": "在一個模擬的長迴圈中，每處理1000次迭代就呼叫 DoEvents 一次，以便更新狀態列和Excel介面，並允許應用程式回應其他事件。"}
    ],
    "keywords": ["doevents", "ui responsiveness", "prevent freezing", "yield control", "application not responding", "處理事件", "防止卡死", "程式回應"]
},
{
    "name": "Collection.Remove",
    "category": "陣列、集合與字典",
    "syntax": "collectionObject.Remove(IndexOrKey)",
    "description": "從 Collection 物件中移除一個項目。可以透過項目的索引 (1-based) 或其唯一的鍵 (如果新增時已提供) 來指定要移除的項目。",
    "parameters": [
        {"name": "IndexOrKey", "description": "必需。數值表達式 (1 到 Count) 或字串表達式 (鍵名)。"}
    ],
    "examples": [
        {"code": "Dim myColl As New Collection\nmyColl.Add \"Apple\", \"Fruit1\"\nmyColl.Add \"Banana\"\nmyColl.Add \"Cherry\", \"Fruit3\"\n\nDebug.Print \"移除前數量: \" & myColl.Count ' Output: 3\nmyColl.Remove \"Fruit1\" ' Remove by key\nDebug.Print \"移除 'Fruit1' 後數量: \" & myColl.Count ' Output: 2\nDebug.Print \"索引1的項目: \" & myColl(1) ' Was Banana, now maybe Cherry or error if key was 1st numerically\nmyColl.Remove 1 ' Remove by index (now removes 'Banana')\nDebug.Print \"再次移除後數量: \" & myColl.Count ' Output: 1 (Cherry remains)\nSet myColl = Nothing", "explanation": "演示如何使用索引和鍵從 Collection 中移除項目。注意，按索引移除後，後續項目的索引會改變。"}
    ],
    "keywords": ["collection remove", "delete from collection", "remove item vba", "集合移除", "刪除集合項目"]
},
{
    "name": "Worksheet.Evaluate Method",
    "category": "Excel 核心操作",
    "syntax": "result = worksheetObject.Evaluate(Name)",
    "description": "將 Microsoft Excel 名稱轉換為物件或值。此方法與方括號快捷方式類似 (例如，[A1] 或 [MyNamedRange])，但可以用於動態構造的名稱。",
    "parameters": [
        {"name": "Name", "description": "必需。物件的名稱 (字串)，使用 Excel 的命名約定 (例如，\"A1\", \"Sheet2!B5\", \"MyNamedRange\", \"SUM(C1:C10)\")。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet\nSet ws = ThisWorkbook.Sheets(1)\nws.Range(\"A1\").Value = 10\nws.Range(\"A2\").Value = 20\nws.Names.Add Name:=\"MyCellA1\", RefersToR1C1:=\"=Sheet1!R1C1\"\n\nDim valA1 As Variant\nvalA1 = ws.Evaluate(\"A1\") ' Equivalent to ws.Range(\"A1\").Value\nMsgBox \"A1 (via Evaluate): \" & valA1\n\nDim sumResult As Double\nsumResult = ws.Evaluate(\"SUM(A1:A2)\")\nMsgBox \"SUM(A1:A2) (via Evaluate): \" & sumResult\n\nDim namedRangeVal As Variant\nnamedRangeVal = ws.Evaluate(\"MyCellA1\")\nMsgBox \"MyCellA1 (via Evaluate): \" & namedRangeVal", "explanation": "演示如何使用 Evaluate 方法獲取儲存格的值、計算公式的結果以及獲取已命名範圍的值。"}
    ],
    "keywords": ["evaluate excel name", "string to range", "calculate formula vba", "excel indirect vba", "計算名稱", "字串轉物件"]
},
{
    "name": "Application.Evaluate Method (ShortForm Brackets)",
    "category": "Excel 核心操作",
    "syntax": "result = [ExcelNameString]",
    "description": "Evaluate 方法的簡寫形式。方括號內的字串會被 Excel 嘗試解析為名稱、範圍或公式。",
    "parameters": [
        {"name": "ExcelNameString", "description": "必需。物件的名稱 (字串)，使用 Excel 的命名約定，括在方括號中。"}
    ],
    "examples": [
        {"code": "Sheet1.Range(\"B1\").Value = 50\nSheet1.Range(\"B2\").Value = 75\nDim res As Variant\nres = [SUM(Sheet1!B1:B2)] ' Evaluates the SUM formula\nMsgBox \"[SUM(Sheet1!B1:B2)] = \" & res\n\nDim cellVal As Variant\ncellVal = [Sheet1!B1] ' Gets the value of Sheet1!B1\nMsgBox \"[Sheet1!B1] = \" & cellVal\n\n' ThisWorkbook.Names.Add Name:=\"TestRate\", RefersTo:=\"=0.05\"\n' Dim rateVal As Double\n' rateVal = [TestRate]\n' MsgBox \"[TestRate] = \" & rateVal", "explanation": "演示如何使用方括號簡寫形式來計算公式、獲取儲存格值以及獲取已命名範圍的值。"}
    ],
    "keywords": ["evaluate shortcut", "excel square brackets", "short form evaluate", "計算快捷方式", "方括號評估"]
},
{
    "name": "Range.Value2 Property",
    "category": "Excel 核心操作",
    "syntax": "value = rangeObject.Value2",
    "description": "傳回或設定儲存格的值。與 .Value 屬性類似，但 Value2 不使用 Currency 和 Date 資料類型。它會將這些類型的值傳回為浮點數 (Double)。使用 Value2 通常可以提高效能。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = Now ' Store current date and time\nRange(\"A1\").NumberFormat = \"m/d/yyyy h:mm:ss AM/PM\"\n\nDim val1 As Variant, val2 As Variant\nval1 = Range(\"A1\").Value  ' val1 will be of Date type\nval2 = Range(\"A1\").Value2 ' val2 will be of Double type (serial date-time number)\n\nMsgBox \"Using .Value: TypeName=\" & TypeName(val1) & \", Value=\" & val1\nMsgBox \"Using .Value2: TypeName=\" & TypeName(val2) & \", Value=\" & val2", "explanation": "比較 .Value 和 .Value2 在讀取包含日期時間的儲存格時的差異。Value2 將日期作為序列號（Double）傳回。"}
    ],
    "keywords": ["range value2", "cell value performance", "excel date as number", "儲存格值2", "效能值讀取"]
},
{
    "name": "Workbook.Saved Property",
    "category": "Excel 核心操作",
    "syntax": "booleanResult = workbookObject.Saved",
    "description": "如果自上次儲存活頁簿以來沒有對其進行任何變更，則為 True。您可以將此屬性設為 True 以指示活頁簿已儲存 (即使未實際儲存)，這樣在關閉時不會提示使用者。唯讀/寫入布林值。",
    "parameters": [],
    "examples": [
        {"code": "Dim wb As Workbook\nSet wb = ActiveWorkbook\nIf Not wb.Saved Then\n  MsgBox wb.Name & \" 有未儲存的變更。\"\n  ' wb.Save ' Optionally save it\nElse\n  MsgBox wb.Name & \" 目前沒有未儲存的變更。\"\nEnd If\n' Example of setting it to avoid prompt on close (use with caution)\n' If some minor changes were made by code that don't need saving:\n' wb.Saved = True ' Excel will now think it's saved\n' wb.Close SaveChanges:=False ' Can now close without prompt", "explanation": "檢查活動活頁簿是否有未儲存的變更，並示範如何將 Saved 屬性設為 True 以在關閉時避免儲存提示（應謹慎使用）。"}
    ],
    "keywords": ["workbook saved status", "check if saved", "excel save state", "活頁簿儲存狀態", "是否已儲存"]
},
{
    "name": "Worksheet.Shapes.AddShape",
    "category": "Excel 核心操作",
    "syntax": "Set shp = worksheetObject.Shapes.AddShape(Type As MsoAutoShapeType, Left As Single, Top As Single, Width As Single, Height As Single)",
    "description": "在工作表上建立一個新的 AutoShape，並傳回代表該圖案的 Shape 物件。",
    "parameters": [
        {"name": "Type", "description": "必需。MsoAutoShapeType 常數，指定要建立的圖案類型 (例如，msoShapeRectangle, msoShapeOval, msoShapeFlowchartProcess)。"},
        {"name": "Left, Top", "description": "必需。圖案左上角的水平和垂直位置 (以點為單位)，相對於工作表。"},
        {"name": "Width, Height", "description": "必需。圖案的寬度和高度 (以點為單位)。"}
    ],
    "examples": [
        {"code": "Dim myOval As Shape\nSet myOval = ActiveSheet.Shapes.AddShape(msoShapeOval, 100, 50, 120, 60)\nmyOval.Fill.ForeColor.RGB = RGB(100, 150, 200)\nmyOval.TextFrame.Characters.Text = \"橢圓形\"\nmyOval.TextFrame.HorizontalAlignment = xlHAlignCenter\nmyOval.TextFrame.VerticalAlignment = xlVAlignCenter", "explanation": "在活動工作表上新增一個橢圓形 AutoShape，設定其填充顏色和文字。"}
    ],
    "keywords": ["add autoshape", "insert shape excel", "drawing object", "新增自選圖案", "插入圖形"]
},
{
    "name": "Worksheet.ChartObjects Method / Collection",
    "category": "Excel 核心操作",
    "syntax": "Set chtObj = worksheetObject.ChartObjects([IndexOrName])\nSet newChtObj = worksheetObject.ChartObjects.Add(Left, Top, Width, Height)",
    "description": "ChartObjects 方法 (帶參數) 傳回工作表上單個嵌入式圖表物件 (ChartObject)。ChartObjects 屬性 (不帶參數) 傳回代表工作表上所有嵌入式圖表物件的 ChartObjects 集合。Add 方法用於新增新的嵌入式圖表容器。",
    "parameters": [
        {"name": "IndexOrName (Method)", "description": "可選。圖表物件的名稱或索引號。"},
        {"name": "Left, Top, Width, Height (Add Method)", "description": "必需。新圖表物件容器的位置和尺寸。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet: Set ws = ActiveSheet\nDim newChartObj As ChartObject\n' Add a new chart object container\nSet newChartObj = ws.ChartObjects.Add(Left:=100, Top:=75, Width:=300, Height:=200)\n' Now, define the chart within this container\nWith newChartObj.Chart\n  .ChartType = xlXYScatterSmooth\n  ' .SetSourceData Source:=ws.Range(\"A1:B10\") ' Example source data\n  .HasTitle = True\n  .ChartTitle.Text = \"我的XY散佈圖\"\nEnd With\nMsgBox \"已新增嵌入式圖表: \" & newChartObj.Name", "explanation": "在活動工作表上新增一個新的嵌入式圖表容器，然後設定其內部圖表的類型和標題。"}
    ],
    "keywords": ["embedded chart excel", "add chartobject", "chartobjects collection", "嵌入式圖表", "新增圖表容器"]
},
{
    "name": "Application.FileDialogProperty (msoFileDialogFolderPicker)",
    "category": "Excel 核心操作",
    "syntax": "Set fd = Application.FileDialog(msoFileDialogFolderPicker)\nfd.Title = \"Select a Folder\"\nfd.InitialFileName = \"C:\\Users\\\"\nIf fd.Show = -1 Then selectedPath = fd.SelectedItems(1)",
    "description": "使用 FileDialog 物件的 msoFileDialogFolderPicker 類型來顯示一個對話框，允許使用者選擇一個資料夾。",
    "parameters": [
        {"name": "msoFileDialogFolderPicker (Constant)", "description": "FileDialog 類型，用於選擇資料夾。"},
        {"name": ".Title", "description": "屬性：設定對話框的標題。"},
        {"name": ".InitialFileName", "description": "屬性：設定對話框開啟時的初始路徑。"},
        {"name": ".Show()", "description": "方法：顯示對話框。如果使用者選擇資料夾並點擊確定，則傳回 -1。"},
        {"name": ".SelectedItems(1)", "description": "屬性：傳回包含使用者選擇的資料夾完整路徑的字串。"}
    ],
    "examples": [
        {"code": "Dim folderPath As String\nWith Application.FileDialog(msoFileDialogFolderPicker)\n  .Title = \"請選擇一個專案資料夾\"\n  .AllowMultiSelect = False\n  If .Show = -1 Then ' User clicked OK\n    folderPath = .SelectedItems(1)\n    MsgBox \"您選擇的資料夾是: \" & folderPath\n  Else\n    MsgBox \"使用者取消了選擇。\"\n  End If\nEnd With", "explanation": "顯示一個資料夾選擇對話框，讓使用者選擇一個資料夾，然後顯示所選的路徑。"}
    ],
    "keywords": ["folder picker", "select folder dialog", "choose directory", "filedialog", "資料夾選擇器", "選擇目錄"]
},
{
    "name": "Collection.Count",
    "category": "陣列、集合與字典",
    "syntax": "numberOfItems = collectionObject.Count",
    "description": "傳回 Collection 物件中包含的項目數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim myStrings As New Collection\nmyStrings.Add \"Apple\"\nmyStrings.Add \"Banana\"\nmyStrings.Add \"Cherry\"\nMsgBox \"集合中有 \" & myStrings.Count & \" 個項目。\"", "explanation": "建立一個集合，新增三個項目，然後顯示集合中的項目數量。"}
    ],
    "keywords": ["collection count", "number of items in collection", "集合計數", "項目數量"]
},
{
    "name": "Collection.Item",
    "category": "陣列、集合與字典",
    "syntax": "itemValue = collectionObject.Item(IndexOrKey)",
    "description": "從 Collection 物件中依其索引 (1-based) 或唯一的鍵 (如果新增時已提供) 傳回特定項目。",
    "parameters": [
        {"name": "IndexOrKey", "description": "必需。數值表達式 (1 到 Count) 或字串表達式 (鍵名)。"}
    ],
    "examples": [
        {"code": "Dim fruits As New Collection\nfruits.Add \"Red Apple\", \"F1\"\nfruits.Add \"Yellow Banana\", \"F2\"\nMsgBox \"依索引 2 取得: \" & fruits.Item(2) ' 傳回 \"Yellow Banana\"\nMsgBox \"依鍵 'F1' 取得: \" & fruits.Item(\"F1\") ' 傳回 \"Red Apple\"", "explanation": "演示如何使用索引和鍵從 Collection 中檢索項目。"}
    ],
    "keywords": ["collection item", "get item from collection", "access collection element", "集合項目", "讀取集合元素"]
},
// --- More String ---
{
    "name": "Replace Function (Detailed Example)",
    "category": "字串與文本操作",
    "syntax": "Replace(expression, find, replace, [start As Long = 1], [count As Long = -1], [compare As VbCompareMethod = vbBinaryCompare])",
    "description": "傳回一個字串，其中指定的子字串已被另一個子字串取代指定次數。詳細參數說明：start (開始取代的位置，1-based)，count (要取代的次數，-1 表示全部取代)，compare (vbBinaryCompare 區分大小寫，vbTextCompare 不區分)。",
    "parameters": [
        {"name": "expression", "description": "必需。包含要搜尋的子字串的原始字串。"},
        {"name": "find", "description": "必需。要被取代的子字串。"},
        {"name": "replace", "description": "必需。用於取代的字串。"},
        {"name": "start", "description": "可選。搜尋的起始位置。預設為 1。"},
        {"name": "count", "description": "可選。要執行的取代次數。預設為 -1 (全部取代)。"},
        {"name": "compare", "description": "可選。指定比較類型 (vbBinaryCompare 或 vbTextCompare)。預設為 vbBinaryCompare。"}
    ],
    "examples": [
        {"code": "Dim originalText As String: originalText = \"The quick brown fox jumps over the lazy dog. The dog was quick.\"\nDim newText1 As String, newText2 As String, newText3 As String\n' 1. Replace all 'quick' with 'fast' (case-sensitive)\nnewText1 = Replace(originalText, \"quick\", \"fast\")\nDebug.Print \"1: \" & newText1\n\n' 2. Replace all 'the' with 'a' (case-insensitive)\nnewText2 = Replace(originalText, \"the\", \"a\", compare:=vbTextCompare)\nDebug.Print \"2: \" & newText2\n\n' 3. Replace first two occurrences of 'dog' with 'cat' starting from character 1\nnewText3 = Replace(originalText, \"dog\", \"cat\", 1, 2, vbTextCompare)\nDebug.Print \"3: \" & newText3", "explanation": "第一個範例區分大小寫地將所有 \"quick\" 取代為 \"fast\"。第二個範例不區分大小寫地將所有 \"the\" 取代為 \"a\"。第三個範例不區分大小寫地將前兩次出現的 \"dog\" 取代為 \"cat\"。"}
    ],
    "keywords": ["replace string", "find and replace", "text manipulation", "substitute text", "字串取代", "尋找並取代"]
},
// --- More File/Folder ---
{
    "name": "FileSystemObject.GetAbsolutePathName (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "absolutePathString = fso.GetAbsolutePathName(PathSpec)",
    "description": "從提供的路徑規格傳回完整且明確的路徑。如果 PathSpec 是相對路徑，則會基於目前磁碟機和目錄來解析它。",
    "parameters": [
        {"name": "PathSpec", "description": "必需。檔案或資料夾的路徑規格 (可以是相對的或絕對的)。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, absPath As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Assuming current directory is C:\\Users\\YourName\nabsPath = fso.GetAbsolutePathName(\"Documents\\MyFile.txt\")\nMsgBox \"絕對路徑: \" & absPath ' 可能傳回 C:\\Users\\YourName\\Documents\\MyFile.txt\n\nabsPath = fso.GetAbsolutePathName(\"..\\Desktop\")\nMsgBox \"上層的桌面路徑: \" & absPath ' 可能傳回 C:\\Users\\Desktop", "explanation": "演示如何使用 GetAbsolutePathName 將相對路徑轉換為絕對路徑。實際結果取決於執行時的目前目錄。"}
    ],
    "keywords": ["fso", "absolute path", "full path", "resolve path", "filesystemobject", "絕對路徑", "完整路徑"]
},
{
    "name": "Drive Object Properties (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "driveObject.AvailableSpace | .TotalSize | .FreeSpace | .VolumeName | .DriveLetter | .FileSystem | .IsReady | .Path | .RootFolder | .SerialNumber | .ShareName | .DriveType",
    "description": "FileSystemObject 的 Drive 物件提供有關磁碟機的各種資訊。",
    "parameters": [
        {"name": ".AvailableSpace", "description": "傳回指定磁碟機或網路共用上使用者可用的空間量 (位元組)。"},
        {"name": ".TotalSize", "description": "傳回磁碟機或網路共用的總空間 (位元組)。"},
        {"name": ".FreeSpace", "description": "與 AvailableSpace 類似，通常指總可用空間。"},
        {"name": ".VolumeName", "description": "設定或傳回指定磁碟機的磁碟區名稱。"},
        {"name": ".DriveLetter", "description": "傳回磁碟機的字母。"},
        {"name": ".FileSystem", "description": "傳回指定磁碟機使用的檔案系統類型 (例如 \"NTFS\", \"FAT32\")。"},
        {"name": ".IsReady", "description": "如果磁碟機已就緒，則為 True (例如，已插入媒體)。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, drv As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet drv = fso.GetDrive(fso.GetDriveName(Application.Path)) ' Get drive of Excel installation\nMsgBox \"Excel 所在磁碟機: \" & drv.DriveLetter & vbCrLf & _\n       \"磁碟區名稱: \" & drv.VolumeName & vbCrLf & _\n       \"檔案系統: \" & drv.FileSystem & vbCrLf & _\n       \"總空間: \" & Format(drv.TotalSize / (1024^3), \"0.00\") & \" GB\" & vbCrLf & _\n       \"可用空間: \" & Format(drv.AvailableSpace / (1024^3), \"0.00\") & \" GB\"", "explanation": "獲取 Excel 應用程式安裝所在磁碟機的 Drive 物件，並顯示其磁碟機代號、磁碟區名稱、檔案系統、總大小和可用空間。"}
    ],
    "keywords": ["fso drive object", "disk information", "drive space", "volume name", "filesystem", "磁碟機資訊", "磁碟空間"]
},
{
    "name": "Folder Object Properties (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "folderObject.Attributes | .DateCreated | .DateLastAccessed | .DateLastModified | .Drive | .IsRootFolder | .Name | .ParentFolder | .Path | .ShortName | .ShortPath | .Size | .Type | .Files | .SubFolders",
    "description": "FileSystemObject 的 Folder 物件提供有關資料夾的各種屬性以及存取其內容的方法。",
    "parameters": [
        {"name": ".Attributes", "description": "資料夾的屬性 (例如，唯讀、隱藏、系統、目錄)。"},
        {"name": ".DateCreated / .DateLastAccessed / .DateLastModified", "description": "日期/時間戳記。"},
        {"name": ".Name", "description": "資料夾的名稱。"},
        {"name": ".Path", "description": "資料夾的完整路徑。"},
        {"name": ".Size", "description": "資料夾中所有檔案和子資料夾的總大小 (位元組)。"},
        {"name": ".Files", "description": "傳回一個 Files 集合，包含資料夾中的所有檔案。"},
        {"name": ".SubFolders", "description": "傳回一個 Folders 集合，包含資料夾中的所有子資料夾。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, myFolder As Object, aFile As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFolder = fso.GetFolder(\"C:\\Windows\") ' Example folder\nMsgBox \"資料夾名稱: \" & myFolder.Name & vbCrLf & _\n       \"路徑: \" & myFolder.Path & vbCrLf & _\n       \"檔案數: \" & myFolder.Files.Count & vbCrLf & _\n       \"子資料夾數: \" & myFolder.SubFolders.Count & vbCrLf & _\n       \"大小 (Bytes): \" & myFolder.Size\n' List first 5 files\nDim count As Integer: count = 0\nFor Each aFile In myFolder.Files\n    Debug.Print \"  File: \" & aFile.Name\n    count = count + 1\n    If count >= 5 Then Exit For\nNext aFile", "explanation": "獲取 C:\\Windows 資料夾的 Folder 物件，顯示其名稱、路徑、檔案數、子資料夾數和總大小，並列印前5個檔案的名稱。"}
    ],
    "keywords": ["fso folder object", "directory information", "folder properties", "list files in folder", "資料夾資訊", "列出檔案"]
},
    // Existing commands would be here, ensure a comma before this block if vbaCommands is not empty.
// For example: const vbaCommands = [ /* existing commands */,
// --- Start of new commands ---
{
    "name": "File Object Properties (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "fileObject.Attributes | .DateCreated | .DateLastAccessed | .DateLastModified | .Drive | .Name | .ParentFolder | .Path | .ShortName | .ShortPath | .Size | .Type",
    "description": "FileSystemObject 的 File 物件提供有關檔案的各種屬性以及操作檔案的方法。",
    "parameters": [
        {"name": ".Attributes", "description": "檔案的屬性 (例如，唯讀、隱藏、系統、封存)。"},
        {"name": ".DateCreated / .DateLastAccessed / .DateLastModified", "description": "日期/時間戳記。"},
        {"name": ".Name", "description": "檔案的名稱 (不含路徑)。"},
        {"name": ".Path", "description": "檔案的完整路徑。"},
        {"name": ".Size", "description": "檔案的大小 (位元組)。"},
        {"name": ".Type", "description": "描述檔案類型的字串 (例如 \"文字文件\", \"Microsoft Excel 工作表\")。"},
        {"name": ".ParentFolder", "description": "傳回包含此檔案的 Folder 物件。"},
        {"name": ".Drive", "description": "傳回檔案所在磁碟機的 Drive 物件。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, myFile As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFile = fso.GetFile(\"C:\\Windows\\notepad.exe\") ' Example file\nMsgBox \"檔案名稱: \" & myFile.Name & vbCrLf & _\n       \"類型: \" & myFile.Type & vbCrLf & _\n       \"大小: \" & myFile.Size & \" bytes\" & vbCrLf & _\n       \"上次修改: \" & myFile.DateLastModified", "explanation": "獲取 C:\\Windows\\notepad.exe 檔案的 File 物件，並顯示其名稱、類型、大小和上次修改日期。"}
    ],
    "keywords": ["fso file object", "file information", "file properties", "filesystemobject", "檔案資訊", "檔案屬性"]
},
{
    "name": "File.OpenAsTextStream (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "Set ts = fileObject.OpenAsTextStream([IOMode As IOMode = ForReading], [Format As Tristate = TristateFalse])",
    "description": "開啟指定的檔案並傳回一個 TextStream 物件，可用於讀取或附加到檔案。",
    "parameters": [
        {"name": "IOMode", "description": "可選。IOMode 常數：ForReading (1, 預設), ForWriting (2), ForAppending (8)。"},
        {"name": "Format", "description": "可選。Tristate 常數，指示開啟檔案的格式：TristateUseDefault (-2), TristateTrue (-1, Unicode), TristateFalse (0, ASCII, 預設)。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, myFile As Object, textStream As Object, fileContent As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFile = fso.GetFile(\"C:\\Temp\\MyDocument.txt\") ' Assume this file exists\nIf myFile.Size > 0 Then\n  Set textStream = myFile.OpenAsTextStream(1) ' 1 = ForReading\n  fileContent = textStream.ReadAll\n  textStream.Close\n  MsgBox \"檔案內容:\\n\" & fileContent\nElse\n  MsgBox \"檔案為空或不存在。\"\nEnd If\nSet fso = Nothing: Set myFile = Nothing: Set textStream = Nothing", "explanation": "獲取檔案物件，然後使用 OpenAsTextStream 方法以讀取模式打開它，讀取全部內容並顯示。"}
    ],
    "keywords": ["fso opentextstream", "read text file fso", "textstream from file", "開啟文字流"]
},
{
    "name": "Static Array Declaration",
    "category": "陣列、集合與字典",
    "syntax": "Dim ArrayName(LowerBound To UpperBound) As DataType\nDim ArrayName(Size) As DataType ' If Option Base 0, index from 0 to Size. If Option Base 1, index from 1 to Size.",
    "description": "宣告一個固定大小的陣列。一旦宣告，其大小不能改變。",
    "parameters": [
        {"name": "ArrayName", "description": "陣列的名稱。"},
        {"name": "LowerBound To UpperBound", "description": "指定陣列每個維度的索引範圍。"},
        {"name": "Size", "description": "如果只提供一個數字，它代表上限，下限取決於 Option Base 設定。"},
        {"name": "DataType", "description": "陣列元素儲存的資料類型。"}
    ],
    "examples": [
        {"code": "Dim studentNames(1 To 3) As String\nstudentNames(1) = \"Alice\"\nstudentNames(2) = \"Bob\"\nstudentNames(3) = \"Charlie\"\nMsgBox studentNames(2) ' Displays \"Bob\"", "explanation": "宣告一個可以儲存3個學生姓名的固定大小字串陣列。"},
        {"code": "Dim monthlySales(11) As Double ' If Option Base 0, this is 0 to 11 (12 elements)\nmonthlySales(0) = 1500.50 ' January sales (index 0)\n' ...\nmonthlySales(11) = 2100.75 ' December sales (index 11)", "explanation": "宣告一個儲存12個月銷售額的雙精度浮點數陣列 (假設 Option Base 0)。"}
    ],
    "keywords": ["static array", "fixed-size array", "declare array", "array bounds", "固定大小陣列", "靜態陣列"]
},
{
    "name": "Dynamic Array Declaration and ReDim",
    "category": "陣列、集合與字典",
    "syntax": "Dim DynamicArrayName() As DataType\nReDim [Preserve] DynamicArrayName(NewUpperBound) ' Or (NewLowerBound To NewUpperBound)",
    "description": "宣告一個動態陣列 (不指定初始大小)，然後使用 ReDim 語句在執行階段設定或變更其大小。使用 Preserve 關鍵字可以在調整大小時保留陣列現有內容 (通常僅限於調整最後一個維度的大小，或在增加維度數時)。",
    "parameters": [
        {"name": "DynamicArrayName()", "description": "宣告時使用空括號表示為動態陣列。"},
        {"name": "ReDim", "description": "用於在執行階段設定或改變動態陣列大小的關鍵字。"},
        {"name": "Preserve", "description": "可選。在改變陣列最後一個維度的大小時保留陣列中的現有資料。"}
    ],
    "examples": [
        {"code": "Dim customerIDs() As Long\nDim numCustomers As Integer: numCustomers = CInt(InputBox(\"輸入客戶數量:\"))\nIf numCustomers > 0 Then\n  ReDim customerIDs(1 To numCustomers)\n  Dim i As Integer\n  For i = 1 To numCustomers\n    customerIDs(i) = 1000 + i\n  Next i\n  MsgBox \"最後一個客戶ID: \" & customerIDs(numCustomers)\nElse\n  MsgBox \"未指定客戶數量。\"\nEnd If", "explanation": "根據使用者輸入決定動態陣列 customerIDs 的大小，然後填充值。"},
        {"code": "Dim dataPoints() As Double\nReDim dataPoints(0 To 2)\ndataPoints(0) = 1.1: dataPoints(1) = 2.2: dataPoints(2) = 3.3\n' Add more space while preserving existing data\nReDim Preserve dataPoints(0 To 4)\ndataPoints(3) = 4.4\ndataPoints(4) = 5.5\nDebug.Print \"Data at index 1 (preserved): \" & dataPoints(1)", "explanation": "先定義一個包含3個元素的動態陣列，然後使用 ReDim Preserve 將其擴展到5個元素，同時保留原始數據。"}
    ],
    "keywords": ["dynamic array", "redim array", "resize array", "preserve array data", "動態陣列", "重定義陣列", "陣列大小調整"]
},
{
    "name": "Multi-dimensional Array",
    "category": "陣列、集合與字典",
    "syntax": "Dim MultiArray(Dim1_Upper, Dim2_Upper, ...) As DataType\nDim MultiArray(L1 To U1, L2 To U2, ...) As DataType",
    "description": "宣告多維陣列以表格或更複雜的結構儲存資料。最多可以有60個維度，但通常使用2維或3維。",
    "parameters": [
        {"name": "DimN_Upper", "description": "每個維度的上限 (如果 Option Base 為0或1)。"},
        {"name": "LN To UN", "description": "每個維度的明確下限和上限。"}
    ],
    "examples": [
        {"code": "Dim matrix(1 To 3, 1 To 4) As Integer ' A 3x4 matrix\nDim r As Integer, c As Integer\nFor r = 1 To 3\n  For c = 1 To 4\n    matrix(r, c) = r * 10 + c\n    Debug.Print \"matrix(\" & r & \",\" & c & \") = \" & matrix(r, c)\n  Next c\nNext r", "explanation": "宣告一個3列4欄的二維整數陣列 (矩陣)，並填充值。"},
        {"code": "Dim salesData(1 To 2, 1 To 12, 1 To 3) As Currency ' Product, Month, Region\nsalesData(1, 1, 1) = 5000 ' Sales for Product 1, Month 1, Region 1\nMsgBox \"示例數據: \" & salesData(1, 1, 1)", "explanation": "宣告一個三維貨幣陣列來儲存按產品、月份和區域劃分的銷售數據。"}
    ],
    "keywords": ["multidimensional array", "2d array", "3d array", "matrix array", "table array", "多維陣列", "二維陣列", "三維陣列", "矩陣"]
},
{
    "name": "Worksheet.UsedRange Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set ur = worksheetObject.UsedRange",
    "description": "傳回一個 Range 物件，代表指定工作表上已使用的儲存格範圍。這是包含任何資料的最小矩形區域。",
    "parameters": [],
    "examples": [
        {"code": "Dim dataRange As Range\nSet dataRange = ActiveSheet.UsedRange\nMsgBox \"已使用範圍的位址: \" & dataRange.Address & vbCrLf & _\n       \"包含 \" & dataRange.Rows.Count & \" 列和 \" & dataRange.Columns.Count & \" 欄。\"\ndataRange.Select ' Selects the entire used area", "explanation": "獲取活動工作表上的已使用範圍，顯示其位址、大小，然後選取該範圍。"}
    ],
    "keywords": ["used range", "data area", "actual data range", "excel", "已使用範圍", "資料區域"]
},
{
    "name": "Range.ClearOutline (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ClearOutline",
    "description": "清除指定範圍的大綱 (移除所有分組)。",
    "parameters": [],
    "examples": [
        {"code": "' Assume rows 2-5 are grouped\n' Rows(\"2:5\").Group\n' Range(\"A1\").CurrentRegion.ClearOutline ' Clears any outline in the current region of A1\n' MsgBox \"範圍的大綱已清除。\"", "explanation": "如果A1儲存格所在的目前區域有設定大綱 (分組)，則此程式碼會清除該大綱。"}
    ],
    "keywords": ["clear outline", "remove grouping", "ungroup excel", "清除大綱", "取消分組"]
},
{
    "name": "Range.Group (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Group([Start], [End], [By], [Periods])",
    "description": "建立範圍的大綱 (分組)。通常用於對列或欄進行分組。對於日期，可以用於按日、月、年等分組。",
    "parameters": [
        {"name": "Start", "description": "可選。對於日期分組，為 True 表示按指定日期開始分組。"},
        {"name": "End", "description": "可選。對於日期分組，為 True 表示按指定日期結束分組。"},
        {"name": "By", "description": "可選。對於數值分組，為間隔。對於日期分組，為包含週期的陣列。"},
        {"name": "Periods", "description": "可選 (日期分組)。布林值陣列，指定分組週期 (年、季、月、週、日、時、分)。"}
    ],
    "examples": [
        {"code": "Rows(\"5:10\").Group ' Group rows 5 to 10\nColumns(\"C:E\").Group ' Group columns C to E\nMsgBox \"列和欄已分組。\"", "explanation": "將第5到第10列分組，並將C到E欄分組。"},
        {"code": "Range(\"A1:A20\").Group Start:=True, End:=True, By:=7, Periods:=Array(False, False, False, True, False, False, False) ' Group by week (if A1:A20 contains dates)", "explanation": "如果A1:A20包含日期，則嘗試按週對這些日期進行分組 (此範例更適用於樞紐分析表中的日期欄位分組，直接對Range使用日期分組參數較少見，除非是特定操作)。更常見的是直接分組列或欄。"}
    ],
    "keywords": ["group rows", "group columns", "outline excel", "data grouping", "分組列", "分組欄", "建立大綱"]
},
{
    "name": "Range.Subtotal (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Subtotal(GroupBy As Long, FunctionNum As XlConsolidationFunction, TotalList, [Replace As Boolean = True], [PageBreaks As Boolean = False], [SummaryBelowData As XlSummaryRow = xlSummaryBelow])",
    "description": "為範圍建立小計。範圍必須是已排序的清單。",
    "parameters": [
        {"name": "GroupBy", "description": "必需。進行小計的欄位 (1-based index within the range)。"},
        {"name": "FunctionNum", "description": "必需。XlConsolidationFunction 常數 (例如 xlSum, xlCount, xlAverage)。"},
        {"name": "TotalList", "description": "必需。一個 1-based 的整數陣列，指示要加入小計的欄位。"},
        {"name": "SummaryBelowData", "description": "可選。XlSummaryRow 常數，指定摘要資訊是否顯示在資料下方。"}
    ],
    "examples": [
        {"code": "Dim dataRange As Range\nSet dataRange = Range(\"A1\").CurrentRegion ' Assume A1 is top-left of a sorted list\n' Sort by the GroupBy column first if not already sorted\n' dataRange.Sort Key1:=dataRange.Columns(1), Order1:=xlAscending, Header:=xlYes\n\n' Subtotal by first column (GroupBy:=1), sum values in third column (TotalList:=Array(3))\ndataRange.Subtotal GroupBy:=1, FunctionNum:=xlSum, TotalList:=Array(3), _\n                   Replace:=True, PageBreaks:=False, SummaryBelowData:=xlSummaryBelow\nMsgBox \"已為第一欄新增小計 (加總第三欄)。\"", "explanation": "在以A1為起點的目前資料區域，按第一欄的變化進行分類匯總，對第三欄的數值進行加總。假設第一欄已排序。"}
    ],
    "keywords": ["subtotal", "summary data", "group and sum", "excel data analysis", "小計", "分類匯總"]
},
{
    "name": "Debug.Print",
    "category": "錯誤處理與調試",
    "syntax": "Debug.Print [OutputList]",
    "description": "在VBA編輯器的「即時運算」視窗 (Immediate Window) 中顯示文字或變數的值。這是一個非常有用的調試工具。",
    "parameters": [
        {"name": "OutputList", "description": "可選。要列印的一個或多個以逗號或分號分隔的表達式。"}
    ],
    "examples": [
        {"code": "Dim myVar As String: myVar = \"Test Value\"\nDim counter As Integer: counter = 10\nDebug.Print \"變數 myVar 的值是: \" & myVar\nDebug.Print \"計數器:\"; counter; \"時間:\"; Time", "explanation": "在即時運算視窗中輸出變數的值和一些文字。使用分號 (;) 會緊密連接輸出，使用逗號 (,) 會在標準定位點位置輸出。"}
    ],
    "keywords": ["debug print", "immediate window", "vba debugging", "output variable", "調試輸出", "即時運算視窗"]
},
{
    "name": "Debug.Assert",
    "category": "錯誤處理與調試",
    "syntax": "Debug.Assert BooleanExpression",
    "description": "當指定的 BooleanExpression 評估為 False 時，在VBA編輯器中暫停執行 (進入中斷模式)。如果表達式為 True，則不執行任何操作。此語句僅在開發環境中有效，在編譯後的執行檔中會被忽略。",
    "parameters": [
        {"name": "BooleanExpression", "description": "必需。一個評估為 True 或 False 的表達式。"}
    ],
    "examples": [
        {"code": "Function CalculateDiscount(price As Double, quantity As Integer) As Double\n  Debug.Assert price > 0 And quantity > 0 ' Assert that price and quantity are positive\n  If quantity >= 10 Then\n    CalculateDiscount = price * quantity * 0.9 ' 10% discount\n  Else\n    CalculateDiscount = price * quantity\n  End If\nEnd Function\n\nSub TestDiscount()\n  Dim finalPrice As Double\n  finalPrice = CalculateDiscount(50, 5) ' This is fine\n  Debug.Print finalPrice\n  ' finalPrice = CalculateDiscount(-10, 2) ' This will trigger Debug.Assert and break execution\nEnd Sub", "explanation": "在 CalculateDiscount 函數的開頭，使用 Debug.Assert 確保傳入的 price 和 quantity 都是正數。如果任一為非正數，執行將在中斷模式下暫停於 Debug.Assert 行。"}
    ],
    "keywords": ["debug assert", "assertion vba", "test condition", "debugging tool", "判斷提示", "條件測試"]
},
{
    "name": "Application.GetPhonetic (Excel)",
    "category": "Excel 核心操作",
    "syntax": "phoneticString = Application.GetPhonetic(Text)",
    "description": "傳回儲存格中文字的日文注音假名 (拼音指南) 字串。如果儲存格沒有注音假名資訊，則傳回空字串。主要用於日文版 Excel。",
    "parameters": [
        {"name": "Text", "description": "必需。可以是一個字串，或包含要提取注音假名的儲存格 (Range 物件)。"}
    ],
    "examples": [
        {"code": "Dim ph As String\n' Range(\"A1\").Value = \"東京\" ' Assuming Japanese text with phonetic info in A1\n' Range(\"A1\").Phonetic.Visible = True ' Make phonetic visible in cell (if not already)\n' ph = Application.GetPhonetic(Range(\"A1\"))\n' If ph <> \"\" Then\n'   MsgBox \"A1儲存格的注音假名是: \" & ph\n' Else\n'   MsgBox \"A1儲存格沒有注音假名資訊，或者此功能在此Excel版本/語言中不可用。\"\n' End If", "explanation": "嘗試獲取儲存格A1中文字的日文注音假名。此功能的效果取決於Excel的語言版本和儲存格內容是否包含注音資訊。"}
    ],
    "keywords": ["phonetic", "furigana", "japanese excel", "get phonetic text", "注音假名", "日文拼音指南"]
},
{
    "name": "Environ Function (More Examples)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "Environ({envstring | number})",
    "description": "傳回與作業系統環境變數相關聯的 String。下面是更多常見的環境變數範例。",
    "parameters": [
        {"name": "envstring", "description": "環境變數的名稱 (例如 \"COMPUTERNAME\", \"OS\", \"PROCESSOR_ARCHITECTURE\")。"}
    ],
    "examples": [
        {"code": "Debug.Print \"Computer Name: \" & Environ(\"COMPUTERNAME\")\nDebug.Print \"Operating System: \" & Environ(\"OS\")\nDebug.Print \"User Domain: \" & Environ(\"USERDOMAIN\")\nDebug.Print \"Processor Architecture: \" & Environ(\"PROCESSOR_ARCHITECTURE\")\nDebug.Print \"Number of Processors: \" & Environ(\"NUMBER_OF_PROCESSORS\")\nDebug.Print \"Program Files Path: \" & Environ(\"ProgramFiles\")\nDebug.Print \"System Root: \" & Environ(\"SystemRoot\")", "explanation": "列印多個常見的 Windows 環境變數的值到立即視窗。"}
    ],
    "keywords": ["environment variables", "system information", "os details", "computer info", "環境變數", "系統資訊"]
},
{
    "name": "Collection Object (More Usage)",
    "category": "陣列、集合與字典",
    "description": "Collection 物件是儲存和管理相關項目群組的便捷方式。項目可以是任何資料類型，包括其他物件。可以使用索引 (1-based) 或唯一的字串鍵來存取項目。",
    "parameters": [
        {"name": "Before / After (Add method)", "description": "在 Add 方法中，可以使用 Before 或 After 引數將新項目插入到集合中的特定位置 (相對於現有項目)。"}
    ],
    "examples": [
        {"code": "Dim myTasks As New Collection\nDim taskObj1 As Object, taskObj2 As Object, taskObj3 As Object\n\n' Simulate task objects (could be class instances or dictionaries)\nSet taskObj1 = CreateObject(\"Scripting.Dictionary\"): taskObj1(\"Name\") = \"Task A\": taskObj1(\"Priority\") = 1\nSet taskObj2 = CreateObject(\"Scripting.Dictionary\"): taskObj2(\"Name\") = \"Task B\": taskObj2(\"Priority\") = 3\nSet taskObj3 = CreateObject(\"Scripting.Dictionary\"): taskObj3(\"Name\") = \"Task C\": taskObj3(\"Priority\") = 2\n\nmyTasks.Add taskObj1, \"T1\"\nmyTasks.Add taskObj3, \"T3\", Before:=\"T1\" ' Add T3 before T1\nmyTasks.Add taskObj2, \"T2\", After:=myTasks.Count ' Add T2 at the end (After last existing item's index)\n\nDim task As Object\nDim i As Long\nFor i = 1 To myTasks.Count\n    Set task = myTasks(i)\n    Debug.Print \"Task \" & i & \" Name: \" & task(\"Name\") & \", Priority: \" & task(\"Priority\")\nNext i\n' Expected order: Task C, Task A, Task B", "explanation": "演示如何使用 Collection 的 Add 方法中的 Before 和 After 引數來控制新增項目的位置，並儲存複雜物件 (此處為 Dictionary)。"}
    ],
    "keywords": ["collection object advanced", "vba collection order", "insert into collection", "object collection", "集合物件進階", "排序集合項目"]
},
{
    "name": "Application.International Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "settingValue = Application.International(Index As XlApplicationInternational)",
    "description": "傳回有關目前國家/地區和國際設定的資訊。",
    "parameters": [
        {"name": "Index", "description": "必需。XlApplicationInternational 常數，指定要傳回的設定 (例如，xlCountryCode, xlCountrySetting, xlCurrencyDigits, xlDateSeparator, xlDecimalSeparator, xlThousandsSeparator, xlTimeSeparator)。"}
    ],
    "examples": [
        {"code": "Debug.Print \"國家/地區代碼: \" & Application.International(xlCountryCode)\nDebug.Print \"國家/地區設定: \" & Application.International(xlCountrySetting)\nDebug.Print \"日期分隔符號: \" & Application.International(xlDateSeparator)\nDebug.Print \"小數分隔符號: \" & Application.International(xlDecimalSeparator)\nDebug.Print \"千位分隔符號: \" & Application.International(xlThousandsSeparator)\nDebug.Print \"貨幣符號: \" & Application.International(xlCurrencySymbol)\nDebug.Print \"通用貨幣格式: \" & Application.International(xlGeneralFormatName)", "explanation": "顯示 Excel 目前使用的各種國際和地區設定，如日期分隔符號、小數點符號等。"}
    ],
    "keywords": ["international settings", "regional settings", "excel localization", "date format", "number format", "國際設定", "地區設定"]
},
{
    "name": "Parameter Object Properties (ADODB.Command)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Parameter 物件具有多個屬性，用於定義如何將參數傳遞給資料庫命令。",
    "parameters": [
        {"name": ".Name", "description": "參數的名稱 (例如，\"@ParamName\")。"},
        {"name": ".Type", "description": "參數的資料類型 (DataTypeEnum 常數，例如 adInteger, adVarChar, adDate)。"},
        {"name": "Direction", "description": "參數的方向 (ParameterDirectionEnum，例如 adParamInput, adParamOutput, adParamInputOutput, adParamReturnValue)。"},
        {"name": ".Size", "description": "對於字串或二進制參數，為最大大小。"},
        {"name": ".Value", "description": "參數的值。"},
        {"name": ".Precision", "description": "對於數值參數，為最大總位數。"},
        {"name": ".NumericScale", "description": "對於數值參數，為小數點右邊的位數。"},
        {"name": ".Attributes", "description": "ParameterAttributesEnum，描述參數的特性 (例如 adParamNullable, adParamSigned)。"}
    ],
    "examples": [
        {"code": "Dim cmd As Object, param As Object ' ADODB.Command, ADODB.Parameter\n' Set cmd = CreateObject(\"ADODB.Command\")\n' ' ... set cmd.ActiveConnection and cmd.CommandText ...\n' ' Example: Creating an input parameter for a stored procedure\n' Set param = cmd.CreateParameter(\"InputCustID\", adVarChar, adParamInput, 10) ' Name, Type, Direction, Size\n' param.Value = \"ALFKI\"\n' cmd.Parameters.Append param\n'\n' ' Example: Creating an output parameter\n' Dim paramOut As Object\n' Set paramOut = cmd.CreateParameter(\"RowCount\", adInteger, adParamOutput)\n' cmd.Parameters.Append paramOut\n'\n' ' cmd.Execute\n' ' MsgBox \"Output RowCount: \" & cmd.Parameters(\"RowCount\").Value", "explanation": "演示如何建立輸入參數 (adVarChar) 和輸出參數 (adInteger)，設定其屬性，並將它們附加到 Command 物件的 Parameters 集合中。"}
    ],
    "keywords": ["adodb parameter properties", "parameter type", "parameter direction", "parameter value", "參數屬性", "ADO參數"]
},
// Word specific objects
{
    "name": "Document.ActiveWindow Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set wdWindow = documentObject.ActiveWindow",
    "description": "傳回一個代表指定文件視窗的 Window 物件。如果文件未在視窗中開啟，則此屬性不可用。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object, activeWin As Object ' Word.Window\n' Set wdDoc = ActiveDocument\n' If Not wdDoc Is Nothing Then\n'   Set activeWin = wdDoc.ActiveWindow\n'   If Not activeWin Is Nothing Then\n'     MsgBox \"活動文件視窗標題: \" & activeWin.Caption\n'     activeWin.WindowState = wdWindowStateMaximize ' Maximize the document window\n'   End If\n' End If", "explanation": "獲取活動文件的活動視窗，顯示其標題，並將該文件視窗最大化。"}
    ],
    "keywords": ["word active window", "document window object", "word ui", "活動文件視窗"]
},
{
    "name": "Document.Range Method (Word)",
    "category": "Word 文件處理",
    "syntax": "Set rng = documentObject.Range([Start As Long], [End As Long])",
    "description": "傳回一個 Range 物件，代表文件中指定的區域。Start 和 End 引數是字元位置。",
    "parameters": [
        {"name": "Start", "description": "可選。範圍的起始字元位置。如果省略，則從文件開頭開始。"},
        {"name": "End", "description": "可選。範圍的結束字元位置。如果省略，則到文件結尾。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, myRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' ' Get a range for the first 100 characters of the document\n' Set myRange = wdDoc.Range(Start:=0, End:=100)\n' myRange.Font.ColorIndex = wdBrightGreen\n' myRange.Select\n' MsgBox \"已選取並格式化文件的前100個字元。\"", "explanation": "選取並格式化文件的前100個字元。"}
    ],
    "keywords": ["word document range", "select text range", "character position", "文件範圍", "字元範圍"]
},
{
    "name": "Range.InsertBefore / .InsertAfter (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.InsertBefore(Text As String)\nrangeObject.InsertAfter(Text As String)",
    "description": "在指定的 Range 物件之前或之後插入指定的文字。原始範圍會擴展以包含新文字。",
    "parameters": [
        {"name": "Text", "description": "必需。要插入的文字。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range ' Get current selection\n' selRange.InsertBefore \"[前綴文字] \"\n' selRange.InsertAfter \" [後綴文字]\"\n' selRange.Font.Bold = True ' The original range now includes the new text", "explanation": "在目前選取的文字前後分別插入前綴和後綴文字，並將整個新範圍設為粗體。"}
    ],
    "keywords": ["word insert text before", "word insert text after", "add text to range", "插入文字前後"]
},
{
    "name": "Range.GoTo Method (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newRange = rangeObject.GoTo(What As WdGoToItem, [Which As WdGoToDirection], [Count As Long], [Name As String])",
    "description": "將範圍移動到指定項目，並傳回一個代表該新位置的 Range 物件。這與 Selection.GoTo 類似，但操作於 Range 物件。",
    "parameters": [
        {"name": "What", "description": "必需。WdGoToItem 常數 (例如，wdGoToPage, wdGoToLine, wdGoToHeading)。"},
        {"name": "Which", "description": "可選。WdGoToDirection 常數 (例如，wdGoToNext, wdGoToPrevious)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, currentRange As Object, nextHeadingRange As Object\n' Set wdDoc = ActiveDocument\n' Set currentRange = wdDoc.Range(0, 0) ' Start of document\n' ' Go to the next heading from the current range\n' Set nextHeadingRange = currentRange.GoTo(What:=wdGoToHeading, Which:=wdGoToNext)\n' If Not nextHeadingRange Is Nothing Then\n'   nextHeadingRange.Select\n'   MsgBox \"已跳至下一個標題: \" & Left(nextHeadingRange.Paragraphs(1).Range.Text, 50)\n' End If", "explanation": "從文件開頭開始，使用 Range.GoTo 方法跳至下一個標題並選取它。"}
    ],
    "keywords": ["word range goto", "navigate with range", "find item range", "範圍跳轉"]
},
// PowerPoint specific objects
{
    "name": "Presentation.Slides Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set slds = presentationObject.Slides",
    "description": "傳回一個 Slides 集合，代表指定簡報中的所有投影片。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\nDim sld As Object ' PowerPoint.Slide\n' Set pptPres = ActivePresentation\n' MsgBox \"此簡報共有 \" & pptPres.Slides.Count & \" 張投影片。\"\n' For Each sld In pptPres.Slides\n'   Debug.Print \"投影片 \" & sld.SlideIndex & \": \" & sld.Name\n' Next sld", "explanation": "顯示活動簡報中的投影片總數，並遍歷所有投影片，列印其索引和名稱。"}
    ],
    "keywords": ["powerpoint slides collection", "all slides", "iterate slides", "投影片集合"]
},
{
    "name": "Slide.Shapes.AddTable (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set tblShape = slideObject.Shapes.AddTable(NumRows As Long, NumColumns As Long, Left As Single, Top As Single, Width As Single, Height As Single)",
    "description": "在投影片上新增一個表格圖案，並傳回代表該表格的 Shape 物件。",
    "parameters": [
        {"name": "NumRows, NumColumns", "description": "必需。表格的列數和欄數。"},
        {"name": "Left, Top, Width, Height", "description": "必需。表格的位置和大小 (以點為單位)。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, newTable As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set newTable = pptSlide.Shapes.AddTable(NumRows:=3, NumColumns:=4, Left:=50, Top:=100, Width:=400, Height:=150)\n' ' Populate the table\n' newTable.Table.Cell(1, 1).Shape.TextFrame.TextRange.Text = \"標題1\"\n' newTable.Table.Cell(2, 1).Shape.TextFrame.TextRange.Text = \"資料A\"\n' MsgBox \"已在第一張投影片新增表格。\"", "explanation": "在第一張投影片上新增一個3列4欄的表格，並填充一些儲存格。"}
    ],
    "keywords": ["powerpoint add table", "insert table ppt", "ppt table shape", "新增表格PPT"]
},
{
    "name": "Table.Cell (PowerPoint Shape)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set cel = tableShapeObject.Table.Cell(Row As Long, Column As Long)",
    "description": "傳回一個 Cell 物件，代表表格圖案 (Shape 物件的 Table 屬性) 中的特定儲存格。",
    "parameters": [
        {"name": "Row", "description": "必需。儲存格所在的列號 (1-based)。"},
        {"name": "Column", "description": "必需。儲存格所在的欄號 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim tblShape As Object ' PowerPoint.Shape (a table)\nDim targetCell As Object ' PowerPoint.Cell\n' Set tblShape = ActivePresentation.Slides(1).Shapes(\"MyTableShape\") ' Assume table shape exists\n' Set targetCell = tblShape.Table.Cell(2, 3) ' Row 2, Column 3\n' targetCell.Shape.TextFrame.TextRange.Text = \"已更新的值\"\n' targetCell.Shape.Fill.ForeColor.RGB = RGB(255, 255, 150) ' Light yellow fill", "explanation": "獲取名為 \"MyTableShape\" 的表格圖案中第2列第3欄的儲存格，並更新其文字和背景色。"}
    ],
    "keywords": ["powerpoint table cell", "access ppt table cell", "format table cell ppt", "PPT表格儲存格"]
},
{
    "name": "Slide.Design Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set des = slideObject.Design",
    "description": "傳回一個 Design 物件，代表指定投影片所使用的設計範本。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object, currentDesign As Object ' PowerPoint.Design\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set currentDesign = pptSlide.Design\n' If Not currentDesign Is Nothing Then\n'   MsgBox \"第一張投影片使用的設計範本名稱: \" & currentDesign.Name\n'   ' You can apply a different design template:\n'   ' ActivePresentation.ApplyTemplate \"C:\\Path\\To\\NewTemplate.potx\"\n' End If", "explanation": "獲取第一張投影片的設計範本物件，並顯示其名稱。同時示範了如何套用新範本 (註解中)。"}
    ],
    "keywords": ["powerpoint slide design", "presentation template", "design template", "投影片設計範本"]
},
{
    "name": "Application.OperatingSystem (Excel/Word/PowerPoint)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "osString = Application.OperatingSystem",
    "description": "傳回目前作業系統的名稱和版本號 (字串)。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"作業系統: \" & Application.OperatingSystem", "explanation": "顯示執行 Office 應用程式的作業系統資訊。"}
    ],
    "keywords": ["operating system", "os version", "system info", "作業系統資訊", "通用"]
},
{
    "name": "Application.PathSeparator (Excel/Word/PowerPoint)",
    "category": "檔案與資料夾管理",
    "syntax": "separatorChar = Application.PathSeparator",
    "description": "傳回作業系統使用的路徑分隔符號 (例如，在 Windows 上是 \"\\\")。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim myPath As String, fileName As String\nfileName = \"report.xlsx\"\nmyPath = \"C:\" & Application.PathSeparator & \"MyDocs\" & Application.PathSeparator & fileName\nMsgBox \"完整路徑: \" & myPath", "explanation": "使用 PathSeparator 屬性來建構平台獨立的檔案路徑 (儘管 VBA 主要在 Windows 上使用，但這是良好實踐)。"}
    ],
    "keywords": ["path separator", "directory separator", "file path construction", "路徑分隔符號", "通用"]
},
// --- Additional Error Handling & Debugging ---
{
    "name": "Error Statement",
    "category": "錯誤處理與調試",
    "syntax": "Error errornumber",
    "description": "模擬發生一個指定編號的錯誤。可用於測試錯誤處理常式。",
    "parameters": [
        {"name": "errornumber", "description": "必需。任何有效的錯誤編號 (0-65535)。"}
    ],
    "examples": [
        {"code": "Sub TestCustomErrorHandler()\n  On Error GoTo HandleMyError\n  Dim x As Integer\n  x = CInt(InputBox(\"輸入一個數字 (輸入0來觸發錯誤):\"))\n  If x = 0 Then\n    Error 11 ' Simulate Division by zero error\n  Else\n    MsgBox \"100 / \" & x & \" = \" & 100 / x\n  End If\nExit Sub\nHandleMyError:\n  MsgBox \"發生錯誤! 編號: \" & Err.Number & \", 描述: \" & Err.Description\nEnd Sub", "explanation": "如果使用者輸入0，則使用 Error 11 語句模擬一個「除以零」的錯誤，以測試 HandleMyError 錯誤處理程序。"}
    ],
    "keywords": ["simulate error", "raise error vba", "test error handler", "模擬錯誤", "觸發錯誤"]
},
// --- More Math/Date ---
{
    "name": "DatePart Function",
    "category": "數學、日期與時間",
    "syntax": "DatePart(interval As String, dateValue, [firstdayofweek As VbDayOfWeek = vbSunday], [firstweekofyear As VbFirstWeekOfYear = vbFirstJan1])",
    "description": "傳回包含日期特定部分的 Variant (Integer)。",
    "parameters": [
        {"name": "interval", "description": "必需。字串表達式，表示要傳回的時間間隔 (例如 \"yyyy\"-年, \"q\"-季, \"m\"-月, \"y\"-年中日, \"d\"-日, \"w\"-周中日, \"ww\"-年中週, \"h\"-時, \"n\"-分, \"s\"-秒)。"},
        {"name": "dateValue", "description": "必需。要評估的 Date 值。"}
    ],
    "examples": [
        {"code": "Dim myDate As Date: myDate = Now\nMsgBox \"目前年份: \" & DatePart(\"yyyy\", myDate)\nMsgBox \"目前季度: \" & DatePart(\"q\", myDate)\nMsgBox \"目前月份: \" & DatePart(\"m\", myDate)\nMsgBox \"今天是今年的第 \" & DatePart(\"y\", myDate) & \" 天。\"\nMsgBox \"今天是本週的第 \" & DatePart(\"w\", myDate, vbMonday) & \" 天 (週一為第一天)。\"\nMsgBox \"今天是今年的第 \" & DatePart(\"ww\", myDate, vbMonday, vbFirstFourDays) & \" 週。\"", "explanation": "使用 DatePart 函數從目前日期和時間中提取各種不同的時間部分，如年、季、月、年中日、周中日和年中週。"}
    ],
    "keywords": ["datepart", "extract date part", "get year", "get month", "get quarter", "date components", "日期部分", "提取日期資訊"]
},
{
    "name": "Excel Data Validation (Advanced) - Dynamic Lists, Custom Formulas",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Scenario: Implement complex data validation rules in Excel using VBA, such as creating dependent dropdown lists (where the choice in one list filters options in another), or applying custom formula-based validation that standard UI options don't easily cover.",
    "description": "此案例演示了如何使用VBA創建比Excel標準數據驗證UI更複雜的驗證規則。**1. 依賴性下拉清單**：假設A列是“國家”，B列是“城市”。當用戶在A列選擇一個國家後，B列的下拉清單應只顯示該國家的城市。VBA可以：a. 監聽A列的`Worksheet_Change`事件。b. 當A列的值改變時，查找該國家對應的城市列表（可能存儲在另一個隱藏的工作表或已命名範圍中）。c. 動態地更新B列對應儲存格的數據驗證清單來源 (`.Validation.Add Type:=xlValidateList, Formula1:=\"=CityListRange\"` 或直接用逗號分隔的字串)。**2. 自定義公式驗證**：對於複雜的業務規則，例如，“如果C列是‘加急’，則D列的日期必須在今天之後的3天內，否則必須在7天內”，可以使用VBA設置一個基於`xlValidateCustom`類型的數據驗證，其`Formula1`是一個計算結果為TRUE/FALSE的Excel公式。VBA可以在UserForm提交數據到工作表前，或在`Worksheet_Change`事件中動態設置這些驗證規則或執行額外的檢查。**3. 動態範圍驗證**：例如，驗證輸入的數值必須大於同一行另一列的值 (`Formula1:=\"=B1>A1\"`，並應用到多行)。VBA可以遍歷範圍並為每個儲存格應用相對的公式驗證。這種自動化對於確保數據輸入的準確性和一致性，特別是在複雜的模板或多人協作的活頁簿中非常有用。",
    "parameters": [
        {"name": "Dependent Dropdown Logic", "description": "如何根據一個儲存格的選擇來篩選另一個儲存格的下拉選項。"},
        {"name": "Custom Validation Formulas", "description": "用於複雜條件檢查的Excel公式。"},
        {"name": "VBA Event Handling (Worksheet_Change)", "description": "用於觸發驗證更新或依賴性清單篩選的事件處理程序。"},
        {"name": "Named Ranges or Helper Sheets", "description": "用於存儲下拉清單源數據或驗證參數。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA for Dependent Dropdown (in Sheet module) ---\n' Private Sub Worksheet_Change(ByVal Target As Range)\n'   Dim KeyCells As Range\n'   Dim countryCell As Range, cityCell As Range\n'   Dim countryName As String, cityListRangeName As String\n'\n'   ' We are interested in changes in the 'Country' column (e.g., Column A)\n'   Set KeyCells = Me.Columns(\"A\") ' Adjust column as needed\n'   If Not Intersect(Target, KeyCells) Is Nothing And Target.Cells.Count = 1 Then\n'     Set countryCell = Target\n'     Set cityCell = countryCell.Offset(0, 1) ' Assume City is in the next column (B)\n'     countryName = Trim(countryCell.Value)\n'\n'     ' Clear previous validation and value in city cell\n'     cityCell.Validation.Delete\n'     cityCell.Value = \"\"\n'\n'     If countryName <> \"\" Then\n'       ' Construct the name of the named range for cities of the selected country\n'       ' (Assume named ranges like \"Cities_USA\", \"Cities_Canada\" exist)\n'       cityListRangeName = \"Cities_\" & Replace(countryName, \" \", \"_\")\n'       \n'       On Error Resume Next ' Check if named range exists\n'       If Not ThisWorkbook.Names(cityListRangeName) Is Nothing Or _\n'          Not Me.Names(cityListRangeName) Is Nothing Then ' Check workbook and worksheet scope names\n'         On Error GoTo 0\n'         cityCell.Validation.Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, _\n'                                 Operator:=xlBetween, Formula1:=\"=\" & cityListRangeName\n'         cityCell.Validation.InputMessage = \"請從清單中選擇一個城市。\"\n'         cityCell.Validation.ShowInput = True\n'         cityCell.Validation.ShowError = True\n'         cityCell.Validation.ErrorTitle = \"無效城市\"\n'         cityCell.Validation.ErrorMessage = \"請選擇一個有效的城市。\"\n'       Else\n'         On Error GoTo 0\n'         cityCell.Validation.Add Type:=xlValidateInputOnly ' Or no validation if no list\n'         cityCell.Validation.InputMessage = \"未找到 '\" & countryName & \"' 的城市清單。\"\n'         ' cityCell.Validation.Add Type:=xlValidateList, Formula1:=\"=\"\"(無城市)\"\"\" ' Provide a dummy list\n'       End If\n'     End If\n'   End If\n' End Sub\n'\n' ' --- Conceptual VBA for Custom Formula Validation (in a standard module) ---\n' Sub ApplyCustomDateValidation(targetRange As Range, conditionCellAddress As String, urgentDays As Integer, normalDays As Integer)\n'   Dim validationFormula As String\n'   ' Example: If C1 = \"Urgent\", then D1 must be within 3 days from today, else within 7 days.\n'   ' Formula for D1 (assuming targetRange is D1):\n'   ' =IF(C1=\"Urgent\",AND(D1>=TODAY(),D1<=TODAY()+3),AND(D1>=TODAY(),D1<=TODAY()+7))\n'   ' For applying to multiple rows, C1 and D1 should be relative in the formula string or use R1C1 style\n'   ' This example is for a single cell for simplicity\n'   validationFormula = \"=IF(\" & conditionCellAddress & \"=\"\"Urgent\"\",AND(\" & targetRange.Address(False, False) & \">=TODAY(),\" & targetRange.Address(False, False) & \"<=TODAY()+\" & urgentDays & \"),\" & _\n'                       \"AND(\" & targetRange.Address(False, False) & \">=TODAY(),\" & targetRange.Address(False, False) & \"<=TODAY()+\" & normalDays & \"))\"\n'\n'   With targetRange.Validation\n'     .Delete\n'     .Add Type:=xlValidateCustom, AlertStyle:=xlValidAlertStop, Formula1:=validationFormula\n'     .ErrorMessage = \"輸入的日期不符合條件。如果類型為'Urgent'，需在 \" & urgentDays & \" 天內；否則需在 \" & normalDays & \" 天內。\"\n'     .ErrorTitle = \"日期錯誤\"\n'     .ShowError = True\n'   End With\n' End Sub\n'\n' ' How to call the custom validation setup:\n' Sub SetupValidations()\n'    ' ApplyCustomDateValidation ThisWorkbook.Sheets(\"Sheet1\").Range(\"D1\"), \"C1\", 3, 7\n' End Sub", "explanation": "此案例概念性地展示了兩種進階數據驗證的VBA實現方法：**1. 依賴性下拉清單**：在工作表的 `Worksheet_Change` 事件中，當“國家”列（假設A列）的值改變時，會觸發代碼。代碼會根據所選國家，動態地將“城市”列（假設B列）對應儲存格的數據驗證清單來源更改為一個預先定義的、與國家相關的已命名範圍（例如，名為 `Cities_USA` 的範圍包含美國城市列表）。如果找不到對應的城市列表，則可以清除驗證或設置一個提示。**2. 自定義公式驗證**：`ApplyCustomDateValidation` 子程序演示瞭如何為目標儲存格設定一個基於複雜條件的自定義公式驗證。例如，如果C1儲存格的值是“Urgent”，則D1儲存格的日期必須在未來3天內；否則，必須在未來7天內。VBA會構建這個 `IF` 和 `AND` 組合的Excel公式，並將其應用於目標儲存格的 `xlValidateCustom` 類型驗證。實際應用中，這些公式和條件可以更複雜，並且可以動態應用於整個數據範圍。"}
    ],
    "keywords": ["vba excel advanced data validation", "excel dependent dropdown list vba", "custom formula validation excel vba", "dynamic data validation excel", "worksheet_change validation", "Excel進階數據驗證", "VBA依賴性下拉清單", "自定義公式驗證"]
},
{
    "name": "在Word文檔的表格中自動計算並填充匯總行 (Excel to Word)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Data is extracted from Excel and populated into a table in a Word document. After populating the detail rows, VBA needs to calculate totals (e.g., sum of a numeric column) for certain columns in the Word table and write these totals into a designated summary row (e.g., the last row) of that Word table.",
    "description": "此案例演示瞭如何在將數據從Excel填充到Word文檔中的表格後，使用VBA在Word表格內部執行計算並填寫匯總資訊。腳本會：1. 從Excel讀取數據並將其填充到Word文檔中的一個目標表格（假設此步驟已完成）。2. 定位Word文檔中的目標表格（例如，通過索引或書籤）。3. 確定需要進行匯總計算的列（例如，金額列、數量列）和用於顯示匯總結果的行（通常是表格的最後一行或一個特定的“總計”行）。4. VBA會遍歷Word表格中數據區域的相關列的儲存格，讀取每個儲存格的數值（需要將文本轉換為數字，並處理可能的錯誤或非數字內容），然後進行累加。5. 將計算出的總和（或其他匯總結果，如平均值、計數）寫回到Word表格中匯總行的相應儲存格。6. (可選) 對匯總行的儲存格應用特定格式（例如，粗體、不同的背景色）。這個過程避免了在Word中手動計算或依賴Word的表格公式（如果VBA控制更為方便），確保了數據填充和匯總的一致性。",
    "parameters": [
        {"name": "Word Document and Table Object", "description": "指向包含目標表格的Word文檔和該表格的物件。"},
        {"name": "Data Columns in Word Table", "description": "Word表格中包含需要匯總的數值的列的索引。"},
        {"name": "Summary Row in Word Table", "description": "Word表格中用於顯示匯總結果的行的索引。"},
        {"name": "Calculation Type", "description": "要執行的匯總計算類型 (例如，Sum, Average, Count)。"}
    ],
    "examples": [
        {"code": "Sub CalculateAndFillWordTableSummaryRow(ByVal wdTable As Object, ByVal dataStartRow As Long, ByVal dataEndRow As Long, ByVal sumColumnIndex As Long, ByVal totalRowIndex As Long)\n' wdTable is a Word.Table object\n' dataStartRow is the first row of data to sum (e.g., 2 if row 1 is header)\n' dataEndRow is the last row of data (e.g., wdTable.Rows.Count - 1 if last row is total row)\n' sumColumnIndex is the column number (1-based) in the Word table to sum\n' totalRowIndex is the row number (1-based) where the total should be placed\n\n    Dim i As Long\n    Dim currentCellValue As String\n    Dim columnSum As Double: columnSum = 0\n    Dim cellToSum As Object ' Word.Cell\n    Dim totalCell As Object ' Word.Cell\n\n    If wdTable Is Nothing Then Exit Sub\n    If dataEndRow < dataStartRow Then Exit Sub\n    If totalRowIndex > wdTable.Rows.Count Or sumColumnIndex > wdTable.Columns.Count Then Exit Sub\n\n    On Error GoTo ErrorHandler\n\n    ' --- Sum the specified column in the Word table ---\n    For i = dataStartRow To dataEndRow\n        Set cellToSum = wdTable.Cell(i, sumColumnIndex)\n        currentCellValue = Trim(Replace(cellToSum.Range.Text, Chr(13) & Chr(7), \"\")) ' Clean cell text\n        currentCellValue = Replace(currentCellValue, \",\", \"\") ' Remove thousands separators for CDbl\n        \n        If IsNumeric(currentCellValue) Then\n            columnSum = columnSum + CDbl(currentCellValue)\n        Else\n            Debug.Print \"警告: 行 \" & i & \", 欄 \" & sumColumnIndex & \" 的值 '\" & currentCellValue & \"' 不是數字，已跳過。\"\n        End If\n    Next i\n\n    ' --- Write the sum to the total row ---\n    Set totalCell = wdTable.Cell(totalRowIndex, sumColumnIndex)\n    totalCell.Range.Text = Format(columnSum, \"#,##0.00\") ' Format the sum\n    totalCell.Range.Font.Bold = True ' Optional: Make total bold\n    \n    Debug.Print \"欄 \" & sumColumnIndex & \" 的總和 \" & columnSum & \" 已寫入表格 '\" & wdTable.ID & \"' 的第 \" & totalRowIndex & \" 列。\"\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"在Word表格計算匯總時發生錯誤: \" & Err.Number & \" - \" & Err.Description, vbCritical\nEnd Sub\n\n' --- Example of how to call the above Sub ---\nSub TestWordTableSummation()\n    Dim wdApp As Object, wdDoc As Object, myTable As Object\n    ' On Error Resume Next\n    ' Set wdApp = GetObject(, \"Word.Application\")\n    ' If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    ' If wdApp Is Nothing Then Exit Sub\n    ' wdApp.Visible = True\n    ' Set wdDoc = wdApp.Documents.Open(\"C:\\Path\\To\\YourWordDocWithTable.docx\") ' **替換路徑**\n    \n    ' If wdDoc.Tables.Count > 0 Then\n    '   Set myTable = wdDoc.Tables(1) ' Assuming it's the first table\n        ' Assume table has headers in row 1, data from row 2 to row (myTable.Rows.Count - 1),\n        ' and total row is the last row. We want to sum column 3 (Amount).\n    '   If myTable.Rows.Count > 2 Then ' At least one data row and one total row\n    '       Call CalculateAndFillWordTableSummaryRow(myTable, 2, myTable.Rows.Count - 1, 3, myTable.Rows.Count)\n    '       wdDoc.Save\n    '   Else\n    '       MsgBox \"表格行數不足，無法計算總計。\"\n    '   End If\n    ' Else\n    '   MsgBox \"Word文檔中未找到表格。\"\n    ' End If\n    ' ' wdDoc.Close\n    ' ' Set wdDoc = Nothing: Set wdApp = Nothing: Set myTable = Nothing\nEnd Sub", "explanation": "此VBA子程序 `CalculateAndFillWordTableSummaryRow` 接受一個Word表格物件以及關於數據行、匯總列和總計行的信息。它會：1. 遍歷指定數據列中的每一行，讀取儲存格的文本。2. 清理文本（移除儲存格標記和千位分隔符）並嘗試將其轉換為數字。3. 將有效的數值累加。4. 最後，將計算出的總和格式化並寫入Word表格中指定的總計行和列，並可選地將總計值設為粗體。`TestWordTableSummation` 過程（註解狀態）演示瞭如何打開一個Word文檔，獲取其中的一個表格，然後調用 `CalculateAndFillWordTableSummaryRow` 來為該表格的特定列計算並填寫總計。**重要提示：** `TestWordTableSummation` 中的文件路徑和表格/列索引需要根據您的實際Word文檔進行調整。儲存格內容清理邏輯可能也需要根據Word表格中數值的實際格式進行調整。"}
    ],
    "keywords": ["vba word table calculation", "sum column in word table vba", "excel to word table summary", "automate word table totals", "Word表格自動計算匯總", "VBA填充Word表格總計"]
},
// Final few to reach 100 new distinct ones.
{
    "name": "Application.IsMember (Excel/Word/PowerPoint)",
    "category": "程式流程與結構控制",
    "syntax": "isMemberResult = Application.IsMember(ObjectName)",
    "description": "用於測試指定的成員是否為 Application 物件的成員。通常用於檢查特定版本的 Office 應用程式是否支援某個較新的屬性或方法，以避免在舊版本中執行時產生錯誤。傳回 True 如果成員存在，否則傳回 False。",
    "parameters": [
        {"name": "ObjectName", "description": "必需。一個字串，表示要測試的屬性或方法的名稱 (例如，\"ActiveWindow.DisplayGridlines\")。"}
    ],
    "examples": [
        {"code": "' In Excel\nIf Application.IsMember(\"WorksheetFunction.XLOOKUP\") Then\n    MsgBox \"此Excel版本支援 XLOOKUP 函數。\"\n    ' value = Application.WorksheetFunction.XLookup(...\nElse\n    MsgBox \"此Excel版本不支援 XLOOKUP。將使用 VLOOKUP 作為備用。\"\n    ' value = Application.WorksheetFunction.VLookup(...\nEnd If", "explanation": "檢查目前 Excel 版本是否支援較新的 XLOOKUP 工作表函數。如果支援，則可以使用它；否則，可以選擇使用 VLOOKUP 作為備用方案。這有助於編寫更具版本兼容性的代碼。"}
    ],
    "keywords": ["application ismember", "check object member existence", "office version compatibility", "feature detection vba", "檢查物件成員是否存在", "Office版本兼容性", "功能檢測"]
},
{
    "name": "DateSerial Function (Edge Cases)",
    "category": "數學、日期與時間",
    "syntax": "DateSerial(year, month, day)",
    "description": "DateSerial 函數不僅能創建標準日期，還能處理超出常規範圍的月或日參數，它會自動調整到正確的日期。例如，Month 參數為0會得到前一年的12月，Day 參數為0會得到前一個月的最後一天。",
    "parameters": [
        {"name": "year", "description": "必需。年份數字。"},
        {"name": "month", "description": "必需。月份數字。可以是相對值，例如 1 - 1 = 0 (前一年12月)。"},
        {"name": "day", "description": "必需。日期數字。可以是相對值，例如 1 - 1 = 0 (前一月最後一天)。"}
    ],
    "examples": [
        {"code": "Dim firstDayOfThisMonth As Date\nfirstDayOfThisMonth = DateSerial(Year(Now), Month(Now), 1)\nMsgBox \"本月第一天: \" & Format(firstDayOfThisMonth, \"yyyy-mm-dd\")\n\nDim lastDayOfLastMonth As Date\nlastDayOfLastMonth = DateSerial(Year(Now), Month(Now), 0)\nMsgBox \"上個月最後一天: \" & Format(lastDayOfLastMonth, \"yyyy-mm-dd\")\n\nDim dayInNextYear As Date\ndayInNextYear = DateSerial(Year(Now), Month(Now) + 3, 15) '三個月後的15號\nMsgBox \"三個月後的15號: \" & Format(dayInNextYear, \"yyyy-mm-dd\")", "explanation": "演示如何使用 DateSerial 獲取本月第一天、上個月最後一天，以及未來某個相對日期。"}
    ],
    "keywords": ["dateserial advanced", "relative dates vba", "calculate month end", "日期計算", "相對日期"]
},
{
    "name": "ActivateMicrosoftApp (General Purpose Sub)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "Call ActivateMicrosoftApp(\"Excel.Application\")",
    "description": "一個通用子程序，用於嘗試啟動或啟用指定的 Microsoft Office 應用程式 (如 Excel, Word, PowerPoint, Outlook)。如果應用程式已執行，則嘗試使其成為活動視窗；如果未執行，則嘗試啟動它。",
    "parameters": [
        {"name": "appName", "description": "必需。字串，表示應用程式的 ProgID (例如 \"Excel.Application\", \"Word.Application\")。"}
    ],
    "examples": [
        {"code": "Sub TestActivateApps()\n    Call ActivateMicrosoftApp(\"Excel.Application\")\n    MsgBox \"Excel 應該已被啟用或啟動。\"\n    ' Call ActivateMicrosoftApp(\"Word.Application\")\n    ' MsgBox \"Word 應該已被啟用或啟動。\"\nEnd Sub\n\nSub ActivateMicrosoftApp(ByVal appProgID As String)\n    Dim appObj As Object\n    Dim appVisible As Boolean\n    appVisible = True ' Default to making it visible\n\n    On Error Resume Next\n    Set appObj = GetObject(, appProgID)\n    If Err.Number <> 0 Then ' Not running or not accessible\n        Err.Clear\n        On Error GoTo CreateErrorHandler ' Different handling if CreateObject fails\n        Set appObj = CreateObject(appProgID)\n        Debug.Print appProgID & \" 實例已建立。\"\n        ' For some apps, Visible needs to be True after creation\n        Select Case LCase(appProgID)\n            Case \"excel.application\", \"word.application\", \"powerpoint.application\"\n                appObj.Visible = True\n            ' Outlook doesn't have a .Visible property at Application level for this purpose\n        End Select\n    Else\n        Debug.Print appProgID & \" 現有實例已被取得。\"\n        ' Try to make it visible or bring to front\n        Select Case LCase(appProgID)\n            Case \"excel.application\", \"word.application\", \"powerpoint.application\"\n                If Not appObj.Visible Then appObj.Visible = True\n                appObj.Activate ' For Excel and Word, this brings app to front\n                                ' For PowerPoint, appObj.ActiveWindow.Activate might be needed if a pres is open\n            Case \"outlook.application\"\n                ' Outlook activation is different, often just runs in background\n                ' You might need to iterate windows or use ShellExecute to bring to front\n                On Error Resume Next\n                appObj.ActiveExplorer.Activate\n                If Err.Number <> 0 Then appObj.ActiveInspector.Activate\n                Err.Clear\n        End Select\n    End If\n    On Error GoTo 0\n    Set appObj = Nothing\n    Exit Sub\nCreateErrorHandler:\n    MsgBox \"無法建立 \" & appProgID & \" 的物件。錯誤: \" & Err.Description, vbCritical\n    Set appObj = Nothing\nEnd Sub", "explanation": "ActivateMicrosoftApp 子程序首先嘗試使用 GetObject 獲取指定 Office 應用程式的現有執行個體。如果失敗（表示應用程式未執行或無法存取），則嘗試使用 CreateObject 建立新執行個體。然後，它會嘗試將應用程式視窗設為可見並啟用它。注意，Outlook 的啟用行為與其他 Office 應用程式不同。"}
    ],
    "keywords": ["activate office application", "getorcreate object", "ensure app running", "vba app activate", "啟用Office應用", "獲取或創建對象", "通用"]
},
{
    "name": "Timer Function (Precise Timing)",
    "category": "數學、日期與時間",
    "syntax": "startTime = Timer\n' ... code to measure ...\nendTime = Timer\nduration = endTime - startTime",
    "description": "Timer 函數傳回自午夜以來經過的秒數 (Single 精確度)。可用於測量 VBA 程式碼區段的執行時間。",
    "parameters": [],
    "examples": [
        {"code": "Sub MeasureExecutionTime()\n    Dim startTime As Single, endTime As Single, i As Long\n    startTime = Timer\n    ' Simulate a time-consuming task\n    For i = 1 To 20000000\n        ' Do nothing, just loop\n    Next i\n    endTime = Timer\n    MsgBox \"程式碼執行耗時: \" & Format(endTime - startTime, \"0.0000\") & \" 秒。\"\nEnd Sub", "explanation": "記錄開始時間，執行一個迴圈，然後記錄結束時間，計算並顯示持續時間。"}
    ],
    "keywords": ["timer function", "measure code execution", "performance timing", "elapsed time", "計時器函數", "測量執行時間"]
},
{
    "name": "CreateObject with Early/Late Binding",
    "category": "程式流程與結構控制",
    "description": "在 VBA 中建立物件時，可以選擇早期繫結 (Early Binding) 或晚期繫結 (Late Binding)。\n**早期繫結**：需要在 VBA 編輯器的「工具」>「設定引用項目」中勾選相應的物件程式庫 (例如，Microsoft Excel Object Library)。然後可以使用強型別宣告物件 (例如 `Dim xlApp As Excel.Application`)。優點是效能較好、有 IntelliSense 提示、編譯時期型別檢查。缺點是如果目標電腦上沒有該版本的物件程式庫，程式碼可能無法執行。\n**晚期繫結**：不需要設定引用項目。物件宣告為通用 `As Object` (例如 `Dim xlApp As Object`)，並使用 `CreateObject(\"ProgID\")` 建立實例。優點是版本獨立性較好。缺點是效能稍差、沒有 IntelliSense、錯誤在執行階段才會發現。",
    "parameters": [
        {"name": "Early Binding Syntax", "description": "Dim obj As LibraryName.ClassName \nSet obj = New LibraryName.ClassName \n' OR \nDim obj As LibraryName.ClassName \nSet obj = CreateObject(\"ProgID\") ' (If ProgID is known and ref set)"},
        {"name": "Late Binding Syntax", "description": "Dim obj As Object \nSet obj = CreateObject(\"ProgID\")"}
    ],
    "examples": [
        {"code": "' --- Early Binding Example (Requires Microsoft Excel Object Library reference) ---\n' Sub EarlyBindExcel()\n'   Dim xlAppEarly As Excel.Application\n'   Dim xlBookEarly As Excel.Workbook\n'   On Error Resume Next\n'   Set xlAppEarly = GetObject(, \"Excel.Application\")\n'   If xlAppEarly Is Nothing Then Set xlAppEarly = New Excel.Application\n'   On Error GoTo 0\n'   If xlAppEarly Is Nothing Then MsgBox \"Cannot start Excel.\": Exit Sub\n'   xlAppEarly.Visible = True\n'   Set xlBookEarly = xlAppEarly.Workbooks.Add\n'   xlBookEarly.Sheets(1).Range(\"A1\").Value = \"Early Bound Excel\"\n'   ' xlAppEarly.Quit ' Cleanup\n'   Set xlBookEarly = Nothing: Set xlAppEarly = Nothing\n' End Sub\n\n' --- Late Binding Example (No specific reference needed) ---\nSub LateBindExcel()\n  Dim xlAppLate As Object ' As Object\n  Dim xlBookLate As Object ' As Object\n  On Error Resume Next\n  Set xlAppLate = GetObject(, \"Excel.Application\")\n  If xlAppLate Is Nothing Then Set xlAppLate = CreateObject(\"Excel.Application\")\n  On Error GoTo 0\n  If xlAppLate Is Nothing Then MsgBox \"Cannot start Excel.\": Exit Sub\n  xlAppLate.Visible = True\n  Set xlBookLate = xlAppLate.Workbooks.Add\n  xlBookLate.Sheets(1).Range(\"A1\").Value = \"Late Bound Excel\"\n  ' xlAppLate.Quit ' Cleanup\n  Set xlBookLate = Nothing: Set xlAppLate = Nothing\nEnd Sub", "explanation": "提供早期繫結和晚期繫結操作 Excel 的範例。早期繫結範例（已註解）需要先在 VBA 編輯器的「工具」>「設定引用項目」中勾選 \"Microsoft Excel [版本號] Object Library\"。晚期繫結則不需要。在晚期繫結中，所有對 Excel 物件的方法和屬性的呼叫都是在執行階段解析的。"}
    ],
    "keywords": ["early binding", "late binding", "createobject binding", "vba object declaration", "performance vs compatibility", "早期繫結", "晚期繫結", "物件宣告"]
},
{
    "name": "財務契約違反預警與Outlook通知系統 (Excel+Outlook)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: An Excel workbook stores loan agreements with key financial covenants (e.g., Debt Service Coverage Ratio, Loan-to-Value, Current Ratio). Client financial data is periodically updated in another Excel sheet. VBA calculates covenant compliance. If a breach or near-breach (e.g., within 10% of threshold) is detected, an alert email is drafted in Outlook to the relationship manager and credit risk officer.",
    "description": "此系統用於自動監控企業客戶的財務契約遵守情況並及時發出預警。1. **Excel數據結構**：a. “Covenants”工作表：儲存每筆貸款的客戶ID、貸款ID、契約類型 (例如 DSCR下限, LTV上限)、契約規定值、預警閾值 (例如，實際值與規定值差異小於10%)。b. “ClientFinancials”工作表：定期更新的客戶財務數據，包含計算契約所需指標的原始數據 (例如，EBITDA、債務總額、資產公允價值、流動資產、流動負債)。c. “AlertLog”工作表：記錄已發出的預警。2. **VBA分析引擎**：a. 遍歷“ClientFinancials”中最新一期數據的客戶。b. 對於每個客戶，查找其在“Covenants”中對應的契約條款。c. 計算實際的財務指標值。d. 比較實際值與契約規定值及預警閾值。3. **Outlook通知整合**：a. 如果檢測到契約違反或接近違反預警閾值，VBA將啟動Outlook。b. 創建一個新的郵件項目。c. 收件人設為該客戶的客戶經理和相關的信貸風險部門郵箱（可從配置表中讀取）。d. 郵件主旨標明“財務契約預警 - 客戶 [客戶名稱]”。e. 郵件正文包含詳細信息：客戶名稱、貸款ID、違反/預警的契約名稱、契約規定值、客戶實際值、差異百分比。f. (可選) 將觸發預警的客戶財務數據摘要或相關契約條款作為附件（例如，Excel範圍複製為圖片，或生成小型PDF報告）。g. 郵件可以设置为直接發送或顯示給用戶預覽後發送。h. 在Excel的“AlertLog”中記錄已發送的預警。",
    "parameters": [
        {"name": "Excel Covenant Sheet", "description": "定義各貸款財務契約條款的工作表。"},
        {"name": "Excel Client Financials Sheet", "description": "客戶最新的財務數據錄入表。"},
        {"name": "VBA Calculation & Comparison Logic", "description": "計算財務指標並與契約比較的核心VBA代碼。"},
        {"name": "Outlook Email Template/Recipients", "description": "預警郵件的內容模板和收件人規則。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet (Main Logic) ---\nSub CheckCovenantsAndAlert()\n    Dim wsFins As Worksheet, wsCovs As Worksheet, wsAlertLog As Worksheet\n    Dim olApp As Object, olMail As Object\n    Dim lastFinRow As Long, lastCovRow As Long, i As Long, c As Long, nextAlertRow As Long\n    Dim clientID As String, finValue As Double, covRuleValue As Double, covWarningThreshold As Double\n    Dim covenantDesc As String, alertMsg As String, rmEmail As String, riskEmail As String\n\n    ' Set wsFins = ThisWorkbook.Sheets(\"ClientFinancials\")\n    ' Set wsCovs = ThisWorkbook.Sheets(\"Covenants\")\n    ' Set wsAlertLog = ThisWorkbook.Sheets(\"AlertLog\")\n    ' ' ... Find last rows, set up Outlook app ...\n\n    ' For i = 2 To lastFinRow ' Loop through latest client financials\n    '   clientID = wsFins.Cells(i, \"ClientID_Col\").Value\n    '   ' For c = 2 To lastCovRow ' Loop through covenants for this client\n    '   '   If wsCovs.Cells(c, \"ClientID_Col\").Value = clientID Then\n    '   '     covenantDesc = wsCovs.Cells(c, \"CovenantName_Col\").Value\n    '   '     covRuleValue = wsCovs.Cells(c, \"RuleValue_Col\").Value\n    '   '     covWarningThreshold = wsCovs.Cells(c, \"WarningThreshold_Col\").Value ' e.g., 0.1 for 10%\n    '   '     finValue = GetCalculatedFinancialMetric(clientID, covenantDesc, wsFins, i) ' Custom function\n    \n    '   '     Dim breach As Boolean: breach = False\n    '   '     Dim warning As Boolean: warning = False\n    '   '     ' --- Comparison Logic (example for a MAX type covenant like LTV) ---\n    '   '     If finValue > covRuleValue Then breach = True\n    '   '     If Not breach And finValue > (covRuleValue * (1 - covWarningThreshold)) Then warning = True\n    \n    '   '     If breach Or warning Then\n    '   '       rmEmail = GetRMEmail(clientID) ' Custom function\n    '   '       riskEmail = \"credit.risk@bank.com\"\n    '   '       Set olMail = olApp.CreateItem(0)\n    '   '       With olMail\n    '   '         .To = rmEmail\n    '   '         .CC = riskEmail\n    '   '         .Subject = \"財務契約預警: \" & clientID & \" - \" & covenantDesc\n    '   '         alertMsg = \"客戶 \" & clientID & \" 的財務契約 '\" & covenantDesc & \"' \" & _\n    '   '                      IIf(breach, \"已違反\", \"接近預警線\") & \".\"\n    '   '         alertMsg = alertMsg & vbCrLf & \"規定值: \" & covRuleValue & \", 實際值: \" & finValue\n    '   '         .Body = alertMsg\n    '   '         .Display ' Or .Send\n    '   '       End With\n    '   '       ' Log to wsAlertLog\n    '   '     End If\n    '   '   End If\n    '   ' Next c\n    ' Next i\n    ' MsgBox \"財務契約檢查完成。\"\nEnd Sub", "explanation": "此VBA概念性腳本概述了檢查客戶財務數據是否符合貸款契約的流程。它會遍歷客戶財務數據和契約規則，如果發現違反或接近預警線的情況，則會準備一封Outlook郵件通知相關的客戶經理和風險部門。實際的`GetCalculatedFinancialMetric`和`GetRMEmail`需要自行實現。"}
    ],
    "keywords": ["excel financial covenant monitoring", "vba outlook alert system", "loan risk management automation", "bank covenant breach notification", "財務契約監控", "VBA Outlook預警", "銀行風控自動化"]
},
{
    "name": "通過Outlook自動收集客戶逾期財務報表/文件",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Excel tracks required client document submission dates (e.g., quarterly financial statements, annual reports, updated collateral valuations). VBA identifies upcoming or overdue documents and automatically drafts/sends reminder emails via Outlook to client contacts, CC'ing the Relationship Manager.",
    "description": "此工具用於自動化追蹤和提醒客戶提交逾期的財務報表或其他關鍵文件。1. **Excel文檔追蹤表 (“DocumentTracker”)**：包含客戶ID、客戶聯繫人姓名、聯繫人郵箱、文件類型 (例如，“Q1財報”、“年報”、“擔保品評估報告”)、規定提交截止日期、實際提交日期 (初始為空)、提醒狀態 (例如，“未提醒”、“已發送第一次提醒”、“已升級”)。2. **VBA提醒邏輯**：a. 定期執行的VBA過程掃描“DocumentTracker”表。b. 對於每個“實際提交日期”為空且已過“規定提交截止日期”（或即將到期，例如提前7天）的記錄：  i. 根據提醒狀態決定郵件內容。例如，第一次提醒語氣較溫和，後續提醒可逐漸升級或包含更詳細的後果說明。  ii. 查找該客戶對應的客戶經理郵箱（可從另一“RM_Client_Map”表獲取）。3. **Outlook郵件生成與發送**：a. 創建一個新的Outlook郵件項目。b. 收件人為客戶聯繫人郵箱，抄送給客戶經理。c. 主旨包含客戶名稱、文件類型和“提醒”字樣。d. 郵件正文使用標準化模板，說明需要提交的文件、截止日期以及提交方式。e. (可選) 郵件可以設置重要性或要求已讀回執。f. 郵件可以直接發送或先顯示給客戶經理預覽。g. 更新Excel中該記錄的“提醒狀態”和“上次提醒日期”。",
    "parameters": [
        {"name": "Excel Document Tracking Sheet", "description": "記錄客戶應提交文件、截止日期和狀態的工作表。"},
        {"name": "Client Contact & RM Email List", "description": "客戶聯繫方式和客戶經理信息的來源。"},
        {"name": "Outlook Email Reminder Templates", "description": "不同提醒級別的郵件模板。"},
        {"name": "VBA Scheduling Logic", "description": "如何以及何時觸發提醒掃描 (例如，每日)。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub SendOverdueDocumentReminders()\n    Dim wsTracker As Worksheet, olApp As Object, olMail As Object\n    Dim lastRow As Long, i As Long, dueDate As Date, daysOverdue As Long\n    Dim clientEmail As String, rmEmail As String, docType As String, clientName As String\n\n    ' Set wsTracker = ThisWorkbook.Sheets(\"DocumentTracker\")\n    ' ' Assume columns: ClientID, ClientName, ContactEmail, DocumentType, DueDate, ActualSubmitDate, ReminderStatus\n    ' Set olApp = CreateObject(\"Outlook.Application\")\n    ' lastRow = wsTracker.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    ' For i = 2 To lastRow\n    '   If IsEmpty(wsTracker.Cells(i, \"ActualSubmitDate_Col\").Value) And _\n    '      IsDate(wsTracker.Cells(i, \"DueDate_Col\").Value) Then\n    '     dueDate = CDate(wsTracker.Cells(i, \"DueDate_Col\").Value)\n    '     daysOverdue = Date - dueDate\n    '     docType = wsTracker.Cells(i, \"DocumentType_Col\").Value\n    '     clientName = wsTracker.Cells(i, \"ClientName_Col\").Value\n\n    '     If daysOverdue > 0 And daysOverdue <= 7 Then ' Example: 1-7 days overdue, first reminder\n    '       If wsTracker.Cells(i, \"ReminderStatus_Col\").Value <> \"First Reminder Sent\" Then\n    '         clientEmail = wsTracker.Cells(i, \"ContactEmail_Col\").Value\n    '         rmEmail = GetRMEmailForClient(wsTracker.Cells(i, \"ClientID_Col\").Value) ' Custom function\n    '         Set olMail = olApp.CreateItem(0)\n    '         With olMail\n    '           .To = clientEmail\n    '           .CC = rmEmail\n    '           .Subject = \"提醒：貴公司 '\" & docType & \"' 尚未提交 - \" & clientName\n    '           .Body = \"尊敬的 \" & clientName & \"，\\n\\n此郵件旨在提醒您，貴公司的 '\" & docType & \"' 原定於 \" & Format(dueDate, \"yyyy-mm-dd\") & \" 提交，目前已逾期 \" & daysOverdue & \" 天。請盡快提交。\\n\\n謝謝合作。\"\n    '           .Display ' Or .Send\n    '         End With\n    '         wsTracker.Cells(i, \"ReminderStatus_Col\").Value = \"First Reminder Sent\"\n    '         wsTracker.Cells(i, \"LastReminderDate_Col\").Value = Date\n    '       End If\n    '     ElseIf daysOverdue > 7 Then ' Second / Escalation reminder logic here\n    '         ' ... similar email logic with stronger wording ...\n    '     End If\n    '   End If\n    ' Next i\n    ' MsgBox \"逾期文件提醒處理完成。\"\nEnd Sub", "explanation": "此概念性腳本掃描Excel中的“DocumentTracker”表，識別已過期但尚未提交的文件。對於符合條件的記錄，它會構建一封提醒郵件，收件人為客戶聯繫人，抄送客戶經理，並更新Excel中的提醒狀態。"}
    ],
    "keywords": ["excel outlook document tracking", "vba automated reminders", "overdue report collection", "post-loan document management", "文件提交追蹤", "自動郵件提醒", "貸後文件管理"]
},
{
    "name": "從Outlook監控客戶負面新聞/預警並更新Excel風險日誌",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: VBA monitors a specific Outlook folder (or rules forward relevant emails there) where news alerts or internal risk flags concerning corporate clients are received. It extracts client identifiers and alert summaries, logging them into an Excel 'Client Risk Log' for review and action by RMs or risk teams.",
    "description": "此工具用於從Outlook郵件中自動捕捉與客戶相關的負面新聞或內部風險提示，並記錄到Excel中。1. **Outlook設定**：a. 設定Outlook規則，將來自特定新聞源 (例如，路透社、彭博，或內部合規/風險部門) 包含特定關鍵詞 (例如，“預警”、“負面新聞”、“訴訟”、“違約風險”) 的郵件自動移動到一個專用資料夾 (例如，“客戶風險警報”)。2. **Excel風險日誌表 (“ClientRiskLog”)**：包含客戶ID/名稱、警報日期、警報來源 (例如，新聞標題、郵件主旨)、警報摘要/關鍵內容、風險級別初判 (可選)、負責人、處理狀態。3. **VBA處理邏輯**：a. VBA腳本定期掃描指定的Outlook“客戶風險警報”資料夾中的未讀郵件。b. 對於每封郵件：  i. 嘗試從郵件主旨或正文中提取客戶的唯一標識符 (例如，公司股票代碼、註冊名稱的關鍵部分)。這可能需要預定義的客戶關鍵詞列表或更智能的文本分析。  ii. 提取警報的關鍵摘要 (例如，郵件主旨本身，或正文中的特定段落)。  iii. (可選) 根據郵件內容中的關鍵詞或來源，初步判斷一個風險級別。c. 將提取到的信息（客戶標識、警報日期、來源、摘要、初判級別）作為新記錄寫入到Excel的“ClientRiskLog”表中。d. 郵件可以標記為已讀或移動到“已處理警報”資料夾。e. (可選) 如果警報級別較高，可以立即觸發一個Outlook任務或郵件通知給相關的客戶經理。4. **後續行動**：客戶經理或風險團隊定期審閱“ClientRiskLog”表，對記錄的警報進行核實、評估影響，並採取相應的貸後管理措施。",
    "parameters": [
        {"name": "Outlook Monitored Folder for Alerts", "description": "存放客戶風險警報郵件的Outlook資料夾。"},
        {"name": "Client Identification Logic", "description": "如何從郵件內容中識別出相關客戶。"},
        {"name": "Alert Summary Extraction Rules", "description": "如何從郵件中提取警報的關鍵信息。"},
        {"name": "Excel Client Risk Log Sheet", "description": "用於記錄警報詳情的工作表。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub LogClientRiskAlertsFromOutlook()\n    Dim olApp As Object, olNS As Object, olAlertFolder As Object, olMail As Object\n    Dim wsLog As Worksheet, nextLogRow As Long\n    Dim clientIdentifier As String, alertSummary As String, mailSubject As String\n\n    ' Set olApp = CreateObject(\"Outlook.Application\")\n    ' Set olNS = olApp.GetNamespace(\"MAPI\")\n    ' Set olAlertFolder = olNS.GetDefaultFolder(6).Folders(\"客戶風險警報\") ' Adjust path\n    ' Set wsLog = ThisWorkbook.Sheets(\"ClientRiskLog\")\n    ' nextLogRow = wsLog.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n\n    ' For Each olMail In olAlertFolder.Items\n    '   If olMail.UnRead Then\n    '     mailSubject = olMail.Subject\n    '     clientIdentifier = ExtractClientFromSubjectOrBody(mailSubject, olMail.Body) ' Custom function\n    '     alertSummary = Left(mailSubject & \" - \" & olMail.Body, 500) ' Simplified summary\n    \n    '     If clientIdentifier <> \"\" Then\n    '       wsLog.Cells(nextLogRow, \"A\").Value = clientIdentifier\n    '       wsLog.Cells(nextLogRow, \"B\".Value = olMail.ReceivedTime\n    '       wsLog.Cells(nextLogRow, \"C\").Value = olMail.SenderName\n    '       wsLog.Cells(nextLogRow, \"D\").Value = alertSummary\n    '       wsLog.Cells(nextLogRow, \"E\").Value = \"待評估\" ' Initial Status\n    '       nextLogRow = nextLogRow + 1\n    '       olMail.UnRead = False\n    '       ' olMail.Move olAlertFolder.Folders(\"ProcessedAlerts\")\n    '     End If\n    '   End If\n    ' Next olMail\n    ' MsgBox \"客戶風險警報日誌已更新。\"\nEnd Sub\n\nFunction ExtractClientFromSubjectOrBody(subject As String, body As String) As String\n    ' Placeholder for logic to find client name/ID\n    ' Example: If InStr(subject, \"ClientX Corp\") > 0 Then ExtractClientFromSubjectOrBody = \"ClientX Corp\"\n    ExtractClientFromSubjectOrBody = \"UnknownClient\" ' Default if not found\nEnd Function", "explanation": "此概念性腳本掃描Outlook中特定文件夾的未讀郵件。它嘗試從每封郵件的主旨或正文中提取客戶標識和警報摘要（通過自定義函數`ExtractClientFromSubjectOrBody`），然後將這些信息記錄到Excel的“ClientRiskLog”表中，並將郵件標記為已讀或移動。"}
    ],
    "keywords": ["outlook email monitoring vba", "excel client risk log", "news alert processing vba", "automated risk flagging", "監控郵件提取風險", "Excel客戶風險日誌", "自動化風險標記"]
},
{
    "name": "從Excel自動生成並通過Outlook郵寄貸款還款通知單",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Excel sheet contains loan details, including client information, loan amount, interest rate, payment due dates, and calculated installment amounts. VBA generates a formatted repayment advice for each loan with an upcoming due date and emails it to the client via Outlook.",
    "description": "此工具自動化貸款還款通知的生成和發送。1. **Excel貸款明細表 (“LoanLedger”)**：包含客戶ID、客戶名稱、客戶郵箱、貸款合同號、下一還款日、本期應還本金、本期應還利息、本期應還總額、貸款餘額等。2. **VBA通知生成邏輯**：a. VBA腳本篩選“LoanLedger”表中“下一還款日”在指定期限內（例如，未來7天或15天）的記錄。b. 對於每條符合條件的貸款記錄：  i. 準備還款通知單的內容。這可以是一個格式化的字符串，或者VBA可以在一個臨時的Excel工作表區域中生成一個小型表格化的通知單。3. **Outlook郵件整合**：a. 創建一個新的Outlook郵件項目。b. 收件人為該筆貸款記錄中的客戶郵箱。c. 主旨包含“還款通知”、“貸款合同號”和“到期日”。d. 郵件正文包含問候語和還款通知的核心信息（應還金額、還款賬號、到期日等）。  i. 如果通知單是在Excel中生成的表格，可以將該表格區域複製為圖片 (`Range.CopyPicture`) 並粘貼到郵件正文的HTMLBody中，或者將該區域另存為PDF作為附件。  ii. 如果通知單是文本，直接填入郵件正文。e. (可選) 添加銀行聯繫方式或查詢鏈接。f. 郵件可以直接發送或顯示供人工審核。g. 在Excel的“LoanLedger”表中更新一個“通知已發送日期”列。",
    "parameters": [
        {"name": "Excel Loan Ledger Sheet", "description": "包含所有貸款明細和還款信息的工作表。"},
        {"name": "Repayment Advice Format", "description": "通知單的格式和內容模板 (文本或Excel區域)。"},
        {"name": "Outlook Email Template", "description": "發送通知郵件的標準郵件模板。"},
        {"name": "VBA Criteria for Sending Reminders", "description": "例如，提前多少天發送還款通知。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub SendLoanRepaymentAdvices()\n    Dim wsLedger As Worksheet, olApp As Object, olMail As Object\n    Dim lastRow As Long, i As Long, nextDueDate As Date, daysToDue As Long\n    Dim clientEmail As String, loanID As String, paymentAmount As Currency, clientName As String\n    Dim adviceText As String\n\n    ' Set wsLedger = ThisWorkbook.Sheets(\"LoanLedger\")\n    ' ' Assume: Col A=LoanID, B=ClientName, C=ClientEmail, D=NextDueDate, E=PaymentAmount\n    ' Set olApp = CreateObject(\"Outlook.Application\")\n    ' lastRow = wsLedger.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    ' For i = 2 To lastRow\n    '   If IsDate(wsLedger.Cells(i, \"D\").Value) Then\n    '     nextDueDate = CDate(wsLedger.Cells(i, \"D\").Value)\n    '     daysToDue = DateDiff(\"d\", Date, nextDueDate)\n    '     If daysToDue >= 0 And daysToDue <= 7 Then ' Due in the next 7 days\n    '       loanID = wsLedger.Cells(i, \"A\").Value\n    '       clientName = wsLedger.Cells(i, \"B\").Value\n    '       clientEmail = wsLedger.Cells(i, \"C\").Value\n    '       paymentAmount = CCur(wsLedger.Cells(i, \"E\").Value)\n    '\n    '       adviceText = \"尊敬的 \" & clientName & \"，\\n\\n您的貸款 \" & loanID & \" 將於 \" & Format(nextDueDate, \"yyyy年m月d日\") & \" 到期，\"\n    '       adviceText = adviceText & \"本期應還金額為： \" & Format(paymentAmount, \"#,##0.00\") & \" 元。\\n\\n請確保按時還款。\"\n    '       adviceText = adviceText & \"\\n\\n銀行敬上\"\n    '\n    '       Set olMail = olApp.CreateItem(0)\n    '       With olMail\n    '         .To = clientEmail\n    '         .Subject = \"貸款還款通知 - 合同號: \" & loanID & \" - 到期日: \" & Format(nextDueDate, \"yyyy-mm-dd\")\n    '         .Body = adviceText\n    '         .Display ' Or .Send\n    '       End With\n    '       ' wsLedger.Cells(i, \"NotificationSentDate_Col\").Value = Date ' Log sent date\n    '     End If\n    '   End If\n    ' Next i\n    ' MsgBox \"還款通知郵件處理完成。\"\nEnd Sub", "explanation": "此概念性腳本掃描Excel中的“LoanLedger”表，查找未來7天內到期的貸款。對於每筆此類貸款，它會生成一段還款通知文本，並創建一封Outlook郵件發送給客戶，郵件中包含貸款號、到期日和應還金額。"}
    ],
    "keywords": ["excel outlook loan repayment reminder", "vba automated payment advice", "generate email from excel data", "bank loan notification", "還款通知自動化", "Excel生成郵件", "貸款到期提醒"]
},
{
    "name": "從Outlook郵件互動中提取客戶關係紀要到Excel",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Relationship Managers (RMs) often have important email exchanges with clients. This tool helps them select one or more emails in Outlook and, with a click of a button (e.g., a custom ribbon button in Outlook), extract key details (sender, recipient, date, subject, and a portion of the body or a user-input summary) into a structured 'Client Interaction Log' in Excel.",
    "description": "此工具旨在幫助客戶經理方便地將重要的Outlook郵件往來記錄到Excel中，作為客戶關係管理和貸後跟進的依據。1. **Outlook自定義功能 (例如，功能區按鈕或右鍵菜單)**：a. 在Outlook中添加一個自定義按鈕，例如“記錄到貸後日誌”。2. **Excel客戶互動日誌表 (“ClientInteractionLog”)**：包含客戶ID/名稱、互動日期、互動類型 (例如，“郵件”)、發件人、收件人、郵件主旨、關鍵內容摘要、RM備註。3. **VBA宏 (在Outlook中或由Outlook調用Excel宏)**：a. 當RM在Outlook中選擇一封或多封郵件並點擊自定義按鈕時，VBA被觸發。b. 對於選中的每封郵件：  i. 提取發件人姓名和郵箱、收件人列表、郵件發送/接收日期、郵件主旨。  ii. (可選) 嘗試從郵件正文中提取開頭的一段文本作為內容預覽，或者彈出一個小輸入框讓RM快速輸入該郵件的摘要或關鍵點。  iii. (可選) 嘗試從郵件主旨或發件人信息中關聯到Excel客戶列表中的客戶ID。c. 將這些提取到的信息作為新記錄寫入到Excel的“ClientInteractionLog”表中。d. (可選) 原始郵件可以在Outlook中被分類到一個“已記錄”的資料夾。4. **用途**：該日誌表可以用於快速回顧與特定客戶的溝通歷史，準備客戶拜訪，或在信貸審查時提供客戶互動背景。",
    "parameters": [
        {"name": "Outlook Custom UI Element", "description": "例如，Outlook功能區上的按鈕，用於觸發宏。"},
        {"name": "Selected Outlook Email(s)", "description": "用戶在Outlook中選中的一封或多封郵件。"},
        {"name": "Excel Client Interaction Log Sheet", "description": "用於存儲提取的郵件摘要信息的工作表。"},
        {"name": "VBA Logic for Data Extraction and Excel Writing", "description": "從MailItem對象提取所需屬性並將其寫入Excel的代碼。"}
    ],
    "examples": [
        {"code": "' --- This code would typically reside in Outlook VBA (ThisOutlookSession) ---\n' --- or be an Excel macro called from Outlook. This is a conceptual Outlook VBA snippet. ---\n' Public Sub LogSelectedEmailsToExcel()\n'   Dim olSelection As Outlook.Selection\n'   Dim olMail As Outlook.MailItem\n'   Dim xlApp As Object ' Excel.Application\n'   Dim xlBook As Object ' Excel.Workbook\n'   Dim xlSheet As Object ' Excel.Worksheet\n'   Dim nextRow As Long\n'   Dim excelFilePath As String: excelFilePath = \"C:\\Path\\To\\ClientInteractionLog.xlsx\" ' **實際路徑**\n'   Dim sheetName As String: sheetName = \"Interactions\"\n\n'   Set olSelection = Application.ActiveExplorer.Selection\n'   If olSelection.Count = 0 Then MsgBox \"請先選擇一封或多封郵件。\", vbInformation: Exit Sub\n\n'   On Error Resume Next\n'   Set xlApp = GetObject(, \"Excel.Application\")\n'   If xlApp Is Nothing Then Set xlApp = CreateObject(\"Excel.Application\")\n'   If xlApp Is Nothing Then MsgBox \"無法啟動Excel。\": Exit Sub\n'   On Error GoTo 0\n'   xlApp.Visible = True ' Or False for background operation\n\n'   On Error Resume Next\n'   Set xlBook = xlApp.Workbooks.Open(excelFilePath)\n'   If xlBook Is Nothing Then\n'       Set xlBook = xlApp.Workbooks.Add\n'       Set xlSheet = xlBook.Sheets(1)\n'       xlSheet.Name = sheetName\n'       xlSheet.Range(\"A1:G1\").Value = Array(\"LogDate\", \"MailDate\", \"Sender\", \"To\", \"CC\", \"Subject\", \"Summary/Notes\")\n'       xlBook.SaveAs excelFilePath\n'   Else\n'       Set xlSheet = xlBook.Sheets(sheetName)\n'       If xlSheet Is Nothing Then ' Sheet doesn't exist in opened workbook\n'           Set xlSheet = xlBook.Sheets.Add(After:=xlBook.Sheets(xlBook.Sheets.Count))\n'           xlSheet.Name = sheetName\n'           xlSheet.Range(\"A1:G1\").Value = Array(\"LogDate\", \"MailDate\", \"Sender\", \"To\", \"CC\", \"Subject\", \"Summary/Notes\")\n'       End If\n'   End If\n'   If xlSheet Is Nothing Then MsgBox \"無法訪問Excel工作表 '\" & sheetName & \"'.\": Exit Sub\n'   On Error GoTo 0\n'   nextRow = xlSheet.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n\n'   For Each olMail In olSelection\n'     If olMail.Class = olMail Then ' olMail (43) is the Class constant for MailItem\n'       Dim userSummary As String\n'       userSummary = InputBox(\"請為郵件輸入摘要 (主旨: '\" & olMail.Subject & \"'):\", \"記錄郵件摘要\", Left(olMail.Body, 200))\n'       If userSummary = \"\" And MsgBox(\"摘要為空，是否繼續記錄？\", vbYesNo) = vbNo Then GoTo NextMail\n\n'       xlSheet.Cells(nextRow, \"A\").Value = Now ' Log timestamp\n'       xlSheet.Cells(nextRow, \"B\").Value = olMail.ReceivedTime ' Or SentOn\n'       xlSheet.Cells(nextRow, \"C\").Value = olMail.SenderName & \" (\" & olMail.SenderEmailAddress & \")\"\n'       xlSheet.Cells(nextRow, \"D\").Value = olMail.To\n'       xlSheet.Cells(nextRow, \"E\").Value = olMail.CC\n'       xlSheet.Cells(nextRow, \"F\").Value = olMail.Subject\n'       xlSheet.Cells(nextRow, \"G\").Value = userSummary\n'       nextRow = nextRow + 1\n'       ' Optional: Categorize or move the email in Outlook\n'       ' olMail.Categories = \"Logged to Excel\"\n'       ' olMail.Save\n'     End If\n'NextMail:\n'   Next olMail\n\n'   xlBook.Save\n'   ' xlBook.Close False ' Or leave open\n'   ' If xlApp.Workbooks.Count = 0 Then xlApp.Quit\n'   MsgBox olSelection.Count & \" 封選中郵件的摘要已嘗試記錄到Excel。\"\n'   Set olMail = Nothing: Set olSelection = Nothing\n'   Set xlSheet = Nothing: Set xlBook = Nothing: Set xlApp = Nothing\n' End Sub", "explanation": "此概念性Outlook VBA腳本 (`LogSelectedEmailsToExcel`) 在用戶選擇Outlook中的郵件並觸發它後執行。它會嘗試打開或創建一個指定的Excel日誌文件和工作表。對於每封選中的郵件，它會彈出一個輸入框讓用戶輸入該郵件的摘要，然後將郵件的關鍵信息（日期、發件人、收件人、主旨）和用戶輸入的摘要記錄到Excel工作表的新行中。"}
    ],
    "keywords": ["outlook vba log email to excel", "excel client communication log", "export outlook email details", "outlook macro save email summary", "記錄Outlook郵件到Excel", "客戶溝通日誌"]
},
{
    "name": "基於Excel風險標記自動生成Outlook任務指派",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: An Excel sheet used for portfolio risk assessment flags certain clients or loans with high-risk indicators or specific required actions (e.g., 'Immediate Review Needed', 'Update Financials', 'Site Visit Pending'). VBA scans this sheet and, for newly flagged items or items with approaching deadlines, automatically creates and assigns Outlook Task items to the responsible Relationship Managers or team members.",
    "description": "此工具用於將Excel中識別的風險點或待辦事項轉化為Outlook中的可追蹤任務。1. **Excel風險/行動計劃表 (“RiskActionTracker”)**：包含客戶ID、風險描述/行動項、風險級別、**責任人郵箱**、**截止日期**、任務創建狀態 (例如，“待創建任務”、“任務已創建”)、完成狀態。2. **VBA任務生成邏輯**：a. VBA腳本掃描“RiskActionTracker”表中“任務創建狀態”為“待創建任務”（或類似標記）的行，或者“截止日期”即將到來的行。b. 對於每條符合條件的記錄：  i. 提取任務所需信息：客戶ID、風險/行動描述、責任人郵箱、截止日期。3. **Outlook任務創建**：a. 創建一個新的Outlook `TaskItem` 對象。b. **設定任務屬性**：  i. `.Subject`：例如，“貸後行動: [客戶ID] - [風險描述]”。  ii. `.Body`：更詳細的說明、相關數據的摘要或指向Excel中記錄的鏈接。  iii. `.Assign`：如果需要正式指派並追蹤，則使用此方法（或者直接在 `.Owner` 或郵件中發送任務）。更簡單的做法是創建任務後，如果知道責任人的郵箱，可以直接在任務的 `.Recipients.Add` 後 `.Assign`，或者將任務 `.Send` 給責任人。最簡單的是在自己的任務列表創建，並將責任人信息放在主題或正文。此處假設創建後指派或發送。  iv. `.DueDate`：設定任務的截止日期。  v. `.StartDate`：設定任務的開始日期 (可選)。  vi. `.ReminderSet = True` 和 `.ReminderTime`：設定提醒。  vii. `.Importance`：設定重要性級別。  viii. `.Status = olTaskNotStarted` (0)。c. **指派與保存/發送**：  i. 如果要正式指派：使用 `.Assign`，然後設定 `.Recipients.Add(ResponsbilePersonEmail)`，最後 `.Send`。  ii. 如果只是在自己任務列表創建並提醒他人，則保存 `.Save()` 後，可另行郵件通知。  iii. 此示例傾向於創建任務後顯示或直接指派。d. 更新Excel中該記錄的“任務創建狀態”為“任務已於 [日期] 創建”，並可記錄Outlook任務的EntryID以便後續關聯。4. **通知 (可選)**：除了任務本身，還可以額外發送一封郵件給責任人，告知已為其分配新任務。",
    "parameters": [
        {"name": "Excel Risk/Action Tracking Sheet", "description": "包含待辦事項、責任人和截止日期的工作表。"},
        {"name": "Outlook Task Properties Mapping", "description": "如何將Excel中的數據映射到Outlook任務的各個字段。"},
        {"name": "VBA Logic for Triggering Task Creation", "description": "決定何時以及為哪些Excel記錄創建Outlook任務的規則。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub CreateOutlookTasksFromExcelRiskSheet()\n    Dim wsTracker As Worksheet, olApp As Object, olTask As Object\n    Dim lastRow As Long, i As Long\n    Dim clientID As String, actionItem As String, responsibleEmail As String, dueDate As Date\n\n    ' Set wsTracker = ThisWorkbook.Sheets(\"RiskActionTracker\")\n    ' ' Assume: Col A=ClientID, B=ActionItem, C=ResponsibleEmail, D=DueDate, E=TaskCreationStatus\n    ' Set olApp = CreateObject(\"Outlook.Application\")\n    ' lastRow = wsTracker.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    ' For i = 2 To lastRow\n    '   If LCase(Trim(CStr(wsTracker.Cells(i, \"E\").Value))) = \"pending creation\" Or IsEmpty(wsTracker.Cells(i, \"E\").Value) Then\n    '     clientID = Trim(CStr(wsTracker.Cells(i, \"A\").Value))\n    '     actionItem = Trim(CStr(wsTracker.Cells(i, \"B\").Value))\n    '     responsibleEmail = Trim(CStr(wsTracker.Cells(i, \"C\").Value))\n    '     If IsDate(wsTracker.Cells(i, \"D\").Value) Then dueDate = CDate(wsTracker.Cells(i, \"D\").Value) Else dueDate = Date + 7 ' Default due date\n    \n    '     If responsibleEmail <> \"\" And InStr(responsibleEmail, \"@\") > 0 Then\n    '       Set olTask = olApp.CreateItem(3) ' 3 = olTaskItem\n    '       With olTask\n    '         .Subject = \"貸後跟進: \" & clientID & \" - \" & Left(actionItem, 50)\n    '         .Body = \"客戶ID: \" & clientID & vbCrLf & \"需採取行動: \" & actionItem & vbCrLf & \"詳情請參考Excel追蹤表。\"\n    '         .DueDate = dueDate\n    '         .StartDate = Date\n    '         .ReminderSet = True\n    '         .ReminderTime = .DueDate - 1 + TimeValue(\"09:00:00\") ' Reminder day before at 9 AM\n    '         .Importance = 2 ' olImportanceHigh\n    '         .Status = 0 ' olTaskNotStarted\n    '         .Assign ' Assign the task\n    '         .Recipients.Add responsibleEmail\n    '         .Recipients.ResolveAll\n    '         .Send ' This sends the task assignment\n    '         ' OR, if just creating for self and notifying via email: .Save then create separate mail item.\n    '       End With\n    '       wsTracker.Cells(i, \"E\").Value = \"Task Created \" & Format(Now, \"yyyy-mm-dd\")\n    '       Debug.Print \"Task created for \" & clientID & \" and assigned to \" & responsibleEmail\n    '     Else\n    '       wsTracker.Cells(i, \"E\").Value = \"Error: Invalid Responsible Email\"\n    '     End If\n    '   End If\n    ' Next i\n    ' MsgBox \"Outlook任務創建處理完成。\"\nEnd Sub", "explanation": "此概念性腳本掃描Excel中的“RiskActionTracker”表，查找需要創建任務的記錄。對於每條記錄，它會創建一個Outlook任務，設定主題、正文、截止日期、提醒等，然後嘗試將任務指派並發送給Excel中指定的責任人郵箱。完成後，更新Excel中的任務創建狀態。"}
    ],
    "keywords": ["excel to outlook task automation", "vba create assigned task", "risk management task assignment", "automate follow-up tasks", "Excel觸發Outlook任務", "自動指派任務"]
},
{
    "name": "Excel追蹤擔保品到期日並用Outlook發送續期提醒",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: An Excel sheet maintains a list of collateral items linked to corporate loans, including collateral type, valuation, and importantly, expiry dates (e.g., for insurance policies covering the collateral, or valuation report validity). VBA periodically scans this list and sends out Outlook email reminders for items nearing expiry to relevant internal teams (e.g., RMs, credit admin, legal) to initiate renewal or re-assessment processes.",
    "description": "此工具用於自動化擔保品（如保險單、評估報告）的到期管理。1. **Excel擔保品管理表 (“CollateralLog”)**：包含客戶ID、貸款ID、擔保品編號、擔保品類型、擔保品描述、評估價值、**評估/保險到期日**、負責部門/RM郵箱、提醒狀態。2. **VBA到期檢查與提醒邏輯**：a. VBA腳本定期（例如，每日或每週）掃描“CollateralLog”表。b. 篩選出“評估/保險到期日”在未來特定預警期內（例如，90天、60天、30天）的記錄。c. 檢查“提醒狀態”，避免重複發送同一級別的提醒。3. **Outlook提醒郵件生成**：a. 對於每個符合提醒條件的擔保品記錄：  i. 創建一個新的Outlook郵件項目。  ii. 收件人設為該擔保品記錄中指定的負責部門/RM郵箱。  iii. 主旨包含“擔保品到期提醒”、客戶ID、擔保品編號和到期日期。  iv. 郵件正文詳細說明即將到期的擔保品信息，並提示需要採取的行動（例如，聯繫客戶辦理續保、安排新的評估）。  v. (可選) 附上與該擔保品相關的內部參考文件或指引的鏈接。  vi. 郵件可以直接發送，或顯示給操作員確認後發送。b. 更新Excel中該擔保品記錄的“提醒狀態”（例如，“已發送90天提醒”）和“上次提醒日期”。4. **升級機制 (可選)**：如果擔保品在第一輪提醒後仍未處理，當進入下一個預警期（例如，30天內到期）時，可以發送升級提醒，可能抄送給更高級別的管理人員。",
    "parameters": [
        {"name": "Excel Collateral Log Sheet", "description": "包含擔保品詳情和到期日期的工作表。"},
        {"name": "Reminder Trigger Periods", "description": "定義提前多少天發送第一、第二輪提醒 (例如，90, 60, 30天)。"},
        {"name": "Outlook Email Templates for Reminders", "description": "不同提醒級別的標準郵件模板。"},
        {"name": "Responsible Party Email Mapping", "description": "如何確定每條提醒郵件的接收人。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub SendCollateralExpiryReminders()\n    Dim wsCollateral As Worksheet, olApp As Object, olMail As Object\n    Dim lastRow As Long, i As Long, expiryDate As Date, daysToExpiry As Long\n    Dim clientID As String, collateralID As String, responsibleEmail As String, reminderType As String\n\n    ' Set wsCollateral = ThisWorkbook.Sheets(\"CollateralLog\")\n    ' ' Assume: Col A=ClientID, B=CollateralID, C=ExpiryDate, D=ResponsibleEmail, E=ReminderStatus\n    ' Set olApp = CreateObject(\"Outlook.Application\")\n    ' lastRow = wsCollateral.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    ' For i = 2 To lastRow\n    '   If IsDate(wsCollateral.Cells(i, \"C\").Value) Then\n    '     expiryDate = CDate(wsCollateral.Cells(i, \"C\").Value)\n    '     daysToExpiry = DateDiff(\"d\", Date, expiryDate)\n    '     clientID = wsCollateral.Cells(i, \"A\").Value\n    '     collateralID = wsCollateral.Cells(i, \"B\").Value\n    '     responsibleEmail = wsCollateral.Cells(i, \"D\").Value\n    '     reminderType = \"\"\n\n    '     If daysToExpiry > 0 And daysToExpiry <= 30 And InStr(wsCollateral.Cells(i, \"E\").Value, \"30DaySent\") = 0 Then\n    '       reminderType = \"30天到期提醒\"\n    '     ElseIf daysToExpiry > 30 And daysToExpiry <= 90 And InStr(wsCollateral.Cells(i, \"E\").Value, \"90DaySent\") = 0 Then\n    '       reminderType = \"90天到期提醒\"\n    '     End If\n\n    '     If reminderType <> \"\" And responsibleEmail <> \"\" Then\n    '       Set olMail = olApp.CreateItem(0)\n    '       With olMail\n    '         .To = responsibleEmail\n    '         .Subject = reminderType & \" - 擔保品: \" & collateralID & \" (客戶: \" & clientID & \")\"\n    '         .Body = \"尊敬的同事，\\n\\n客戶 \" & clientID & \" 的擔保品 '\" & collateralID & \"' 將於 \" & Format(expiryDate, \"yyyy-mm-dd\") & \" 到期 (剩餘 \" & daysToExpiry & \" 天)。\"\n    '         .Body = .Body & \"\\n請及時安排續期或重新評估事宜。\\n\\n貸後管理部\"\n    '         .Display ' Or .Send\n    '       End With\n    '       wsCollateral.Cells(i, \"E\").Value = wsCollateral.Cells(i, \"E\").Value & reminderType & Format(Date, \"yyyyMMdd\") & \"; \"\n    '     End If\n    '   End If\n    ' Next i\n    ' MsgBox \"擔保品到期提醒處理完成。\"\nEnd Sub", "explanation": "此概念性腳本掃描Excel中的“CollateralLog”表，查找在未來90天或30天內到期的擔保品。對於符合條件且尚未發送相應提醒的記錄，它會創建一封Outlook郵件發送給指定的責任人，並更新Excel中的提醒狀態。"}
    ],
    "keywords": ["excel collateral management", "outlook expiry reminder vba", "automate renewal notifications", "bank risk management tools", "擔保品到期提醒", "自動續期通知", "Excel結合Outlook"]
},
{
    "name": "從Outlook客戶反饋郵件中提取信息並記錄到Excel進行趨勢分析",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: A dedicated Outlook mailbox (or folder) receives client feedback, inquiries, or complaints. VBA processes these emails, attempts to categorize them (e.g., based on keywords), extracts key information (client ID if available, date, summary of issue/feedback), and logs this into an Excel sheet. This data can then be used for trend analysis, identifying common pain points, or service improvement opportunities, which are relevant to overall client relationship risk.",
    "description": "此工具用於將分散的客戶反饋郵件結構化地記錄到Excel中，以便分析。1. **Outlook監控資料夾**：設定一個專門的Outlook資料夾（例如，“客戶反饋中心”）接收所有客戶反饋郵件。2. **Excel反饋日誌表 (“ClientFeedbackLog”)**：包含客戶ID（如果可識別）、收到日期、郵件主旨、反饋來源（例如，郵件發件人）、**反饋類型初判**（例如，產品問題、服務投訴、一般諮詢、正面反饋 - 可基於關鍵詞）、反饋內容摘要、處理狀態、責任人。3. **VBA郵件處理與分類邏輯**：a. VBA腳本掃描監控資料夾中的未讀郵件。b. 對於每封郵件：  i. 提取發件人、主旨、接收日期和郵件正文。  ii. 嘗試從發件人郵箱或郵件內容中識別客戶ID。  iii. **關鍵詞分析與分類**：根據預定義的關鍵詞列表（可存儲在另一個Excel配置表中）分析郵件主旨和正文，為該反饋初步打上類型標籤。例如，包含“無法登錄”、“錯誤”等詞的可能標記為“技術問題”。  iv. 提取或生成一個簡短的內容摘要。c. 將提取和分類的信息寫入到Excel的“ClientFeedbackLog”表中。d. 郵件可以標記為已處理，並根據反饋類型移動到不同的子資料夾 (例如，“投訴待辦”、“諮詢已閱”)。4. **數據分析與報告**：Excel中的結構化反饋數據可以用於：a. 創建數據透視表，分析各類反饋的數量、來源和趨勢。b. 識別常見問題點，為改進產品或服務提供依據。c. 追蹤投訴的處理進度和解決情況。",
    "parameters": [
        {"name": "Outlook Monitored Feedback Folder", "description": "接收客戶反饋郵件的Outlook資料夾。"},
        {"name": "Keyword List for Categorization (Excel/VBA)", "description": "用於將反饋郵件自動分類的關鍵詞及其對應類別。"},
        {"name": "Client Identification Logic from Email", "description": "如何從郵件中識別客戶。"},
        {"name": "Excel Feedback Log Sheet", "description": "記錄和分類客戶反饋的工作表。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub LogClientFeedbackFromOutlook()\n    Dim olApp As Object, olNS As Object, olFeedbackFolder As Object, olMail As Object\n    Dim wsLog As Worksheet, wsKeywords As Worksheet\n    Dim nextLogRow As Long, i As Long, k As Long, lastKeywordRow As Long\n    Dim mailSubject As String, mailBody As String, senderEmail As String, feedbackType As String\n\n    ' Set olApp = CreateObject(\"Outlook.Application\")\n    ' Set olNS = olApp.GetNamespace(\"MAPI\")\n    ' Set olFeedbackFolder = olNS.GetDefaultFolder(6).Folders(\"客戶反饋中心\") ' Adjust\n    ' Set wsLog = ThisWorkbook.Sheets(\"ClientFeedbackLog\")\n    ' Set wsKeywords = ThisWorkbook.Sheets(\"FeedbackKeywords\") ' Col A: Keyword, Col B: Category\n    ' nextLogRow = wsLog.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n    ' lastKeywordRow = wsKeywords.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    ' For Each olMail In olFeedbackFolder.Items\n    '   If olMail.UnRead Then\n    '     mailSubject = olMail.Subject\n    '     mailBody = olMail.Body\n    '     senderEmail = olMail.SenderEmailAddress\n    '     feedbackType = \"未分類\"\n\n    '     ' Attempt to categorize based on keywords in subject or body\n    '     For k = 2 To lastKeywordRow\n    '       If InStr(1, mailSubject, wsKeywords.Cells(k, \"A\").Value, vbTextCompare) > 0 Or _\n    '          InStr(1, mailBody, wsKeywords.Cells(k, \"A\").Value, vbTextCompare) > 0 Then\n    '         feedbackType = wsKeywords.Cells(k, \"B\").Value\n    '         Exit For\n    '       End If\n    '     Next k\n    '\n    '     wsLog.Cells(nextLogRow, \"A\").Value = IdentifyClient(senderEmail, mailBody) ' Custom function\n    '     wsLog.Cells(nextLogRow, \"B\").Value = olMail.ReceivedTime\n    '     wsLog.Cells(nextLogRow, \"C\").Value = senderEmail\n    '     wsLog.Cells(nextLogRow, \"D\").Value = mailSubject\n    '     wsLog.Cells(nextLogRow, \"E\").Value = feedbackType\n    '     wsLog.Cells(nextLogRow, \"F\").Value = Left(mailBody, 1000) ' Summary\n    '     wsLog.Cells(nextLogRow, \"G\").Value = \"待處理\"\n    '     nextLogRow = nextLogRow + 1\n    '     olMail.UnRead = False\n    '     ' olMail.Move olFeedbackFolder.Folders(\"ProcessedFeedback\")\n    '   End If\n    ' Next olMail\n    ' MsgBox \"客戶反饋郵件已記錄到Excel。\"\nEnd Sub\n\nFunction IdentifyClient(emailAddr As String, bodyText As String) As String\n    ' Placeholder for logic to identify client ID/Name\n    IdentifyClient = emailAddr ' Default to email if no other logic\nEnd Function", "explanation": "此概念性腳本監控Outlook中特定文件夾的未讀郵件。對於每封郵件，它會嘗試根據Excel“FeedbackKeywords”表中的關鍵詞對反饋進行分類，然後將發件人、主旨、分類、正文摘要等信息記錄到“ClientFeedbackLog”表中。"}
    ],
    "keywords": ["outlook email parsing vba", "excel client feedback analysis", "categorize emails vba", "text mining outlook emails", "客戶反饋郵件處理", "Excel記錄郵件內容", "郵件自動分類"]
},
{
    "name": "通過Excel和Outlook自動分發銀行內部風險報告 (Excel/PDF)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: VBA in a master Excel workbook generates various internal risk reports (e.g., portfolio risk summary, overdue loan list, sector concentration report). These reports might be specific sheets within the master workbook or saved as separate Excel/PDF files. VBA then automatically drafts and sends these reports via Outlook to predefined distribution lists (also managed in an Excel sheet).",
    "description": "此工具用於自動化銀行內部風險報告的生成和分發。1. **Excel報告生成與配置**：a. 一個主Excel活頁簿包含用於生成各種風險報告的數據和VBA宏。例如，一個宏可能創建“月度逾期報告”工作表，另一個宏生成“行業集中度PDF報告”。b. “DistributionList”工作表：包含報告類型、對應的收件人郵箱列表（可以是多個郵箱，用分號隔開）、抄送列表、報告文件附件的路徑（如果報告是另存的）或工作表名稱（如果是主活頁簿內的工作表）。2. **VBA報告分發引擎**：a. 在所有報告生成完畢後，VBA腳本會讀取“DistributionList”表。b. 對於列表中的每一行（每條分發規則）：  i. 獲取報告類型、收件人、抄送人、以及要附加的報告文件路徑或工作表名稱。3. **Outlook郵件準備與發送**：a. 創建一個新的Outlook郵件項目。b. 設定收件人 (.To) 和抄送人 (.CC)。c. 設定郵件主旨，例如，“[報告類型] - [報告期] 已生成”。d. 郵件正文可以包含簡短的說明或指向報告存儲位置的鏈接。e. **處理附件**：  i. 如果報告是單獨的文件（例如PDF），則使用 `.Attachments.Add FilePath`。  ii. 如果報告是當前主活頁簿中的某個工作表，可以先將該工作表複製到一個新的臨時活頁簿中，將該臨時活頁簿保存，然後附加，處理完畢後刪除臨時文件。或者，如果允許，直接附加包含該工作表的主活頁簿（需謹慎）。  iii. 另一種方法是將工作表區域導出為PDF，然後附加PDF。f. 郵件可以直接發送或顯示供最終確認。g. (可選) 在“DistributionList”表中記錄該報告的發送時間和狀態。",
    "parameters": [
        {"name": "Excel Report Generation Macros", "description": "用於生成各種風險報告的VBA代碼。"},
        {"name": "Excel Distribution List Sheet", "description": "定義報告類型、收件人和附件規則的工作表。"},
        {"name": "Report File Paths or Sheet Names", "description": "指定要作為附件的報告文件或工作表。"},
        {"name": "Outlook Email Templates", "description": "分發郵件的標準內容模板。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub DistributeInternalRiskReports()\n    Dim wsDistList As Worksheet, olApp As Object, olMail As Object\n    Dim lastRow As Long, i As Long\n    Dim reportType As String, recipients As String, ccRecipients As String, attachmentPath As String, emailSubject As String\n\n    ' Set wsDistList = ThisWorkbook.Sheets(\"DistributionList\")\n    ' ' Assume: Col A=ReportType, B=ToRecipients, C=CCRecipients, D=AttachmentPathOrSheetName\n    ' Set olApp = CreateObject(\"Outlook.Application\")\n    ' lastRow = wsDistList.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    ' For i = 2 To lastRow\n    '   reportType = wsDistList.Cells(i, \"A\").Value\n    '   recipients = wsDistList.Cells(i, \"B\").Value\n    '   ccRecipients = wsDistList.Cells(i, \"C\").Value\n    '   attachmentPath = wsDistList.Cells(i, \"D\").Value\n    '   emailSubject = reportType & \" - 報告期 \" & Format(Date, \"yyyy-mm\") & \" 已準備就緒\"\n    '\n    '   If recipients <> \"\" And attachmentPath <> \"\" Then\n    '     Set olMail = olApp.CreateItem(0)\n    '     With olMail\n    '       .To = recipients\n    '       If ccRecipients <> \"\" Then .CC = ccRecipients\n    '       .Subject = emailSubject\n    '       .Body = \"尊敬的同事，\\n\\n附件為最新的 \" & reportType & \"。請查收。\\n\\n系統自動發送\"\n    '       ' Check if attachmentPath is a file path or a sheet name to handle\n    '       If Dir(attachmentPath) <> \"\" Then ' It's a file path\n    '         .Attachments.Add attachmentPath\n    '       Else ' Assume it's a sheet name in ThisWorkbook, export as PDF then attach\n    '         Dim tempPdfPath As String\n    '         tempPdfPath = Environ(\"TEMP\") & \"\\\" & attachmentPath & \"_\" & Format(Now, \"yyyymmddhhmmss\") & \".pdf\"\n    '         On Error Resume Next\n    '         ThisWorkbook.Sheets(attachmentPath).ExportAsFixedFormat Type:=xlTypePDF, Filename:=tempPdfPath, Quality:=xlQualityStandard\n    '         If Err.Number = 0 Then .Attachments.Add tempPdfPath: Kill tempPdfPath ' Add then delete temp PDF\n    '         On Error GoTo 0\n    '       End If\n    '       .Display ' Or .Send\n    '     End With\n    '     ' wsDistList.Cells(i, \"LastSent_Col\").Value = Now\n    '   End If\n    ' Next i\n    ' MsgBox \"內部風險報告分發郵件已處理。\"\nEnd Sub", "explanation": "此概念性腳本讀取Excel“DistributionList”表中的分發規則。對於每條規則，它會創建一封Outlook郵件，設定收件人、抄送人、主旨和正文。它會檢查附件欄位是指向一個實際文件路徑還是當前活頁簿中的工作表名。如果是文件路徑，則直接附加；如果是工作表名，則嘗試將該工作表導出為臨時PDF文件然後附加，之後刪除臨時PDF。"}
    ],
    "keywords": ["excel outlook report distribution", "vba automate email attachments", "send reports via outlook vba", "internal reporting automation", "自動分發報告", "Excel郵件附件", "內部報告自動化"]
},
{
    "name": "使用Excel UserForm觸發向客戶發送特定資料請求郵件 (Outlook)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: A Relationship Manager (RM) needs specific, non-standard information from a corporate client. An Excel UserForm allows the RM to select/enter the client ID, define the specific information or documents requested, and optionally set a due date. VBA then drafts a standardized request email in Outlook, populates it with these details, and presents it to the RM for review and sending.",
    "description": "此工具為客戶經理提供了一個快速、標準化的方式來向客戶發出特定資料請求。1. **Excel客戶主數據表 (“ClientMaster”)**：包含客戶ID、客戶名稱、主要聯繫人姓名、主要聯繫人郵箱。2. **Excel UserForm (`ufAdHocRequest`) 設計**：a. 下拉框選擇客戶ID（可從“ClientMaster”表填充，選擇後自動帶出客戶名稱和聯繫人郵箱）。b. 大型文本框用於RM輸入具體的資料請求內容/問題列表。c. 日期選擇器用於RM設定期望客戶回覆的截止日期 (可選)。d. 預覽/發送按鈕。3. **VBA郵件生成邏輯**：a. 當RM在UserForm中填寫完畢並點擊按鈕後：  i. VBA獲取客戶郵箱、RM輸入的請求詳情和期望截止日期。  ii. 創建一個新的Outlook郵件項目。  iii. 收件人設為客戶聯繫人郵箱，抄送給RM自己。  iv. 主旨可以標準化，例如，“資料請求 - [客戶名稱] - [簡要請求主題]”。  v. 郵件正文包含標準化的問候語、RM輸入的具體請求內容、期望的截止日期以及感謝語。  vi. 郵件使用 `.Display` 方法顯示給RM，讓其在發送前可以進行最終檢查或微調。4. **Excel請求日誌 (可選)**：a. 將每次通過UserForm發出的請求（客戶ID、請求內容、發送日期、期望截止日期）記錄到一個“AdHocRequestLog”工作表中，以便追蹤。這個工具確保了即使是非標準的資料請求也能以專業和一致的格式發出，並有助於記錄這些臨時請求。",
    "parameters": [
        {"name": "Excel UserForm for Request Input", "description": "包含客戶選擇、請求詳情輸入和截止日期設定的界面。"},
        {"name": "Excel Client Master Data Sheet", "description": "提供客戶聯繫信息的來源。"},
        {"name": "Outlook Email Template (Structure defined in VBA)", "description": "請求郵件的標準化格式和措辭。"},
        {"name": "Excel Ad-hoc Request Log Sheet (Optional)", "description": "用於記錄發出的臨時請求的工作表。"}
    ],
    "examples": [
        {"code": "' --- UserForm (ufAdHocRequest) Conceptual Code for 'Draft Email' Button ---\n' Private Sub cmdDraftRequestEmail_Click()\n'   Dim clientID As String, clientEmail As String, clientName As String\n'   Dim requestDetails As String, dueDate As Variant\n'   Dim olApp As Object, olMail As Object\n'   Dim wsMaster As Worksheet, findRow As Range\n'\n'   If Me.cboClientID.ListIndex = -1 Then MsgBox \"請選擇客戶ID。\": Exit Sub\n'   clientID = Me.cboClientID.Value\n'   requestDetails = Me.txtRequestDetails.Value\n'   If Trim(requestDetails) = \"\" Then MsgBox \"請輸入請求詳情。\": Exit Sub\n'   If IsDate(Me.txtDueDate.Value) Then dueDate = CDate(Me.txtDueDate.Value) Else dueDate = Empty\n'\n'   ' Get client details from master sheet\n'   Set wsMaster = ThisWorkbook.Sheets(\"ClientMaster\") ' Assume Col A=ClientID, B=ClientName, C=ContactEmail\n'   Set findRow = wsMaster.Columns(\"A\").Find(What:=clientID, LookIn:=xlValues, LookAt:=xlWhole)\n'   If findRow Is Nothing Then MsgBox \"未在主數據表中找到客戶ID：\" & clientID: Exit Sub\n'   clientName = wsMaster.Cells(findRow.Row, \"B\").Value\n'   clientEmail = wsMaster.Cells(findRow.Row, \"C\").Value\n'   If clientEmail = \"\" Or InStr(clientEmail, \"@\") = 0 Then MsgBox \"客戶郵箱無效。\": Exit Sub\n'\n'   Set olApp = CreateObject(\"Outlook.Application\")\n'   Set olMail = olApp.CreateItem(0)\n'   With olMail\n'     .To = clientEmail\n'     .CC = Application.UserName & \"@bank.com\" ' CC to self (RM)\n'     .Subject = \"資料請求 - \" & clientName & \" - 截止日期: \" & IIf(IsEmpty(dueDate), \"盡快\", Format(dueDate, \"yyyy-mm-dd\"))\n'     Dim bodyStr As String\n'     bodyStr = \"尊敬的 \" & clientName & \"，\\n\\n\" \n'     bodyStr = bodyStr & \"根據我行貸後管理需要，請貴公司提供以下資料/信息：\\n\"\n'     bodyStr = bodyStr & requestDetails & \"\\n\\n\"\n'     If Not IsEmpty(dueDate) Then\n'       bodyStr = bodyStr & \"請於 \" & Format(dueDate, \"yyyy年m月d日\") & \" 前提供。\\n\\n\"\n'     End If\n'     bodyStr = bodyStr & \"感謝您的合作。\\n\\n此致，\\n\" & Application.UserName & \"\\n[您的銀行名稱]\"\n'     .Body = bodyStr\n'     .Display\n'   End With\n'\n'   ' Optional: Log this request to 'AdHocRequestLog' sheet\n'   ' ... logging code ...\n'   MsgBox \"資料請求郵件已為客戶 '\" & clientName & \"' 準備好，請在Outlook中檢查並發送。\"\n' End Sub", "explanation": "此概念性UserForm按鈕事件代碼演示了如何從UserForm獲取客戶ID、請求詳情和截止日期。然後，它從“ClientMaster”表查找客戶的郵箱，並創建一封標準格式的Outlook郵件，將請求信息填充到郵件正文中，並將郵件顯示給客戶經理預覽。"}
    ],
    "keywords": ["excel userform outlook email", "vba generate adhoc request", "client data request automation", "outlook mail draft vba", "Excel UserForm觸發郵件", "自動生成資料請求"]
},
{
    "name": "基於Excel配置的Outlook郵件過濾與自動歸檔系統",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: An Excel sheet defines rules for filtering incoming Outlook emails and automatically moving them to specific subfolders. Rules can be based on sender, subject keywords, recipient addresses, or message content. This helps in organizing a high-volume inbox, especially for shared mailboxes or specific project-related correspondence.",
    "description": "此工具實現了基於Excel規則的Outlook郵件自動歸檔。1. **Excel歸檔規則表 (“MailArchiveRules”)**：a. 包含列：規則ID、來源資料夾 (默認為收件匣，或指定其他)、條件欄位 (例如，發件人郵箱、主旨、正文內容、收件人包含)、條件類型 (例如，等於、包含、開頭為、正則表達式)、條件值、目標歸檔資料夾路徑 (相對於收件匣或完整路徑)。2. **VBA郵件處理引擎**：a. VBA腳本（可在Outlook啟動時運行，或手動觸發，或通過`Application.OnTime`定期運行）讀取“MailArchiveRules”表中的所有規則。b. 遍歷指定來源資料夾中的郵件項目（例如，所有未讀郵件，或所有郵件）。c. 對於每封郵件，逐條檢查是否符合“MailArchiveRules”表中定義的某條規則的條件。  i. 根據“條件欄位”和“條件類型”檢查郵件的相應屬性是否與“條件值”匹配。例如，如果規則是“主旨包含‘月報’”，則檢查`olMail.Subject Like \"*月報*\"`。ii. 可以實現多條件AND/OR邏輯（例如，規則表增加一列定義條件組合方式）。d. **執行歸檔**：  i. 如果郵件符合某條規則，則將該郵件移動到規則中指定的“目標歸檔資料夾”。需要VBA代碼來解析目標資料夾路徑並找到或創建該Outlook資料夾對象。  ii. 郵件移動後，可以跳出規則檢查循環（如果設定為匹配第一條規則即執行）。e. **日誌記錄 (可選)**：將每條執行的歸檔操作（郵件、匹配的規則、移動到的目標資料夾、時間）記錄到Excel的“ArchiveLog”表中。這個系統有助於保持Outlook收件匣的整潔，並自動將郵件分類到相關的項目或客戶資料夾中，提高信息檢索效率。",
    "parameters": [
        {"name": "Excel Archiving Rules Sheet", "description": "定義郵件篩選條件和目標歸檔資料夾的工作表。"},
        {"name": "Outlook Source Folder(s) to Monitor", "description": "要應用歸檔規則的一個或多個Outlook資料夾。"},
        {"name": "VBA Rule Matching and Mail Moving Logic", "description": "解析規則、匹配郵件並執行移動操作的代碼。"},
        {"name": "Outlook Target Archive Folders", "description": "用於存放歸檔郵件的Outlook資料夾結構 (VBA可能需要動態創建它們)。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet (Can be adapted for Outlook VBA or Excel VBA controlling Outlook) ---\nSub AutoArchiveEmailsBasedOnExcelRules()\n    Dim olApp As Object, olNS As Object, sourceFolder As Object, targetFolder As Object\n    Dim rulesSheet As Worksheet, logSheet As Worksheet\n    Dim mailItem As Object, rule As Range, ruleSet As Range\n    Dim criteriaField As String, criteriaType As String, criteriaValue As String, targetFolderPath As String\n    Dim mailProperty As String, match As Boolean, processedCount As Long\n\n    ' Set olApp = CreateObject(\"Outlook.Application\")\n    ' Set olNS = olApp.GetNamespace(\"MAPI\")\n    ' Set sourceFolder = olNS.GetDefaultFolder(6) ' Inbox, or specific folder\n    ' Set rulesSheet = ThisWorkbook.Sheets(\"MailArchiveRules\")\n    ' Set logSheet = ThisWorkbook.Sheets(\"ArchiveLog\") ' Optional\n    ' Set ruleSet = rulesSheet.Range(\"A2:E\" & rulesSheet.Cells(Rows.Count, \"A\").End(xlUp).Row) ' A:Field, B:Type, C:Value, D:TargetFolder, E:Enabled(T/F)\n\n    ' For Each mailItem In sourceFolder.Items ' Consider restricting to Unread or specific date range\n    '   If mailItem.Class = olMail Then\n    '     match = False\n    '     For Each rule In ruleSet.Rows\n    '       If LCase(Trim(CStr(rule.Cells(1, 5).Value))) = \"true\" Then ' Check if rule is enabled\n    '         criteriaField = LCase(Trim(CStr(rule.Cells(1, 1).Value)))\n    '         criteriaType = LCase(Trim(CStr(rule.Cells(1, 2).Value)))\n    '         criteriaValue = Trim(CStr(rule.Cells(1, 3).Value))\n    '         targetFolderPath = Trim(CStr(rule.Cells(1, 4).Value))\n    '\n    '         Select Case criteriaField\n    '           Case \"senderemailaddress\": mailProperty = mailItem.SenderEmailAddress\n    '           Case \"subject\": mailProperty = mailItem.Subject\n    '           Case \"body\": mailProperty = mailItem.Body\n    '           Case \"to\": mailProperty = mailItem.To\n    '           Case Else: mailProperty = \"\"\n    '         End Select\n    '\n    '         If mailProperty <> \"\" Then\n    '           Select Case criteriaType\n    '             Case \"contains\": If InStr(1, mailProperty, criteriaValue, vbTextCompare) > 0 Then match = True\n    '             Case \"equals\": If LCase(mailProperty) = LCase(criteriaValue) Then match = True\n    '             Case \"startswith\": If LCase(Left(mailProperty, Len(criteriaValue))) = LCase(criteriaValue) Then match = True\n    '             ' Add more: regex, etc.\n    '           End Select\n    '         End If\n    '\n    '         If match Then\n    '           Set targetFolder = GetOutlookFolder(olNS, targetFolderPath, True) ' Custom function to get/create folder\n    '           If Not targetFolder Is Nothing Then\n    '             mailItem.Move targetFolder\n    '             processedCount = processedCount + 1\n    '             ' LogAction mailItem, rule.Cells(1,0).Value ' RuleID if you have one\n    '             Exit For ' Stop processing more rules for this mail if moved\n    '           End If\n    '         End If\n    '       End If ' End if rule enabled\n    '     Next rule\n    '   End If\n    ' Next mailItem\n    ' MsgBox processedCount & \" 封郵件已根據規則自動歸檔。\"\nEnd Sub\n\nFunction GetOutlookFolder(ns As Object, folderPath As String, createIfMissing As Boolean) As Object ' Outlook.MAPIFolder\n    ' Custom function to parse folderPath (e.g., \"Inbox/Sub1/Sub2\") and get/create it.\n    ' Returns MAPIFolder object or Nothing.\n    ' (Implementation detail omitted for brevity)\n    Set GetOutlookFolder = Nothing ' Placeholder\nEnd Function", "explanation": "此概念性腳本讀取Excel“MailArchiveRules”表中的歸檔規則。對於指定Outlook源文件夾中的每封郵件，它會遍歷規則。如果郵件的某個屬性（如發件人、主旨）符合規則的條件類型（如包含、等於）和條件值，則郵件會被移動到規則中指定的目標資料夾。需要一個輔助函數`GetOutlookFolder`來解析路徑並獲取或創建目標Outlook資料夾。"}
    ],
    "keywords": ["outlook email archiving vba", "excel rules for outlook folders", "automate email organization", "vba move emails to folder", "郵件自動歸檔", "Excel規則管理Outlook", "郵件整理自動化"]
},
{
    "name": "企業客戶年度審查提醒與資料準備自動化 (Excel+Outlook)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: An Excel master list tracks corporate clients and their annual review dates. VBA identifies clients due for review in the upcoming period (e.g., next month), sends a notification email to the RM, prepares a preliminary data pack (e.g., by creating a new Excel workbook populated with the client's basic info, last review date, and placeholders for new data), and creates a task in Outlook for the RM.",
    "description": "此工具協助客戶經理準備和追蹤企業客戶的年度審查。1. **Excel客戶審查計劃表 (“AnnualReviewSchedule”)**：包含客戶ID、客戶名稱、客戶經理、**上次審查日期**、**下次計劃審查日期**（可基於上次審查日期+1年計算）、審查狀態（例如，待計劃、準備中、已完成）、提醒發送狀態。2. **VBA審查提醒與準備邏輯**：a. VBA腳本定期掃描“AnnualReviewSchedule”表，查找“下次計劃審查日期”在未來特定時間窗口內（例如，下個月或未來45天）且“提醒發送狀態”為空的記錄。b. 對於每條符合條件的客戶記錄：  i. **準備初步資料包**：    - 可以複製一個標準的Excel審查模板文件。    - 從客戶主數據表、歷史審查記錄（如果存在）中提取客戶基本信息、上次審查的關鍵結論、當前貸款餘額等，並填充到新複製的審查模板文件的指定位置。    - 審查模板中應包含需要客戶經理在本次審查中更新或填寫的空白欄位和指引。    - 將此初步資料包保存到一個共享位置或客戶經理的個人文件夾，文件名包含客戶ID和審查年份。  ii. **創建Outlook任務**：    - 為客戶經理創建一個Outlook任務，主題為“客戶年度審查準備 - [客戶ID]”，截止日期設為下次計劃審查日期前一兩週。    - 任務正文中包含客戶名稱、審查到期日，並可附上指向已準備的初步資料包文件的鏈接。  iii. **發送Outlook通知郵件**：    - 向客戶經理發送一封郵件，通知其客戶[客戶ID]的年度審查即將到期，初步資料包已準備好（附上路徑或鏈接），並已為其創建Outlook任務。    - 抄送給客戶經理的主管或貸後管理團隊（可選）。  iv. **更新Excel狀態**：在“AnnualReviewSchedule”表中更新該客戶的“提醒發送狀態”（例如，“已發送準備提醒”）和“提醒日期”。3. **後續**：客戶經理根據任務和郵件提醒，使用準備好的初步資料包，完成客戶的年度審查，並在審查完成後更新Excel中的“審查狀態”和“實際審查日期”。",
    "parameters": [
        {"name": "Excel Annual Review Schedule Sheet", "description": "包含客戶審查日期和狀態的工作表。"},
        {"name": "Excel Review Template File", "description": "用於生成初步資料包的標準審查模板。"},
        {"name": "VBA Logic for Data Pack Preparation", "description": "從各處提取客戶信息並填充到審查模板的代碼。"},
        {"name": "Outlook Task and Email Notification Content", "description": "任務和郵件的標準化內容。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub PrepareForAnnualReviews()\n    Dim wsReview As Worksheet, olApp As Object, olMail As Object, olTask As Object\n    Dim lastRow As Long, i As Long, nextReviewDate As Date, daysToReview As Long\n    Dim clientID As String, rmEmail As String, dataPackPath As String\n\n    ' Set wsReview = ThisWorkbook.Sheets(\"AnnualReviewSchedule\")\n    ' ' Assume: A=ClientID, B=ClientName, C=RMEmail, D=NextReviewDate, E=ReminderStatus\n    ' Set olApp = CreateObject(\"Outlook.Application\")\n    ' lastRow = wsReview.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    ' For i = 2 To lastRow\n    '   If IsDate(wsReview.Cells(i, \"D\").Value) And IsEmpty(wsReview.Cells(i, \"E\").Value) Then\n    '     nextReviewDate = CDate(wsReview.Cells(i, \"D\").Value)\n    '     daysToReview = DateDiff(\"d\", Date, nextReviewDate)\n    '     If daysToReview > 0 And daysToReview <= 45 Then ' Due in next 45 days\n    '       clientID = wsReview.Cells(i, \"A\").Value\n    '       rmEmail = wsReview.Cells(i, \"C\").Value\n    '\n    '       ' 1. Prepare Data Pack (Conceptual - function would do this)\n    '       dataPackPath = CreateReviewDataPack(clientID) ' Returns path to the prepared file\n    '       If dataPackPath = \"\" Then GoTo NextClient ' Skip if data pack fails\n    '\n    '       ' 2. Create Outlook Task\n    '       Set olTask = olApp.CreateItem(3) ' olTaskItem\n    '       With olTask\n    '         .Subject = \"年度審查準備: \" & clientID\n    '         .Body = \"客戶 \" & clientID & \" 的年度審查將於 \" & Format(nextReviewDate, \"yyyy-mm-dd\") & \" 到期。\" & _\n    '                   vbCrLf & \"初步資料包位於: \" & dataPackPath\n    '         .DueDate = nextReviewDate - 7 ' Due one week before review date\n    '         .ReminderSet = True\n    '         .Save ' Save to RM's task list (or .Assign and .Send if assigning)\n    '       End With\n    '\n    '       ' 3. Send Outlook Email Notification\n    '       Set olMail = olApp.CreateItem(0)\n    '       With olMail\n    '         .To = rmEmail\n    '         .Subject = \"提醒: 客戶 \" & clientID & \" 年度審查即將於 \" & Format(nextReviewDate, \"yyyy-mm-dd\") & \" 到期\"\n    '         .Body = \"尊敬的客戶經理，\\n\\n客戶 \" & clientID & \" 的年度審查將於 \" & Format(nextReviewDate, \"yyyy-mm-dd\") & \" 到期。\"\n    '         .Body = .Body & \"\\n我們已為您準備了初步的資料包，存放於: \" & dataPackPath\n    '         .Body = .Body & \"\\n相關的Outlook任務也已創建。請及時跟進。\\n\\n貸後管理部\"\n    '         .Display ' Or .Send\n    '       End With\n    '       wsReview.Cells(i, \"E\").Value = \"ReminderSent_\" & Format(Date, \"yyyyMMdd\")\n    '     End If\n    '   End If\n'NextClient:\n    ' Next i\n    ' MsgBox \"年度審查提醒和資料準備處理完成。\"\nEnd Sub\n\nFunction CreateReviewDataPack(clientID As String) As String\n    ' Placeholder: This function would:\n    ' 1. Copy a template Excel review file.\n    ' 2. Populate it with data for clientID from other sheets/DB.\n    ' 3. Save it to a shared location or RM's folder.\n    ' 4. Return the full path to the saved file.\n    CreateReviewDataPack = \"C:\\Temp\\ReviewPack_\" & clientID & \".xlsx\" ' Dummy path\nEnd Function", "explanation": "此概念性腳本掃描Excel“AnnualReviewSchedule”表，查找即將需要年度審查的客戶。對於每個客戶，它會調用一個（假設的）`CreateReviewDataPack`函數來生成一個初步的資料包（一個填充了客戶信息的Excel審查模板）。然後，它為負責的客戶經理創建一個Outlook任務，提醒他們準備審查，並發送一封包含資料包路徑和任務信息的通知郵件。最後，更新Excel中的提醒狀態。"}
    ],
    "keywords": ["excel outlook annual review automation", "vba client review reminder", "automate data pack generation", "outlook task from excel data", "客戶年度審查自動化", "資料準備提醒", "Excel生成Outlook任務"]
},
{
    "name": "多表貸款數據按客戶ID合併與歷史還款記錄分析 (Excel)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Loan origination data is in 'LoanOrigination' sheet (LoanID, ClientID, OriginationDate, Amount, Term). Payment history is in 'PaymentHistory' sheet (LoanID, PaymentDate, AmountPaid, PrincipalPaid, InterestPaid). VBA consolidates this by ClientID into a 'ClientLoanSummary' sheet, showing all loans per client and a summary of their payment performance (e.g., total paid, remaining balance, average days overdue if tracked).",
    "description": "此工具用於將分散在不同工作表中的客戶貸款信息和還款歷史按客戶ID進行合併和初步分析。1. **Excel數據表**：a. “LoanOrigination”表：LoanID (主鍵), ClientID, OriginationDate, LoanAmount, LoanTerm (月), InterestRate。b. “PaymentHistory”表：PaymentID, LoanID (外鍵), PaymentDate, AmountPaid, PrincipalComponent, InterestComponent, DaysOverdue (可選)。c. “ClientMaster”表 (可選)：ClientID (主鍵), ClientName, ContactInfo。2. **VBA合併與分析邏輯**：a. 創建一個新的“ClientLoanSummary”工作表。b. 遍歷“ClientMaster”表（或從“LoanOrigination”提取唯一ClientID列表）。c. 對於每個ClientID：  i. 在“ClientLoanSummary”中寫入客戶基本信息。  ii. 查找“LoanOrigination”表中該客戶的所有貸款記錄，並將貸款詳情（LoanID, Amount, Term, Rate）列出。  iii. 對於客戶的每筆貸款，從“PaymentHistory”表中查找並彙總其所有還款記錄：計算已還本金總額、已還利息總額、總還款次數、平均逾期天數（如果DaysOverdue列存在）。  iv. 計算該筆貸款的當前剩餘應還本金。  v. 將這些還款摘要信息和剩餘本金寫到“ClientLoanSummary”表中對應貸款的旁邊。3. **更新條件**：可以設定一個“上次更新日期”儲存格。只有當“LoanOrigination”或“PaymentHistory”表的數據自上次更新以來發生變化時（例如，通過比較最大日期或記錄數），才執行完整的合併和分析。或者，提供一個按鈕手動觸發刷新。4. **輸出**：“ClientLoanSummary”表清晰展示每個客戶名下的所有貸款及其詳細的還款概況和當前狀態。",
    "parameters": [
        {"name": "Loan Origination Data Sheet", "description": "包含貸款發放原始記錄的工作表。"},
        {"name": "Payment History Data Sheet", "description": "包含每筆貸款的還款明細的工作表。"},
        {"name": "Client Master Data Sheet (Optional)", "description": "客戶基本信息表。"},
        {"name": "Output Client Loan Summary Sheet", "description": "用於展示合併和分析結果的工作表。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub ConsolidateClientLoanAndPaymentHistory()\n    Dim wsOrig As Worksheet, wsHist As Worksheet, wsSummary As Worksheet, wsClient As Worksheet\n    Dim dictClients As Object ' To store unique client IDs and their summary rows\n    Dim lastRowO As Long, lastRowH As Long, lastRowC As Long, rO As Long, rH As Long, rC As Long, nextSumRow As Long\n\n    ' Set wsOrig = ThisWorkbook.Sheets(\"LoanOrigination\")\n    ' Set wsHist = ThisWorkbook.Sheets(\"PaymentHistory\")\n    ' Set wsClient = ThisWorkbook.Sheets(\"ClientMaster\") ' Optional\n    ' Set wsSummary = ThisWorkbook.Sheets(\"ClientLoanSummary\")\n    ' wsSummary.Cells.ClearContents\n    ' wsSummary.Range(\"A1:H1\").Value = Array(\"ClientID\", \"ClientName\", \"LoanID\", \"OrigAmount\", \"TotalPaid\", \"PrincipalRem\", \"AvgDaysOverdue\", \"LastPaymentDate\")\n    ' nextSumRow = 2\n    ' Set dictClients = CreateObject(\"Scripting.Dictionary\")\n\n    ' ' Populate dictClients with ClientIDs from ClientMaster or LoanOrigination\n    ' lastRowC = wsClient.Cells(Rows.Count, \"A\").End(xlUp).Row\n    ' For rC = 2 To lastRowC\n    '   Dim currentClientID As String: currentClientID = wsClient.Cells(rC, \"ClientID_Col\").Value\n    '   If Not dictClients.Exists(currentClientID) Then\n    '     dictClients.Add currentClientID, wsClient.Cells(rC, \"ClientName_Col\").Value\n    '   End If\n    ' Next rC\n\n    ' For Each clientIDKey In dictClients.Keys\n    '   wsSummary.Cells(nextSumRow, \"A\").Value = clientIDKey\n    '   wsSummary.Cells(nextSumRow, \"B\").Value = dictClients(clientIDKey) ' Client Name\n    '   Dim clientFirstLoanRow As Long: clientFirstLoanRow = nextSumRow ' For merging cells later if needed\n\n    '   lastRowO = wsOrig.Cells(Rows.Count, \"A\").End(xlUp).Row\n    '   For rO = 2 To lastRowO\n    '     If wsOrig.Cells(rO, \"ClientID_Col\").Value = clientIDKey Then\n    '       Dim loanID As String: loanID = wsOrig.Cells(rO, \"LoanID_Col\").Value\n    '       wsSummary.Cells(nextSumRow, \"C\").Value = loanID\n    '       wsSummary.Cells(nextSumRow, \"D\").Value = wsOrig.Cells(rO, \"LoanAmount_Col\").Value\n    '       Dim totalPaidForLoan As Double: totalPaidForLoan = 0\n    '       Dim principalPaidForLoan As Double: principalPaidForLoan = 0\n    '       Dim totalDaysOverdue As Long: totalDaysOverdue = 0\n    '       Dim paymentCount As Long: paymentCount = 0\n    '       Dim lastPmtDate As Date: lastPmtDate = CDate(0)\n\n    '       lastRowH = wsHist.Cells(Rows.Count, \"A\").End(xlUp).Row\n    '       For rH = 2 To lastRowH\n    '         If wsHist.Cells(rH, \"LoanID_Col\").Value = loanID Then\n    '           totalPaidForLoan = totalPaidForLoan + wsHist.Cells(rH, \"AmountPaid_Col\").Value\n    '           principalPaidForLoan = principalPaidForLoan + wsHist.Cells(rH, \"PrincipalPaid_Col\").Value\n    '           ' If wsHist.Cells(rH, \"DaysOverdue_Col\").Value > 0 Then totalDaysOverdue = totalDaysOverdue + wsHist.Cells(rH, \"DaysOverdue_Col\").Value\n    '           paymentCount = paymentCount + 1\n    '           If wsHist.Cells(rH, \"PaymentDate_Col\").Value > lastPmtDate Then lastPmtDate = wsHist.Cells(rH, \"PaymentDate_Col\").Value\n    '         End If\n    '       Next rH\n    '       wsSummary.Cells(nextSumRow, \"E\").Value = totalPaidForLoan\n    '       wsSummary.Cells(nextSumRow, \"F\").Value = wsOrig.Cells(rO, \"LoanAmount_Col\").Value - principalPaidForLoan\n    '       ' If paymentCount > 0 Then wsSummary.Cells(nextSumRow, \"G\").Value = totalDaysOverdue / paymentCount Else wsSummary.Cells(nextSumRow, \"G\").Value = 0\n    '       If lastPmtDate <> CDate(0) Then wsSummary.Cells(nextSumRow, \"H\").Value = lastPmtDate\n    '       nextSumRow = nextSumRow + 1\n    '     End If\n    '   Next rO\n    '   ' Optionally merge client info cells if client has multiple loans\n    '   ' If nextSumRow - 1 >= clientFirstLoanRow + 1 Then\n    '   '   wsSummary.Range(wsSummary.Cells(clientFirstLoanRow, \"A\"), wsSummary.Cells(nextSumRow - 1, \"A\")).Merge\n    '   '   wsSummary.Range(wsSummary.Cells(clientFirstLoanRow, \"B\"), wsSummary.Cells(nextSumRow - 1, \"B\")).Merge\n    '   ' End If\n    ' Next clientIDKey\n    ' wsSummary.Columns.AutoFit\n    ' MsgBox \"客戶貸款與還款歷史彙總完成。\"\nEnd Sub", "explanation": "此概念性腳本首先從“ClientMaster”表（或直接從貸款發放表）收集唯一的客戶ID列表。然後，對於每個客戶，它查找其在“LoanOrigination”表中的所有貸款記錄。對於每筆貸款，它再到“PaymentHistory”表中查找並彙總所有相關的還款記錄，計算已付總額、剩餘本金、平均逾期天數等。所有這些合併的信息都被寫入到“ClientLoanSummary”工作表中。"}
    ],
    "keywords": ["excel data consolidation vba", "join excel sheets by id", "loan payment history analysis", "client loan summary report", "多表數據合併", "Excel客戶貸款分析", "還款記錄彙總"]
},
{
    "name": "貸後檢查清單完成度與到期日追蹤儀表板 (Excel)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: A bank uses a standardized checklist (stored in an Excel template sheet) for post-loan reviews or site visits. For each loan/client, a copy of this checklist is filled out. This tool tracks the completion status and due dates for all checklist items across multiple clients/loans, providing a dashboard summary.",
    "description": "此工具用於追蹤多個貸後檢查清單的完成情況和到期項目。1. **Excel數據結構**：a. “ChecklistTemplate”工作表：包含標準的檢查項列表，每行是一個檢查項，列可包含：ItemID, ItemDescription, Category, ResponsibleDept, StandardDueDateOffset (例如，相對於貸款發放日後多少天), RiskWeighting。b. “ChecklistStatus_LoanXXX”工作表 (每個貸款一個，或一個總表)：包含來自模板的ItemID, ItemDescription，以及新增列：ActualCompletionDate, Status (待辦、進行中、已完成、逾期、N/A), Notes, FindingSummary。c. (主控) “MasterLoanList”表：LoanID, ClientID, LoanOriginationDate, NextFullReviewDate。d. (輸出) “ChecklistDashboard”表：用於顯示統計數據。2. **VBA功能**：a. **為新貸款生成檢查清單**：當“MasterLoanList”中出現新貸款時，VBA可以自動複製“ChecklistTemplate”的內容到一個新的以該LoanID命名的工作表 (或添加到一個總的檢查狀態表中)，並根據`StandardDueDateOffset`和`LoanOriginationDate`計算每個檢查項的初步截止日期。b. **更新儀表板**：一個宏定期掃描所有“ChecklistStatus_LoanXXX”工作表（或總表），彙總以下信息到“ChecklistDashboard”：  i. 每個檢查項類別的總體完成百分比。  ii. 即將到期（例如，未來7天內）的檢查項數量。  iii. 已逾期的檢查項數量和列表（含貸款ID、檢查項描述、原定截止日期、責任部門）。  iv. (可選) 按客戶經理或部門匯總的未完成/逾期項目。c. **數據驗證與輸入輔助**：在每個“ChecklistStatus_LoanXXX”表中，為“Status”列提供下拉列表，為“ActualCompletionDate”列設定日期格式驗證。3. **更新條件**：儀表板的更新可以手動觸發，或在打開主活頁簿時自動刷新，或在任何“ChecklistStatus_LoanXXX”表發生更改後觸發。",
    "parameters": [
        {"name": "Checklist Template Sheet", "description": "包含標準貸後檢查項目的模板。"},
        {"name": "Individual Checklist Status Sheets/Master Log", "description": "記錄每個貸款/客戶的檢查清單完成情況。"},
        {"name": "VBA for Checklist Generation and Dashboard Update", "description": "自動生成新清單並匯總狀態到儀表板的代碼。"},
        {"name": "Dashboard Display Logic", "description": "如何在儀表板上呈現統計數據和預警信息。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet for Dashboard Update ---\nSub UpdateChecklistDashboard()\n    Dim wsDashboard As Worksheet, wsMasterLoans As Worksheet, wsChecklistTemplate As Worksheet\n    Dim loanID As String, checklistSheetName As String, wsChecklist As Worksheet\n    Dim totalItems As Long, completedItems As Long, overdueItems As Long, upcomingItems As Long\n    Dim lastLoanRow As Long, lastItemRow As Long, rL As Long, rC As Long, nextDashRow As Long\n\n    ' Set wsDashboard = ThisWorkbook.Sheets(\"ChecklistDashboard\")\n    ' Set wsMasterLoans = ThisWorkbook.Sheets(\"MasterLoanList\")\n    ' Set wsChecklistTemplate = ThisWorkbook.Sheets(\"ChecklistTemplate\") ' To get total possible items\n    ' wsDashboard.Cells.ClearContents\n    ' wsDashboard.Range(\"A1:F1\").Value = Array(\"LoanID\", \"ClientID\", \"TotalItems\", \"Completed\", \"Upcoming (7d)\", \"Overdue\")\n    ' nextDashRow = 2\n    ' totalItems = wsChecklistTemplate.Cells(Rows.Count, \"A\").End(xlUp).Row - 1 ' Assuming header in template\n\n    ' lastLoanRow = wsMasterLoans.Cells(Rows.Count, \"A\").End(xlUp).Row\n    ' For rL = 2 To lastLoanRow\n    '   loanID = wsMasterLoans.Cells(rL, \"LoanID_Col\").Value\n    '   checklistSheetName = \"ChecklistStatus_\" & loanID\n    '   On Error Resume Next\n    '   Set wsChecklist = ThisWorkbook.Sheets(checklistSheetName)\n    '   If Err.Number <> 0 Then ' Sheet not found, log or skip\n    '     Debug.Print \"Checklist sheet not found for loan: \" & loanID\n    '     Set wsChecklist = Nothing\n    '     Err.Clear\n    '   End If\n    '   On Error GoTo 0 ' Restore error handling\n\n    '   If Not wsChecklist Is Nothing Then\n    '     completedItems = 0: overdueItems = 0: upcomingItems = 0\n    '     lastItemRow = wsChecklist.Cells(Rows.Count, \"A\").End(xlUp).Row\n    '     For rC = 2 To lastItemRow ' Assuming ItemID in Col A, Status in Col D, DueDate in Col C\n    '       Dim itemStatus As String: itemStatus = LCase(Trim(CStr(wsChecklist.Cells(rC, \"D\").Value)))\n    '       Dim itemDueDate As Date\n    '       If LCase(itemStatus) = \"completed\" Or LCase(itemStatus) = \"已完成\" Then\n    '         completedItems = completedItems + 1\n    '       ElseIf IsDate(wsChecklist.Cells(rC, \"C\").Value) Then\n    '         itemDueDate = CDate(wsChecklist.Cells(rC, \"C\").Value)\n    '         If itemDueDate < Date Then overdueItems = overdueItems + 1\n    '         If itemDueDate >= Date And itemDueDate <= Date + 7 Then upcomingItems = upcomingItems + 1\n    '       End If\n    '     Next rC\n    '     wsDashboard.Cells(nextDashRow, \"A\").Value = loanID\n    '     wsDashboard.Cells(nextDashRow, \"B\").Value = wsMasterLoans.Cells(rL, \"ClientID_Col\").Value\n    '     wsDashboard.Cells(nextDashRow, \"C\").Value = totalItems ' Or count actual items if dynamic\n    '     wsDashboard.Cells(nextDashRow, \"D\").Value = completedItems\n    '     wsDashboard.Cells(nextDashRow, \"E\").Value = upcomingItems\n    '     wsDashboard.Cells(nextDashRow, \"F\").Value = overdueItems\n    '     nextDashRow = nextDashRow + 1\n    '   End If\n    '   Set wsChecklist = Nothing\n    ' Next rL\n    ' wsDashboard.Columns.AutoFit\n    ' MsgBox \"貸後檢查清單儀表板已更新。\"\nEnd Sub", "explanation": "此概念性腳本演示了如何更新一個貸後檢查清單的儀表板。它會遍歷一個主貸款列表，然後對於每個貸款，嘗試找到其對應的檢查清單狀態工作表。接著，它會統計該清單中已完成、即將到期和已逾期的項目數量，並將這些信息彙總到“ChecklistDashboard”工作表中。模板檢查項總數可以從“ChecklistTemplate”獲得。"}
    ],
    "keywords": ["excel checklist tracking vba", "post-loan review dashboard", "automated task monitoring excel", "due date tracking vba", "貸後檢查表自動化", "Excel任務儀表板", "到期日追蹤"]
},
{
    "name": "多源數據交叉驗證與差異報告生成 (Excel)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: A bank has client data stored across multiple systems, extracts of which are available in different Excel sheets (e.g., 'CoreBankingExtract', 'CreditSystemExtract', 'CRMData'). This tool performs cross-validation of key data points (e.g., client name, address, exposure limits) for consistency and generates a report highlighting discrepancies.",
    "description": "此工具用於自動比較來自不同系統的客戶數據，以識別不一致之處。1. **Excel數據源表**：a. “CoreBankingData”表：ClientID (主鍵), ClientName_Core, Address_Core, ExposureLimit_Core。b. “CreditSystemData”表：ClientID (主鍵), ClientName_Credit, Address_Credit, ApprovedLimit_Credit。c. “CRMData”表：ClientID (主鍵), ClientName_CRM, PrimaryContact_CRM, LastContactDate_CRM。2. **VBA交叉驗證邏輯**：a. 創建一個新的“DiscrepancyReport”工作表。b. 以一個主列表（例如，“CoreBankingData”中的ClientID）為基礎進行遍歷。c. 對於每個ClientID：  i. 使用VLOOKUP、MATCH/INDEX組合，或字典對象，從其他數據表中查找該ClientID對應的記錄。  ii. 比較各個數據源中相同的欄位（例如，比較ClientName_Core, ClientName_Credit, ClientName_CRM）。  iii. 如果發現任何不一致（例如，姓名不同、地址有差異、授信額度不匹配），則在“DiscrepancyReport”中記錄該ClientID、不一致的欄位名稱、各個系統中的值以及差異描述。3. **差異高亮與統計**：a. 在“DiscrepancyReport”中，可以使用條件格式高亮顯示存在差異的行或儲存格。b. 計算存在差異的客戶總數，以及各個欄位出現差異的頻次。4. **更新條件**：通常按需執行，或在任一源數據表更新後執行。可以通過比較工作表的“上次修改日期”屬性來判斷是否需要重新運行。5. **輸出**：“DiscrepancyReport”表提供了數據質量問題的清晰概覽，便於相關部門進行核查和修正。",
    "parameters": [
        {"name": "Multiple Excel Source Data Sheets", "description": "包含來自不同系統的客戶數據的表格。"},
        {"name": "Key Fields for Cross-Validation", "description": "需要在各個系統之間進行比較的關鍵數據欄位。"},
        {"name": "Matching Key (e.g., ClientID)", "description": "用於在不同表格之間關聯記錄的唯一標識符。"},
        {"name": "Output Discrepancy Report Sheet", "description": "用於記錄所有不一致數據項的工作表。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub CrossValidateClientData()\n    Dim wsCore As Worksheet, wsCredit As Worksheet, wsCRM As Worksheet, wsReport As Worksheet\n    Dim dictCore As Object, dictCredit As Object, dictCRM As Object\n    Dim clientID As Variant, r As Long, nextReportRow As Long\n\n    ' Set wsCore = ThisWorkbook.Sheets(\"CoreBankingData\")\n    ' Set wsCredit = ThisWorkbook.Sheets(\"CreditSystemData\")\n    ' Set wsCRM = ThisWorkbook.Sheets(\"CRMData\")\n    ' Set wsReport = ThisWorkbook.Sheets(\"DiscrepancyReport\")\n    ' wsReport.Cells.ClearContents\n    ' wsReport.Range(\"A1:G1\").Value = Array(\"ClientID\", \"Field\", \"CoreValue\", \"CreditValue\", \"CRMValue\", \"DiscrepancyType\", \"Notes\")\n    ' nextReportRow = 2\n\n    ' ' Load data into dictionaries for faster lookup (ClientID as key)\n    ' Set dictCore = LoadSheetToDictionary(wsCore, 1) ' Col 1 (A) is ClientID\n    ' Set dictCredit = LoadSheetToDictionary(wsCredit, 1)\n    ' Set dictCRM = LoadSheetToDictionary(wsCRM, 1)\n\n    ' For Each clientID In dictCore.Keys ' Iterate through clients from Core system\n    '   Dim coreData As Object: Set coreData = dictCore(clientID)\n    '   Dim creditData As Object, crmData As Object\n    '   If dictCredit.Exists(clientID) Then Set creditData = dictCredit(clientID) Else Set creditData = Nothing\n    '   If dictCRM.Exists(clientID) Then Set crmData = dictCRM(clientID) Else Set crmData = Nothing\n\n    '   ' Compare ClientName (assuming column index 2 for name in all source dicts)\n    '   Dim nameCore As String: nameCore = coreData(2)\n    '   Dim nameCredit As String: If Not creditData Is Nothing Then nameCredit = creditData(2) Else nameCredit = \"[N/A]\"\n    '   Dim nameCRM As String: If Not crmData Is Nothing Then nameCRM = crmData(2) Else nameCRM = \"[N/A]\"\n    '   If Not (LCase(nameCore) = LCase(nameCredit) And LCase(nameCore) = LCase(nameCRM)) Then ' Simplified check\n    '       If Not (LCase(nameCore) = LCase(nameCredit) And LCase(nameCore) = LCase(nameCRM) And LCase(nameCredit) = LCase(nameCRM)) Then ' More thorough check\n    '           wsReport.Cells(nextReportRow, \"A\").Value = clientID\n    '           wsReport.Cells(nextReportRow, \"B\").Value = \"ClientName\"\n    '           wsReport.Cells(nextReportRow, \"C\").Value = nameCore\n    '           wsReport.Cells(nextReportRow, \"D\").Value = nameCredit\n    '           wsReport.Cells(nextReportRow, \"E\").Value = nameCRM\n    '           wsReport.Cells(nextReportRow, \"F\").Value = \"Name Mismatch\"\n    '           nextReportRow = nextReportRow + 1\n    '       End If\n    '   End If\n\n    '   ' Compare Address (assuming column index 3 for address)\n    '   ' ... similar logic for address, limits, etc. ...\n    ' Next clientID\n    ' wsReport.Columns.AutoFit\n    ' MsgBox \"客戶數據交叉驗證完成。請查看差異報告。\"\nEnd Sub\n\nFunction LoadSheetToDictionary(sh As Worksheet, keyCol As Long) As Object\n    ' Helper function to load a sheet into a dictionary of dictionaries\n    ' Outer dictionary key: ClientID (from keyCol)\n    ' Inner dictionary key: Column Header (from row 1), Value: Cell Value\n    Dim dict As Object: Set dict = CreateObject(\"Scripting.Dictionary\")\n    ' Dim lastR As Long: lastR = sh.Cells(Rows.Count, keyCol).End(xlUp).Row\n    ' Dim lastC As Long: lastC = sh.Cells(1, Columns.Count).End(xlToLeft).Column\n    ' Dim r As Long, c As Long, clientKey As String\n    ' For r = 2 To lastR\n    '   clientKey = Trim(CStr(sh.Cells(r, keyCol).Value))\n    '   If clientKey <> \"\" And Not dict.Exists(clientKey) Then\n    '     Set dict(clientKey) = CreateObject(\"Scripting.Dictionary\")\n    '     For c = 1 To lastC\n    '       dict(clientKey)(Trim(CStr(sh.Cells(1, c).Value))) = sh.Cells(r, c).Value\n    '     Next c\n    '   End If\n    ' Next r\n    ' Set LoadSheetToDictionary = dict\nEnd Function", "explanation": "此概念性腳本概述了如何進行跨表數據驗證。它首先使用一個輔助函數 `LoadSheetToDictionary` 將每個源數據工作表加載到一個Scripting.Dictionary對象中，以便通過ClientID進行快速查找。然後，它遍歷一個主數據源（例如核心銀行系統的客戶列表）中的每個客戶ID。對於每個客戶，它會嘗試從其他系統的字典中查找相應的記錄，並比較關鍵欄位（如客戶名稱、地址等）。如果發現不一致，則將差異的詳細信息記錄到“DiscrepancyReport”工作表中。"}
    ],
    "keywords": ["excel data validation across sheets", "vba compare data multiple sheets", "data consistency check excel", "cross-system data reconciliation", "多表數據交叉驗證", "Excel數據一致性檢查", "差異報告生成"]
},
{
    "name": "按風險評級動態調整客戶聯繫頻率計劃表 (Excel)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: A bank defines different required contact frequencies for corporate clients based on their internal risk rating (e.g., High Risk - monthly contact, Medium Risk - quarterly, Low Risk - semi-annually). This Excel tool uses a client list with current risk ratings and last contact dates to dynamically generate a 'Contact Schedule' for RMs, highlighting clients due or overdue for contact.",
    "description": "此工具幫助客戶經理規劃和追蹤基於風險級別的客戶聯繫頻率。1. **Excel數據表**：a. “ClientRiskProfile”表：ClientID, ClientName, RiskRating (例如，高、中、低), LastContactDate, RM_Email。b. “ContactFrequencyRules”表：RiskRating, RequiredFrequencyDays (例如，高風險=30天，中風險=90天，低風險=180天)。2. **VBA計劃生成邏輯**：a. 創建或更新一個“RMContactSchedule”工作表。b. 遍歷“ClientRiskProfile”中的每個客戶。c. 根據客戶的`RiskRating`，從“ContactFrequencyRules”表中查找其對應的`RequiredFrequencyDays`。d. 計算該客戶的“下次應聯繫日期” (`NextContactDueDate = LastContactDate + RequiredFrequencyDays`)。e. **狀態判斷**：  i. 如果`NextContactDueDate`已過，則標記為“聯繫逾期”。  ii. 如果`NextContactDueDate`在未來7天內，則標記為“即將聯繫”。  iii. 否則，可以顯示“按計劃”。f. 將客戶ID、名稱、下次應聯繫日期、狀態、RM郵箱等信息寫入“RMContactSchedule”表。3. **儀表板與提醒**：a. “RMContactSchedule”表可以使用條件格式高亮顯示“聯繫逾期”和“即將聯繫”的客戶。b. 可以創建數據透視表或摘要，按RM匯總需要聯繫的客戶數量。c. (可選集成Outlook) 對於“聯繫逾期”或“即將聯繫”的客戶，可以為對應的RM在Outlook中創建提醒任務。4. **更新條件**：當“ClientRiskProfile”表中的風險評級或上次聯繫日期更新時，或定期（例如，每週一）運行此計劃生成宏。",
    "parameters": [
        {"name": "Client Risk Profile Sheet", "description": "包含客戶風險評級和上次聯繫日期的工作表。"},
        {"name": "Contact Frequency Rules Sheet", "description": "定義不同風險級別對應的聯繫頻率的工作表。"},
        {"name": "Output RM Contact Schedule Sheet", "description": "顯示每個客戶下次應聯繫日期和狀態的工作表。"},
        {"name": "VBA Logic for Calculating Next Contact Date and Status", "description": "計算並標記客戶聯繫狀態的代碼。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub GenerateRMContactSchedule()\n    Dim wsProfile As Worksheet, wsRules As Worksheet, wsSchedule As Worksheet\n    Dim dictFreqRules As Object ' RiskRating (key), FrequencyDays (value)\n    Dim lastRowP As Long, lastRowR As Long, rP As Long, rR As Long, nextSchedRow As Long\n    Dim clientID As String, riskRating As String, lastContact As Date, nextContact As Date, contactStatus As String\n\n    ' Set wsProfile = ThisWorkbook.Sheets(\"ClientRiskProfile\")\n    ' Set wsRules = ThisWorkbook.Sheets(\"ContactFrequencyRules\")\n    ' Set wsSchedule = ThisWorkbook.Sheets(\"RMContactSchedule\")\n    ' wsSchedule.Cells.ClearContents\n    ' wsSchedule.Range(\"A1:F1\").Value = Array(\"ClientID\", \"ClientName\", \"RiskRating\", \"LastContact\", \"NextContactDue\", \"Status\")\n    ' nextSchedRow = 2\n\n    ' ' Load Frequency Rules into Dictionary\n    ' Set dictFreqRules = CreateObject(\"Scripting.Dictionary\")\n    ' lastRowR = wsRules.Cells(Rows.Count, \"A\").End(xlUp).Row\n    ' For rR = 2 To lastRowR\n    '   dictFreqRules(Trim(CStr(wsRules.Cells(rR, \"A\").Value))) = CLng(wsRules.Cells(rR, \"B\").Value)\n    ' Next rR\n\n    ' lastRowP = wsProfile.Cells(Rows.Count, \"A\").End(xlUp).Row\n    ' For rP = 2 To lastRowP\n    '   clientID = wsProfile.Cells(rP, \"ClientID_Col\").Value\n    '   riskRating = Trim(CStr(wsProfile.Cells(rP, \"RiskRating_Col\").Value))\n    '   If IsDate(wsProfile.Cells(rP, \"LastContactDate_Col\").Value) Then\n    '     lastContact = CDate(wsProfile.Cells(rP, \"LastContactDate_Col\").Value)\n    '   Else\n    '     lastContact = Date - 365 ' Default if no last contact, assume long overdue\n    '   End If\n\n    '   If dictFreqRules.Exists(riskRating) Then\n    '     nextContact = DateAdd(\"d\", dictFreqRules(riskRating), lastContact)\n    '   Else ' Default frequency if risk rating rule not found\n    '     nextContact = DateAdd(\"d\", 180, lastContact) ' e.g., default 180 days\n    '   End If\n\n    '   If nextContact < Date Then\n    '     contactStatus = \"聯繫逾期 (\" & Date - nextContact & \"天)\"\n    '   ElseIf nextContact <= Date + 7 Then\n    '     contactStatus = \"即將聯繫 (7天內)\"\n    '   Else\n    '     contactStatus = \"按計劃\"\n    '   End If\n\n    '   wsSchedule.Cells(nextSchedRow, \"A\").Value = clientID\n    '   wsSchedule.Cells(nextSchedRow, \"B\").Value = wsProfile.Cells(rP, \"ClientName_Col\").Value\n    '   wsSchedule.Cells(nextSchedRow, \"C\").Value = riskRating\n    '   wsSchedule.Cells(nextSchedRow, \"D\").Value = lastContact\n    '   wsSchedule.Cells(nextSchedRow, \"E\").Value = nextContact\n    '   wsSchedule.Cells(nextSchedRow, \"F\").Value = contactStatus\n    '   nextSchedRow = nextSchedRow + 1\n    ' Next rP\n    ' wsSchedule.Columns.AutoFit\n    ' MsgBox \"客戶聯繫頻率計劃表已生成/更新。\"\nEnd Sub", "explanation": "此概念性腳本首先從“ContactFrequencyRules”表加載不同風險級別對應的聯繫頻率（天數）到一個字典中。然後，它遍歷“ClientRiskProfile”表中的每個客戶，根據其風險級別和上次聯繫日期，計算出下次應聯繫的日期。接著，它判斷該聯繫是“逾期”、“即將到期”還是“按計劃”，並將這些信息輸出到“RMContactSchedule”工作表中。"}
    ],
    "keywords": ["excel client contact schedule", "vba risk-based contact frequency", "rm task planning excel", "customer relationship management excel", "客戶聯繫計劃表", "風險導向聯繫頻率", "Excel貸後管理"]
},
{
    "name": "從Excel批量生成貸款合同關鍵條款變更確認函 (Excel to Word/PDF)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: When terms of existing loans are amended (e.g., interest rate change, maturity extension, covenant modification), a formal confirmation letter needs to be sent to the client. This tool uses an Excel list of amendments and a Word template to batch-generate these letters.",
    "description": "此工具用於批量生成貸款合同條款變更的確認函。1. **Excel變更記錄表 (“AmendmentLog”)**：包含客戶ID、客戶名稱、貸款合同號、**原條款類型** (例如，“利率”，“到期日”，“保證金比例”)、**原條款內容**、**新條款類型**（如果與原類型不同）、**新條款內容**、變更生效日期、經辦RM。2. **Word確認函模板 (“AmendmentConfirmationTemplate.dotx”)**：一個標準的Word範本，包含通用文本和用於填充客戶特定信息及變更詳情的占位符（例如，[ClientName], [LoanContractNo], [AmendmentEffectiveDate], [OriginalTermDescription], [OriginalTermValue], [NewTermDescription], [NewTermValue]）。3. **VBA文件生成邏輯**：a. VBA腳本讀取“AmendmentLog”表中需要生成確認函的記錄（例如，可以有一個“確認函生成狀態”列）。b. 對於每條記錄：  i. 獲取所有相關數據。  ii. 打開（或基於範本創建新的）Word應用程式和文檔。  iii. 使用從Excel中讀取的數據替換Word模板中的所有占位符。對於條款變更的描述，可能需要動態構建一些文本來清晰地呈現變更前後的對比。  iv. 將填充好的Word文檔另存為一個新的Word文件（文件名可包含客戶ID和合同號）和/或直接導出為PDF。  v. (可選) 更新Excel中該記錄的“確認函生成狀態”和“生成日期”。4. **後續**：生成的確認函可以由RM審閱後通過郵件發送給客戶，或進行打印和郵寄。",
    "parameters": [
        {"name": "Excel Amendment Log Sheet", "description": "記錄貸款合同條款變更詳情的工作表。"},
        {"name": "Word Confirmation Letter Template", "description": "包含占位符的標準確認函Word範本。"},
        {"name": "VBA Logic for Data Merging and Document Saving", "description": "將Excel數據填充到Word模板並保存/導出文件的代碼。"},
        {"name": "Output Folder for Generated Letters", "description": "存放生成的Word或PDF確認函的文件夾。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet (Assumes Word Automation) ---\nSub BatchGenerateAmendmentConfirmations()\n    Dim wsAmend As Worksheet, wdApp As Object, wdDoc As Object\n    Dim lastRow As Long, i As Long\n    Dim clientName As String, loanNo As String, effectiveDate As Date, origTerm As String, newTerm As String\n    Dim outputFileName As String\n\n    ' Set wsAmend = ThisWorkbook.Sheets(\"AmendmentLog\")\n    ' ' Assume: A=ClientID, B=ClientName, C=LoanNo, D=EffectiveDate, E=OriginalTerm, F=NewTerm, G=Status\n    ' Const TEMPLATE_PATH As String = \"C:\\Templates\\AmendmentConfirmTemplate.dotx\"\n    ' Const OUTPUT_FOLDER As String = \"C:\\GeneratedConfirmations\\\"\n\n    ' On Error Resume Next\n    ' Set wdApp = GetObject(, \"Word.Application\")\n    ' If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    ' If wdApp Is Nothing Then MsgBox \"無法啟動Word.\": Exit Sub\n    ' On Error GoTo 0\n    ' ' wdApp.Visible = True\n\n    ' lastRow = wsAmend.Cells(Rows.Count, \"A\").End(xlUp).Row\n    ' For i = 2 To lastRow\n    '   If LCase(Trim(CStr(wsAmend.Cells(i, \"G\").Value))) = \"pending generation\" Then\n    '     clientName = wsAmend.Cells(i, \"B\").Value\n    '     loanNo = wsAmend.Cells(i, \"C\").Value\n    '     effectiveDate = CDate(wsAmend.Cells(i, \"D\").Value)\n    '     origTerm = wsAmend.Cells(i, \"E\").Value\n    '     newTerm = wsAmend.Cells(i, \"F\").Value\n    '\n    '     Set wdDoc = wdApp.Documents.Add(Template:=TEMPLATE_PATH)\n    '\n    '     Call FindAndReplaceInDoc(wdDoc, \"[ClientName]\", clientName)\n    '     Call FindAndReplaceInDoc(wdDoc, \"[LoanContractNo]\", loanNo)\n    '     Call FindAndReplaceInDoc(wdDoc, \"[AmendmentEffectiveDate]\", Format(effectiveDate, \"yyyy年m月d日\"))\n    '     Call FindAndReplaceInDoc(wdDoc, \"[OriginalTermDetails]\", origTerm)\n    '     Call FindAndReplaceInDoc(wdDoc, \"[NewTermDetails]\", newTerm)\n    '     Call FindAndReplaceInDoc(wdDoc, \"[GenerationDate]\", Format(Date, \"yyyy年m月d日\"))\n    '\n    '     outputFileName = OUTPUT_FOLDER & \"Confirm_\" & ReplaceChars(loanNo) & \"_\" & Format(Date, \"yyyymmdd\")\n    '     wdDoc.SaveAs2 outputFileName & \".docx\"\n    '     ' wdDoc.ExportAsFixedFormat OutputFileName:=outputFileName & \".pdf\", ExportFormat:=wdExportFormatPDF\n    '     wdDoc.Close False\n    '     wsAmend.Cells(i, \"G\").Value = \"Generated \" & Date\n    '   End If\n    ' Next i\n    ' MsgBox \"批量變更確認函已生成。\"\nEnd Sub\n\nSub FindAndReplaceInDoc(docToSearch As Object, findTxt As String, replaceTxt As String)\n    ' Helper for Word Find/Replace\n    ' With docToSearch.Content.Find\n    '   .ClearFormatting\n    '   .Replacement.ClearFormatting\n    '   .Text = findTxt\n    '   .Replacement.Text = replaceTxt\n    '   .Forward = True\n    '   .Wrap = wdFindContinue\n    '   .Execute Replace:=wdReplaceAll\n    ' End With\nEnd Sub\nFunction ReplaceChars(strIn As String) As String ' Basic char replace for filename\n    ReplaceChars = Replace(Replace(Replace(strIn, \"/\", \"-\"), \"\\\", \"-\"), \":\", \"-\")\nEnd Function", "explanation": "此概念性腳本讀取Excel“AmendmentLog”表中標記為待生成的記錄。對於每條記錄，它會打開一個Word確認函模板，使用 `FindAndReplaceInDoc` 輔助函數將Excel中的變更詳情（如客戶名、合同號、原條款、新條款、生效日期）填充到模板的占位符中，然後將生成的確認函另存為新的Word文檔（並可選地導出為PDF）。完成後，更新Excel中的生成狀態。"}
    ],
    "keywords": ["excel to word mail merge vba", "batch document generation", "loan amendment confirmation", "automate legal letters", "批量生成Word文檔", "Excel數據填充Word模板", "貸款變更確認函"]
},
{
    "name": "根據Excel中的產品參數和客戶選擇動態生成服務協議 (Excel to Word)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: A bank offers various service packages or products with customizable features. An RM uses an Excel UserForm or a structured Excel sheet to select a base product and then choose specific add-on features or parameters (e.g., service levels, transaction limits, fee options). VBA then assembles a service agreement in Word by pulling standard clauses for the base product and selectively including clauses for the chosen add-ons, populating placeholders with client and specific parameter values.",
    "description": "此工具用於動態生成包含客戶選擇的特定產品特性和服務條款的服務協議。1. **Excel配置與選擇界面**：a. “ProductMaster”表：定義基礎產品/服務包及其標準條款的ID列表。b. “AddOnFeatures”表：定義可選的附加特性、其描述文本、對應的附加條款ID列表。c. “ClauseLibrary”表：存儲所有標準條款和附加條款的文本，以唯一的ClauseID標識。d. 一個UserForm或輸入工作表，允許RM選擇客戶、基礎產品，並勾選所需的附加特性，同時輸入任何特定參數（如服務費率、生效日期）。2. **VBA協議組裝引擎**：a. 當RM提交選擇後，VBA首先根據選擇的基礎產品從“ProductMaster”獲取其必須包含的標準條款ID列表。b. 然後，根據RM勾選的附加特性，從“AddOnFeatures”表獲取這些特性對應的附加條款ID列表。c. 合併所有需要包含的條款ID，並去除重複。d. 從“ClauseLibrary”表中查找每個ID對應的條款文本。e. （可選）對條款按預設順序進行排序。3. **Word文檔生成**：a. 打開一個標準的Word服務協議模板，模板中包含客戶信息占位符和一個用於插入條款主體的區域（例如，一個特定的書籤或樣式標記）。b. 將客戶信息填充到占位符。c. 將所有篩選並排序好的條款文本逐條插入到Word文檔的條款主體區域。d. (可選) 根據選擇的產品或特性，動態調整協議中的某些參數值（例如，費率表）。e. 將生成的協議另存為客戶特定的文件。這個系統確保了協議的準確性和一致性，同時允許根據客戶的具體選擇進行定制。",
    "parameters": [
        {"name": "Excel Product & Clause Configuration Sheets", "description": "定義產品、可選特性及其對應條款的表格。"},
        {"name": "Excel UserForm or Input Sheet for Selection", "description": "RM選擇產品和特性的界面。"},
        {"name": "Word Service Agreement Template", "description": "包含占位符和條款插入點的Word範本。"},
        {"name": "VBA Logic for Clause Selection, Ordering, and Merging", "description": "根據用戶選擇篩選、排序並將條款插入Word的代碼。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet (Core Assembly Logic) ---\nSub AssembleServiceAgreement(clientID As String, baseProductID As String, selectedAddOnIDs As Collection)\n    Dim wsClauses As Worksheet, wsProducts As Worksheet, wsAddOns As Worksheet\n    Dim wdApp As Object, wdDoc As Object\n    Dim clauseIDsToInclude As Object ' Scripting.Dictionary to store unique clause IDs and their order\n    Dim clauseText As String, productClauseList As String, addOnClauseList As String\n    Dim i As Long, arrClause As Variant\n\n    ' Set wsClauses = ThisWorkbook.Sheets(\"ClauseLibrary\") ' Col A: ClauseID, Col B: ClauseText, Col C: OrderInDoc\n    ' Set wsProducts = ThisWorkbook.Sheets(\"ProductMaster\") ' Col A: ProductID, Col B: CommaSepClauseIDs\n    ' Set wsAddOns = ThisWorkbook.Sheets(\"AddOnFeatures\") ' Col A: AddOnID, Col B: CommaSepClauseIDs\n    ' Set clauseIDsToInclude = CreateObject(\"Scripting.Dictionary\")\n\n    ' ' 1. Get base product clauses\n    ' productClauseList = Application.VLookup(baseProductID, wsProducts.Range(\"A:B\"), 2, False)\n    ' If Not IsError(productClauseList) Then\n    '   For Each arrClause In Split(productClauseList, \",\")\n    '     If Not clauseIDsToInclude.Exists(Trim(arrClause)) Then clauseIDsToInclude.Add Trim(arrClause), GetClauseOrder(Trim(arrClause), wsClauses)\n    '   Next arrClause\n    ' End If\n\n    ' ' 2. Get add-on clauses\n    ' Dim addOnID As Variant\n    ' For Each addOnID In selectedAddOnIDs\n    '   addOnClauseList = Application.VLookup(addOnID, wsAddOns.Range(\"A:B\"), 2, False)\n    '   If Not IsError(addOnClauseList) Then\n    '     For Each arrClause In Split(addOnClauseList, \",\")\n    '       If Not clauseIDsToInclude.Exists(Trim(arrClause)) Then clauseIDsToInclude.Add Trim(arrClause), GetClauseOrder(Trim(arrClause), wsClauses)\n    '     Next arrClause\n    '   End If\n    ' Next addOnID\n\n    ' ' 3. Sort clauses (if dictionary values are order numbers, or convert to array and sort)\n    ' Dim sortedClauseArray As Variant: sortedClauseArray = SortDictionaryByValue(clauseIDsToInclude) ' Custom sort function\n\n    ' ' 4. Create Word doc and insert clauses\n    ' ' Set wdApp = CreateObject(\"Word.Application\") ... Open template ...\n    ' ' For i = LBound(sortedClauseArray) To UBound(sortedClauseArray)\n    ' '   Dim currentClauseID As String: currentClauseID = sortedClauseArray(i, 0) ' Assuming key is in first col of sorted array\n    ' '   clauseText = Application.VLookup(currentClauseID, wsClauses.Range(\"A:B\"), 2, False)\n    ' '   If Not IsError(clauseText) Then\n    ' '     wdDoc.Range.InsertAfter clauseText & vbCrLf ' Insert clause text\n    ' '   End If\n    ' ' Next i\n    ' ' ... Fill placeholders, Save document ...\n    ' MsgBox \"服務協議已生成。\"\nEnd Sub\n\nFunction GetClauseOrder(clauseID As String, clauseSheet As Worksheet) As Long\n    ' Helper to get sort order for a clause from ClauseLibrary sheet (Col C)\n    ' On Error Resume Next\n    ' GetClauseOrder = Application.VLookup(clauseID, clauseSheet.Range(\"A:C\"), 3, False)\n    ' If IsError(GetClauseOrder) Then GetClauseOrder = 9999 ' Default if not found\nEnd Function\nFunction SortDictionaryByValue(dict As Object) As Variant\n    ' Helper to sort dictionary by value (order number) and return sorted array\n    ' (Implementation for sorting dictionary by value and returning array omitted for brevity)\nEnd Function", "explanation": "此概念性腳本概述了服務協議的組裝邏輯。它首先根據選擇的基礎產品和附加特性，從Excel配置表中收集所有相關條款的ID。然後，它可能會根據條款庫中定義的順序對這些條款ID進行排序。接著，它打開一個Word模板，填充客戶特定的占位符，然後從條款庫中檢索每個條款ID對應的文本，並按順序將它們插入到Word文檔中。需要輔助函數 `GetClauseOrder` (從條款庫獲取條款順序) 和 `SortDictionaryByValue` (如果使用字典存儲條款及其順序並需要排序)。"}
    ],
    "keywords": ["excel word dynamic agreement generation", "vba assemble document from clauses", "product configurator excel word", "service agreement automation", "動態生成服務協議", "Excel條款庫Word組裝", "產品配置"]
},
{
    "name": "Excel數據變化追蹤與審計日誌記錄 (Excel)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: For critical Excel workbooks used in loan management (e.g., risk rating models, collateral valuation sheets), VBA tracks changes made to specific important cells or ranges. When a change occurs, it logs the details (timestamp, username, worksheet, cell address, old value, new value) to a hidden 'AuditLog' sheet.",
    "description": "此工具用於記錄對Excel工作簿中關鍵數據的更改，以提供審計追蹤。1. **Excel結構**：a. **數據工作表**：包含需要追蹤更改的關鍵數據的工作表。b. **“AuditLog”工作表** (通常設為`xlSheetVeryHidden`)：包含列：Timestamp, UserName (Excel用戶名), ComputerName (可選), WorkbookName, SheetName, CellAddress, OldValue, NewValue, ChangeType (例如，手動更改、VBA更改 - 如果可區分)。c. (可選) **“TrackedRanges”配置表**：定義哪些工作表和範圍需要被監控。2. **VBA審計追蹤邏輯 (主要在 `Worksheet_Change` 事件中)**：a. 在需要追蹤更改的每個工作表的代碼模塊中，使用 `Worksheet_Change(ByVal Target As Range)` 事件處理程序。b. 在事件處理程序中，首先檢查 `Target` (發生更改的儲存格或範圍) 是否與“TrackedRanges”配置表中定義的需要監控的範圍有交集 (`Intersect(Target, MonitoredRange)`).c. 如果 `Target` 在受監控範圍內：  i. **獲取舊值**：這比較棘手，因為 `Worksheet_Change` 事件在更改已經發生後觸發。一種常見方法是在 `Worksheet_SelectionChange` 事件中，當用戶選中受監控的儲存格時，將其當前值存儲到一個全局變數或一個隱藏的“影子”工作表中。然後，在 `Worksheet_Change` 中可以比較當前值和先前存儲的舊值。  ii. **獲取新值**：即 `Target.Value`。  iii. **記錄日誌**：將時間戳、`Application.UserName`、工作簿名、工作表名、`Target.Address`、舊值、新值等信息寫入到“AuditLog”工作表的新行中。iv. **處理多儲存格更改**：如果 `Target` 是一個多儲存格範圍，需要遍歷 `Target.Cells`，並對每個儲存格記錄更改（如果舊值和新值不同）。這時獲取每個儲存格的舊值會更複雜，可能需要在更改前進行範圍複製。3. **保護審計日誌**：“AuditLog”工作表應設置保護，防止未經授權的修改。4. **查看與報告**：可以創建一個UserForm或另一個宏來查看或篩選“AuditLog”中的記錄。這個機制對於追蹤關鍵數據的修改歷史、符合合規要求以及調查數據異常非常重要。",
    "parameters": [
        {"name": "Worksheets and Ranges to Track", "description": "定義哪些儲存格或範圍的更改需要被記錄。"},
        {"name": "Method for Capturing Old Value", "description": "在更改發生前捕獲儲存格舊值的策略 (例如，使用 `Worksheet_SelectionChange` 和全局變數)。"},
        {"name": "Audit Log Sheet Structure", "description": "審計日誌工作表的列定義。"},
        {"name": "VBA Event Handlers (Worksheet_Change, Worksheet_SelectionChange)", "description": "用於捕獲和記錄更改的核心VBA代碼。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet (In a specific Sheet's module, e.g., Sheet1) ---\n' Private previousCellValue As Variant ' Module-level variable to store old value\n\n' Private Sub Worksheet_SelectionChange(ByVal Target As Range)\n'   ' Monitor changes in column A for this example\n'   If Not Intersect(Target, Me.Columns(\"A\")) Is Nothing And Target.Cells.Count = 1 Then\n'     previousCellValue = Target.Value ' Store value when cell is selected\n'   Else\n'     previousCellValue = CVErr(xlErrNA) ' Reset if selection is not a single cell in Col A\n'   End If\n' End Sub\n\n' Private Sub Worksheet_Change(ByVal Target As Range)\n'   Dim wsLog As Worksheet\n'   Dim nextLogRow As Long\n'   Dim oldValue As Variant, newValue As Variant\n'\n'   ' Only track single cell changes in Column A for this simple example\n'   If Not Intersect(Target, Me.Columns(\"A\")) Is Nothing And Target.Cells.CountLarge = 1 Then\n'     ' Check if previousCellValue was set for this cell (might not be if change was programmatic or paste)\n'     ' A more robust solution for programmatic changes might need a different approach or a before_change event if available.\n'     If IsError(previousCellValue) Then ' If SelectionChange didn't capture it (e.g. paste)\n'         ' This is tricky, as the original value is gone. One might use Undo temporarily if allowed and safe.\n'         ' Application.EnableEvents = False\n'         ' Application.Undo\n'         ' oldValue = Target.Value\n'         ' Target.Value = newValue ' Redo the change or apply the new value again (depending on source of 'newValue')\n'         ' Application.EnableEvents = True\n'         ' For simplicity, we'll log 'Unknown' if previousCellValue is not reliably captured.\n'         oldValue = \"[未知舊值]\"\n'     Else\n'         oldValue = previousCellValue\n'     End If\n'     newValue = Target.Value\n'\n'     ' Only log if value actually changed\n'     If CStr(oldValue) <> CStr(newValue) Then\n'       On Error Resume Next\n'       Set wsLog = ThisWorkbook.Sheets(\"AuditLogSheet\")\n'       If wsLog Is Nothing Then ' Create log sheet if it doesn't exist\n'         Set wsLog = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count))\n'         wsLog.Name = \"AuditLogSheet\"\n'         wsLog.Range(\"A1:H1\").Value = Array(\"Timestamp\", \"User\", \"Workbook\", \"Sheet\", \"Cell\", \"OldValue\", \"NewValue\", \"Computer\")\n'         wsLog.Visible = xlSheetVeryHidden ' Hide it well\n'       End If\n'       On Error GoTo 0 ' Or an error handler\n'       If wsLog Is Nothing Then Exit Sub ' Could not create/access log sheet\n'\n'       nextLogRow = wsLog.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n'       wsLog.Cells(nextLogRow, \"A\").Value = Now\n'       wsLog.Cells(nextLogRow, \"B\").Value = Application.UserName\n'       wsLog.Cells(nextLogRow, \"C\").Value = ThisWorkbook.Name\n'       wsLog.Cells(nextLogRow, \"D\").Value = Me.Name ' Target.Worksheet.Name\n'       wsLog.Cells(nextLogRow, \"E\").Value = Target.Address(False, False)\n'       wsLog.Cells(nextLogRow, \"F\").Value = oldValue\n'       wsLog.Cells(nextLogRow, \"G\").Value = newValue\n'       wsLog.Cells(nextLogRow, \"H\").Value = Environ(\"COMPUTERNAME\")\n'       Debug.Print \"更改已記錄: \" & Target.Address & \" 從 '\" & oldValue & \"' 到 '\" & newValue & \"'\"\n'     End If\n'     ' Update previousCellValue for next change on this cell if user stays on it and changes again\n'     previousCellValue = newValue\n'   End If\n' End Sub", "explanation": "此概念性代碼（應放置在要監控的工作表的代碼模塊中）使用 `Worksheet_SelectionChange` 事件在用戶選中A列的某個儲存格時，將其當前值存儲在一個模塊級變數 `previousCellValue` 中。然後，當 `Worksheet_Change` 事件因A列儲存格的值發生實際更改而觸發時，它會比較 `previousCellValue`（舊值）和 `Target.Value`（新值）。如果值不同，則將更改的詳細信息（時間戳、用戶名、工作簿/表名、儲存格位址、舊值、新值、計算機名）記錄到一個名為“AuditLogSheet”的隱藏工作表中。**注意**：這種獲取舊值的方法對於手動單儲存格更改有效，但對於複製粘貼、填充多個儲存格或VBA程式化更改，可能無法可靠捕獲每個儲存格的舊值，或者需要更複雜的“撤銷/重做”技巧（不推薦用於常規審計）或在更改前複製監控範圍的副本。"}
    ],
    "keywords": ["excel audit trail vba", "track cell changes excel", "log data modifications vba", "worksheet_change event logging", "excel data integrity", "Excel數據更改追蹤", "審計日誌VBA", "記錄儲存格修改"]
},
{
    "name": "客戶信用額度動態調整建議引擎 (Excel)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Based on a client's latest financial performance, payment history, risk rating changes, and overall market conditions (which might be input or stored in separate sheets), this Excel tool provides a recommendation for adjusting their credit limit. The logic can involve a scoring model.",
    "description": "此工具用於根據多方面因素自動生成客戶信用額度的調整建議。1. **Excel數據源**：a. “ClientData”表：ClientID, CurrentCreditLimit, CurrentRiskRating, Industry。b. “FinancialPerformance”表：ClientID, ReportingPeriod, Revenue, NetProfit, DebtToEquityRatio, CurrentRatio (最新一期數據)。c. “PaymentHistorySummary”表：ClientID, AvgDaysOverdueLastYear, PercentageOnTimePayments.d. “MarketOutlook”表：Industry, MarketTrendFactor (例如，1.1表示樂觀，0.9表示悲觀)。e. “ScoringModelRules”表：定義評分卡的各項指標、權重和得分標準。例如：  i. 指標 (例如，D/E Ratio < 0.5)，得分 (+10)。  ii. 指標 (例如，AvgDaysOverdue < 5)，得分 (+5)。  iii. 指標 (例如，RiskRating = 'Low')，得分 (+15)。2. **VBA建議引擎**：a. 創建一個“LimitAdjustmentRec”工作表用於輸出結果。b. 遍歷“ClientData”中的每個客戶。c. **收集數據**：為該客戶從“FinancialPerformance”、“PaymentHistorySummary”和“MarketOutlook”表中提取相關數據。d. **計算綜合得分**：根據“ScoringModelRules”表中定義的規則和權重，計算客戶的綜合信用調整得分。e. **生成調整建議**：  i. 基於綜合得分，決定是建議增加、減少還是維持當前信用額度。調整的幅度也可以基於得分或預設百分比。例如，總得分 > 80，建議增加10%；得分 < 40，建議減少15%。  ii. 建議的新額度不能超過基於客戶財務狀況（例如，營收的一定百分比）計算出的理論上限。  iii. 將客戶ID、當前額度、綜合得分、建議操作（增加/減少/維持）、建議調整幅度、建議新額度、以及支持該建議的主要理由（例如，哪些評分項貢獻最大）寫入到“LimitAdjustmentRec”工作表。3. **更新條件**：當任何輸入數據表（客戶財務、支付歷史、風險評級、市場展望）發生重大更新時，可以觸發此建議引擎的重新計算。",
    "parameters": [
        {"name": "Multiple Excel Data Sheets for Client Info", "description": "包含客戶基本數據、財務表現、支付歷史、風險評級等。"},
        {"name": "Scoring Model Rules Sheet", "description": "定義信用額度調整建議評分模型的規則和權重。"},
        {"name": "VBA Logic for Data Aggregation, Scoring, and Recommendation", "description": "執行數據收集、評分計算並生成調整建議的核心代碼。"},
        {"name": "Output Credit Limit Recommendation Sheet", "description": "顯示每個客戶的額度調整建議及其依據。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub GenerateCreditLimitAdjustmentRecommendations()\n    Dim wsClient As Worksheet, wsFins As Worksheet, wsPmtHist As Worksheet, wsMarket As Worksheet, wsRules As Worksheet, wsRec As Worksheet\n    Dim dictScores As Object ' For storing scores per client\n    ' ... (Declare other necessary variables) ...\n\n    ' Set wsClient = ThisWorkbook.Sheets(\"ClientData\")\n    ' ' ... (Set other worksheet objects) ...\n    ' Set wsRec = ThisWorkbook.Sheets(\"LimitAdjustmentRec\")\n    ' wsRec.Cells.ClearContents\n    ' wsRec.Range(\"A1:G1\").Value = Array(\"ClientID\", \"CurrentLimit\", \"TotalScore\", \"Recommendation\", \"Adjustment%\", \"NewGuidelineLimit\", \"KeyReasons\")\n    ' Dim nextRecRow As Long: nextRecRow = 2\n\n    ' ' Load scoring rules into a more usable structure if complex (e.g., array of custom types or collection of dictionaries)\n\n    ' Dim lastClientRow As Long: lastClientRow = wsClient.Cells(Rows.Count, \"A\").End(xlUp).Row\n    ' For Dim rCli As Long = 2 To lastClientRow\n    '   Dim clientID As String: clientID = wsClient.Cells(rCli, \"ClientID_Col\").Value\n    '   Dim currentLimit As Double: currentLimit = wsClient.Cells(rCli, \"CurrentLimit_Col\").Value\n    '   Dim totalScore As Double: totalScore = 0\n    '   Dim keyReasons As String: keyReasons = \"\"\n\n    '   ' --- 1. Fetch Data for Client (from wsFins, wsPmtHist, wsMarket) ---\n    '   ' Dim clientRevenue As Double: clientRevenue = GetClientFinancial(clientID, \"Revenue\", wsFins)\n    '   ' Dim clientDERatio As Double: clientDERatio = GetClientFinancial(clientID, \"DERatio\", wsFins)\n    '   ' Dim avgOverdue As Long: avgOverdue = GetPaymentHistoryMetric(clientID, \"AvgOverdue\", wsPmtHist)\n    '   ' Dim marketFactor As Double: marketFactor = GetMarketFactor(wsClient.Cells(rCli, \"Industry_Col\").Value, wsMarket)\n\n    '   ' --- 2. Calculate Score based on ScoringModelRules sheet ---\n    '   ' For each rule in wsRules:\n    '   '   Dim metricValue As Variant ' (e.g., clientDERatio)\n    '   '   Dim ruleThreshold As Double, ruleScore As Double, ruleWeight As Double, ruleDescription As String\n    '   '   ' ... get metricValue for current client related to the rule ...\n    '   '   ' ... compare metricValue with ruleThreshold and add (ruleScore * ruleWeight) to totalScore ...\n    '   '   ' ... if score is significant, add ruleDescription to keyReasons ...\n    '   ' totalScore = totalScore + (calculated_score_for_metric * weight_for_metric)\n    '   ' Example simplified score calculation:\n    '   ' If clientDERatio < 0.5 Then totalScore = totalScore + 20: keyReasons = keyReasons & \"D/E Ratio良好; \"\n    '   ' If avgOverdue < 10 Then totalScore = totalScore + 15: keyReasons = keyReasons & \"還款及時; \"\n    '   ' totalScore = totalScore * marketFactor ' Adjust by market factor\n\n    '   ' --- 3. Generate Recommendation ---\n    '   Dim recommendation As String, adjustmentPct As Double, newLimit As Double\n    '   ' If totalScore >= 80 Then\n    '   '   recommendation = \"建議增加額度\"\n    '   '   adjustmentPct = 0.1 ' Increase by 10%\n    '   ' ElseIf totalScore < 40 Then\n    '   '   recommendation = \"建議減少額度\"\n    '   '   adjustmentPct = -0.15 ' Decrease by 15%\n    '   ' Else\n    '   '   recommendation = \"維持當前額度\"\n    '   '   adjustmentPct = 0\n    '   ' End If\n    '   ' newLimit = currentLimit * (1 + adjustmentPct)\n    '   ' ' Apply theoretical cap if any (e.g., newLimit cannot exceed 20% of revenue)\n    '   ' Dim capLimit As Double: capLimit = clientRevenue * 0.2\n    '   ' If newLimit > capLimit Then newLimit = capLimit\n\n    '   wsRec.Cells(nextRecRow, \"A\").Value = clientID\n    '   wsRec.Cells(nextRecRow, \"B\").Value = currentLimit\n    '   wsRec.Cells(nextRecRow, \"C\").Value = totalScore\n    '   wsRec.Cells(nextRecRow, \"D\").Value = recommendation\n    '   wsRec.Cells(nextRecRow, \"E\").Value = Format(adjustmentPct, \"0.0%\")\n    '   wsRec.Cells(nextRecRow, \"F\").Value = newLimit\n    '   wsRec.Cells(nextRecRow, \"G\").Value = Left(keyReasons, 255)\n    '   nextRecRow = nextRecRow + 1\n    ' Next rCli\n    ' wsRec.Columns.AutoFit\n    ' MsgBox \"客戶信用額度動態調整建議已生成。\"\nEnd Sub", "explanation": "此概念性腳本描述了一個信用額度調整建議引擎。它會為每個客戶從不同的Excel工作表中收集財務數據、支付歷史和市場信息。然後，基於一個（假設的）“ScoringModelRules”表，它會計算一個綜合得分。根據這個得分，它會生成一個關於增加、減少或維持當前信用額度的建議，以及建議的調整百分比和調整後的新額度。結果會記錄在一個專門的“LimitAdjustmentRec”輸出工作表中。"}
    ],
    "keywords": ["excel credit limit adjustment vba", "dynamic credit scoring excel", "loan portfolio management tool", "risk-based limit setting", "客戶信用額度調整", "Excel動態評分模型", "貸後額度管理"]
},
{
    "name": "大額交易監控與可疑活動標記 (Excel)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: An Excel sheet receives or logs daily transaction data for corporate clients (ClientID, TransactionDate, TransactionAmount, TransactionType, Counterparty). VBA processes this data to identify and flag potentially suspicious activities based on predefined rules, such as unusually large transactions compared to the client's historical average, transactions with high-risk counterparties, or rapid succession of large withdrawals.",
    "description": "此工具用於監控客戶的大額交易並標記潛在的可疑活動。1. **Excel數據表**：a. “DailyTransactions”表：ClientID, TransactionDate, TransactionAmount, TransactionType (貸/借), Currency, CounterpartyID, CounterpartyName, CounterpartyRiskRating (可選)。b. “ClientProfile”表：ClientID, AvgTransactionSizeLast6M, MaxSingleTransactionLast6M, KnownHighRiskCounterparties (逗號分隔列表)。c. “SuspiciousActivityLog”表：記錄被標記的交易及其原因。2. **VBA監控與標記邏輯**：a. VBA腳本處理“DailyTransactions”表中的新交易記錄（例如，僅處理當日或特定日期範圍內的交易）。b. 對於每筆交易：  i. **大額交易識別**：將`TransactionAmount`與該客戶在“ClientProfile”中記錄的`AvgTransactionSizeLast6M`和`MaxSingleTransactionLast6M`進行比較。例如，如果交易金額超過平均值的5倍或歷史最大單筆的2倍，則標記。  ii. **高風險交易對手**：檢查`CounterpartyID`或`CounterpartyName`是否在客戶的`KnownHighRiskCounterparties`列表中，或者`CounterpartyRiskRating`是否為高。  iii. **異常模式**：檢查短期內是否有多次大額提現或轉賬至同一未知交易對手。 (這部分邏輯較複雜，可能需要按客戶分組交易後分析)。  iv. (可選) 根據交易金額、類型和交易對手風險，計算一個綜合的“可疑評分”。c. 如果任何規則被觸發或可疑評分超過閾值，則將該交易的詳細信息（包括觸發的規則描述）記錄到“SuspiciousActivityLog”表中。3. **更新與報告**：a. “ClientProfile”表中的歷史平均/最大交易額度需要定期（例如，每月）根據最新的交易數據進行更新。b. “SuspiciousActivityLog”表可以作為反洗錢(AML)團隊或風險管理部門的日常審查輸入。4. **更新條件**：每日處理新的交易數據時運行。",
    "parameters": [
        {"name": "Daily Transaction Data Sheet", "description": "包含客戶每日交易明細的工作表。"},
        {"name": "Client Profile Sheet with Historical Norms", "description": "存儲客戶歷史交易行為（如平均/最大交易額）的工作表。"},
        {"name": "Suspicious Activity Rules", "description": "定義哪些交易模式被視為可疑的規則（例如，金額閾值、交易對手列表）。"},
        {"name": "Output Suspicious Activity Log Sheet", "description": "記錄被標記為可疑的交易及其原因的工作表。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub MonitorLargeTransactionsAndFlagSuspicious()\n    Dim wsTrans As Worksheet, wsProfile As Worksheet, wsLog As Worksheet\n    Dim lastTransRow As Long, lastProfRow As Long, rT As Long, rP As Long, nextLogRow As Long\n    Dim clientID As String, transAmount As Double, avgTrans As Double, maxTrans As Double, counterparty As String\n    Dim isSuspicious As Boolean, reason As String\n\n    ' Set wsTrans = ThisWorkbook.Sheets(\"DailyTransactions\")\n    ' Set wsProfile = ThisWorkbook.Sheets(\"ClientProfile\")\n    ' Set wsLog = ThisWorkbook.Sheets(\"SuspiciousActivityLog\")\n    ' ' ... Clear Log sheet or find next row, setup headers ...\n    ' wsLog.Range(\"A1:E1\").Value = Array(\"LogDate\", \"ClientID\", \"TransactionID\", \"Reason\", \"TransactionDetails\")\n    ' nextLogRow = 2\n\n    ' lastTransRow = wsTrans.Cells(Rows.Count, \"A\").End(xlUp).Row\n    ' For rT = 2 To lastTransRow ' Loop through today's transactions\n    '   clientID = wsTrans.Cells(rT, \"ClientID_Col\").Value\n    '   transAmount = wsTrans.Cells(rT, \"TransactionAmount_Col\").Value\n    '   counterparty = wsTrans.Cells(rT, \"Counterparty_Col\").Value\n    '   isSuspicious = False: reason = \"\"\n\n    '   ' Find client profile data\n    '   Dim clientProfileRow As Range\n    '   Set clientProfileRow = wsProfile.Columns(\"A\").Find(What:=clientID, LookIn:=xlValues, LookAt:=xlWhole)\n    '   If Not clientProfileRow Is Nothing Then\n    '     avgTrans = wsProfile.Cells(clientProfileRow.Row, \"AvgTrans_Col\").Value\n    '     maxTrans = wsProfile.Cells(clientProfileRow.Row, \"MaxTrans_Col\").Value\n    '     Dim highRiskCPList As String: highRiskCPList = wsProfile.Cells(clientProfileRow.Row, \"HighRiskCP_Col\").Value\n\n    '     ' Rule 1: Unusually Large Transaction\n    '     If transAmount > (avgTrans * 5) And avgTrans > 0 Then isSuspicious = True: reason = reason & \"金額遠超平均水平; \"\n    '     If transAmount > (maxTrans * 2) And maxTrans > 0 Then isSuspicious = True: reason = reason & \"金額遠超歷史最大單筆; \"\n    '     ' Rule 2: Transaction with High-Risk Counterparty\n    '     If InStr(1, highRiskCPList, counterparty, vbTextCompare) > 0 Then isSuspicious = True: reason = reason & \"與已知高風險交易對手交易; \"\n    '     ' Add more rules (e.g., velocity, specific transaction types)\n    '   Else\n    '     reason = \"未找到客戶交易概況； \"\n    '     ' Decide if all transactions for unknown profiles are suspicious or just log a warning\n    '     isSuspicious = True ' Example: Flag if profile missing\n    '   End If\n\n    '   If isSuspicious Then\n    '     wsLog.Cells(nextLogRow, \"A\").Value = Now\n    '     wsLog.Cells(nextLogRow, \"B\").Value = clientID\n    '     wsLog.Cells(nextLogRow, \"C\").Value = wsTrans.Cells(rT, \"TransactionID_Col\").Value\n    '     wsLog.Cells(nextLogRow, \"D\").Value = reason\n    '     wsLog.Cells(nextLogRow, \"E\").Value = \"金額: \" & transAmount & \", 對手: \" & counterparty\n    '     nextLogRow = nextLogRow + 1\n    '   End If\n    ' Next rT\n    ' wsLog.Columns.AutoFit\n    ' MsgBox \"大額交易監控與可疑活動標記完成。\"\nEnd Sub", "explanation": "此概念性腳本遍歷“DailyTransactions”表中的交易。對於每筆交易，它會查找“ClientProfile”表中對應客戶的歷史交易概況（如平均和最大交易金額）以及已知的高風險交易對手列表。然後，它應用預定義的規則（例如，交易金額是否遠超歷史水平，交易對手是否在高風險名單中）來判斷交易是否可疑。如果可疑，則將相關信息記錄到“SuspiciousActivityLog”表中。"}
    ],
    "keywords": ["excel transaction monitoring vba", "suspicious activity detection excel", "aml tools excel vba", "large transaction reporting", "大額交易監控", "Excel可疑活動標記", "反洗錢工具"]
},
{
    "name": "客戶授信集中度按行業/區域/擔保方式的動態分析儀表板 (Excel)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: An Excel workbook contains detailed loan exposure data for all corporate clients, including their industry, geographical region, and primary collateral type. This tool dynamically generates a dashboard showing credit concentration percentages by these dimensions, comparing them against predefined internal limits, and highlighting any breaches or near-breaches.",
    "description": "此工具用於分析和監控銀行在不同維度（行業、區域、擔保方式）上的授信集中度風險。1. **Excel數據源**：a. “LoanBook”表：ClientID, LoanID, OutstandingBalance, IndustryCode, IndustryName, RegionCode, RegionName, PrimaryCollateralType, RiskRating。b. “ConcentrationLimits”表：DimensionType (例如，“Industry”，“Region”，“CollateralType”)，DimensionValue (例如，“房地產業”，“華東區”，“保證擔保”)，ConcentrationLimitPercentage (例如，總體授信的20%)。2. **VBA彙總與比較邏輯**：a. 創建或更新一個“ConcentrationDashboard”工作表。b. **計算總授信額**：首先計算“LoanBook”中所有貸款的總未償還餘額。c. **按維度彙總**：  i. **行業集中度**：使用`SUMIFS`或VBA遍歷，按“IndustryName”彙總每個行業的總授信餘額，然後計算其佔總授信額的百分比。  ii. **區域集中度**：類似地，按“RegionName”彙總和計算百分比。  iii. **擔保方式集中度**：按“PrimaryCollateralType”彙總和計算百分比。d. **與限額比較**：對於每個維度下的每個類別（例如，每個特定行業），從“ConcentrationLimits”表中查找其對應的集中度限額百分比。比較實際集中度百分比與限額。3. **儀表板展示**：a. 在“ConcentrationDashboard”上，為每個維度（行業、區域、擔保方式）創建一個表格，顯示該維度下各類別的授信總額、佔比、以及預設的限額和是否超限的標記。b. 使用條件格式高亮顯示接近或超過限額的集中度百分比。c. (可選) 使用Excel圖表（例如，餅圖或條形圖）直觀展示各維度的集中度分佈。4. **更新條件**：“LoanBook”數據更新後，或“ConcentrationLimits”表調整後，應重新運行此分析。",
    "parameters": [
        {"name": "Loan Book Data Sheet", "description": "包含每筆貸款的餘額和相關分類維度（行業、區域、擔保方式）的工作表。"},
        {"name": "Concentration Limits Sheet", "description": "定義不同維度和類別的授信集中度限額的工作表。"},
        {"name": "VBA Logic for Aggregation and Comparison", "description": "按各維度彙總授信額、計算佔比並與限額比較的代碼。"},
        {"name": "Output Concentration Dashboard Sheet", "description": "以表格和圖表形式展示集中度分析結果的工作表。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub GenerateConcentrationRiskDashboard()\n    Dim wsLoans As Worksheet, wsLimits As Worksheet, wsDash As Worksheet\n    Dim dictIndustry As Object, dictRegion As Object, dictCollateral As Object ' Dictionaries for aggregation\n    Dim totalPortfolioExposure As Double, currentExposure As Double, limitPct As Double, actualPct As Double\n    Dim lastLoanRow As Long, rL As Long, nextDashRow As Long\n\n    ' Set wsLoans = ThisWorkbook.Sheets(\"LoanBook\")\n    ' Set wsLimits = ThisWorkbook.Sheets(\"ConcentrationLimits\")\n    ' Set wsDash = ThisWorkbook.Sheets(\"ConcentrationDashboard\")\n    ' wsDash.Cells.ClearContents\n    ' Set dictIndustry = CreateObject(\"Scripting.Dictionary\")\n    ' ' ... Initialize other dictionaries ...\n\n    ' ' 1. Calculate Total Portfolio Exposure\n    ' lastLoanRow = wsLoans.Cells(Rows.Count, \"A\").End(xlUp).Row\n    ' totalPortfolioExposure = Application.WorksheetFunction.Sum(wsLoans.Range(\"OutstandingBalance_Col\" & \"2:\" & \"OutstandingBalance_Col\" & lastLoanRow))\n    ' If totalPortfolioExposure = 0 Then MsgBox \"總授信餘額為零，無法分析。\": Exit Sub\n\n    ' ' 2. Aggregate by Industry (Example)\n    ' For rL = 2 To lastLoanRow\n    '   Dim industry As String: industry = wsLoans.Cells(rL, \"IndustryName_Col\").Value\n    '   currentExposure = wsLoans.Cells(rL, \"OutstandingBalance_Col\").Value\n    '   dictIndustry(industry) = dictIndustry(industry) + currentExposure\n    ' Next rL\n\n    ' ' 3. Display on Dashboard and Compare with Limits (Example for Industry)\n    ' nextDashRow = 2\n    ' wsDash.Cells(1, 1).Value = \"行業集中度分析\"\n    ' wsDash.Range(\"A2:E2\").Value = Array(\"行業\", \"授信餘額\", \"佔比 (%)\", \"限額 (%)\", \"是否超限\")\n    ' For Each keyIndustry In dictIndustry.Keys\n    '   wsDash.Cells(nextDashRow, \"A\").Value = keyIndustry\n    '   wsDash.Cells(nextDashRow, \"B\").Value = dictIndustry(keyIndustry)\n    '   actualPct = (dictIndustry(keyIndustry) / totalPortfolioExposure)\n    '   wsDash.Cells(nextDashRow, \"C\").Value = Format(actualPct, \"0.00%\")\n    '   ' Find limit for this industry from wsLimits\n    '   limitPct = GetConcentrationLimit(\"Industry\", keyIndustry, wsLimits, totalPortfolioExposure) ' Custom function\n    '   wsDash.Cells(nextDashRow, \"D\").Value = Format(limitPct, \"0.00%\")\n    '   If actualPct > limitPct And limitPct > 0 Then\n    '     wsDash.Cells(nextDashRow, \"E\").Value = \"是\"\n    '     wsDash.Cells(nextDashRow, \"E\").Interior.Color = vbRed\n    '   Else\n    '     wsDash.Cells(nextDashRow, \"E\").Value = \"否\"\n    '   End If\n    '   nextDashRow = nextDashRow + 1\n    ' Next keyIndustry\n    ' ' ... Repeat for Region and CollateralType ...\n    ' wsDash.Columns.AutoFit\n    ' MsgBox \"授信集中度儀表板已生成。\"\nEnd Sub\n\nFunction GetConcentrationLimit(dimType As String, dimValue As String, limitsSheet As Worksheet, totalExposure As Double) As Double\n    ' Placeholder: Finds the limit % from limitsSheet for the given dimension type and value.\n    ' Returns the limit as a decimal (e.g., 0.2 for 20%).\n    ' On Error Resume Next\n    ' Dim foundRow As Range\n    ' Dim searchRange As Range: Set searchRange = limitsSheet.Columns(\"DimensionValue_Col\")\n    ' Set foundRow = searchRange.Find(What:=dimValue, LookIn:=xlValues, LookAt:=xlWhole, After:=limitsSheet.Cells(1, searchRange.Column))\n    ' If Not foundRow Is Nothing Then\n    '    If LCase(limitsSheet.Cells(foundRow.Row, \"DimensionType_Col\").Value) = LCase(dimType) Then\n    '        GetConcentrationLimit = limitsSheet.Cells(foundRow.Row, \"LimitPercentage_Col\").Value\n    '        Exit Function\n    '    End If\n    ' End If\n    ' GetConcentrationLimit = 1 ' Default to 100% if no specific limit found (meaning no effective limit)\nEnd Function", "explanation": "此概念性腳本首先計算總的授信組合敞口。然後，它使用字典對象按行業（以及類似地按區域和擔保方式，此處未完全展示）彙總授信餘額。接著，它將這些彙總數據寫入“ConcentrationDashboard”工作表，計算每個類別的實際授信佔比，並從“ConcentrationLimits”表中查找對應的預設限額。最後，它比較實際佔比與限額，並標記是否超限。需要一個輔助函數 `GetConcentrationLimit` 來從限額表中查找特定維度的限額。"}
    ],
    "keywords": ["excel credit concentration risk", "vba portfolio analysis dashboard", "sector concentration monitoring", "risk management excel tools", "授信集中度分析", "Excel風險儀表板", "行業集中度監控"]
},
{
    "name": "進階數據驗證與清理自動化 (Excel)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Before data from an Excel sheet can be uploaded to a core banking system or used for critical reporting, it must pass a series of complex validation and cleaning rules. These rules go beyond simple data type checks and involve cross-field consistency, adherence to business logic, and formatting requirements. VBA automates this, flags errors, suggests corrections, and can optionally auto-correct certain common issues.",
    "description": "此工具用於對Excel數據執行進階的驗證和清理。1. **Excel數據表與規則表**：a. “DataInput”表：包含待驗證和清理的原始數據。b. “ValidationRules”表：定義詳細的驗證規則。列可包含：RuleID, TargetColumnName, ValidationType (例如，“Required”, “DataType”, “Range”, “Pattern”, “Lookup”, “CrossField”), Parameter1 (例如，數據類型“Date”, 範圍下限, 正則表達式模式, 查找範圍), Parameter2 (例如，範圍上限), ErrorMessage, AutoCorrectAction (可選，例如，“ToUpperCase”, “TrimSpaces”, “DefaultValueIfEmpty”)。2. **VBA驗證與清理引擎**：a. VBA腳本讀取“ValidationRules”表中的所有規則。b. 遍歷“DataInput”表中的每一行數據（或選定範圍）。c. 對於每條數據記錄的每個目標欄位，應用“ValidationRules”表中定義的所有相關規則：  i. **執行驗證**：根據`ValidationType`和參數執行校驗。例如，`DataType`檢查（IsNumeric, IsDate），`Range`檢查數值範圍，`Pattern`使用正則表達式檢查格式 (例如，證件號碼、郵箱)，`Lookup`檢查值是否存在於一個有效的列表中（來自另一工作表或範圍），`CrossField`檢查多個欄位之間的一致性（例如，如果A='已婚',則B不能為空）。  ii. **錯誤處理**：如果驗證失敗，則在該儲存格旁的一個“錯誤描述”列中記錄`ErrorMessage`，並可選地高亮顯示該儲存格。  iii. **自動清理 (可選)**：如果規則定義了`AutoCorrectAction`且錯誤類型適用於自動修正（例如，去除多餘空格、轉換大小寫、為空值填寫預設值），則執行修正並記錄操作。3. **結果報告**：a. 在處理完所有數據後，生成一個驗證摘要報告，說明總共檢查的記錄數、發現的錯誤數、自動修正的數量。b. “DataInput”表中的錯誤儲存格會被高亮，並附有錯誤描述，方便用戶手動修正剩餘問題。這個系統確保了數據在進入後續流程前達到較高的質量標準。",
    "parameters": [
        {"name": "Excel Data Input Sheet", "description": "包含原始待驗證數據的工作表。"},
        {"name": "Excel Validation Rules Sheet", "description": "詳細定義每列驗證規則（類型、參數、錯誤消息、自動修正動作）的工作表。"},
        {"name": "VBA Engine for Rule Parsing and Execution", "description": "讀取規則、遍歷數據、執行驗證和清理的核心代碼。"},
        {"name": "Error Reporting and Highlighting", "description": "如何在原始數據表上標記錯誤並生成摘要報告的機制。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub AdvancedDataValidationAndCleaning()\n    Dim wsData As Worksheet, wsRules As Worksheet, wsLog As Worksheet ' Optional log sheet\n    Dim ruleSet As Range, dataRange As Range\n    Dim rData As Range, rRule As Range\n    Dim errorsFound As Long: errorsFound = 0\n    Dim correctionsMade As Long: correctionsMade = 0\n\n    ' Set wsData = ThisWorkbook.Sheets(\"DataInput\")\n    ' Set wsRules = ThisWorkbook.Sheets(\"ValidationRules\")\n    ' ' Set dataRange = wsData.Range(\"A2:Z\" & wsData.Cells(Rows.Count, \"A\").End(xlUp).Row) ' Example data range\n    ' Set ruleSet = wsRules.Range(\"A2:G\" & wsRules.Cells(Rows.Count, \"A\").End(xlUp).Row) ' Rule definition range\n    ' ' Assume wsData has an adjacent column for error messages for each data column, or use comments\n\n    ' For Each rRule In ruleSet.Rows\n    '   Dim targetColName As String: targetColName = rRule.Cells(1, \"TargetColumnName_Col\").Value\n    '   Dim validationType As String: validationType = rRule.Cells(1, \"ValidationType_Col\").Value\n    '   Dim param1 As String: param1 = rRule.Cells(1, \"Param1_Col\").Value\n    '   Dim param2 As String: param2 = rRule.Cells(1, \"Param2_Col\").Value\n    '   Dim errorMsg As String: errorMsg = rRule.Cells(1, \"ErrorMessage_Col\").Value\n    '   Dim autoCorrect As String: autoCorrect = rRule.Cells(1, \"AutoCorrect_Col\").Value\n    '   Dim targetColIndex As Long\n    '   On Error Resume Next ' Find target column index in data sheet header\n    '   targetColIndex = Application.Match(targetColName, wsData.Rows(1), 0)\n    '   If Err.Number <> 0 Then Debug.Print \"Rule Error: Column '\" & targetColName & \"' not found in data.\": GoTo NextRule\n    '   On Error GoTo 0\n\n    '   For Each rData In dataRange.Rows ' Iterate each data row for the specific column\n    '     Dim cellToValidate As Range: Set cellToValidate = wsData.Cells(rData.Row, targetColIndex)\n    '     Dim cellValue As Variant: cellValue = cellToValidate.Value\n    '     Dim isValid As Boolean: isValid = True\n    '     Dim originalValue As Variant: originalValue = cellValue\n\n    '     ' --- Apply Auto-Correction First (if any) ---\n    '     ' If autoCorrect <> \"\" Then\n    '     '   Select Case LCase(autoCorrect)\n    '     '     Case \"touppercase\": cellValue = UCase(CStr(cellValue)): cellToValidate.Value = cellValue\n    '     '     Case \"trimspaces\": cellValue = Trim(CStr(cellValue)): cellToValidate.Value = cellValue\n    '     '     ' ... more auto-correct actions ...\n    '     '   End Select\n    '     '   If CStr(originalValue) <> CStr(cellValue) Then correctionsMade = correctionsMade + 1\n    '     ' End If\n\n    '     ' --- Perform Validation ---\n    '     ' Select Case LCase(validationType)\n    '     '   Case \"required\": If IsEmpty(cellValue) Or Trim(CStr(cellValue)) = \"\" Then isValid = False\n    '     '   Case \"datatype\": If LCase(param1) = \"numeric\" And Not IsNumeric(cellValue) Then isValid = False\n    '     '                  If LCase(param1) = \"date\" And Not IsDate(cellValue) Then isValid = False\n    '     '   Case \"range\": If IsNumeric(cellValue) Then If Not (CDbl(cellValue) >= CDbl(param1) And CDbl(cellValue) <= CDbl(param2)) Then isValid = False Else isValid = False\n    '     '   Case \"pattern\": ' Dim rgx As Object: Set rgx = CreateObject(\"VBScript.RegExp\")\n    '     '                  ' rgx.Pattern = param1: If Not rgx.Test(CStr(cellValue)) Then isValid = False\n    '     '   ' ... more validation types ...\n    '     ' End Select\n\n    '     ' If Not isValid Then\n    '     '   errorsFound = errorsFound + 1\n    '     '   wsData.Cells(rData.Row, targetColIndex + 1).Value = errorMsg ' Log error in adjacent cell\n    '     '   cellToValidate.Interior.Color = vbYellow ' Highlight error\n    '     ' End If\n    '   Next rData\n'NextRule:\n    ' Next rRule\n    ' MsgBox \"數據驗證與清理完成。發現 \" & errorsFound & \" 個錯誤，執行了 \" & correctionsMade & \" 次自動修正。\"\nEnd Sub", "explanation": "此概念性腳本從“ValidationRules”工作表中讀取驗證規則。對於“DataInput”工作表中的每個數據，它會應用這些規則。規則可以包括必填檢查、數據類型（數字、日期）、數值範圍、正則表達式模式匹配等。它還概念性地展示了如何處理自動修正（如轉換大小寫、去除空格）。如果驗證失敗，它會在數據旁邊的列中記錄錯誤消息並高亮顯示錯誤儲存格。最後，它會報告發現的錯誤總數和執行的自動修正次數。"}
    ],
    "keywords": ["excel advanced data validation vba", "data cleaning automation excel", "vba regex validation", "cross-field validation excel", "Excel數據進階驗證", "數據清理自動化VBA", "正則表達式驗證"]
},
// --// Existing commands would be here, ensure a comma before this block if vbaCommands is not empty.
// For example: const vbaCommands = [ /* existing commands */,
// --- Start of new commands ---
{
    "name": "批量提取多個Word版貸後檢查報告中的關鍵風險點到Excel",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Relationship Managers submit post-loan review reports or site visit reports as Word documents. These documents have a semi-structured format where key risk points or follow-up items are often under specific headings (e.g., 'Identified Risks', 'Key Concerns', 'Actionable Items'). VBA allows a user to select a folder containing these Word reports. It then loops through each document, extracts text under these predefined headings, and consolidates them into an Excel summary sheet, linking each risk point back to the source document and client.",
    "description": "此工具用於從一批Word格式的貸後檢查報告中自動提取並彙整關鍵風險點。1. **用戶選擇報告文件夾**：VBA首先提示用戶選擇一個包含所有待處理Word報告文件的文件夾 (`Application.FileDialog(msoFileDialogFolderPicker)`). 2. **定義關鍵詞/標題**：在VBA代碼中或一個Excel配置表中定義一組用於識別風險點所在段落的關鍵詞或標題文本 (例如，`Array(\"主要風險點:\", \"需關注事項:\", \"潛在問題:\", \"跟進行動:\")`)。3. **Excel彙總表準備**：準備一個Excel工作表（“RiskPointSummary”），包含列：源文件名、客戶ID (如果可從文件名或文檔內容中提取)、報告日期 (可從文件名或文檔內容提取)、風險/行動點標題、提取的風險/行動點內容。4. **VBA遍歷與提取邏輯**：a. 遍歷用戶選定文件夾中的所有Word文檔 (`.doc`, `.docx`)。b. 對於每個Word文檔：  i. 以唯讀方式打開文檔。  ii. 遍歷文檔中的所有段落 (`wdDoc.Paragraphs`)。  iii. 檢查每個段落的文本是否以預定義的關鍵詞/標題之一開頭 (或包含它)。  iv. 如果找到匹配的標題段落，則提取該標題段落的文本以及其後續的一個或多個段落（直到遇到下一個預定義的關鍵詞/標題，或一個空段落，或達到預設的段落數限制）作為風險點的詳細內容。  v. (可選) 嘗試從文件名或文檔開頭提取客戶ID和報告日期。  vi. 將文件名、客戶ID、報告日期、找到的風險標題以及提取的風險內容作為新的一行寫入到Excel的“RiskPointSummary”表中。  vii. 關閉Word文檔。5. **完成提示**：所有文件處理完畢後，通知用戶已提取的風險點總數和Excel彙總表的位置。這個工具能幫助風險管理部門快速彙總來自大量獨立報告中的關鍵風險信息，進行趨勢分析或集中跟進。",
    "parameters": [
        {"name": "Source Word Reports Folder (User Selected)", "description": "包含貸後檢查報告的Word文檔的文件夾。"},
        {"name": "Keywords/Headings for Risk Sections", "description": "用於在Word文檔中定位風險描述部分的文本標籤。"},
        {"name": "Excel Summary Sheet for Extracted Risks", "description": "存放彙整後的風險點信息的工作表。"},
        {"name": "Logic for Extracting Content under Headings", "description": "找到標題後，如何確定並提取相關風險描述的文本範圍。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub ExtractRiskPointsFromWordReports()\n    Dim wdApp As Object, wdDoc As Object, xlSheet As Worksheet\n    Dim fso As Object, sourceFolder As Object, fileItem As Object\n    Dim folderPath As String, nextRowExcel As Long\n    Dim riskKeywords As Variant, para As Object ' Word.Paragraph\n    Dim currentKeyword As String, riskText As String, clientID As String, reportDate As Variant\n\n    ' Set xlSheet = ThisWorkbook.Sheets(\"RiskPointSummary\")\n    ' ' Headers: FileName, ClientID, ReportDate, RiskHeading, RiskDetails\n    ' xlSheet.Cells.ClearContents ' Or find last row\n    ' xlSheet.Range(\"A1:E1\").Value = Array(\"源文件名\", \"客戶ID\", \"報告日期\", \"風險標題\", \"風險詳情\")\n    ' nextRowExcel = 2\n    ' riskKeywords = Array(\"主要風險點:\", \"需關注事項:\", \"潛在問題:\", \"跟進行動:\") ' CHINESE\n\n    ' ' 1. User selects folder\n    ' With Application.FileDialog(msoFileDialogFolderPicker)\n    '   .Title = \"請選擇包含Word貸後報告的文件夾\"\n    '   If .Show = -1 Then folderPath = .SelectedItems(1) Else Exit Sub\n    ' End With\n    ' If Right(folderPath, 1) <> Application.PathSeparator Then folderPath = folderPath & Application.PathSeparator\n\n    ' On Error Resume Next\n    ' Set wdApp = GetObject(, \"Word.Application\")\n    ' If wdApp Is Nothing Then Set wdApp = CreateObject(\"Word.Application\")\n    ' If wdApp Is Nothing Then MsgBox \"無法啟動Word.\": Exit Sub\n    ' On Error GoTo 0\n    ' ' wdApp.Visible = False\n    ' Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    ' Set sourceFolder = fso.GetFolder(folderPath)\n\n    ' For Each fileItem In sourceFolder.Files\n    '   If (LCase(fso.GetExtensionName(fileItem.Name)) = \"docx\" Or _\n    '       LCase(fso.GetExtensionName(fileItem.Name)) = \"doc\") And Left(fileItem.Name, 2) <> \"~$\" Then\n    '     Set wdDoc = wdApp.Documents.Open(fileItem.Path, ReadOnly:=True, Visible:=False)\n    '     clientID = ExtractClientIDFromFileName(fileItem.Name) ' Custom function\n    '     reportDate = ExtractReportDateFromContent(wdDoc) ' Custom function\n    '     Dim inRiskSection As Boolean: inRiskSection = False\n    '     riskText = \"\"\n\n    '     For Each para In wdDoc.Paragraphs\n    '       Dim paraText As String: paraText = Trim(para.Range.Text)\n    '       Dim isKeywordPara As Boolean: isKeywordPara = False\n    '       For Each KeyW In riskKeywords\n    '         If InStr(1, paraText, CStr(KeyW), vbTextCompare) = 1 Then ' Starts with keyword\n    '           If inRiskSection And riskText <> \"\" Then ' Save previous risk section\n    '             xlSheet.Cells(nextRowExcel, 1).Value = fileItem.Name\n    '             xlSheet.Cells(nextRowExcel, 2).Value = clientID\n    '             xlSheet.Cells(nextRowExcel, 3).Value = reportDate\n    '             xlSheet.Cells(nextRowExcel, 4).Value = currentKeyword\n    '             xlSheet.Cells(nextRowExcel, 5).Value = riskText\n    '             nextRowExcel = nextRowExcel + 1\n    '           End If\n    '           currentKeyword = CStr(KeyW)\n    '           riskText = Replace(paraText, currentKeyword, \"\", , , vbTextCompare) ' Get text after keyword in same para\n    '           inRiskSection = True\n    '           isKeywordPara = True\n    '           Exit For\n    '         End If\n    '       Next KeyW\n    '\n    '       If Not isKeywordPara And inRiskSection Then\n    '         If paraText <> \"\" Then ' Collect subsequent non-empty paragraphs\n    '           riskText = riskText & vbCrLf & paraText\n    '         Else ' Empty paragraph might signify end of section\n    '           If riskText <> \"\" Then ' Save current risk section\n    '             xlSheet.Cells(nextRowExcel, 1).Value = fileItem.Name\n    '             xlSheet.Cells(nextRowExcel, 2).Value = clientID\n    '             xlSheet.Cells(nextRowExcel, 3).Value = reportDate\n    '             xlSheet.Cells(nextRowExcel, 4).Value = currentKeyword\n    '             xlSheet.Cells(nextRowExcel, 5).Value = riskText\n    '             nextRowExcel = nextRowExcel + 1\n    '           End If\n    '           inRiskSection = False: riskText = \"\"\n    '         End If\n    '       End If\n    '     Next para\n    '     ' Save the last collected risk section if any\n    '     If inRiskSection And riskText <> \"\" Then\n    '       xlSheet.Cells(nextRowExcel, 1).Value = fileItem.Name\n    '       xlSheet.Cells(nextRowExcel, 2).Value = clientID\n    '       xlSheet.Cells(nextRowExcel, 3).Value = reportDate\n    '       xlSheet.Cells(nextRowExcel, 4).Value = currentKeyword\n    '       xlSheet.Cells(nextRowExcel, 5).Value = riskText\n    '       nextRowExcel = nextRowExcel + 1\n    '     End If\n    '     wdDoc.Close False\n    '   End If\n    ' Next fileItem\n    ' xlSheet.Columns.AutoFit\n    ' MsgBox \"貸後報告中的關鍵風險點提取完成。\"\n    ' ' ... Clean up objects ...\nEnd Sub", "explanation": "此概念性腳本首先讓用戶選擇一個包含Word報告的資料夾。然後，它遍歷該資料夾中的每個Word文檔。對於每個文檔，它會逐個段落讀取內容。如果某個段落以預定義的風險相關關鍵詞（例如“主要風險點:”）開頭，腳本會將此關鍵詞視為風險標題，並開始收集其後續段落的文本作為風險詳情，直到遇到下一個關鍵詞或一個空段落。提取到的文件名、客戶ID（假設可從文件名提取）、報告日期（假設可從內容提取）、風險標題和風險詳情會被記錄到Excel的“RiskPointSummary”工作表中。需要自定義函數 `ExtractClientIDFromFileName` 和 `ExtractReportDateFromContent`。"}
    ],
    "keywords": ["vba extract from word paragraphs", "word to excel risk consolidation", "parse word document headings", "automate report data mining", "從Word段落提取到Excel", "貸後報告風險彙總", "解析Word標題內容"]
},
{
    "name": "批量驗證Word文檔中特定條款是否符合標準庫 (Excel記錄差異)",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: A bank has a standard library of legal clauses for loan agreements, stored in an Excel sheet ('ClauseLibrary'). This tool allows a user to select a folder of Word loan agreements. VBA then attempts to find specific, critical clauses within each Word document (e.g., by searching for a clause title or a unique starting phrase) and compares the extracted text against the standard version in the ClauseLibrary. Any deviations are logged in an Excel 'DeviationReport' sheet.",
    "description": "此工具用於自動比較多個Word文檔中的關鍵法律條款與標準條款庫的差異。1. **Excel標準條款庫 (“ClauseLibrary”)**：包含列：ClauseID (唯一標識)、ClauseTitle (用於在Word中定位的標題或起始短語)、StandardClauseText (標準條款的完整文本)。2. **用戶選擇Word文檔文件夾**：提示用戶選擇包含待比較Word合同文件的文件夾。3. **Excel差異報告表 (“DeviationReport”)**：包含列：源文件名、ClauseID、ClauseTitle (來自庫)、StandardTextLength、ActualTextLength、DeviationType (例如，“文本不同”，“未找到條款”)、(可選) 實際提取到的文本片段。4. **VBA比較邏輯**：a. 遍歷用戶選定文件夾中的每個Word文檔。b. 對於每個Word文檔：  i. 遍歷“ClauseLibrary”中的每一條標準條款。  ii. 在當前Word文檔中，嘗試根據`ClauseTitle`（或起始短語）定位對應的條款。這可能涉及搜索特定標題樣式的段落，或直接搜索文本。  iii. 如果在Word文檔中找到了該條款，則提取其完整文本內容。  iv. **比較文本**：將從Word文檔中提取的條款文本與“ClauseLibrary”中的`StandardClauseText`進行比較。為簡化比較，可以先去除多餘空格、換行符，並可能統一大小寫（視法律文本比較要求而定）。  v. **記錄差異**：如果提取到的文本與標準文本不符，或在Word文檔中未找到該條款，則在“DeviationReport”中記錄相關信息，包括文件名、條款ID、差異類型等。vi. (可選高級功能) 可以嘗試使用更複雜的文本比較算法來高亮顯示具體的差異點，而不僅僅是判斷是否相同。c. 關閉Word文檔。5. **完成提示**：所有文件比較完畢後，提示用戶查看“DeviationReport”。這個工具對於確保合同標準化、快速識別非標條款或潛在的合同風險非常有用。",
    "parameters": [
        {"name": "Excel Standard Clause Library Sheet", "description": "包含標準法律條款ID、標題和文本的工作表。"},
        {"name": "Folder of Word Documents to Check (User Selected)", "description": "包含待比較Word合同文件的文件夾。"},
        {"name": "Logic for Locating Clauses in Word", "description": "如何在Word文檔中找到與標準庫條款對應的條款文本 (例如，按標題搜索)。"},
        {"name": "Text Comparison Method", "description": "比較提取文本與標準文本的策略 (例如，精確匹配、忽略空格/大小寫)。"},
        {"name": "Excel Deviation Report Sheet", "description": "記錄所有發現的差異的工作表。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub CompareWordClausesWithLibrary()\n    Dim wsLibrary As Worksheet, wsReport As Worksheet\n    Dim wdApp As Object, wdDoc As Object\n    Dim folderPath As String, fileItem As Object, fso As Object\n    Dim libLastRow As Long, libRow As Long, nextReportRow As Long\n    Dim clauseID As String, clauseTitle As String, standardText As String, actualText As String\n\n    ' Set wsLibrary = ThisWorkbook.Sheets(\"ClauseLibrary\") ' A:ID, B:Title, C:StandardText\n    ' Set wsReport = ThisWorkbook.Sheets(\"DeviationReport\")\n    ' ' Setup wsReport headers: FileName, ClauseID, ClauseTitle, DeviationType, ActualTextSnippet\n    ' wsReport.Cells.ClearContents\n    ' wsReport.Range(\"A1:E1\").Value = Array(\"文件名\", \"條款ID\", \"條款標題\", \"差異類型\", \"實際文本片段\")\n    ' nextReportRow = 2\n\n    ' ' User selects folder...\n    ' ' ... (FileDialog code as in previous example to get folderPath) ...\n\n    ' ' ... (Initialize Word App, FSO as in previous example) ...\n\n    ' libLastRow = wsLibrary.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    ' For Each fileItem In fso.GetFolder(folderPath).Files\n    '   If (LCase(fso.GetExtensionName(fileItem.Name)) = \"docx\" Or _\n    '       LCase(fso.GetExtensionName(fileItem.Name)) = \"doc\") And Left(fileItem.Name, 2) <> \"~$\" Then\n    '     Set wdDoc = wdApp.Documents.Open(fileItem.Path, ReadOnly:=True, Visible:=False)\n    '\n    '     For libRow = 2 To libLastRow ' Loop through standard clauses\n    '       clauseID = wsLibrary.Cells(libRow, \"A\").Value\n    '       clauseTitle = wsLibrary.Cells(libRow, \"B\").Value\n    '       standardText = Trim(CStr(wsLibrary.Cells(libRow, \"C\").Value))\n    '       actualText = \"\"\n    '       Dim deviationType As String: deviationType = \"\"\n\n    '       ' Find clause in Word doc by title (simplified search)\n    '       Dim foundRange As Object ' Word.Range\n    '       Set foundRange = FindClauseByTitle(wdDoc, clauseTitle)\n    '\n    '       If Not foundRange Is Nothing Then\n    '         actualText = Trim(foundRange.Text)\n    '         ' Normalize text for comparison (remove extra spaces, newlines, case insensitive)\n    '         If NormalizeTextForCompare(actualText) <> NormalizeTextForCompare(standardText) Then\n    '           deviationType = \"文本不符\"\n    '         Else\n    '           deviationType = \"符合標準\"\n    '         End If\n    '       Else\n    '         deviationType = \"未找到條款\"\n    '       End If\n    '\n    '       If deviationType <> \"符合標準\" Then\n    '         wsReport.Cells(nextReportRow, 1).Value = fileItem.Name\n    '         wsReport.Cells(nextReportRow, 2).Value = clauseID\n    '         wsReport.Cells(nextReportRow, 3).Value = clauseTitle\n    '         wsReport.Cells(nextReportRow, 4).Value = deviationType\n    '         wsReport.Cells(nextReportRow, 5).Value = Left(actualText, 255) ' Snippet\n    '         nextReportRow = nextReportRow + 1\n    '       End If\n    '     Next libRow\n    '     wdDoc.Close False\n    '   End If\n    ' Next fileItem\n    ' wsReport.Columns.AutoFit\n    ' MsgBox \"條款比較完成。請查看差異報告。\"\n    ' ' ... Clean up objects ...\nEnd Sub\n\nFunction FindClauseByTitle(doc As Object, title As String) As Object ' Word.Range\n    ' Placeholder: More sophisticated search needed, e.g., find heading with style, then get following paragraph(s)\n    ' Dim para As Object\n    ' For Each para In doc.Paragraphs\n    '   If InStr(1, para.Range.Text, title, vbTextCompare) > 0 Then\n    '     Set FindClauseByTitle = para.Range ' This is very basic, may need to get more content\n    '     Exit Function\n    '   End If\n    ' Next para\n    Set FindClauseByTitle = Nothing\nEnd Function\n\nFunction NormalizeTextForCompare(txt As String) As String\n    ' Basic normalization: lower case, trim, replace multiple spaces with one\n    ' Dim temp As String\n    ' temp = LCase(Trim(txt))\n    ' temp = Replace(temp, vbCrLf, \" \"): temp = Replace(temp, vbLf, \" \"): temp = Replace(temp, vbCr, \" \")\n    ' Do While InStr(temp, \"  \") > 0: temp = Replace(temp, \"  \", \" \"): Loop\n    ' NormalizeTextForCompare = temp\nEnd Function", "explanation": "此概念性腳本讓用戶選擇一個包含Word合同文件的資料夾。它會遍歷每個文件，並將文件中的特定條款（通過 `FindClauseByTitle` 輔助函數按標題查找，此函數需要詳細實現）與Excel“ClauseLibrary”中存儲的標準條款文本進行比較。比較前，文本會通過 `NormalizeTextForCompare` 函數進行初步的規範化（例如，轉小寫、去除多餘空格）。如果發現差異或未找到條款，則會在Excel的“DeviationReport”表中記錄相關信息。"}
    ],
    "keywords": ["vba compare word documents to library", "excel word clause deviation analysis", "contract compliance check vba", "automated document review", "Word條款與標準庫比較", "合同合規性檢查VBA", "自動化文檔審查"]
},
{
    "name": "從多個Word版客戶調研問卷中提取答案並彙整到Excel",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Clients fill out due diligence questionnaires or survey forms provided as Word documents. These documents contain questions (labels) followed by spaces or tables for answers. VBA helps to batch process a folder of these completed Word documents, extract the answers corresponding to predefined questions, and consolidate them into an Excel sheet where each row represents a client's response and each column represents a question's answer.",
    "description": "此工具用於從一批已填寫的Word調研問卷中自動提取答案。1. **Excel問題與答案映射表 (“QuestionMap”)**：包含列：QuestionID (唯一標識)、QuestionLabelInWord (問卷中問題的實際文本或其唯一標識前綴，例如，“1.1 公司全稱：”)、ExcelColumnHeader (答案在Excel彙總表中對應的列標題)。2. **用戶選擇Word問卷文件夾**：提示用戶選擇存放所有已填寫Word問卷的資料夾。3. **Excel答案彙總表 (“SurveyAnswers”)**：包含列：源文件名、客戶名（如果可提取），以及根據“QuestionMap”中`ExcelColumnHeader`定義的各個問題答案列。4. **VBA提取邏輯**：a. 遍歷用戶選定文件夾中的每個Word文檔。b. 對於每個Word文檔：  i. 打開文檔。  ii. 遍歷“QuestionMap”表中的每個問題定義。  iii. 根據`QuestionLabelInWord`，在Word文檔中查找該問題標籤。  iv. **提取答案**：找到標籤後，提取其後續的答案。提取方法取決於問卷格式：    - 如果答案緊跟在標籤後的同一段落，則提取該段落標籤之後的文本。    - 如果答案在標籤的下一段落，則提取下一段落的文本。    - 如果答案在表格中（例如，問題是表頭，答案在下一行的某列），則需要先定位包含標籤的表格，然後再定位到答案儲存格。    - 可能需要清理提取到的文本（例如，去除多餘空格、換行）。  v. 將從當前Word文檔提取到的所有問題的答案（與文件名等元數據一起）作為新的一行寫入到Excel的“SurveyAnswers”表中，每個答案寫入到“QuestionMap”中定義的對應列。  vi. 關閉Word文檔。5. **完成提示**：所有文件處理完畢後通知用戶。",
    "parameters": [
        {"name": "Excel Question Mapping Sheet", "description": "定義如何在Word中查找問題標籤以及答案應寫入Excel哪一列的配置表。"},
        {"name": "Folder of Completed Word Questionnaires (User Selected)", "description": "包含已填寫Word問卷的資料夾。"},
        {"name": "Logic for Finding Question Labels and Extracting Answers in Word", "description": "根據標籤定位並提取相應答案的VBA代碼。"},
        {"name": "Excel Answer Consolidation Sheet", "description": "用於存放所有問卷提取出的答案的彙總工作表。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub ExtractSurveyAnswersFromWord()\n    Dim wsMap As Worksheet, wsAnswers As Worksheet\n    Dim wdApp As Object, wdDoc As Object\n    Dim folderPath As String, fileItem As Object, fso As Object\n    Dim mapLastRow As Long, mapRow As Long, nextAnswerRow As Long\n    Dim qLabel As String, xlColHeader As String, answerText As String\n\n    ' Set wsMap = ThisWorkbook.Sheets(\"QuestionMap\") ' A:Q_ID, B:QLabelInWord, C:ExcelColHeader\n    ' Set wsAnswers = ThisWorkbook.Sheets(\"SurveyAnswers\")\n    ' ' Dynamic headers for wsAnswers based on wsMap Col C\n    ' wsAnswers.Cells.ClearContents\n    ' wsAnswers.Cells(1, 1).Value = \"源文件名\"\n    ' For mapRow = 2 To wsMap.Cells(Rows.Count, \"C\").End(xlUp).Row\n    '    wsAnswers.Cells(1, mapRow).Value = wsMap.Cells(mapRow, \"C\").Value\n    ' Next mapRow\n    ' nextAnswerRow = 2\n\n    ' ' User selects folder...\n    ' ' ... (FileDialog code) ...\n    ' ' ... (Initialize Word App, FSO) ...\n\n    ' mapLastRow = wsMap.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    ' For Each fileItem In fso.GetFolder(folderPath).Files\n    '   If (LCase(fso.GetExtensionName(fileItem.Name)) = \"docx\" Or _\n    '       LCase(fso.GetExtensionName(fileItem.Name)) = \"doc\") And Left(fileItem.Name, 2) <> \"~$\" Then\n    '     Set wdDoc = wdApp.Documents.Open(fileItem.Path, ReadOnly:=True, Visible:=False)\n    '     wsAnswers.Cells(nextAnswerRow, 1).Value = fileItem.Name\n    '\n    '     For mapRow = 2 To mapLastRow\n    '       qLabel = Trim(CStr(wsMap.Cells(mapRow, \"B\").Value))\n    '       xlColHeader = Trim(CStr(wsMap.Cells(mapRow, \"C\").Value))\n    '       answerText = \"\"\n    '\n    '       ' Find qLabel in Word doc and extract answer (very simplified)\n    '       Dim para As Object ' Word.Paragraph\n    '       Dim found As Boolean: found = False\n    '       For Each para In wdDoc.Paragraphs\n    '         If InStr(1, para.Range.Text, qLabel, vbTextCompare) > 0 Then\n    '           ' Attempt to get text after the label in the same paragraph or next non-empty paragraph\n    '           Dim tempText As String\n    '           tempText = Trim(Mid(para.Range.Text, InStr(1, para.Range.Text, qLabel, vbTextCompare) + Len(qLabel)))\n    '           If tempText <> \"\" Then\n    '               answerText = tempText\n    '           ElseIf Not para.Next Is Nothing Then\n    '               answerText = Trim(para.Next.Range.Text) ' Get next paragraph\n    '           End If\n    '           ' Remove potential question number from answer if label was just number\n    '           If IsNumeric(Left(qLabel,1)) And IsNumeric(Left(answerText,1)) And Left(answerText, InStr(answerText,\" \")-1) Like \"#*.\" Then\n    '               answerText = Trim(Mid(answerText, InStr(answerText, \" \") + 1))\n    '           End If\n    '           found = True\n    '           Exit For\n    '         End If\n    '       Next para\n    '       If Not found Then answerText = \"[未找到問題標籤]\"\n    '\n    '       ' Find column in wsAnswers by header name\n    '       Dim ansCol As Long: ansCol = 0\n    '       On Error Resume Next\n    '       ansCol = Application.Match(xlColHeader, wsAnswers.Rows(1), 0)\n    '       On Error GoTo 0\n    '       If ansCol > 0 Then wsAnswers.Cells(nextAnswerRow, ansCol).Value = Left(answerText, 255)\n    '     Next mapRow\n    '     nextAnswerRow = nextAnswerRow + 1\n    '     wdDoc.Close False\n    '   End If\n    ' Next fileItem\n    ' wsAnswers.Columns.AutoFit\n    ' MsgBox \"調研問卷答案提取完成。\"\n    ' ' ... Clean up objects ...\nEnd Sub", "explanation": "此概念性腳本讓用戶選擇一個包含Word問卷的資料夾。它使用一個“QuestionMap”Excel表來定義如何在Word中查找問題標籤以及答案應寫入Excel的哪一列。對於每個Word文檔，它會遍歷QuestionMap中的每個問題，在Word中查找該問題的標籤，然後嘗試提取緊隨其後的文本作為答案。提取的答案和文件名會記錄到“SurveyAnswers”Excel表中。**注意：** 實際的答案提取邏輯會高度依賴於Word問卷的格式（例如，答案是在同一行、下一行、表格中，還是多行文本），因此示例中的提取方法非常簡化，可能需要大幅調整。"}
    ],
    "keywords": ["vba extract from word survey to excel", "parse word questionnaire vba", "word form data extraction", "automate survey analysis excel", "從Word問卷提取答案", "VBA解析Word表單", "自動化調研數據收集"]
},
{
    "name": "從多個Word文檔中按特定樣式提取內容並生成Excel報告",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: A set of Word documents (e.g., research papers, legal briefs, project proposals) consistently use specific paragraph styles to denote important sections (e.g., 'Executive Summary', 'Key Findings', 'Recommendations', 'Conclusion'). VBA processes a folder of these documents, extracts the text from all paragraphs formatted with these specific styles, and consolidates this information into an Excel sheet where each row represents a document and columns correspond to the content of each targeted style.",
    "description": "此工具用於從一批使用特定段落樣式來標記重要部分的Word文檔中提取內容。1. **定義目標樣式名稱**：在VBA代碼中或一個Excel配置表中列出需要提取內容的Word段落樣式名稱 (例如，`Array(\"Executive Summary\", \"Key Findings\", \"Conclusion\")`)。2. **用戶選擇Word文檔文件夾**：提示用戶選擇包含待處理Word文檔的資料夾。3. **Excel彙總表準備**：準備一個Excel工作表（“StyledContentExtract”），第一列為“源文件名”，後續列的表頭為預定義的目標樣式名稱。4. **VBA遍歷與提取邏輯**：a. 遍歷用戶選定文件夾中的每個Word文檔。b. 對於每個Word文檔：  i. 以唯讀方式打開文檔。  ii. 為每個預定義的目標樣式名稱，遍歷文檔中的所有段落 (`wdDoc.Paragraphs`)。  iii. 檢查每個段落的樣式 (`para.Style`) 是否與當前目標樣式名稱匹配。  iv. 如果樣式匹配，則提取該段落的完整文本 (`para.Range.Text`)。如果一個文檔中可能有多個段落應用了同一目標樣式（例如，多個“Key Finding”段落），則可以將它們的文本串聯起來，或為每個匹配的段落創建單獨的記錄（後者會使Excel結構更複雜，但可能更精確）。此示例假設串聯。  v. 將從當前Word文檔提取到的每個目標樣式的內容（與文件名一起）寫入到Excel“StyledContentExtract”表的一行中，每個樣式對應一列。  vi. 關閉Word文檔。5. **完成提示**：所有文件處理完畢後通知用戶。這個方法對於從結構化程度較高、依賴樣式進行內容組織的文檔中快速獲取特定章節的摘要信息非常有效。",
    "parameters": [
        {"name": "Target Paragraph Style Names", "description": "一個包含要在Word文檔中搜索的段落樣式名稱的列表。"},
        {"name": "Folder of Word Documents (User Selected)", "description": "包含待處理Word文檔的資料夾。"},
        {"name": "Excel Output Sheet for Styled Content", "description": "存放從各文檔提取的特定樣式內容的彙總工作表。"},
        {"name": "Logic for Handling Multiple Paragraphs with Same Style", "description": "如果一個文檔中有多個段落應用了同一目標樣式，是將它們的文本合併還是在Excel中創建多行。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub ExtractStyledContentFromWordDocs()\n    Dim wdApp As Object, wdDoc As Object, xlSheet As Worksheet\n    Dim fso As Object, sourceFolder As Object, fileItem As Object\n    Dim folderPath As String, nextRowExcel As Long\n    Dim targetStyles As Variant, styleName As Variant, para As Object ' Word.Paragraph\n    Dim extractedTextForStyle As String, colIndex As Long\n\n    ' Set xlSheet = ThisWorkbook.Sheets(\"StyledContentExtract\")\n    ' targetStyles = Array(\"Executive Summary\", \"Key Findings\", \"Conclusion\") ' **根據實際樣式名稱調整**\n    ' ' Setup Excel headers: FileName, Style1Name, Style2Name, ...\n    ' wsHeaders = Array(\"文件名\")\n    ' ReDim Preserve wsHeaders(LBound(wsHeaders) To UBound(targetStyles) + 1)\n    ' For i = LBound(targetStyles) To UBound(targetStyles)\n    '    wsHeaders(i + 1) = targetStyles(i)\n    ' Next i\n    ' xlSheet.Cells.ClearContents\n    ' xlSheet.Rows(1).Resize(1, UBound(wsHeaders) + 1).Value = wsHeaders\n    ' nextRowExcel = 2\n\n    ' ' User selects folder...\n    ' ' ... (FileDialog code) ...\n    ' ' ... (Initialize Word App, FSO) ...\n\n    ' For Each fileItem In fso.GetFolder(folderPath).Files\n    '   If (LCase(fso.GetExtensionName(fileItem.Name)) = \"docx\" Or _\n    '       LCase(fso.GetExtensionName(fileItem.Name)) = \"doc\") And Left(fileItem.Name, 2) <> \"~$\" Then\n    '     Set wdDoc = wdApp.Documents.Open(fileItem.Path, ReadOnly:=True, Visible:=False)\n    '     xlSheet.Cells(nextRowExcel, 1).Value = fileItem.Name\n    '     colIndex = 2 ' Start writing styled content from Excel column B\n    '\n    '     For Each styleName In targetStyles\n    '       extractedTextForStyle = \"\"\n    '       For Each para In wdDoc.Paragraphs\n    '         Dim paraStyleName As String\n    '         On Error Resume Next ' Style object might not be simple string\n    '         paraStyleName = para.Style.NameLocal ' Or para.Style (can be an object or string)\n    '         If Err.Number <> 0 Then paraStyleName = CStr(para.Style) ' Fallback\n    '         Err.Clear\n    '         On Error GoTo 0\n    '\n    '         If Trim(paraStyleName) = Trim(CStr(styleName)) Then\n    '           extractedTextForStyle = extractedTextForStyle & Trim(para.Range.Text) & vbCrLf ' Append text\n    '         End If\n    '       Next para\n    '       xlSheet.Cells(nextRowExcel, colIndex).Value = Left(Trim(extractedTextForStyle), 32767) ' Excel cell limit\n    '       colIndex = colIndex + 1\n    '     Next styleName\n    '     nextRowExcel = nextRowExcel + 1\n    '     wdDoc.Close False\n    '   End If\n    ' Next fileItem\n    ' xlSheet.Columns.AutoFit\n    ' MsgBox \"按樣式提取Word文檔內容完成。\"\n    ' ' ... Clean up objects ...\nEnd Sub", "explanation": "此概念性腳本讓用戶選擇一個包含Word文檔的資料夾。它使用一個預定義的Word段落樣式名稱數組 (`targetStyles`)。對於每個Word文檔，它會遍歷所有段落，檢查段落的樣式名稱是否與`targetStyles`中的任何一個匹配。如果匹配，則提取該段落的文本。所有匹配同一目標樣式的段落文本會被串聯起來（用換行符分隔），然後寫入到Excel彙總表的對應列中。Excel表的表頭根據文件名和`targetStyles`數組動態生成。"}
    ],
    "keywords": ["vba extract word content by style", "word to excel paragraph style parsing", "automate data extraction word styles", "structured document analysis vba", "按Word樣式提取內容", "VBA解析段落樣式到Excel"]
},
{
    "name": "整合多個Word文檔的特定表格數據到一個Excel主表",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Several Word documents, each for a different client or period, contain a consistently structured table (e.g., 'Financial Summary Table' always being the 2nd table in the document, or a table immediately following a specific heading like 'Key Performance Indicators'). VBA needs to loop through a user-selected folder of these Word documents, find this specific table in each, extract all rows (or specific rows/columns) from it, and append this data into a single master Excel sheet. Each row in Excel should also identify the source Word document.",
    "description": "此工具用於從一批Word文檔中找到特定的表格，並將其所有（或部分）數據彙整到一個Excel主表中。1. **用戶選擇Word文檔文件夾**：提示用戶選擇存放Word文檔的資料夾。2. **定義表格定位邏輯**：確定如何在每個Word文檔中可靠地找到目標表格。方法可以是：a. **按索引**：例如，總是文檔中的第2個表格 (`wdDoc.Tables(2)`)。b. **按標題或鄰近文本**：查找一個特定的標題文本，然後選取緊隨其後的表格。c. **按表格屬性**：如果表格有唯一的列數或行數模式，或特定的第一行標題內容。3. **Excel主表準備**：準備一個Excel工作表（“ConsolidatedTableData”），其列結構應能容納從Word表格中提取的數據，外加一列用於記錄“源文件名”。4. **VBA遍歷與提取邏輯**：a. 遍歷用戶選定文件夾中的每個Word文檔。b. 對於每個Word文檔：  i. 以唯讀方式打開文檔。  ii. 使用預定義的邏輯定位目標表格。  iii. 如果找到目標表格：    - 遍歷表格的每一行 (`wdRow In targetTable.Rows`)，可以選擇跳過表頭行。    - 對於每一行，遍歷其所有儲存格 (`wdCell In wdRow.Cells`) 或只遍歷指定的列。    - 提取每個目標儲存格的文本 (`Trim(wdCell.Range.Text)` 並清理尾部儲存格標記)。    - 將源文件名和從當前Word表格行提取的所有數據點作為新的一行寫入到Excel的“ConsolidatedTableData”表中。  iv. 關閉Word文檔。5. **完成提示**：所有文件處理完畢後通知用戶。這個方法適用於從多個包含相同結構表格的文檔中進行數據彙總和比較。",
    "parameters": [
        {"name": "Folder of Word Documents (User Selected)", "description": "包含源Word文檔的資料夾。"},
        {"name": "Logic for Identifying Target Table in Word", "description": "如何在每個Word文檔中定位到要提取數據的那個特定表格的規則。"},
        {"name": "Rows/Columns to Extract from Table (Optional)", "description": "是提取整個表格，還是只提取特定的行或列。"},
        {"name": "Excel Master Sheet for Consolidated Data", "description": "存放從所有Word表格中提取的數據的彙總工作表。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet ---\nSub ConsolidateSpecificWordTablesToExcel()\n    Dim wdApp As Object, wdDoc As Object, xlSheet As Worksheet\n    Dim fso As Object, sourceFolder As Object, fileItem As Object\n    Dim folderPath As String, nextRowExcel As Long\n    Dim targetTable As Object ' Word.Table\n    Dim wdRow As Object, wdCell As Object ' Word.Row, Word.Cell\n    Dim r As Long, c As Long, colCount As Long\n\n    ' Set xlSheet = ThisWorkbook.Sheets(\"ConsolidatedTableData\")\n    ' ' Clear sheet and set headers (first col for FileName, subsequent for table data)\n    ' xlSheet.Cells.ClearContents\n    ' xlSheet.Cells(1, 1).Value = \"源文件名\"\n    ' ' Headers for table data will be set based on first processed table or predefined\n    ' nextRowExcel = 2\n    ' Const TARGET_TABLE_IDENTIFIER_HEADING As String = \"關鍵績效指標表\" ' CHINESE - Example heading before table\n\n    ' ' User selects folder...\n    ' ' ... (FileDialog code & Initialize Word App, FSO) ...\n\n    ' For Each fileItem In fso.GetFolder(folderPath).Files\n    '   If (LCase(fso.GetExtensionName(fileItem.Name)) = \"docx\" Or _\n    '       LCase(fso.GetExtensionName(fileItem.Name)) = \"doc\") And Left(fileItem.Name, 2) <> \"~$\" Then\n    '     Set wdDoc = wdApp.Documents.Open(fileItem.Path, ReadOnly:=True, Visible:=False)\n    '     Set targetTable = Nothing ' Reset for each document\n\n    '     ' --- Find the target table (example: table after a specific heading) ---\n    '     Dim para As Object ' Word.Paragraph\n    '     For Each para In wdDoc.Paragraphs\n    '       If InStr(1, para.Range.Text, TARGET_TABLE_IDENTIFIER_HEADING, vbTextCompare) > 0 Then\n    '         If para.Next.Range.Tables.Count > 0 Then ' Check if next paragraph's range contains a table\n    '           Set targetTable = para.Next.Range.Tables(1)\n    '           Exit For\n    '         End If\n    '       End If\n    '     Next para\n    '     ' Alternative: If wdDoc.Tables.Count >= 2 Then Set targetTable = wdDoc.Tables(2) ' e.g., always 2nd table\n\n    '     If Not targetTable Is Nothing Then\n    '       ' Set Excel headers from first row of first processed table (if not already set)\n    '       If xlSheet.Cells(1, 2).Value = \"\" And targetTable.Rows.Count > 0 Then\n    '         For c = 1 To targetTable.Rows(1).Cells.Count\n    '           xlSheet.Cells(1, c + 1).Value = CleanWordCellText(targetTable.Cell(1, c).Range.Text)\n    '         Next c\n    '         xlSheet.Rows(1).Font.Bold = True\n    '       End If\n\n    '       ' Extract data from table (skipping header row of Word table, assuming row 1 is header)\n    '       For r = 2 To targetTable.Rows.Count\n    '         xlSheet.Cells(nextRowExcel, 1).Value = fileItem.Name\n    '         For c = 1 To targetTable.Rows(r).Cells.Count\n    '           If (nextRowExcel = 2 And c > xlSheet.Cells(1, Columns.Count).End(xlToLeft).Column -1 ) Then Exit For ' Dont write more cols than headers defined\n    '           xlSheet.Cells(nextRowExcel, c + 1).Value = CleanWordCellText(targetTable.Cell(r, c).Range.Text)\n    '         Next c\n    '         nextRowExcel = nextRowExcel + 1\n    '       Next r\n    '     Else\n    '       Debug.Print \"在文件 '\" & fileItem.Name & \"' 中未找到目標表格。\"\n    '     End If\n    '     wdDoc.Close False\n    '   End If\n    ' Next fileItem\n    ' xlSheet.Columns.AutoFit\n    ' MsgBox \"多個Word文檔中的表格數據已彙整到Excel。\"\n    ' ' ... Clean up objects ...\nEnd Sub\n\nFunction CleanWordCellText(rawTxt As String) As String\n    ' Helper to remove cell markers and trim\n    ' Dim temp As String: temp = Trim(rawTxt)\n    ' If Len(temp) > 0 Then\n    '   Do While Right(temp, 1) = Chr(7) Or Right(temp, 1) = Chr(13): temp = Left(temp, Len(temp) - 1): If Len(temp) = 0 Then Exit Do: Loop\n    ' End If\n    ' CleanWordCellText = temp\nEnd Function", "explanation": "此概念性腳本讓用戶選擇一個資料夾。它會遍歷該資料夾中的Word文檔。對於每個文檔，它嘗試定位一個特定的目標表格（此範例中是通過查找表格前是否有特定標題文本 `TARGET_TABLE_IDENTIFIER_HEADING`）。如果找到表格，它會遍歷表格的行（跳過第一行表頭），並將每行的儲存格數據提取到Excel的“ConsolidatedTableData”工作表中。Excel工作表的表頭可以根據第一個處理的Word表格的表頭動態生成，或預先定義。`CleanWordCellText` 輔助函數用於清理從Word儲存格提取的文本。"}
    ],
    "keywords": ["vba consolidate word tables to excel", "extract multiple word tables", "word table data aggregation excel", "parse specific table from word", "從多個Word表格提取數據", "彙整Word表格到Excel"]
},
{
    "name": "Range.AddressLocal",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AddressLocal([RowAbsolute], [ColumnAbsolute], [ReferenceStyle], [External], [RelativeTo])",
    "description": "以使用者語言傳回代表儲存格範圍參照的字串。",
    "parameters": [
        {"name": "RowAbsolute", "description": "可選。True 表示傳回絕對列參照。預設為 True。"},
        {"name": "ColumnAbsolute", "description": "可選。True 表示傳回絕對欄參照。預設為 True。"},
        {"name": "ReferenceStyle", "description": "可選。XlReferenceStyle 常數 (xlA1 或 xlR1C1)。預設為 xlA1。"},
        {"name": "External", "description": "可選。True 表示傳回包含工作簿和工作表名稱的外部參照。預設為 False。"},
        {"name": "RelativeTo", "description": "可選。如果 ReferenceStyle 是 xlA1，則此引數是一個 Range 物件，指定傳回相對位址的左上角儲存格。"}
    ],
    "examples": [
        {"code": "MsgBox Range(\"A1\").AddressLocal ' 在中文Excel中可能傳回 \"$A$1\" (取決於設定)", "explanation": "取得儲存格 A1 的本地化絕對位址。"}
    ],
    "keywords": ["位址本地化", "儲存格參照", "excel", "cell address local", "localized reference"]
},
{
    "name": "Range.AdvancedFilter",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AdvancedFilter(Action As XlFilterAction, [CriteriaRange], [CopyToRange], [Unique As Boolean = False])",
    "description": "根據準則範圍篩選清單。可以將結果複製到其他位置或就地篩選。",
    "parameters": [
        {"name": "Action", "description": "必需。XlFilterAction 常數 (xlFilterInPlace 或 xlFilterCopy)。"},
        {"name": "CriteriaRange", "description": "可選。包含篩選準則的範圍。"},
        {"name": "CopyToRange", "description": "可選。如果 Action 是 xlFilterCopy，則為複製篩選結果的目標範圍。"},
        {"name": "Unique", "description": "可選。True 表示僅篩選唯一記錄。"}
    ],
    "examples": [
        {"code": "' 假設 A1:D100 是資料範圍，F1:F2 是準則範圍，結果複製到 H1\n' Range(\"A1:D100\").AdvancedFilter Action:=xlFilterCopy, CriteriaRange:=Range(\"F1:F2\"), CopyToRange:=Range(\"H1\"), Unique:=False", "explanation": "對 A1:D100 範圍執行進階篩選，使用 F1:F2 的準則，並將結果複製到 H1 開始的區域。"}
    ],
    "keywords": ["進階篩選", "複雜篩選", "excel", "advanced filter", "criteria filter"]
},
{
    "name": "Worksheet.Cells.SpecialCells",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Cells.SpecialCells(Type As XlCellType, [Value])",
    "description": "傳回一個 Range 物件，代表工作表上所有符合指定類型和值的儲存格。與 Range.SpecialCells 類似，但通常應用於整個工作表的儲存格。",
    "parameters": [
        {"name": "Type", "description": "必需。XlCellType 常數。"},
        {"name": "Value", "description": "可選。如果 Type 是 xlCellTypeConstants 或 xlCellTypeFormulas，則此引數用於確定結果中包含哪些類型的儲存格。"}
    ],
    "examples": [
        {"code": "Dim constantsOnly As Range\nOn Error Resume Next\nSet constantsOnly = ActiveSheet.Cells.SpecialCells(xlCellTypeConstants)\nOn Error GoTo 0\nIf Not constantsOnly Is Nothing Then constantsOnly.Interior.Color = vbYellow", "explanation": "高亮顯示活動工作表上所有包含常數的儲存格。"}
    ],
    "keywords": ["全表特殊儲存格", "篩選工作表儲存格", "excel", "worksheet special cells", "all cells filter"]
},
{
    "name": "Range.ShowDetail",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ShowDetail [= True | False]",
    "description": "如果範圍是分級顯示 (大綱) 中可展開或摺疊的摘要列或摘要欄的左上角儲存格，則此屬性設定或傳回該摘要的詳細資料是否顯示。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示詳細資料 (展開)，False 表示隱藏詳細資料 (摺疊)。"}],
    "examples": [
        {"code": "' 假設第5列是一個已分組/大綱的摘要列\n' If Rows(5).ShowDetail = False Then Rows(5).ShowDetail = True ' 展開第5列的詳細資料", "explanation": "如果第5列的詳細資料是摺疊的，則將其展開。"}
    ],
    "keywords": ["顯示詳細資料", "展開大綱", "摺疊大綱", "excel", "show detail", "outline expand", "outline collapse"]
},
{
    "name": "Workbook.Names.Add",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.Names.Add(Name As String, RefersTo As String, [Visible As Boolean = True], [MacroType], [ShortcutKey], [Category], [NameLocal], [RefersToLocal], [CategoryLocal], [RefersToR1C1], [RefersToR1C1Local])",
    "description": "在活頁簿中定義一個新的名稱 (已命名範圍或常數)。",
    "parameters": [
        {"name": "Name", "description": "必需。新名稱的文字。"},
        {"name": "RefersTo", "description": "必需。名稱所參照的公式或值 (A1 樣式或 R1C1 樣式，取決於 RefersToR1C1/Local 引數)。"}
    ],
    "examples": [
        {"code": "ThisWorkbook.Names.Add Name:=\"SalesTaxRate\", RefersTo:=\"=0.05\"\nMsgBox \"SalesTaxRate 的值: \" & [SalesTaxRate]", "explanation": "定義一個名為 \"SalesTaxRate\" 的活頁簿級別常數，其值為 0.05。"},
        {"code": "ActiveSheet.Names.Add Name:=\"MyDataArea\", RefersTo:=\"=Sheet1!$A$1:$C$10\"\nRange(\"MyDataArea\").Font.Bold = True", "explanation": "定義一個名為 \"MyDataArea\" 的工作表級別已命名範圍，參照 Sheet1 上的 A1:C10。"}
    ],
    "keywords": ["新增名稱", "已命名範圍", "定義名稱", "excel", "add named range", "define name", "named constant"]
},
{
    "name": "Worksheet.Evaluate (Short Bracket Form)",
    "category": "Excel 核心操作",
    "syntax": "result = [SheetName!Expression]",
    "description": "Worksheet.Evaluate 方法的簡寫形式，用於在特定工作表的上下文中計算運算式。",
    "parameters": [{"name": "SheetName!Expression", "description": "工作表名稱後接驚嘆號，再加上要計算的運算式（如儲存格參照、已命名範圍或公式）。"}],
    "examples": [
        {"code": "Worksheets(\"Sheet1\").Range(\"A1\").Value = 100\nDim val As Variant\nval = [Sheet1!A1*2]\nMsgBox \"Sheet1!A1 * 2 = \" & val", "explanation": "計算 Sheet1 上 A1 儲存格的值乘以 2。"}
    ],
    "keywords": ["工作表計算", "簡寫evaluate", "excel", "worksheet evaluate shortcut", "sheet specific calculation"]
},
// Word Document Processing
{
    "name": "Document.Paragraphs.First / .Last (Word)",
    "category": "Word 文件處理",
    "syntax": "Set firstPara = documentObject.Paragraphs.First\nSet lastPara = documentObject.Paragraphs.Last",
    "description": "Paragraphs 集合的 First 和 Last 屬性分別傳回文件中的第一個和最後一個段落物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Paragraphs.Count > 0 Then\n'   wdDoc.Paragraphs.First.Range.Font.Size = 16\n'   wdDoc.Paragraphs.Last.Range.InsertAfter vbCrLf & \"--- 文件結束 ---\"\n'   MsgBox \"已修改第一個和最後一個段落。\"\n' End If", "explanation": "將文件第一個段落的字型大小設為16，並在最後一個段落後新增文字。"}
    ],
    "keywords": ["word first paragraph", "word last paragraph", "document start end paragraph", "第一個段落", "最後一個段落"]
},
{
    "name": "Range.Characters (Word)",
    "category": "Word 文件處理",
    "syntax": "Set charsCollection = rangeObject.Characters",
    "description": "傳回一個 Characters 集合，代表範圍中的字元。可以逐字元存取和格式化。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdRange As Object ' Word.Range\nDim firstChar As Object ' Word.Range (representing a character)\n' Set wdRange = ActiveDocument.Paragraphs(1).Range\n' If wdRange.Characters.Count > 0 Then\n'   Set firstChar = wdRange.Characters(1)\n'   firstChar.Font.ColorIndex = wdRed ' Make the first character red\n'   MsgBox \"第一個段落的第一個字元已設為紅色。\"\n' End If", "explanation": "獲取第一個段落的範圍，然後將其第一個字元的顏色設為紅色。"}
    ],
    "keywords": ["word characters collection", "format individual characters", "字元集合", "格式化單個字元"]
},
{
    "name": "Document.Sections (Word)",
    "category": "Word 文件處理",
    "syntax": "Set sectionsColl = documentObject.Sections",
    "description": "傳回一個 Sections 集合，代表指定文件中的所有節。節是用於設定不同頁面格式 (如頁首頁尾、欄數、頁面方向) 的區域。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim sec As Object ' Word.Section\n' Set wdDoc = ActiveDocument\n' MsgBox \"文件共有 \" & wdDoc.Sections.Count & \" 個節。\"\n' For Each sec In wdDoc.Sections\n'   Debug.Print \"節 \" & sec.Index & \" 的頁面方向: \" & sec.PageSetup.Orientation\n'   ' sec.PageSetup.Orientation = wdOrientLandscape ' Example: Change to landscape\n' Next sec", "explanation": "顯示文件中的節數量，並遍歷每個節以列印其頁面方向。"}
    ],
    "keywords": ["word sections", "document sections", "page formatting sections", "節集合", "頁面格式節"]
},
// Outlook Mail & Item Management
{
    "name": "MailItem.SenderEmailAddress (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "emailAddr = mailItemObject.SenderEmailAddress",
    "description": "傳回一個字串，表示 Outlook 郵件項目的寄件者電子郵件地址。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem, assume it points to a received email\n' ' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   MsgBox \"寄件者郵箱: \" & olMail.SenderEmailAddress\n' End If", "explanation": "獲取所選郵件的寄件者實際電子郵件地址。"}
    ],
    "keywords": ["outlook sender email", "get sender address", "寄件者郵箱地址"]
},
{
    "name": "MailItem.Recipients (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set recipientsColl = mailItemObject.Recipients",
    "description": "傳回一個 Recipients 集合，代表 Outlook 項目的所有收件者 (包括 To, CC, BCC)。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\nDim recip As Object ' Outlook.Recipient\n' Set olMail = Application.CreateItem(0) ' olMailItem\n' olMail.Recipients.Add \"user1@example.com\"\n' olMail.Recipients.Add \"user2@example.com\" \n' olMail.Recipients.Item(2).Type = 2 ' olCC (2)\n' olMail.Recipients.ResolveAll\n' For Each recip In olMail.Recipients\n'   Debug.Print recip.Name & \" (\" & recip.Address & \") - Type: \" & recip.Type\n' Next recip", "explanation": "建立新郵件，新增兩個收件者，將第二個設為CC，然後解析並遍歷所有收件者，列印其名稱、地址和類型。"}
    ],
    "keywords": ["outlook recipients", "email recipients collection", "to cc bcc", "收件者集合"]
},
// PowerPoint Presentation Creation
{
    "name": "Slide.Shapes.AddTextbox (PowerPoint - Details)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set shp = slideObject.Shapes.AddTextbox(Orientation, Left, Top, Width, Height)",
    "description": "在投影片上建立一個文字方塊。Orientation 指定文字方向 (例如 msoTextOrientationHorizontal)。Left, Top, Width, Height 以點為單位定義文字方塊的位置和大小。",
    "parameters": [
        {"name": "Orientation", "description": "MsoTextOrientation 常數。"},
        {"name": "Left, Top, Width, Height", "description": "以點為單位的 Single 值。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim newTextbox As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set newTextbox = pptSlide.Shapes.AddTextbox(msoTextOrientationHorizontal, 72, 72, 288, 50) ' 1 inch from top/left, 4in wide, 0.7in high\n' newTextbox.TextFrame.TextRange.Text = \"這是文字方塊中的內容。\"\n' newTextbox.TextFrame.TextRange.Font.Color.RGB = RGB(0, 0, 128)", "explanation": "在第一張投影片的指定位置新增一個水平文字方塊，並設定其文字內容和字型顏色。"}
    ],
    "keywords": ["powerpoint add textbox", "insert text box", "ppt shape text", "新增文字方塊"]
},
// File & Folder Management
{
    "name": "FileSystemObject.GetStandardStream (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "Set ts = fso.GetStandardStream(StandardStreamType As StandardStreamTypes, [Unicode As Boolean = False])",
    "description": "傳回一個 TextStream 物件，可用於讀取標準輸入 (StdIn)、寫入標準輸出 (StdOut) 或標準錯誤 (StdErr)。主要用於命令列腳本環境，在VBA中直接應用較少，除非與Shell命令結合使用並重定向流。",
    "parameters": [
        {"name": "StandardStreamType", "description": "StdIn (0), StdOut (1), StdErr (2)。"},
        {"name": "Unicode", "description": "可選。True 表示以 Unicode 處理流。"}
    ],
    "examples": [
        {"code": "' Dim fso As Object, stdOut As Object\n' Set fso = CreateObject(\"Scripting.FileSystemObject\")\n' ' This is more relevant when running cscript.exe with WSH\n' ' In VBA for Office, direct use of StdOut is not common for console output.\n' ' Typically, Debug.Print or a UserForm/Sheet is used for output.\n' ' Set stdOut = fso.GetStandardStream(1)\n' ' stdOut.WriteLine \"This would go to StdOut if script run by cscript.\"", "explanation": "獲取標準輸出流。在VBA Office應用中，此功能直接用途有限，更多用於 WSH/CScript 環境。"}
    ],
    "keywords": ["fso standard stream", "stdin", "stdout", "stderr", "console output script", "標準流"]
},
// String & Text
{
    "name": "Filter Function (String Array)",
    "category": "字串與文本操作",
    "syntax": "resultArray = Filter(SourceArray, Match As String, [Include As Boolean = True], [Compare As VbCompareMethod = vbBinaryCompare])",
    "description": "從一個一維字串陣列中篩選出包含 (或不包含) 特定子字串的元素，並傳回一個新的字串陣列。",
    "parameters": [
        {"name": "SourceArray", "description": "必需。要篩選的一維字串陣列。"},
        {"name": "Match", "description": "必需。要在陣列元素中搜尋的子字串。"},
        {"name": "Include", "description": "可選。True (預設) 表示傳回包含 Match 的元素；False 表示傳回不包含 Match 的元素。"},
        {"name": "Compare", "description": "可選。vbBinaryCompare (預設，區分大小寫) 或 vbTextCompare (不區分大小寫)。"}
    ],
    "examples": [
        {"code": "Dim arrFruits() As String: arrFruits = Split(\"Apple,Banana,Orange,Apricot,Grape\", \",\")\nDim filtered1 As Variant, filtered2 As Variant\nfiltered1 = Filter(arrFruits, \"Ap\", True, vbTextCompare)\n' filtered1 will contain \"Apple\", \"Apricot\", \"Grape\"\nDebug.Print \"包含 'Ap': \" & Join(filtered1, \", \")\n\nfiltered2 = Filter(arrFruits, \"an\", False, vbTextCompare)\n' filtered2 will contain \"Apple\", \"Apricot\", \"Grape\" (excludes Banana, Orange)\nDebug.Print \"不包含 'an': \" & Join(filtered2, \", \")", "explanation": "第一個範例篩選出陣列中包含 \"Ap\" (不區分大小寫) 的水果。第二個範例篩選出不包含 \"an\" (不區分大小寫) 的水果。"}
    ],
    "keywords": ["filter string array", "search in array", "array subset", "篩選字串陣列", "陣列搜尋"]
},
// Math, Date & Time
{
    "name": "DateAdd Function (More Intervals)",
    "category": "數學、日期與時間",
    "syntax": "DateAdd(interval, number, date)",
    "description": "DateAdd 函數的 interval 引數可以使用多種間隔字串： \"yyyy\" (年), \"q\" (季), \"m\" (月), \"y\" (年中日), \"d\" (日), \"w\" (周中日 - 星期幾), \"ww\" (週), \"h\" (時), \"n\" (分), \"s\" (秒)。",
    "parameters": [
        {"name": "interval", "description": "必需。時間間隔字串。"},
        {"name": "number", "description": "必需。要增加的間隔數。"},
        {"name": "date", "description": "必需。基礎日期。"}
    ],
    "examples": [
        {"code": "Dim dt As Date: dt = #2023-10-26 14:30:00#\nDebug.Print \"加2季: \" & DateAdd(\"q\", 2, dt)\nDebug.Print \"加7天: \" & DateAdd(\"d\", 7, dt)\nDebug.Print \"加3週: \" & DateAdd(\"ww\", 3, dt)\nDebug.Print \"減5小時: \" & DateAdd(\"h\", -5, dt)\nDebug.Print \"加90分鐘: \" & DateAdd(\"n\", 90, dt)", "explanation": "演示使用 DateAdd 函數進行不同時間間隔的日期計算，包括季度、天、週、小時和分鐘。"}
    ],
    "keywords": ["dateadd intervals", "date calculation", "add time", "日期增加間隔", "時間計算"]
},
// Data Types, Conversion & Validation
{
    "name": "CBool Function (Details)",
    "category": "資料類型、轉換與驗證",
    "syntax": "CBool(expression)",
    "description": "將運算式轉換為布林 (Boolean) 資料類型。如果運算式為零 (0)，則 CBool 傳回 False；否則傳回 True。對於字串，\"True\" (不區分大小寫) 轉為 True，\"False\" 轉為 False，其他可轉為數值的字串按其數值轉換。",
    "parameters": [{"name": "expression", "description": "必需。任何有效的字串或數值運算式。"}],
    "examples": [
        {"code": "Debug.Print CBool(0)       ' False\nDebug.Print CBool(100)     ' True\nDebug.Print CBool(-5)      ' True\nDebug.Print CBool(\"True\")  ' True\nDebug.Print CBool(\"FALSE\") ' False\nDebug.Print CBool(\"0\")     ' False (string \"0\" converts to numeric 0)\nDebug.Print CBool(\"123\")   ' True (string \"123\" converts to numeric 123)", "explanation": "演示 CBool 如何將不同的數值和字串轉換為布林值。"}
    ],
    "keywords": ["cbool conversion", "to boolean", "boolean cast", "轉換為布林值"]
},
// Program Flow
{
    "name": "AppActivate Statement",
    "category": "程式流程與結構控制",
    "syntax": "AppActivate title, [wait]",
    "description": "啟動一個應用程式視窗，使其成為前景焦點視窗。視窗標題必須完全匹配或部分匹配。",
    "parameters": [
        {"name": "title", "description": "必需。字串，指定要啟動的視窗標題，或由 Shell 函數傳回的應用程式任務 ID。"},
        {"name": "wait", "description": "可選。布林值。True 表示呼叫的應用程式在啟動目標應用程式前必須有焦點。False (預設) 表示即使呼叫應用程式沒有焦點，也會立即嘗試啟動。"}
    ],
    "examples": [
        {"code": "' Shell \"NOTEPAD.EXE\", vbNormalFocus\n' Application.Wait Now + TimeValue(\"00:00:01\") ' Give Notepad time to open\n' On Error Resume Next ' In case Notepad title is different or not found\n' AppActivate \"無標題 - 記事本\" ' For Chinese Windows Notepad, or use Task ID\n' If Err.Number <> 0 Then AppActivate \"Untitled - Notepad\" ' For English\n' On Error GoTo 0\n' SendKeys \"AppActivated!\", True", "explanation": "啟動記事本，然後嘗試使用 AppActivate 將其帶到前景。視窗標題可能因系統語言而異。"}
    ],
    "keywords": ["appactivate", "activate window", "bring to front", "focus window", "啟用視窗", "切換焦點"]
},
// Error Handling
{
    "name": "Err.Source Property",
    "category": "錯誤處理與調試",
    "syntax": "errSourceString = Err.Source",
    "description": "傳回或設定一個字串，表示最初產生錯誤的物件或應用程式的名稱。對於 VBA 錯誤，它通常是專案名稱加點再加模組名稱 (例如，Project1.Module1)。",
    "parameters": [],
    "examples": [
        {"code": "Sub TestErrorSource()\n  On Error GoTo HandleErr\n  Dim x As Integer: x = 1 / 0 ' Division by zero error\n  Exit Sub\nHandleErr:\n  MsgBox \"錯誤來源: \" & Err.Source & vbCrLf & _\n         \"錯誤號碼: \" & Err.Number & vbCrLf & _\n         \"錯誤描述: \" & Err.Description\nEnd Sub", "explanation": "在錯誤處理程序中，顯示 Err.Source 屬性，以指出錯誤發生的位置 (專案和模組)。"}
    ],
    "keywords": ["err source", "error object source", "vba error location", "錯誤來源", "錯誤位置"]
},
// --- 10 new basic commands above ---
// --- More Excel Core Operations ---
{
    "name": "Range.Activate",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Activate",
    "description": "啟動範圍中的單一儲存格。要選取儲存格範圍，請使用 Select 方法。指定的儲存格必須在活動工作表上。",
    "parameters": [],
    "examples": [
        {"code": "Worksheets(\"Sheet1\").Activate\nRange(\"C5\").Activate\nMsgBox \"儲存格 C5 已被啟用，目前選取的是 C5。\"", "explanation": "先啟用 Sheet1，然後啟用該工作表上的 C5 儲存格。ActiveCell 將會是 C5。"}
    ],
    "keywords": ["啟用儲存格", "焦點儲存格", "excel", "activate cell", "focus cell"]
},
{
    "name": "Range.Address (R1C1 Style)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Address(ReferenceStyle:=xlR1C1)",
    "description": "以 R1C1 參照樣式傳回代表儲存格範圍參照的字串。",
    "parameters": [
        {"name": "ReferenceStyle:=xlR1C1", "description": "指定傳回 R1C1 樣式。"}
    ],
    "examples": [
        {"code": "MsgBox Range(\"B3\").Address(ReferenceStyle:=xlR1C1) ' 傳回 \"R3C2\"", "explanation": "取得儲存格 B3 的 R1C1 樣式絕對位址。"},
        {"code": "MsgBox Range(\"A1:C2\").Address(RowAbsolute:=False, ColumnAbsolute:=False, ReferenceStyle:=xlR1C1) ' 傳回 \"R[1]C[1]:R[2]C[3]\" 如果是相對於某個位置", "explanation": "取得範圍 A1:C2 的 R1C1 樣式相對位址（如果相對於某個儲存格）。通常絕對位址更常見。"}
    ],
    "keywords": ["R1C1位址", "儲存格參照R1C1", "excel", "cell address r1c1", "r1c1 reference"]
},
{
    "name": "Worksheet.PrintPreview",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.PrintPreview([EnableChanges As Boolean = False])",
    "description": "顯示指定工作表的預覽列印。使用者可以從預覽中調整邊距、設定等，或直接列印。",
    "parameters": [
        {"name": "EnableChanges", "description": "可選。True 表示允許使用者在預覽列印視窗中進行頁面設定的變更。預設為 False。"}
    ],
    "examples": [
        {"code": "ActiveSheet.PrintPreview", "explanation": "顯示活動工作表的預覽列印視窗。"}
    ],
    "keywords": ["預覽列印", "列印預覽", "excel", "print preview", "view before print"]
},
{
    "name": "Workbook.PrintPreview",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.PrintPreview([EnableChanges As Boolean = False])",
    "description": "顯示指定活頁簿中所有工作表的預覽列印。",
    "parameters": [
        {"name": "EnableChanges", "description": "可選。True 表示允許使用者在預覽列印視窗中進行頁面設定的變更。"}
    ],
    "examples": [
        {"code": "ThisWorkbook.PrintPreview", "explanation": "顯示目前執行程式碼的整個活頁簿的預覽列印。"}
    ],
    "keywords": ["活頁簿預覽列印", "excel", "workbook print preview"]
},
{
    "name": "Application.Dialogs Property",
    "category": "Excel 核心操作",
    "syntax": "Set dlg = Application.Dialogs(XlBuiltInDialogConstant)\ndlg.Show",
    "description": "傳回一個 Dialog 物件，代表指定的 Excel 內建對話框。可以使用 Show 方法來顯示對話框。",
    "parameters": [
        {"name": "XlBuiltInDialogConstant", "description": "必需。一個 XlBuiltInDialog 常數，指定要顯示的對話框 (例如，xlDialogPrint, xlDialogOpen, xlDialogSaveAs)。"}
    ],
    "examples": [
        {"code": "Dim dlgOpen As Dialog\nSet dlgOpen = Application.Dialogs(xlDialogOpen)\nIf dlgOpen.Show Then ' Show returns True if OK is clicked\n  MsgBox \"使用者開啟了一個檔案 (或點擊了確定)。\"\nElse\n  MsgBox \"使用者取消了開啟對話框。\"\nEnd If", "explanation": "顯示 Excel 的標準「開啟舊檔」對話框，並根據使用者的操作 (確定或取消) 顯示訊息。"}
    ],
    "keywords": ["內建對話框", "Excel對話框", "excel", "built-in dialogs", "dialogs collection", "xlDialogOpen"]
},
// --- More Word ---
{
    "name": "Range.InsertParagraphAfter (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.InsertParagraphAfter",
    "description": "在指定的 Range 物件之後插入一個新的段落。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.Content.InsertParagraphAfter ' Insert a new paragraph at the end of the document\n' wdDoc.Paragraphs.Last.Range.Text = \"這是新插入的最後一個段落。\"", "explanation": "在文件的末尾新增一個新的段落，並設定其文字。"}
    ],
    "keywords": ["word insert paragraph", "add paragraph after", "新增段落後"]
},
{
    "name": "Range.FormattedText Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set formattedRange = rangeObject.FormattedText\nrangeObject.FormattedText = anotherRange.FormattedText",
    "description": "設定或傳回一個 Range 物件，代表具有字元格式的指定範圍的文字。用於複製和貼上包含格式的文字。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim sourceRange As Object, targetRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' Set sourceRange = wdDoc.Paragraphs(1).Range ' Assume first paragraph has formatting\n' Set targetRange = wdDoc.Paragraphs.Add.Range ' Add a new paragraph\n' targetRange.FormattedText = sourceRange.FormattedText ' Copy formatted text\n' MsgBox \"第一個段落的格式化文字已複製到新段落。\"", "explanation": "將第一個段落的格式化文字 (包括字型、顏色等) 複製到一個新段落中。"}
    ],
    "keywords": ["word formatted text", "copy text with formatting", "paste formatted text", "格式化文字", "複製帶格式文字"]
},
// --- More Outlook ---
{
    "name": "MailItem.SentOn Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "dtSent = mailItemObject.SentOn",
    "description": "傳回一個 Date，表示 Outlook 郵件項目實際傳送的日期和時間。對於未傳送的郵件，此屬性傳回 #1/1/4501#。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem, assume it's a sent item\n' ' Set olMail = Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderSentMail).Items(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   If olMail.SentOn > #1/2/4501# Then ' Check if it's a valid date (not the default for unsent)\n'     MsgBox \"郵件傳送於: \" & olMail.SentOn\n'   Else\n'     MsgBox \"此郵件尚未傳送或傳送日期未知。\"\n'   End If\n' End If", "explanation": "獲取寄件匣中第一封郵件的實際傳送日期和時間。"}
    ],
    "keywords": ["outlook sent date", "email sent time", "傳送日期", "郵件傳送時間"]
},
{
    "name": "Recipient.AddressEntry Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set addrEntry = recipientObject.AddressEntry",
    "description": "傳回一個 AddressEntry 物件，代表已解析的收件者。AddressEntry 物件包含有關收件者的詳細資訊，例如其地址、類型等。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\nDim recip As Object ' Outlook.Recipient\nDim addrEntry As Object ' Outlook.AddressEntry\n' Set olMail = Application.CreateItem(0)\n' Set recip = olMail.Recipients.Add(\"user@example.com\")\n' recip.Resolve\n' If recip.Resolved Then\n'   Set addrEntry = recip.AddressEntry\n'   MsgBox \"收件者類型: \" & addrEntry.DisplayType & vbCrLf & \"地址: \" & addrEntry.Address\n'   ' DisplayType: 0=User, 1=DistList, etc.\n' End If", "explanation": "解析一個收件者，然後獲取其 AddressEntry 物件以檢視詳細資訊，如顯示類型和實際地址。"}
    ],
    "keywords": ["outlook recipient addressentry", "address book entry", "get recipient details", "收件者地址條目"]
},
// --- More PowerPoint ---
{
    "name": "Slide.ColorScheme Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set cs = slideObject.ColorScheme",
    "description": "傳回或設定一個 ColorScheme 物件，代表指定投影片的色彩配置。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim cs As Object ' PowerPoint.ColorScheme\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set cs = pptSlide.ColorScheme\n' ' Change the background color of the scheme\n' cs.Colors(ppBackground).RGB = RGB(200, 230, 255) ' Light blue background\n' pptSlide.FollowMasterBackground = msoFalse ' Apply slide-specific background\n' MsgBox \"第一張投影片的背景色已更改。\"", "explanation": "獲取第一張投影片的色彩配置物件，並修改其背景色的RGB值。"}
    ],
    "keywords": ["powerpoint colorscheme", "slide colors", "presentation theme colors", "色彩配置", "投影片顏色"]
},
// --- More FSO ---
{
    "name": "FileSystemObject.Folder.CreateTextFile (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "Set ts = folderObject.CreateTextFile(FileName As String, [Overwrite As Boolean = True], [Unicode As Boolean = False])",
    "description": "在指定的 Folder 物件中建立一個文字檔案，並傳回一個 TextStream 物件，可用於讀寫該檔案。與 fso.CreateTextFile 類似，但直接從 Folder 物件呼叫。",
    "parameters": [
        {"name": "FileName", "description": "必需。要建立的檔案的名稱 (不含路徑，因為路徑由 Folder 物件提供)。"},
        {"name": "Overwrite", "description": "可選。True (預設) 表示如果檔案已存在則覆蓋。"},
        {"name": "Unicode", "description": "可選。True 表示以 Unicode 格式建立。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, myFolder As Object, newFileStream As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFolder = fso.GetFolder(\"C:\\Temp\") ' Assume C:\\Temp exists\nSet newFileStream = myFolder.CreateTextFile(\"FromFolderObject.txt\", True)\nnewFileStream.WriteLine \"此檔案是從 Folder 物件建立的。\"\nnewFileStream.Close\nMsgBox \"檔案已在 C:\\Temp 中建立。\"", "explanation": "獲取 C:\\Temp 資料夾的 Folder 物件，然後使用其 CreateTextFile 方法在該資料夾中建立一個新文字檔案。"}
    ],
    "keywords": ["fso folder createtextfile", "create file in folder", "textstream fso", "在資料夾中建檔"]
},
// --- More String ---
{
    "name": "StrConv (vbWide, vbNarrow)",
    "category": "字串與文本操作",
    "syntax": "StrConv(string, VbStrConv.vbWide)\nStrConv(string, VbStrConv.vbNarrow)",
    "description": "vbWide 將半形 (單一位元組) 字元轉換為全形 (雙位元組) 字元。vbNarrow 將全形 (雙位元組) 字元轉換為半形 (單一位元組) 字元。主要用於處理東亞語言字元。",
    "parameters": [
        {"name": "vbWide", "description": "轉換為全形。"},
        {"name": "vbNarrow", "description": "轉換為半形。"}
    ],
    "examples": [
        {"code": "Dim halfWidth As String: halfWidth = \"ABC 123 def\"\nDim fullWidth As String: fullWidth = \"ＡＢＣ　１２３　ｄｅｆ\"\nDebug.Print \"轉全形: \" & StrConv(halfWidth, vbWide)\nDebug.Print \"轉半形: \" & StrConv(fullWidth, vbNarrow)", "explanation": "演示如何使用 StrConv 將英數字元在半形和全形之間轉換。"}
    ],
    "keywords": ["strconv vbwide", "strconv vbnarrow", "fullwidth characters", "halfwidth characters", "全形半形轉換", "字元寬度"]
},
// --- More Math/Date ---
{
    "name": "Timer (Single Precision)",
    "category": "數學、日期與時間",
    "syntax": "secondsSinceMidnight = Timer",
    "description": "傳回一個 Single (單精度浮點數)，表示自午夜 (00:00:00) 以來經過的秒數。其精確度通常到毫秒級別或更高，但實際解析度取決於系統硬體和作業系統。",
    "parameters": [],
    "examples": [
        {"code": "Dim t1 As Single, t2 As Single, i As Long\nt1 = Timer\nFor i = 1 To 100000: DoEvents: Next ' A short loop\nt2 = Timer\nMsgBox \"迴圈耗時: \" & (t2 - t1) & \" 秒。\"", "explanation": "使用 Timer 函數測量一個短迴圈的執行時間。由於是 Single 類型，它可以表示小數秒。"}
    ],
    "keywords": ["timer precision", "measure milliseconds", "elapsed time single", "精確計時", "毫秒測量"]
},
// --- More Data Types/Conversion ---
{
    "name": "CVErr Function (Error Values)",
    "category": "資料類型、轉換與驗證",
    "syntax": "errValue = CVErr(errornumber)",
    "description": "傳回一個 Variant，其子類型為 Error (VarType = vbError 或 10)，其中包含使用者定義的錯誤號碼。常用於自訂函數中，當發生無法計算的錯誤時，使其傳回一個可以在工作表上顯示為錯誤值 (如 #VALUE!, #N/A) 的結果。",
    "parameters": [{"name": "errornumber", "description": "必需。任何有效的錯誤號碼 (通常使用預留給使用者定義錯誤的範圍，例如 vbObjectError + N)。"}],
    "examples": [
        {"code": "Function DivideOrError(num As Double, den As Double) As Variant\n  If den = 0 Then\n    DivideOrError = CVErr(xlErrDiv0) ' xlErrDiv0 (2007) is like #DIV/0!\n  Else\n    DivideOrError = num / den\n  End If\nEnd Function\nSub TestDivideError()\n  Range(\"A1\").Value = 10\n  Range(\"A2\").Value = 0\n  Range(\"A3\").Formula = \"=DivideOrError(A1,A2)\" ' Cell A3 will show #DIV/0!\n  ' MsgBox IsError(DivideOrError(10,0)) ' True\nEnd Sub", "explanation": "DivideOrError 自訂函數在除數為零時，使用 CVErr 和 Excel 內建的 xlErrDiv0 錯誤常數傳回一個錯誤值，這會導致在工作表儲存格中顯示為 #DIV/0!。"}
    ],
    "keywords": ["cverr function", "return error value", "user defined function error", "xlErrDiv0", "iserror", "傳回錯誤值", "自訂函數錯誤"]
},
// --- More Program Flow ---
{
    "name": "DefType Statements (DefInt, DefStr, etc.)",
    "category": "程式流程與結構控制",
    "syntax": "DefInt letterrange[, letterrange]...\nDefStr letterrange[, letterrange]...\nDefLng letterrange[, letterrange]...\nDefCur letterrange[, letterrange]...\nDefSng letterrange[, letterrange]...\nDefDbl letterrange[, letterrange]...\nDefBool letterrange[, letterrange]...\nDefDate letterrange[, letterrange]...\nDefObj letterrange[, letterrange]...\nDefVar letterrange[, letterrange]...",
    "description": "在模組層級設定一個或多個範圍的字母的預設資料類型，用於未明確使用 As type 子句宣告的變數、函數參數和函數傳回值。例如，`DefInt A-C` 表示所有以 A, B, C 開頭的未明確宣告型別的變數預設為 Integer。現代 VBA 程式設計中，由於 `Option Explicit` 的廣泛使用和明確型別宣告的優點，DefType 語句已不常用。",
    "parameters": [
        {"name": "letterrange", "description": "必需。一個字母範圍，格式為 letter1[-letter2]。例如 A, I-N, X-Z。"}
    ],
    "examples": [
        {"code": "' Module Level Code (at the very top of a module)\n' Option Explicit ' Recommended, but DefType works without it if vars are not Dim'd with type\n' DefStr S ' Variables starting with S default to String\n' DefInt I, J, K ' Variables starting with I, J, K default to Integer\n'\n' Sub TestDefType()\n'   Dim myString ' Defaults to String because of DefStr S\n'   Dim Index    ' Defaults to Integer because of DefInt I\n'   myString = \"Hello\"\n'   Index = 10\n'   MsgBox TypeName(myString) & \": \" & myString & vbCrLf & _\n'          TypeName(Index) & \": \" & Index\n'   ' Output: String: Hello, Integer: 10\n'\n'   Dim AnotherVar ' If no DefVar or specific Def for A, this would be Variant without Option Explicit\n'                  ' With Option Explicit, this line would cause an error unless Dim'd properly.\n' End Sub", "explanation": "在模組頂部使用 DefStr S 將使所有以字母 S 開頭且未明確指定資料類型的變數預設為 String 類型。DefInt I, J, K 則將以 I, J, 或 K 開頭的變數預設為 Integer。建議始終使用 Option Explicit 並明確宣告所有變數的類型，以避免混淆和潛在錯誤。"}
    ],
    "keywords": ["deftype statement", "defint", "defstr", "default data type", "implicit typing", "預設資料類型", "隱含類型宣告"]
},
// --- More Error Handling ---
{
    "name": "Err.HelpFile and Err.HelpContext",
    "category": "錯誤處理與調試",
    "syntax": "errHelpFile = Err.HelpFile\nerrHelpContextID = Err.HelpContext",
    "description": "Err.HelpFile 屬性傳回或設定包含錯誤相關說明主題的說明檔案的完整路徑。Err.HelpContext 屬性傳回或設定說明檔案中特定主題的上下文 ID。這些屬性對於自訂錯誤 (使用 Err.Raise) 並提供相關說明特別有用。",
    "parameters": [],
    "examples": [
        {"code": "Sub CustomErrorWithHelp()\n  Const MY_CUSTOM_ERROR As Long = vbObjectError + 1024\n  Const MY_HELP_FILE As String = \"C:\\MyApp\\MyAppHelp.chm\" ' Example help file path\n  Const MY_HELP_CONTEXT_ID As Long = 1001 ' Context ID for this error in help file\n  \n  On Error GoTo HandleMyError\n  \n  Dim userInput As String\n  userInput = InputBox(\"輸入 'TEST' 來觸發自訂錯誤:\")\n  If UCase(userInput) = \"TEST\" Then\n    Err.Raise Number:=MY_CUSTOM_ERROR, _\n              Source:=\"CustomErrorWithHelp.TestInput\", _\n              Description:=\"發生了一個自訂應用程式錯誤。\", _\n              HelpFile:=MY_HELP_FILE, _\n              HelpContext:=MY_HELP_CONTEXT_ID\n  Else\n    MsgBox \"輸入有效。\"\n  End If\n  Exit Sub\n\nHandleMyError:\n  Dim msg As String\n  msg = \"錯誤號: \" & Err.Number & vbCrLf & _\n        \"描述: \" & Err.Description & vbCrLf & _\n        \"來源: \" & Err.Source\n  If Err.HelpFile <> \"\" Then\n    msg = msg & vbCrLf & \"說明檔: \" & Err.HelpFile\n    If Err.HelpContext <> 0 Then\n      msg = msg & vbCrLf & \"說明內容ID: \" & Err.HelpContext\n      ' In a real app, you might provide a button to open help:\n      ' If MsgBox(msg, vbCritical + vbYesNo, \"應用程式錯誤\") = vbYes Then\n      '   Help Err.HelpFile, Err.HelpContext ' This syntax for Help method might vary\n      ' End If\n    End If\n  Else\n    MsgBox msg, vbCritical, \"應用程式錯誤\"\n  End If\n  Err.Clear\nEnd Sub", "explanation": "此範例演示如何使用 Err.Raise 產生一個自訂錯誤，並同時設定其 HelpFile 和 HelpContext 屬性。在錯誤處理常式中，可以檢查這些屬性並（如果適用）為使用者提供打開相關說明檔案特定主題的選項。"}
    ],
    "keywords": ["err helpfile", "err helpcontext", "custom error help", "vba error handling help", "錯誤說明檔案", "自訂錯誤說明"]
},
// --- More API (Conceptual) ---
{
    "name": "SendInput (Windows API - Conceptual)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "' Declare Function SendInput Lib \"user32.dll\" (ByVal nInputs As Long, pInputs As INPUT_TYPE, ByVal cbSize As Long) As Long",
    "description": "SendInput API 函數比 SendKeys 更可靠地合成鍵盤敲擊和滑鼠移動/點擊。它直接將事件插入到裝置輸入流中。使用它需要定義複雜的 INPUT 結構和相關的 KEYBDINPUT、MOUSEINPUT 結構。由於其複雜性，通常用於需要非常精確控制輸入的進階情境。",
    "parameters": [
        {"name": "nInputs", "description": "pInputs 陣列中的結構數量。"},
        {"name": "pInputs", "description": "指向 INPUT 結構陣列的指標。每個結構代表一個輸入事件。"},
        {"name": "cbSize", "description": "INPUT 結構的大小 (位元組)。"}
    ],
    "examples": [
        {"code": "' --- Using SendInput is complex and requires structure definitions ---\n' Type KEYBDINPUT\n'   wVk As Integer\n'   wScan As Integer\n'   dwFlags As Long\n'   time As Long\n'   dwExtraInfo As LongPtr ' Or Long for 32-bit\n' End Type\n'\n' Type MOUSEINPUT ' ... and so on for MOUSEINPUT, HARDWAREINPUT\n'   ...\n' End Type\n'\n' Type INPUT_TYPE ' This is a union in C, harder to do directly in VBA\n'   dwType As Long ' 0 for mouse, 1 for keyboard, 2 for hardware\n'   ' Followed by MOUSEINPUT, KEYBDINPUT, or HARDWAREINPUT structure data\n'   ' In VBA, often done by declaring INPUT_TYPE large enough and copying bytes or using wrapper DLLs.\n' End Type\n'\n' ' Due to complexity, direct SendInput examples are extensive and error-prone without careful handling.\n' ' It's often recommended to use a pre-built library or wrapper if precise input simulation is needed.\n' MsgBox \"SendInput API is for advanced input simulation. Requires INPUT structure definitions.\"", "explanation": "SendInput 是用於模擬鍵盤和滑鼠事件的進階 Windows API。它比 VBA 的 SendKeys 更底層和可靠，但使用起來也更複雜，需要正確定義和填充 INPUT、KEYBDINPUT 和 MOUSEINPUT 等結構。"}
    ],
    "keywords": ["sendinput api", "simulate keyboard input api", "mouse input api", "advanced input simulation", "模擬鍵盤API", "模擬滑鼠API"]
},
// --- 20 new commands above. Total 30 so far. ---
// --- Excel Core Operations ---
{
    "name": "Range.Address (External with Sheet Name)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Address(External:=True)",
    "description": "當 External 引數設為 True 時，Address 屬性會傳回包含活頁簿名稱 (方括號內) 和工作表名稱的完整外部參照字串。",
    "parameters": [
        {"name": "External:=True", "description": "指定傳回外部參照。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook, ws As Worksheet, rng As Range\nSet wb = ThisWorkbook\nSet ws = wb.Sheets(1)\nSet rng = ws.Range(\"C5\")\nMsgBox rng.Address(External:=True) ' 可能傳回類似 \"[MyWorkbook.xlsm]Sheet1!$C$5\"", "explanation": "獲取 Sheet1 上 C5 儲存格的完整外部位址，包括活頁簿和工作表名稱。"}
    ],
    "keywords": ["外部位址", "完整儲存格參照", "excel", "external address", "full cell reference", "workbook and sheet address"]
},
{
    "name": "Worksheet.UsedRange.Rows.Count",
    "category": "Excel 核心操作",
    "syntax": "rowCount = worksheetObject.UsedRange.Rows.Count",
    "description": "傳回工作表已使用範圍內的總列數。這對於確定資料表的實際行數很有用，而不是工作表的總最大列數。",
    "parameters": [],
    "examples": [
        {"code": "Dim activeSheetDataRows As Long\nactiveSheetDataRows = ActiveSheet.UsedRange.Rows.Count\nMsgBox \"活動工作表的已使用範圍包含 \" & activeSheetDataRows & \" 列數據。\"", "explanation": "計算並顯示活動工作表上實際包含數據（或格式）的列數。"}
    ],
    "keywords": ["已使用列數", "數據行數", "excel", "used rows count", "number of data rows"]
},
{
    "name": "Worksheet.UsedRange.Columns.Count",
    "category": "Excel 核心操作",
    "syntax": "colCount = worksheetObject.UsedRange.Columns.Count",
    "description": "傳回工作表已使用範圍內的總欄數。",
    "parameters": [],
    "examples": [
        {"code": "Dim activeSheetDataCols As Long\nactiveSheetDataCols = ActiveSheet.UsedRange.Columns.Count\nMsgBox \"活動工作表的已使用範圍包含 \" & activeSheetDataCols & \" 欄數據。\"", "explanation": "計算並顯示活動工作表上實際包含數據（或格式）的欄數。"}
    ],
    "keywords": ["已使用欄數", "數據欄數", "excel", "used columns count", "number of data columns"]
},
{
    "name": "Range.CopyPicture",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.CopyPicture(Appearance As XlPictureAppearance, Format As XlCopyPictureFormat)",
    "description": "將選定的範圍複製為圖片到剪貼簿。",
    "parameters": [
        {"name": "Appearance", "description": "必需。XlPictureAppearance 常數 (xlScreen - 如螢幕所示，xlPrinter - 如列印所示)。"},
        {"name": "Format", "description": "必需。XlCopyPictureFormat 常數 (xlBitmap - 點陣圖，xlPicture - 圖片 (通常是 EMF))。"}
    ],
    "examples": [
        {"code": "Range(\"A1:C5\").CopyPicture Appearance:=xlScreen, Format:=xlBitmap\n' The picture is now on the clipboard. You can paste it, e.g.:\n' ActiveSheet.Paste Destination:=Range(\"E1\")\n' Or paste into Word/PowerPoint\nMsgBox \"範圍 A1:C5 已作為點陣圖複製到剪貼簿。\"", "explanation": "將範圍 A1:C5 的螢幕外觀複製為點陣圖圖片到剪貼簿。"}
    ],
    "keywords": ["複製為圖片", "範圍轉圖片", "excel", "copy as picture", "range to image"]
},
// --- More Word ---
{
    "name": "Paragraphs.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "longCount = documentOrRangeObject.Paragraphs.Count",
    "description": "傳回指定文件或範圍中段落的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' MsgBox \"此文件共有 \" & wdDoc.Paragraphs.Count & \" 個段落。\"", "explanation": "顯示活動文件中的總段落數。"}
    ],
    "keywords": ["word paragraph count", "number of paragraphs", "段落計數"]
},
{
    "name": "Range.Words (Word)",
    "category": "Word 文件處理",
    "syntax": "Set wordsCollection = rangeObject.Words",
    "description": "傳回一個 Words 集合，代表範圍中的所有單字。每個單字也是一個 Range 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdRange As Object ' Word.Range\nDim firstWord As Object ' Word.Range\n' Set wdRange = ActiveDocument.Paragraphs(1).Range\n' If wdRange.Words.Count > 0 Then\n'   Set firstWord = wdRange.Words(1)\n'   firstWord.Font.Bold = True\n'   MsgBox \"第一個段落的第一個單字 '\" & Trim(firstWord.Text) & \"' 已設為粗體。\"\n' End If", "explanation": "獲取第一個段落的範圍，然後將其第一個單字的字型設為粗體。"}
    ],
    "keywords": ["word words collection", "iterate words", "format individual words", "單字集合", "格式化單字"]
},
// --- More Outlook ---
{
    "name": "MailItem.VotingOptions Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.VotingOptions = \"Option1;Option2;Option3\"",
    "description": "設定或傳回一個字串，指定郵件的投票選項。選項之間用分號分隔。設定此屬性會自動將投票按鈕新增到郵件中。",
    "parameters": [{"name": "String", "description": "包含投票選項的分號分隔字串 (例如 \"Yes;No;Maybe\")。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.Subject = \"團隊午餐投票\"\nolMail.Body = \"請選擇您偏好的午餐地點：\"\nolMail.VotingOptions = \"中餐館;西餐廳;日式料理\"\nolMail.To = \"team@example.com\"\nolMail.Display", "explanation": "建立一封新郵件，並設定投票按鈕選項為“中餐館”、“西餐廳”和“日式料理”。"}
    ],
    "keywords": ["outlook voting buttons", "email voting options", "投票按鈕", "郵件投票"]
},
{
    "name": "MailItem.FlagRequest Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.FlagRequest = \"Request String\"",
    "description": "設定或傳回一個字串，表示郵件的標記要求。例如，\"Follow up\"、\"Review\"、\"Call\"。",
    "parameters": [{"name": "Request String", "description": "標記要求的文字。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.ActiveExplorer.Selection.Item(1) ' Get selected email\n' If TypeName(olMail) = \"MailItem\" Then\n'   olMail.FlagRequest = \"請於本週五前回覆\"\n'   olMail.FlagDueBy = Date + 5 ' Set due date for flag\n'   olMail.Save\n'   MsgBox \"郵件已標記要求。\"\n' End If", "explanation": "為所選郵件設定一個標記要求和到期日。"}
    ],
    "keywords": ["outlook flag email", "set email flag", "follow up flag", "標記郵件", "待辦標記"]
},
// --- More PowerPoint ---
{
    "name": "Shapes.AddChart2 (PowerPoint/Excel)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set shpChart = targetObject.Shapes.AddChart2([Style], [XlChartType], [Left], [Top], [Width], [Height], [NewLayout])",
    "description": "在投影片 (PowerPoint) 或工作表 (Excel) 上新增一個圖表。這是較新的新增圖表方法，提供更多選項。targetObject 可以是 Slide (PPT) 或 Worksheet (Excel)。",
    "parameters": [
        {"name": "Style", "description": "可選。圖表樣式編號。"},
        {"name": "XlChartType", "description": "可選。XlChartType 常數。"},
        {"name": "NewLayout", "description": "可選。True 表示使用新的動態圖表版面配置 (如果適用)。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim chartShape As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides(1)\n' ' Add a default column chart\n' Set chartShape = pptSlide.Shapes.AddChart2(Style:=-1, XlChartType:=xlColumnClustered, _\n'                                       Left:=100, Top:=100, Width:=400, Height:=250)\n' With chartShape.Chart\n'   ' .ChartData.Workbook.Worksheets(1).Range(\"A1:B5\").Value = ... ' Populate data\n'   .HasTitle = True\n'   .ChartTitle.Text = \"新圖表 (AddChart2)\"\n' End With", "explanation": "在第一張投影片上使用 AddChart2 方法新增一個簇狀柱形圖。然後可以設定其資料和標題。"}
    ],
    "keywords": ["powerpoint addchart2", "excel addchart2", "insert chart new method", "新增圖表 (新)"]
},
// --- More FSO ---
{
    "name": "TextStream.SkipLine (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "textStreamObject.SkipLine",
    "description": "從開啟的 TextStream 檔案中讀取時跳過下一整行。檔案指標會移至被跳過行之後緊接的那一行的開頭。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, ts As Object, line2 As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Assume C:\\Temp\\MyLines.txt has at least 2 lines\n' Set ts = fso.OpenTextFile(\"C:\\Temp\\MyLines.txt\", 1) ' ForReading\n' If Not ts.AtEndOfStream Then ts.SkipLine ' Skip the first line\n' If Not ts.AtEndOfStream Then line2 = ts.ReadLine\n' ts.Close\n' MsgBox \"第二行內容是: \" & line2", "explanation": "打開一個文字檔案，使用 SkipLine 跳過第一行，然後讀取第二行的內容。"}
    ],
    "keywords": ["fso skipline", "skip line text file", "textstream skip", "跳過文字行"]
},
// --- More Math/Date ---
{
    "name": "WeekdayName Function",
    "category": "數學、日期與時間",
    "syntax": "WeekdayName(weekday As Long, [abbreviate As Boolean = False], [firstdayofweek As VbDayOfWeek = vbSunday]) As String",
    "description": "傳回一個字串，表示星期幾的名稱。",
    "parameters": [
        {"name": "weekday", "description": "必需。代表星期幾的數字 (1 到 7)。"},
        {"name": "abbreviate", "description": "可選。True 表示傳回縮寫名稱 (例如 \"Mon\")。預設為 False。"},
        {"name": "firstdayofweek", "description": "可選。VbDayOfWeek 常數，指定一週的第一天。"}
    ],
    "examples": [
        {"code": "MsgBox \"今天是: \" & WeekdayName(Weekday(Date), False, vbMonday)", "explanation": "顯示今天的完整星期名稱 (假設週一為一週的第一天)。"},
        {"code": "MsgBox \"週三的縮寫: \" & WeekdayName(4, True, vbMonday) ' 4 is Wednesday if Monday is 1st day", "explanation": "顯示星期三的縮寫名稱。"}
    ],
    "keywords": ["weekdayname", "day of week name", "星期名稱", "日期名稱"]
},
// --- More Program Flow ---
{
    "name": "WithEvents Keyword (Class Modules)",
    "category": "程式流程與結構控制",
    "syntax": "Private WithEvents MyObject As ObjectType",
    "description": "在類別模組或使用者表單模組中，用於宣告一個物件變數，使其可以回應其來源物件觸發的事件。ObjectType 必須是一個具有可觸發事件的物件類型 (例如，Application, Workbook, Worksheet, CommandButton)。",
    "parameters": [
        {"name": "MyObject", "description": "要宣告的物件變數名稱。"},
        {"name": "ObjectType", "description": "物件的類別名稱。"}
    ],
    "examples": [
        {"code": "' In a Class Module named 'AppEventHandler':\n' Private WithEvents App As Excel.Application\n'\n' Private Sub Class_Initialize()\n'   Set App = Application ' Hook into the current Excel application instance\n' End Sub\n'\n' Private Sub App_NewWorkbook(ByVal Wb As Workbook)\n'   MsgBox \"一個新的活頁簿已建立: \" & Wb.Name\n' End Sub\n'\n' ' In a Standard Module to test:\n' Dim myAppHandler As AppEventHandler\n' Sub InitializeAppHandler()\n'   Set myAppHandler = New AppEventHandler\n'   MsgBox \"應用程式事件處理常式已初始化。嘗試建立一個新活頁簿。\"\n' End Sub", "explanation": "此範例 (概念性，需要在類別模組和標準模組中分別放置) 演示如何使用 WithEvents 來捕捉 Excel Application 物件的 NewWorkbook 事件。當一個新活頁簿建立時，App_NewWorkbook 事件程序會被觸發。"}
    ],
    "keywords": ["withevents", "event handling", "object events", "class module events", "事件處理", "物件事件"]
},
// --- 40 new commands ---
// --- Excel Core Operations ---
{
    "name": "Range.Validation.Delete",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.Delete",
    "description": "刪除指定範圍的資料驗證規則。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Validation.Delete\nMsgBox \"儲存格 A1 的資料驗證規則已被刪除 (如果存在)。\"", "explanation": "刪除儲存格 A1 上已有的任何資料驗證設定。"}
    ],
    "keywords": ["刪除資料驗證", "清除驗證", "excel", "delete data validation", "clear validation"]
},
{
    "name": "Range.ListObject Property",
    "category": "Excel 核心操作",
    "syntax": "Set lo = rangeObject.ListObject",
    "description": "如果指定的 Range 物件位於 Excel 表格 (ListObject) 內，則傳回代表該表格的 ListObject 物件。如果儲存格不在表格內，則傳回 Nothing。",
    "parameters": [],
    "examples": [
        {"code": "Dim myTable As ListObject\nOn Error Resume Next ' If A1 is not in a table, ListObject will be Nothing\nSet myTable = Range(\"A1\").ListObject\nOn Error GoTo 0\nIf Not myTable Is Nothing Then\n  MsgBox \"A1 位於表格 '\" & myTable.Name & \"' 中。該表格共有 \" & myTable.ListRows.Count & \" 列數據。\"\nElse\n  MsgBox \"A1 不在 Excel 表格中。\"\nEnd If", "explanation": "檢查儲存格 A1 是否屬於一個 Excel 表格 (ListObject)，如果是，則顯示表格名稱和數據列數。"}
    ],
    "keywords": ["Excel表格物件", "ListObject", "表格屬性", "excel table", "structured table"]
},
{
    "name": "ListObject.Name Property (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "tableNameString = listObject.Name\nlistObject.Name = newNameString",
    "description": "設定或傳回 Excel 表格 (ListObject) 的名稱。",
    "parameters": [{"name": "newNameString", "description": "表格的新名稱。"}],
    "examples": [
        {"code": "Dim tbl As ListObject\n' Assume ActiveSheet has at least one table\nIf ActiveSheet.ListObjects.Count > 0 Then\n  Set tbl = ActiveSheet.ListObjects(1)\n  MsgBox \"第一個表格的原始名稱: \" & tbl.Name\n  tbl.Name = \"SalesDataTable\"\n  MsgBox \"表格名稱已更新為: \" & tbl.Name\nEnd If", "explanation": "獲取活動工作表上的第一個表格，顯示其名稱，然後將其重命名為 \"SalesDataTable\"。"}
    ],
    "keywords": ["表格名稱", "重命名表格", "excel table name", "listobject name", "rename table"]
},
{
    "name": "ListObject.DataBodyRange Property (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "Set dataRange = listObject.DataBodyRange",
    "description": "傳回一個 Range 物件，代表 Excel 表格中不包括標頭列和總計列的數據區域。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As ListObject, dataBody As Range\n' Set tbl = ActiveSheet.ListObjects(\"SalesDataTable\") ' Assume table exists\n' If Not tbl Is Nothing Then\n'   Set dataBody = tbl.DataBodyRange\n'   If Not dataBody Is Nothing Then\n'     dataBody.Interior.Color = RGB(220, 230, 241) ' Light blue\n'     MsgBox \"表格 '\" & tbl.Name & \"' 的數據區域已設定背景色。\"\n'   Else\n'     MsgBox \"表格 '\" & tbl.Name & \"' 沒有數據列。\"\n'   End If\n' End If", "explanation": "獲取名為 \"SalesDataTable\" 的表格的數據主體範圍，並將其背景色設為淺藍色。"}
    ],
    "keywords": ["表格數據區域", "listobject databodyrange", "table data area", "不含表頭表格範圍"]
},
{
    "name": "ListObject.ListRows.Add (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "Set newRow = listObject.ListRows.Add([Position As Long], [AlwaysInsert As Boolean])",
    "description": "將一個新的列新增到 Excel 表格 (ListObject) 中，並傳回代表該新列的 ListRow 物件。新列會自動擴展表格。",
    "parameters": [
        {"name": "Position", "description": "可選。新列的插入位置 (1-based)。如果省略，則在末尾新增。"},
        {"name": "AlwaysInsert", "description": "可選。True 表示總是插入新列，即使在表格下方有數據。預設為 False。"}
    ],
    "examples": [
        {"code": "Dim tbl As ListObject, newLr As ListRow\n' Set tbl = ActiveSheet.ListObjects(\"MyTable\")\n' If Not tbl Is Nothing Then\n'   Set newLr = tbl.ListRows.Add ' Add a new row at the end\n'   newLr.Range.Cells(1, 1).Value = \"New Product\"\n'   newLr.Range.Cells(1, 2).Value = 100 ' Assuming 2nd column is Quantity\n'   MsgBox \"新列已新增到表格 '\" & tbl.Name & \"'。\"\n' End If", "explanation": "在名為 \"MyTable\" 的表格末尾新增一列，並在新列的第一和第二個儲存格中填入數據。"}
    ],
    "keywords": ["新增表格列", "listobject add row", "excel table insert row", "動態增加表格列"]
},
// --- Word Document Processing ---
{
    "name": "Document.Words.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "wordCount = documentObject.Words.Count",
    "description": "傳回指定文件中單字的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' MsgBox \"此文件包含 \" & wdDoc.Words.Count & \" 個單字。\"", "explanation": "計算並顯示活動文件中的總單字數。"}
    ],
    "keywords": ["word count words", "number of words in document", "單字計數"]
},
{
    "name": "Range.InsertBreak (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.InsertBreak([Type As WdBreakType = wdLineBreak])",
    "description": "在指定的範圍前插入分頁、分欄或分節符號。",
    "parameters": [
        {"name": "Type", "description": "可選。WdBreakType 常數，指定要插入的分隔符號類型 (例如，wdPageBreak, wdColumnBreak, wdSectionBreakNextPage)。預設為 wdLineBreak (換行符號，但通常 InsertBreak 用於更強的分隔)。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' selRange.InsertBreak Type:=7 ' 7 = wdPageBreak\n' MsgBox \"已在目前選取位置插入分頁符號。\"", "explanation": "在 Word 文件中目前選取範圍的位置插入一個分頁符號。"}
    ],
    "keywords": ["word insert page break", "insert column break", "insert section break", "插入分頁符號", "插入分節符號"]
},
// --- Outlook Mail & Item Management ---
{
    "name": "MailItem.CreationTime Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "dtCreated = mailItemObject.CreationTime",
    "description": "傳回一個 Date，表示 Outlook 項目的建立日期和時間。此屬性是唯讀的。",
    "parameters": [],
    "examples": [
        {"code": "Dim olDraft As Object ' Outlook.MailItem\n' Set olDraft = Application.CreateItem(olMailItem)\n' olDraft.Subject = \"草稿郵件\"\n' ' Do not send or save yet\n' MsgBox \"此草稿項目的建立時間: \" & olDraft.CreationTime", "explanation": "建立一個新的郵件草稿並顯示其建立時間 (在它被實際儲存或移動到草稿匣之前)。"}
    ],
    "keywords": ["outlook creation time", "email create date", "item timestamp", "建立時間", "郵件建立日期"]
},
{
    "name": "TaskItem.DueDate Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "taskItemObject.DueDate [= Date]",
    "description": "設定或傳回一個 Date，表示 Outlook 任務的到期日。",
    "parameters": [{"name": "Date", "description": "任務的到期日期。"}],
    "examples": [
        {"code": "Dim olTask As Object ' Outlook.TaskItem\nSet olTask = CreateObject(\"Outlook.Application\").CreateItem(3) ' 3 = olTaskItem\nolTask.Subject = \"完成專案報告\"\nolTask.DueDate = Date + 7 ' Due in one week from today\nolTask.Body = \"確保所有章節都已完成並校對。\"\nolTask.Save\nMsgBox \"任務 '\" & olTask.Subject & \"' 已建立，到期日: \" & Format(olTask.DueDate, \"yyyy-mm-dd\")", "explanation": "建立一個新的 Outlook 任務，設定其主旨、到期日和內容，然後儲存它。"}
    ],
    "keywords": ["outlook task due date", "set task deadline", "任務到期日"]
},
// --- PowerPoint Presentation Creation ---
{
    "name": "Slide.SlideNumber Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideNum = slideObject.SlideNumber",
    "description": "傳回投影片在簡報中的實際編號 (如放映時所見，考慮隱藏的投影片)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\n' Set pptSlide = ActiveWindow.View.Slide ' Get current slide in slide view or normal view\n' If Not pptSlide Is Nothing Then\n'   MsgBox \"目前投影片的顯示編號是: \" & pptSlide.SlideNumber\n' End If", "explanation": "顯示目前檢視中投影片的實際投影片編號。這可能與 SlideIndex 不同，如果簡報中有隱藏的投影片或自訂起始編號。"}
    ],
    "keywords": ["powerpoint slide number", "actual slide number", "投影片編號", "幻燈片實際頁碼"]
},
// --- String & Text ---
{
    "name": "StrConv (vbKatakana, vbHiragana)",
    "category": "字串與文本操作",
    "syntax": "StrConv(string, VbStrConv.vbKatakana)\nStrConv(string, VbStrConv.vbHiragana)",
    "description": "vbKatakana 將日文平假名轉換為片假名。vbHiragana 將日文片假名轉換為平假名。主要用於日文文本處理。",
    "parameters": [
        {"name": "vbKatakana", "description": "轉換為片假名。"},
        {"name": "vbHiragana", "description": "轉換為平假名。"}
    ],
    "examples": [
        {"code": "Dim hiraganaText As String: hiraganaText = \"ひらがな\"\nDim katakanaText As String: katakanaText = \"カタカナ\"\nDebug.Print \"轉片假名: \" & StrConv(hiraganaText, vbKatakana) ' Output: ヒラガナ\nDebug.Print \"轉平假名: \" & StrConv(katakanaText, vbHiragana) ' Output: かたかな", "explanation": "演示如何在日文的平假名和片假名之間進行轉換。"}
    ],
    "keywords": ["strconv vbkatakana", "strconv vfhiragana", "japanese character conversion", "katakana", "hiragana", "日文假名轉換", "片假名", "平假名"]
},
// --- Math, Date & Time ---
{
    "name": "DateDiff Function (More Intervals)",
    "category": "數學、日期與時間",
    "syntax": "DateDiff(interval, date1, date2, [firstdayofweek], [firstweekofyear])",
    "description": "DateDiff 函數的 interval 引數可以使用多種間隔字串，除了常見的 \"d\", \"m\", \"yyyy\" 外，還有 \"q\" (季), \"y\" (年中日，同 \"d\"), \"w\" (周中日，表示相差的星期數，基於星期幾), \"ww\" (週次), \"h\" (時), \"n\" (分), \"s\" (秒)。",
    "parameters": [
        {"name": "interval", "description": "必需。時間間隔字串。"},
        {"name": "date1, date2", "description": "必需。要比較的兩個日期。"}
    ],
    "examples": [
        {"code": "Dim startDate As Date, endDate As Date\nstartDate = #1/15/2023 10:00:00 AM#\nendDate = #4/20/2023 02:30:45 PM#\nDebug.Print \"相差季度數: \" & DateDiff(\"q\", startDate, endDate)\nDebug.Print \"相差完整週數 (ww): \" & DateDiff(\"ww\", startDate, endDate, vbMonday)\nDebug.Print \"相差小時數: \" & DateDiff(\"h\", startDate, endDate)\nDebug.Print \"相差分鐘數: \" & DateDiff(\"n\", startDate, endDate)\nDebug.Print \"相差秒數: \" & DateDiff(\"s\", startDate, endDate)", "explanation": "演示使用 DateDiff 計算兩個日期時間之間相差的季度數、完整週數、小時數、分鐘數和秒數。"}
    ],
    "keywords": ["datediff intervals", "time difference", "date comparison", "日期差異間隔", "時間差計算"]
},
// --- Data Types, Conversion & Validation ---
{
    "name": "TypeName of Uninitialized Object",
    "category": "資料類型、轉換與驗證",
    "syntax": "TypeName(objectVariable)",
    "description": "如果一個物件變數已宣告但尚未使用 Set 賦予物件參考 (即其值為 Nothing)，則 TypeName 函數會傳回 \"Nothing\"。",
    "parameters": [{"name": "objectVariable", "description": "任何物件變數。"}],
    "examples": [
        {"code": "Dim myObj As Object\nDim mySheet As Worksheet\nDebug.Print \"TypeName(myObj) before Set: \" & TypeName(myObj) ' Output: Nothing\nDebug.Print \"TypeName(mySheet) before Set: \" & TypeName(mySheet) ' Output: Nothing\nSet mySheet = ThisWorkbook.Sheets(1)\nDebug.Print \"TypeName(mySheet) after Set: \" & TypeName(mySheet) ' Output: Worksheet", "explanation": "顯示在 Set 語句之前和之後，物件變數的 TypeName。未初始化的物件變數類型為 Nothing。"}
    ],
    "keywords": ["typename nothing", "uninitialized object type", "object variable state", "未初始化物件類型"]
},
// --- Program Flow ---
{
    "name": "On...GoSub...Return Statement (Legacy)",
    "category": "程式流程與結構控制",
    "syntax": "On expression GoSub destinationlist\n...\nReturn",
    "description": "根據運算式的值，分支到指定的幾個行標籤或行號之一，並在那裡執行一個子常式。執行完子常式後，Return 語句會將執行返回到 On...GoSub 語句之後的語句。這是較舊的 BASIC 結構，現代 VBA 中通常使用 Select Case 或 If...ElseIf...Else 結合呼叫獨立的 Sub 過程來實現更結構化的程式碼。",
    "parameters": [
        {"name": "expression", "description": "必需。任何評估為小範圍整數的數值運算式。"},
        {"name": "destinationlist", "description": "必需。以逗號分隔的行號或行標籤列表。"}
    ],
    "examples": [
        {"code": "Sub TestOnGoSub()\n  Dim choice As Integer\n  choice = CInt(InputBox(\"輸入 1, 2, 或 3:\"))\n  On choice GoSub HandleOne, HandleTwo, HandleThree\n  MsgBox \"返回主程序。\"\n  Exit Sub ' Important to exit before labels if not called\nHandleOne:\n  MsgBox \"處理選項 1。\"\n  Return\nHandleTwo:\n  MsgBox \"處理選項 2。\"\n  Return\nHandleThree:\n  MsgBox \"處理選項 3。\"\n  Return\nEnd Sub", "explanation": "根據使用者輸入的數字 (1, 2 或 3)，程式會跳轉到相應的標籤 (HandleOne, HandleTwo, HandleThree) 執行子常式，然後使用 Return 返回。不建議在現代 VBA 中大量使用此結構。"}
    ],
    "keywords": ["on gosub", "computed gosub", "legacy control flow", "分支子常式"]
},
{
    "name": "Range.AutoFit (Rows and Columns)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Columns.AutoFit\nrangeObject.Rows.AutoFit",
    "description": "自動調整指定範圍內所有欄的寬度或所有列的高度，以適應其內容。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1:C10\").Value = \"一些可能很長的文字或數字\"\nRange(\"A1:C10\").Columns.AutoFit\nRange(\"A1:C10\").Rows.AutoFit ' 通常對已啟用自動換行的儲存格更有效", "explanation": "對範圍 A1:C10 中的欄和列執行自動調整大小操作。"}
    ],
    "keywords": ["自動調整欄寬", "自動調整列高", "excel autofit", "autofit columns", "autofit rows"]
},
{
    "name": "Worksheet.DisplayRightToLeft Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.DisplayRightToLeft [= Boolean]",
    "description": "如果指定的工作表是從右到左顯示，則為 True。對於從右到左書寫的語言 (如阿拉伯文、希伯來文) 設定工作表佈局。讀取/寫入布林值。",
    "parameters": [{"name": "Boolean", "description": "True 表示從右到左顯示，False (預設) 表示從左到右。"}],
    "examples": [
        {"code": "ActiveSheet.DisplayRightToLeft = True\nMsgBox \"工作表現在從右到左顯示。A1儲存格在最右邊。\"\n' ActiveSheet.DisplayRightToLeft = False ' Restore", "explanation": "將活動工作表的顯示方向設定為從右到左。"}
    ],
    "keywords": ["從右到左顯示", "RTL layout", "excel right to left", "worksheet direction"]
},
// --- Word Document Processing ---
{
    "name": "Document.Characters.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "charCount = documentObject.Characters.Count",
    "description": "傳回指定文件中字元 (包括空格和非列印字元) 的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' MsgBox \"此文件包含 \" & wdDoc.Characters.Count & \" 個字元。\"", "explanation": "計算並顯示活動文件中的總字元數。"}
    ],
    "keywords": ["word character count", "number of characters", "字元計數"]
},
{
    "name": "Selection.Font Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set fontObj = selectionObject.Font",
    "description": "傳回或設定一個 Font 物件，代表指定選取範圍的字元格式。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdSel As Object ' Word.Selection\n' Set wdSel = Application.Selection ' Assuming Word is active app\n' If wdSel.Type <> wdSelectionIP Then ' If something is selected (not just cursor)\n'   wdSel.Font.Name = \"Arial\"\n'   wdSel.Font.Size = 12\n'   wdSel.Font.Bold = True\n'   MsgBox \"選取文字的字型已更新。\"\n' End If", "explanation": "如果 Word 中有文字被選取，則將選取文字的字型設為 Arial、大小12且粗體。"}
    ],
    "keywords": ["word selection font", "format selected text word", "選取文字字型"]
},
// --- Outlook Mail & Item Management ---
{
    "name": "MailItem.UnRead Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.UnRead [= Boolean]",
    "description": "設定或傳回一個布林值，如果 Outlook 項目尚未開啟 (讀取)，則為 True。",
    "parameters": [{"name": "Boolean", "description": "True 表示標記為未讀，False 表示標記為已讀。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.ActiveExplorer.Selection.Item(1) ' Get selected email\n' If TypeName(olMail) = \"MailItem\" Then\n'   If olMail.UnRead Then\n'     MsgBox \"此郵件是未讀的。現在將其標記為已讀。\"\n'     olMail.UnRead = False\n'     olMail.Save ' To persist the UnRead change if it's not an item in a store that auto-saves\n'   Else\n'     MsgBox \"此郵件是已讀的。\"\n'   End If\n' End If", "explanation": "檢查所選郵件是否未讀，如果是，則將其標記為已讀並儲存變更。"}
    ],
    "keywords": ["outlook unread email", "mark as read", "mark as unread", "未讀郵件", "標記已讀"]
},
{
    "name": "TaskItem.Status Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "taskItemObject.Status = OlTaskStatusConstant\ncurrentStatus = taskItemObject.Status",
    "description": "設定或傳回一個 OlTaskStatus 常數，表示任務的狀態。",
    "parameters": [{"name": "OlTaskStatusConstant", "description": "olTaskNotStarted (0), olTaskInProgress (1), olTaskComplete (2), olTaskWaiting (3), olTaskDeferred (4)。"}],
    "examples": [
        {"code": "Dim olTask As Object ' Outlook.TaskItem\n' Set olTask = Application.CreateItem(olTaskItem)\n' olTask.Subject = \"完成季度報告\"\n' olTask.Status = 1 ' olTaskInProgress\n' olTask.Display\n' MsgBox \"任務狀態設為: \" & olTask.StatusReport ' StatusReport provides string representation", "explanation": "建立一個新任務，將其狀態設為「進行中」(olTaskInProgress)，然後顯示任務。"}
    ],
    "keywords": ["outlook task status", "set task progress", "任務狀態", "進度"]
},
// --- PowerPoint Presentation Creation ---
{
    "name": "Slide.Name Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideObject.Name [= stringName]",
    "description": "設定或傳回指定投影片的名稱。此名稱可以用於透過 Slides 集合的 Item 方法來存取投影片。",
    "parameters": [{"name": "stringName", "description": "投影片的新名稱。"}],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\n' Set pptSlide = ActivePresentation.Slides(1)\n' pptSlide.Name = \"IntroductionSlide\"\n' MsgBox \"第一張投影片的名稱已設為: \" & pptSlide.Name\n' Set pptSlide = ActivePresentation.Slides(\"IntroductionSlide\") ' Access by new name\n' pptSlide.Select", "explanation": "將第一張投影片的名稱設為 \"IntroductionSlide\"，然後再通過新名稱來選取它。"}
    ],
    "keywords": ["powerpoint slide name", "rename slide", "投影片命名", "重命名幻燈片"]
},
// --- File & Folder Management ---
{
    "name": "FileSystemObject.File.Copy (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "fileObject.Copy(Destination As String, [OverWriteFiles As Boolean = True])",
    "description": "複製一個檔案到新的位置。這是 File 物件的方法。",
    "parameters": [
        {"name": "Destination", "description": "必需。檔案複製的目標路徑和新檔名。"},
        {"name": "OverWriteFiles", "description": "可選。True (預設) 表示如果目標檔案已存在則覆蓋。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, sourceFile As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.FileExists(\"C:\\Temp\\Source.txt\") Then\n  Set sourceFile = fso.GetFile(\"C:\\Temp\\Source.txt\")\n  sourceFile.Copy \"C:\\Backup\\Source_Copy.txt\", True\n  MsgBox \"檔案已複製到 C:\\Backup\\Source_Copy.txt\"\nElse\n  MsgBox \"源檔案 C:\\Temp\\Source.txt 未找到。\"\nEnd If", "explanation": "獲取一個 File 物件，然後使用其 Copy 方法將檔案複製到新位置。"}
    ],
    "keywords": ["fso file copy", "copy file object", "filesystemobject copy", "檔案物件複製"]
},
// --- Math, Date & Time ---
{
    "name": "MonthName Function (Abbreviate)",
    "category": "數學、日期與時間",
    "syntax": "MonthName(month As Long, [abbreviate As Boolean = False]) As String",
    "description": "傳回代表指定月份名稱的字串。abbreviate 引數設為 True 時傳回縮寫月份名稱。",
    "parameters": [
        {"name": "month", "description": "必需。1 到 12 之間的月份數字。"},
        {"name": "abbreviate", "description": "可選。True 表示縮寫。"}
    ],
    "examples": [
        {"code": "MsgBox \"一月的縮寫: \" & MonthName(1, True)\nMsgBox \"十二月的完整名稱: \" & MonthName(12, False)", "explanation": "顯示一月的縮寫月份名稱和十二月的完整月份名稱。"}
    ],
    "keywords": ["monthname abbreviate", "short month name", "月份名稱縮寫"]
},
// --- Program Flow ---
{
    "name": "DoEvents (When to use)",
    "category": "程式流程與結構控制",
    "description": "DoEvents 應在長時間執行的迴圈或過程中策略性地使用，以允許UI更新、處理掛起的作業系統訊息 (如鍵盤或滑鼠事件)，並避免應用程式顯示「無回應」。不應在每次迴圈迭代中都呼叫它，因為 DoEvents 本身也有開銷。通常每隔一定數量的迭代 (例如每100或1000次) 或每隔一小段時間呼叫一次。",
    "parameters": [],
    "examples": [
        {"code": "For i = 1 To 10000\n  ' Some processing\n  If i Mod 500 = 0 Then ' Every 500 iterations\n    DoEvents\n    Application.StatusBar = \"Processed \" & i & \" records...\"\n  End If\nNext i\nApplication.StatusBar = False", "explanation": "在一個長迴圈中，每500次迭代呼叫一次 DoEvents，並更新狀態列。"}
    ],
    "keywords": ["doevents usage", "when to use doevents", "vba responsiveness", "DoEvents使用時機"]
},
{
    "name": "Worksheet.Visible Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Visible [= xlSheetVisibility]",
    "description": "設定或傳回一個 XlSheetVisibility 常數，決定物件是否可見。可以是 xlSheetVisible (可見), xlSheetHidden (隱藏，可從UI取消隱藏), 或 xlSheetVeryHidden (非常隱藏，只能透過VBA取消隱藏)。",
    "parameters": [{"name": "xlSheetVisibility", "description": "指定可見性狀態的常數。"}],
    "examples": [
        {"code": "Sheets(\"SensitiveData\").Visible = xlSheetVeryHidden\nMsgBox \"'SensitiveData' 工作表已設為非常隱藏。\"", "explanation": "將名為 \"SensitiveData\" 的工作表設定為非常隱藏模式。"},
        {"code": "If Sheets(\"Sheet1\").Visible = xlSheetVisible Then Sheets(\"Sheet1\").Visible = xlSheetHidden", "explanation": "如果 Sheet1 是可見的，則將其隱藏。"}
    ],
    "keywords": ["隱藏工作表", "顯示工作表", "非常隱藏", "excel sheet visibility", "hide sheet", "unhide sheet", "xlsheetveryhidden"]
},
{
    "name": "Range.NumberFormatLocal Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.NumberFormatLocal [= formatStringLocal]",
    "description": "設定或傳回物件的數字格式代碼 (字串)，使用使用者語言的格式代碼。",
    "parameters": [{"name": "formatStringLocal", "description": "表示數字格式的本地化字串代碼 (例如，在某些地區可能是 \"yyyy.mm.dd\" 而不是 \"yyyy-mm-dd\")。"}],
    "examples": [
        {"code": "Range(\"A1\").Value = Date\nRange(\"A1\").NumberFormatLocal = \"yyyy\"\"年\"\"m\"\"月\"\"d\"\"日\"\"\" ' 適用於支援此格式的地區設定\nMsgBox \"A1 的本地化日期格式值: \" & Range(\"A1\").Text", "explanation": "將儲存格 A1 的日期格式設定為本地化的中文日期格式。"}
    ],
    "keywords": ["數字格式本地化", "日期格式本地化", "excel numberformatlocal", "localized format"]
},
// --- Word Document Processing ---
{
    "name": "Selection.TypeParagraph (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.TypeParagraph",
    "description": "在目前的選取範圍或插入點處插入一個新的空白段落 (即按下 ENTER 鍵的效果)。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdApp As Object ' Word.Application\n' Set wdApp = CreateObject(\"Word.Application\")\n' wdApp.Visible = True\n' wdApp.Documents.Add\n' wdApp.Selection.TypeText \"第一段。\"\n' wdApp.Selection.TypeParagraph ' Insert a new paragraph mark\n' wdApp.Selection.TypeText \"這是新段落的開始。\"", "explanation": "在輸入一些文字後，使用 TypeParagraph 插入一個新的段落標記，然後繼續輸入文字到新段落。"}
    ],
    "keywords": ["word type paragraph", "insert new paragraph word", "enter key vba", "插入新段落"]
},
{
    "name": "Document.Variables Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set docVars = documentObject.Variables\ndocVars.Add Name:=\"VarName\", Value:=\"VarValue\"",
    "description": "傳回一個 Variables 集合，代表儲存在指定文件中的變數。文件變數可用於儲存與文件相關的字串資訊。",
    "parameters": [{"name": ".Add(Name, Value)", "description": "方法：新增一個文件變數。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' On Error Resume Next ' In case variable already exists\n' wdDoc.Variables.Add Name:=\"DocumentVersion\", Value:=\"2.1\"\n' If Err.Number <> 0 Then wdDoc.Variables(\"DocumentVersion\").Value = \"2.1.1\" ' Update if exists\n' Err.Clear\n' On Error GoTo 0\n' MsgBox \"文件版本: \" & wdDoc.Variables(\"DocumentVersion\").Value", "explanation": "新增或更新一個名為 \"DocumentVersion\" 的文件變數，並顯示其值。"}
    ],
    "keywords": ["word document variables", "store data in document", "docvariable", "文件變數"]
},
// --- Outlook Mail & Item Management ---
{
    "name": "Explorer.CurrentFolder Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set currentMAPIFolder = outlookApplicationObject.ActiveExplorer.CurrentFolder",
    "description": "傳回一個 MAPIFolder 物件，代表 Outlook 應用程式活動瀏覽器中目前顯示的資料夾。",
    "parameters": [],
    "examples": [
        {"code": "Dim olApp As Object ' Outlook.Application\nDim currentFolder As Object ' Outlook.MAPIFolder\n' Set olApp = CreateObject(\"Outlook.Application\")\n' Set currentFolder = olApp.ActiveExplorer.CurrentFolder\n' If Not currentFolder Is Nothing Then\n'   MsgBox \"Outlook 中目前選取的資料夾是: \" & currentFolder.Name & vbCrLf & _\n'          \"路徑: \" & currentFolder.FolderPath\n' Else\n'   MsgBox \"沒有活動的 Outlook 瀏覽器或資料夾。\"\n' End If", "explanation": "獲取 Outlook 中使用者目前正在檢視的資料夾物件，並顯示其名稱和完整路徑。"}
    ],
    "keywords": ["outlook current folder", "active explorer folder", "get selected folder", "目前資料夾"]
},
{
    "name": "Inspector.CurrentItem Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set currentOutlookItem = outlookApplicationObject.ActiveInspector.CurrentItem",
    "description": "傳回一個物件，代表 Outlook 應用程式活動檢閱器視窗 (例如，開啟的郵件、約會或連絡人視窗) 中目前顯示的 Outlook 項目。",
    "parameters": [],
    "examples": [
        {"code": "Dim olApp As Object ' Outlook.Application\nDim openedItem As Object ' Could be MailItem, AppointmentItem, etc.\n' Set olApp = CreateObject(\"Outlook.Application\")\n' On Error Resume Next ' If no inspector is active\n' Set openedItem = olApp.ActiveInspector.CurrentItem\n' On Error GoTo 0\n' If Not openedItem Is Nothing Then\n'   MsgBox \"目前開啟的 Outlook 項目主旨/標題是: \" & openedItem.Subject ' Subject is common\n'   Debug.Print \"項目類型: \" & TypeName(openedItem)\n' Else\n'   MsgBox \"沒有活動的 Outlook 檢閱器視窗。\"\n' End If", "explanation": "獲取使用者目前在 Outlook 中開啟並檢視的項目 (例如，正在閱讀的郵件或正在編輯的約會)，並顯示其主旨。"}
    ],
    "keywords": ["outlook active inspector", "current open item", "get active email", "目前開啟項目"]
},
// --- PowerPoint Presentation Creation ---
{
    "name": "Slide.Duplicate Method (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set duplicatedSlideRange = slideObject.Duplicate()",
    "description": "建立指定投影片的副本，將副本緊接在原始投影片之後插入，並傳回代表該副本的 SlideRange 物件 (包含單個 Slide)。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\nDim sourceSlide As Object ' PowerPoint.Slide\nDim newSlide As Object ' PowerPoint.Slide\n' Set pptPres = ActivePresentation\n' If pptPres.Slides.Count > 0 Then\n'   Set sourceSlide = pptPres.Slides(1) ' Duplicate the first slide\n'   Set newSlide = sourceSlide.Duplicate(1)(1) ' Duplicate returns SlideRange, access first item\n'   newSlide.Shapes.Title.TextFrame.TextRange.Text = \"這是複製的投影片標題\"\n'   MsgBox \"第一張投影片已複製，新投影片索引為 \" & newSlide.SlideIndex\n' End If", "explanation": "複製簡報中的第一張投影片，並修改新複製投影片的標題。"}
    ],
    "keywords": ["powerpoint duplicate slide", "copy slide ppt", "複製投影片", "幻燈片副本"]
},
// --- File & Folder Management ---
{
    "name": "FileSystemObject.DriveExists (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "booleanResult = fso.DriveExists(DriveSpec)",
    "description": "檢查指定的磁碟機是否存在。傳回 True 如果磁碟機存在，否則傳回 False。",
    "parameters": [{"name": "DriveSpec", "description": "必需。磁碟機代號 (例如 \"C\") 或包含磁碟機代號的完整路徑。"}],
    "examples": [
        {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.DriveExists(\"C\") Then\n  MsgBox \"磁碟機 C: 存在。\"\nElse\n  MsgBox \"磁碟機 C: 不存在或無法存取。\"\nEnd If\nIf Not fso.DriveExists(\"X\") Then MsgBox \"磁碟機 X: 通常不存在。\"", "explanation": "檢查磁碟機 C: 和一個通常不存在的磁碟機 X: 是否存在。"}
    ],
    "keywords": ["fso driveexists", "check drive exists", "validate drive letter", "檢查磁碟機是否存在"]
},
// --- Array, Collections & Dictionaries ---
{
    "name": "Dictionary.Item Property (Set/Get)",
    "category": "陣列、集合與字典",
    "syntax": "dictionaryObject.Item(Key) = NewValue\nretrievedValue = dictionaryObject.Item(Key)",
    "description": "設定或取得與 Scripting.Dictionary 物件中指定鍵關聯的項目。如果設定的鍵不存在，則會新增該鍵和項目。如果嘗試取得不存在的鍵的項目，會發生錯誤 (可以使用 Exists 方法先檢查)。Item 是 Dictionary 的預設屬性，所以 `dictionaryObject(Key)` 也等效於 `dictionaryObject.Item(Key)`。",
    "parameters": [
        {"name": "Key", "description": "必需。要設定或取得的項目的唯一鍵。"},
        {"name": "NewValue", "description": "賦予鍵的新值。"}
    ],
    "examples": [
        {"code": "Dim myDict As Object\nSet myDict = CreateObject(\"Scripting.Dictionary\")\n' Add items using .Item (or default property)\nmyDict.Item(\"Name\") = \"John Doe\"\nmyDict(\"Age\") = 30 ' Using default property\n' Modify an existing item\nmyDict.Item(\"Age\") = 31\n' Retrieve items\nDebug.Print \"Name: \" & myDict.Item(\"Name\")\nDebug.Print \"Age: \" & myDict(\"Age\")\n' Add another item\nmyDict(\"City\") = \"New York\"\nIf myDict.Exists(\"City\") Then Debug.Print \"City: \" & myDict(\"City\")", "explanation": "演示如何使用 .Item 屬性 (或預設屬性) 來新增、修改和讀取字典中的項目。"}
    ],
    "keywords": ["dictionary item", "set dictionary value", "get dictionary value", "scripting.dictionary", "字典項目", "設定字典值", "取得字典值"]
},
// --- Data Types, Conversion & Validation ---
{
    "name": "IsObject Empty Check (More Specific)",
    "category": "資料類型、轉換與驗證",
    "syntax": "If myObjectVariable Is Nothing Then ...\n' And to check if it is a valid object of a specific type:\nIf TypeOf myObjectVariable Is Excel.Worksheet Then ...",
    "description": "檢查物件變數是否為 Nothing (未初始化或已釋放)。要進一步檢查它是否為特定類型的有效物件，可以使用 TypeOf...Is 運算子 (通常用於早期繫結的物件)。",
    "parameters": [
        {"name": "Is Nothing", "description": "檢查物件變數是否未指向任何物件。"},
        {"name": "TypeOf ... Is", "description": "檢查物件變數是否為特定物件類型。"}
    ],
    "examples": [
        {"code": "Dim obj As Object, ws As Worksheet\nSet obj = CreateObject(\"Scripting.FileSystemObject\")\n' Set ws = ThisWorkbook.Sheets(1)\n\nIf obj Is Nothing Then Debug.Print \"obj 是 Nothing.\" Else Debug.Print \"obj 不是 Nothing.\"\nIf ws Is Nothing Then Debug.Print \"ws 是 Nothing.\" Else Debug.Print \"ws 不是 Nothing.\"\n\nIf Not ws Is Nothing Then\n  If TypeOf ws Is Excel.Worksheet Then\n    Debug.Print \"ws 是一個有效的 Worksheet 物件。\"\n  End If\nEnd If", "explanation": "演示如何使用 Is Nothing 來檢查物件變數是否已初始化，以及如何使用 TypeOf...Is 來檢查物件是否為特定類型 (例如 Excel.Worksheet)。"}
    ],
    "keywords": ["is object nothing", "typeof is operator", "check object type", "valid object check", "檢查物件是否為空", "檢查物件類型"]
},
{
    "name": "Range.Rows Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set rowsCollection = rangeObject.Rows",
    "description": "傳回一個 Range 物件，代表指定範圍內的所有列。如果範圍本身就是一整列或多整列，則傳回該範圍本身。",
    "parameters": [],
    "examples": [
        {"code": "Dim dataArea As Range, firstDataRow As Range\nSet dataArea = Range(\"A1:D10\")\nSet firstDataRow = dataArea.Rows(1) ' Gets the first row within dataArea (A1:D1)\nfirstDataRow.Font.Bold = True\nMsgBox \"範圍 \" & dataArea.Address & \" 的第一列 ('\" & firstDataRow.Address & \"') 已設為粗體。\"", "explanation": "獲取範圍 A1:D10 中的第一列 (即 A1:D1)，並將其字型設為粗體。"}
    ],
    "keywords": ["range rows", "access rows in range", "excel rows collection", "範圍中的列"]
},
{
    "name": "Range.Columns Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set columnsCollection = rangeObject.Columns",
    "description": "傳回一個 Range 物件，代表指定範圍內的所有欄。如果範圍本身就是一整欄或多整欄，則傳回該範圍本身。",
    "parameters": [],
    "examples": [
        {"code": "Dim dataArea As Range, secondDataCol As Range\nSet dataArea = Range(\"A1:D10\")\nSet secondDataCol = dataArea.Columns(2) ' Gets the second column within dataArea (B1:B10)\nsecondDataCol.Interior.Color = vbYellow\nMsgBox \"範圍 \" & dataArea.Address & \" 的第二欄 ('\" & secondDataCol.Address & \"') 已設為黃色背景。\"", "explanation": "獲取範圍 A1:D10 中的第二欄 (即 B1:B10)，並將其背景設為黃色。"}
    ],
    "keywords": ["range columns", "access columns in range", "excel columns collection", "範圍中的欄"]
},
// --- Word Document Processing ---
{
    "name": "Document.Sentences Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set sentencesColl = documentObject.Sentences",
    "description": "傳回一個 Sentences 集合，代表文件中的所有句子。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim sent As Object ' Word.Range (representing a sentence)\nDim sentenceCount As Long\n' Set wdDoc = ActiveDocument\n' sentenceCount = wdDoc.Sentences.Count\n' MsgBox \"此文件共有 \" & sentenceCount & \" 個句子。\"\n' If sentenceCount > 0 Then\n'   Debug.Print \"第一個句子: \" & Trim(wdDoc.Sentences(1).Text)\n' End If", "explanation": "計算活動文件中的句子數量，並列印第一個句子的內容。"}
    ],
    "keywords": ["word sentences collection", "iterate sentences", "document text structure", "句子集合", "遍歷句子"]
},
// --- Outlook Mail & Item Management ---
{
    "name": "MailItem.Categories Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.Categories [= categoryString]",
    "description": "設定或傳回一個字串，表示指派給 Outlook 項目的類別。多個類別以逗號或分號分隔 (取決於 Outlook 設定)。",
    "parameters": [{"name": "categoryString", "description": "包含一個或多個類別名稱的字串。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   olMail.Categories = \"重要客戶, 待處理\"\n'   olMail.Save\n'   MsgBox \"郵件類別已設定為: \" & olMail.Categories\n' End If", "explanation": "為所選郵件設定兩個類別：「重要客戶」和「待處理」。"}
    ],
    "keywords": ["outlook categories", "set email category", "categorize mail", "郵件分類", "標記類別"]
},
// --- PowerPoint Presentation Creation ---
{
    "name": "Shapes.AddConnector (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set connShape = slideObject.Shapes.AddConnector(Type As MsoConnectorType, BeginX As Single, BeginY As Single, EndX As Single, EndY As Single)",
    "description": "在投影片上新增一個連接線圖案。",
    "parameters": [
        {"name": "Type", "description": "必需。MsoConnectorType 常數 (例如 msoConnectorStraight, msoConnectorElbow, msoConnectorCurve)。"},
        {"name": "BeginX, BeginY", "description": "必需。連接線起點的水平和垂直位置。"},
        {"name": "EndX, EndY", "description": "必需。連接線終點的水平和垂直位置。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim connector As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set connector = pptSlide.Shapes.AddConnector(msoConnectorStraight, 100, 100, 300, 150)\n' With connector.Line\n'   .ForeColor.RGB = RGB(255, 0, 0) ' Red line\n'   .Weight = 2 ' Line thickness\n'   .EndArrowheadStyle = msoArrowheadTriangle\n' End With\n' MsgBox \"已新增紅色直線箭頭連接線。\"", "explanation": "在第一張投影片上新增一條從 (100,100) 到 (300,150) 的紅色直線連接線，並帶有箭頭。"}
    ],
    "keywords": ["powerpoint add connector", "insert line shape ppt", "drawing connector", "新增連接線"]
},
// --- File & Folder Management (FSO) ---
{
    "name": "FileSystemObject.File.Move (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "fileObject.Move(Destination As String)",
    "description": "將一個檔案從目前位置移動到新的位置。這是 File 物件的方法。",
    "parameters": [{"name": "Destination", "description": "必需。檔案要移動到的目標路徑 (可以包含新檔名)。"}],
    "examples": [
        {"code": "Dim fso As Object, sourceFile As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.FileExists(\"C:\\Temp\\ToMove.txt\") Then\n  Set sourceFile = fso.GetFile(\"C:\\Temp\\ToMove.txt\")\n  sourceFile.Move \"C:\\Archive\\MovedFile.txt\"\n  MsgBox \"檔案已移動到 C:\\Archive\\MovedFile.txt\"\nElse\n  MsgBox \"源檔案 C:\\Temp\\ToMove.txt 未找到。\"\nEnd If", "explanation": "獲取一個 File 物件，然後使用其 Move 方法將檔案移動到新位置並可重命名。"}
    ],
    "keywords": ["fso file move", "move file object", "filesystemobject move", "檔案物件移動"]
},
// --- String & Text Manipulation ---
{
    "name": "String Function (Repeat Character)",
    "category": "字串與文本操作",
    "syntax": "String(Number As Long, Character) As String",
    "description": "傳回一個由重複字元組成的字串。Character 可以是字元碼 (數字) 或字串表達式的第一個字元。",
    "parameters": [
        {"name": "Number", "description": "必需。字串的長度。"},
        {"name": "Character", "description": "必需。字元碼或字串。"}
    ],
    "examples": [
        {"code": "Debug.Print String(10, \"*\")  ' Output: **********\nDebug.Print String(5, 65)   ' Output: AAAAA (65 is ASCII for 'A')\nDebug.Print String(3, \"xyz\") ' Output: xxx (uses first char of \"xyz\")", "explanation": "演示如何使用 String 函數創建由重複的星號、字元'A' (透過 ASCII 碼) 或字串的第一個字元組成的字串。"}
    ],
    "keywords": ["string function", "repeat character", "fill string", "重複字元", "填充字串"]
},
// --- Math, Date & Time ---
{
    "name": "FormatPercent Function",
    "category": "數學、日期與時間",
    "syntax": "FormatPercent(Expression, [NumDigitsAfterDecimal As Long = -1], [IncludeLeadingDigit As VbTriState = vbUseDefault], [UseParensForNegativeNumbers As VbTriState = vbUseDefault], [GroupDigits As VbTriState = vbUseDefault]) As String",
    "description": "傳回一個格式化為百分比 (即乘以 100) 並帶有尾隨 % 符號的運算式字串。",
    "parameters": [
        {"name": "Expression", "description": "必需。要格式化的數值運算式。"},
        {"name": "NumDigitsAfterDecimal", "description": "可選。顯示小數點右側的位數。-1 (預設) 表示使用系統設定。"}
    ],
    "examples": [
        {"code": "Debug.Print FormatPercent(0.75)    ' Output: 75.00% (or system default precision)\nDebug.Print FormatPercent(0.12345, 1) ' Output: 12.3%\nDebug.Print FormatPercent(2.5, 0)     ' Output: 250%", "explanation": "演示如何使用 FormatPercent 將小數轉換為帶有百分號的百分比字串，並可控制小數位數。"}
    ],
    "keywords": ["formatpercent", "percentage format", "number to percent string", "格式化百分比"]
},
// --- Data Types, Conversion & Validation ---
{
    "name": "VarType Function (Return Values)",
    "category": "資料類型、轉換與驗證",
    "description": "VarType 函數傳回一個整數，代表變數的資料子類型。常見的傳回值及其對應的 VbVarType 常數包括：vbEmpty (0), vbNull (1), vbInteger (2), vbLong (3), vbSingle (4), vbDouble (5), vbCurrency (6), vbDate (7), vbString (8), vbObject (9), vbBoolean (11), vbVariant (12, 如果包含陣列，則加上 vbArray), vbDataObject (13), vbByte (17), vbArray (8192)。",
    "parameters": [{"name": "varname", "description": "必需。任何變數。"}],
    "examples": [
        {"code": "Dim myVar As Variant, myArr(2) As Integer\nDebug.Print \"Integer: \" & VarType(10) & \" (vbInteger = \" & vbInteger & \")\"\nDebug.Print \"String: \" & VarType(\"Hello\") & \" (vbString = \" & vbString & \")\"\nDebug.Print \"Date: \" & VarType(Now) & \" (vbDate = \" & vbDate & \")\"\nDebug.Print \"Object (Worksheet): \" & VarType(ActiveSheet) & \" (vbObject = \" & vbObject & \")\"\nDebug.Print \"Array of Integers: \" & VarType(myArr) & \" (vbInteger + vbArray = \" & vbInteger + vbArray & \")\"\nDebug.Print \"Empty Variant: \" & VarType(myVar) & \" (vbEmpty = \" & vbEmpty & \")\"", "explanation": "顯示不同資料類型變數的 VarType 傳回值及其對應的 VbVarType 常數值。"}
    ],
    "keywords": ["vartype constants", "vbvartype", "data subtype", "check variable type code", "變數類型代碼"]
},
// --- Program Flow ---
{
    "name": "Declare Function with PtrSafe and LongPtr (64-bit)",
    "category": "程式流程與結構控制",
    "description": "在64位元Office環境中宣告Windows API函數時，必須使用 PtrSafe 關鍵字。此外，任何代表指標或控制代碼的參數或函數傳回類型，如果原本在32位元中是 Long 類型，則應改為 LongPtr 類型，以確保在32位元和64位元系統上的兼容性。",
    "parameters": [
        {"name": "PtrSafe", "description": "指示 Declare 語句在64位元環境中是安全的。"},
        {"name": "LongPtr", "description": "一種資料類型，在32位元系統中為 Long，在64位元系統中為 LongLong。用於指標和控制代碼。"}
    ],
    "examples": [
        {"code": "#If VBA7 Then ' VBA7 is Office 2010 and later\n  #If Win64 Then ' Checks if it's 64-bit Windows Office\n    Private Declare PtrSafe Function GetActiveWindow Lib \"user32\" () As LongPtr\n  #Else ' 32-bit Windows Office\n    Private Declare Function GetActiveWindow Lib \"user32\" () As Long\n  #End If\n#Else ' Pre-VBA7 (Office 2007 and earlier, always 32-bit)\n  Private Declare Function GetActiveWindow Lib \"user32\" () As Long\n#End If\n\nSub ShowActiveWindowHandle()\n  #If VBA7 Then\n    Dim hwnd As LongPtr\n  #Else\n    Dim hwnd As Long\n  #End If\n  hwnd = GetActiveWindow()\n  MsgBox \"目前活動視窗的控制代碼是: \" & hwnd\nEnd Sub", "explanation": "演示如何使用條件式編譯 (#If VBA7 ... #If Win64 ...) 來為32位元和64位元Office環境正確宣告 GetActiveWindow API 函數，使用 PtrSafe 和 LongPtr。"}
    ],
    "keywords": ["ptrsafe", "longptr", "64-bit vba", "windows api 64bit", "declare function 64bit", "64位元API宣告"]
},
// --- 90 new commands ---
// --- Excel Core Operations ---
{
    "name": "Worksheet.StandardHeight Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "points = worksheetObject.StandardHeight",
    "description": "傳回工作表中所有列的標準 (預設) 高度，以點為單位。此屬性是唯讀的；要設定預設列高，請格式化 Normal 樣式或直接設定特定列的 RowHeight。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"活動工作表的標準列高是: \" & ActiveSheet.StandardHeight & \" 點。\"", "explanation": "顯示活動工作表的標準列高。"}
    ],
    "keywords": ["標準列高", "預設列高", "excel standard row height", "default row height"]
},
{
    "name": "Application.DefaultFilePath Property (Excel/Word/PowerPoint)",
    "category": "Excel 核心操作",
    "syntax": "pathString = Application.DefaultFilePath([Path As XlPathName = xlUserDocuments])",
    "description": "傳回或設定應用程式用於開啟或儲存檔案的預設資料夾路徑。在 Excel 中，Path 引數可以是 XlPathName 常數 (例如 xlUserDocuments, xlLocalUserTemplates)。在 Word/PowerPoint 中，通常不帶參數，傳回預設的「文件」資料夾。",
    "parameters": [{"name": "Path (Excel)", "description": "XlPathName 常數，指定要取得或設定的路徑類型。"}],
    "examples": [
        {"code": "' In Excel:\nMsgBox \"預設的使用者文件路徑: \" & Application.DefaultFilePath(1) ' 1 = xlUserDocuments\n' Application.DefaultFilePath(xlUserDocuments) = \"C:\\MyNewDefaultFolder\" ' Set new default path\n\n' In Word (typically no argument):\n' MsgBox \"Word 預設文件路徑: \" & Application.DefaultFilePath", "explanation": "在 Excel 中，獲取預設的使用者文件資料夾路徑，並示範如何設定它。在 Word 中，通常不帶參數獲取預設文件路徑。"}
    ],
    "keywords": ["預設檔案路徑", "default file path", "application path", "excel", "word", "powerpoint", "通用"]
},
// --- Word Document Processing ---
{
    "name": "Document.Paragraphs Item Method (Word)",
    "category": "Word 文件處理",
    "syntax": "Set paraObject = documentObject.Paragraphs.Item(Index As Long)",
    "description": "從 Paragraphs 集合中傳回單個 Paragraph 物件。",
    "parameters": [{"name": "Index", "description": "必需。段落的索引號 (1-based)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim thirdPara As Object ' Word.Paragraph\n' Set wdDoc = ActiveDocument\n' If wdDoc.Paragraphs.Count >= 3 Then\n'   Set thirdPara = wdDoc.Paragraphs.Item(3)\n'   thirdPara.Range.Font.ColorIndex = wdDarkRed\n'   MsgBox \"第三個段落已設為暗紅色。\"\n' Else\n'   MsgBox \"文件少於3個段落。\"\n' End If", "explanation": "如果文件至少有3個段落，則獲取第三個段落物件並將其文字顏色設為暗紅色。"}
    ],
    "keywords": ["word paragraph item", "get specific paragraph", "存取特定段落"]
},
// --- Outlook Mail & Item Management ---
{
    "name": "MailItem.HTMLBody vs .Body (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "description": "MailItem 物件有 .Body 和 .HTMLBody 兩個屬性來存取郵件正文。\n.Body：傳回或設定純文字格式的郵件正文。如果郵件是HTML格式，.Body 會傳回移除了HTML標籤的純文字近似值。\n.HTMLBody：傳回或設定HTML格式的郵件正文。如果設定此屬性，Outlook 會自動將郵件格式設為HTML。如果郵件是純文字格式，讀取此屬性會傳回轉換為HTML的近似值。\n通常建議先檢查郵件格式 (例如，`olMail.BodyFormat = olFormatHTML`)，然後使用相應的屬性。設定其中一個通常會影響另一個。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.CreateItem(olMailItem)\n' olMail.Subject = \"HTML vs Plain Text\"\n' olMail.Body = \"This is plain text first.\"\n' Debug.Print \"After setting Body, HTMLBody is: \" & Left(olMail.HTMLBody, 100)\n'\n' olMail.HTMLBody = \"<h1>Hello</h1><p>This is <b>HTML</b> text.</p>\"\n' Debug.Print \"After setting HTMLBody, Body is: \" & olMail.Body\n' olMail.Display", "explanation": "演示設定 .Body 後 .HTMLBody 的內容，以及設定 .HTMLBody 後 .Body 的內容。通常設定 HTMLBody 會覆蓋 Body。"}
    ],
    "keywords": ["outlook htmlbody vs body", "email format", "plain text vs html", "郵件格式", "純文字與HTML"]
},
// --- PowerPoint Presentation Creation ---
{
    "name": "Slide.Shapes Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set shapesColl = slideObject.Shapes",
    "description": "傳回一個 Shapes 集合，代表指定投影片上的所有圖案 (包括文字方塊、圖片、AutoShapes、圖表等)。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim shp As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides(1)\n' If pptSlide.Shapes.Count > 0 Then\n'   MsgBox \"第一張投影片有 \" & pptSlide.Shapes.Count & \" 個圖案。\"\n'   For Each shp In pptSlide.Shapes\n'     Debug.Print \"圖案名稱: \" & shp.Name & \", 類型: \" & shp.Type\n'     If shp.HasTextFrame And shp.TextFrame.HasText Then\n'       shp.TextFrame.TextRange.Font.Size = shp.TextFrame.TextRange.Font.Size + 2 ' Increase font size\n'     End If\n'   Next shp\n' Else\n'   MsgBox \"第一張投影片沒有圖案。\"\n' End If", "explanation": "計算第一張投影片上的圖案數量，並遍歷所有圖案，列印其名稱和類型，同時將包含文字的圖案的字型大小增加2點。"}
    ],
    "keywords": ["powerpoint shapes collection", "slide objects", "iterate shapes ppt", "投影片圖案集合", "遍歷圖案"]
},
// --- File & Folder Management (FSO) ---
{
    "name": "FileSystemObject.Folder.Delete (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "folderObject.Delete([Force As Boolean = False])",
    "description": "刪除指定的資料夾及其所有內容 (檔案和子資料夾)。這是 Folder 物件的方法。",
    "parameters": [{"name": "Force", "description": "可選。True 表示即使資料夾包含唯讀檔案也刪除；False (預設) 則不會刪除包含唯讀檔案的資料夾。"}],
    "examples": [
        {"code": "Dim fso As Object, targetFolder As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.FolderExists(\"C:\\Temp\\ToDeleteFolder\") Then\n  Set targetFolder = fso.GetFolder(\"C:\\Temp\\ToDeleteFolder\")\n  On Error Resume Next ' Handle potential errors during deletion\n  targetFolder.Delete True ' Force delete\n  If Err.Number = 0 Then\n    MsgBox \"資料夾 C:\\Temp\\ToDeleteFolder 及其內容已刪除。\"\n  Else\n    MsgBox \"刪除資料夾時發生錯誤: \" & Err.Description\n  End If\n  On Error GoTo 0\nElse\n  MsgBox \"資料夾 C:\\Temp\\ToDeleteFolder 未找到。\"\nEnd If", "explanation": "獲取一個 Folder 物件，然後使用其 Delete 方法強制刪除該資料夾及其所有內容。"}
    ],
    "keywords": ["fso folder delete", "delete folder object", "filesystemobject delete folder", "資料夾物件刪除"]
},
// --- String & Text Manipulation ---
{
    "name": "Like Operator (Character Lists)",
    "category": "字串與文本操作",
    "syntax": "string Like \"pattern[charlist]pattern\"",
    "description": "Like 運算子中的字元列表 `[charlist]` 允許匹配列表中任何單個字元。`[!charlist]` 則匹配任何不在列表中的單個字元。列表可以包含範圍 (例如 `[A-Z]`, `[0-9]`)。",
    "parameters": [
        {"name": "[charlist]", "description": "匹配列表中的任一字元。"},
        {"name": "[!charlist]", "description": "匹配不在列表中的任一字元。"},
        {"name": "[A-F0-9]", "description": "匹配大寫 A-F 或數字 0-9。"}
    ],
    "examples": [
        {"code": "Debug.Print \"C\" Like \"[A-Z]\"     ' True\nDebug.Print \"5\" Like \"[0-9]\"     ' True\nDebug.Print \"m\" Like \"[abc]\"     ' False\nDebug.Print \"X\" Like \"[!abc]\"    ' True\nDebug.Print \"B3\" Like \"[A-Z][0-9]\" ' True", "explanation": "演示如何使用 Like 運算子和字元列表來匹配特定模式，如大寫字母、數字、或特定字元集中的字元。"}
    ],
    "keywords": ["like operator charlist", "pattern matching character set", "vba regex like", "字元列表匹配"]
},
// --- Math, Date & Time ---
{
    "name": "Int vs Fix (Negative Numbers)",
    "category": "數學、日期與時間",
    "description": "Int 和 Fix 函數都傳回數字的整數部分。對於正數，它們的行為相同。對於負數：Int 傳回小於或等於該數字的第一個負整數 (向下取整，遠離零)。Fix 傳回大於或等於該數字的第一個負整數 (向零取整，截斷小數)。",
    "parameters": [],
    "examples": [
        {"code": "Debug.Print \"Int(5.8) = \" & Int(5.8)   ' Output: 5\nDebug.Print \"Fix(5.8) = \" & Fix(5.8)   ' Output: 5\nDebug.Print \"Int(-5.2) = \" & Int(-5.2)  ' Output: -6 (rounds down, away from zero)\nDebug.Print \"Fix(-5.2) = \" & Fix(-5.2)  ' Output: -5 (truncates, towards zero)\nDebug.Print \"Int(-5.8) = \" & Int(-5.8)  ' Output: -6\nDebug.Print \"Fix(-5.8) = \" & Fix(-5.8)  ' Output: -5", "explanation": "比較 Int 和 Fix 函數在處理正數和負數時的行為差異，特別是對於負小數。"}
    ],
    "keywords": ["int vs fix", "truncate vs floor negative", "integer part negative", "取整差異負數"]
},
// --- Data Types, Conversion & Validation ---
{
    "name": "vbNullChar Constant",
    "category": "資料類型、轉換與驗證",
    "syntax": "vbNullChar",
    "description": "一個內建常數，代表值為 0 的字元。它不等同於 vbNullString (空字串指標) 或空字串 \"\"。vbNullChar 通常用於需要傳遞 C 樣式空結尾字串給 API 函數的字串緩衝區的結尾。",
    "parameters": [],
    "examples": [
        {"code": "Dim myString As String\nmyString = \"Hello\" & vbNullChar & \"World\"\nDebug.Print \"Length including vbNullChar: \" & Len(myString) ' Len treats vbNullChar as one char\nDebug.Print \"String: \" & myString ' Output may stop at vbNullChar depending on how it's printed\n' When passing to an API expecting a null-terminated string, VBA strings are often already handled\n' or you might build a byte array and append a 0 byte.", "explanation": "演示 vbNullChar 代表一個值為0的字元。在 VBA 字串中，它被視為一個字元。其主要用途是在與期望空結尾字串的外部函數 (API) 交互時。"}
    ],
    "keywords": ["vbnullchar", "null character", "string termination", "api string buffer", "空字元", "字串結束符"]
},
// --- Program Flow ---
{
    "name": "Option Private Module",
    "category": "程式流程與結構控制",
    "syntax": "Option Private Module",
    "description": "在模組的宣告區使用此語句，可以將整個模組標記為私有。這意味著模組中宣告為 Public 的變數、常數、程序和類別，只在定義它們的專案中可用，而不能被其他引用此專案的專案存取。預設情況下，標準模組中的 Public 成員是可以跨專案引用的。",
    "parameters": [],
    "examples": [
        {"code": "' At the top of a Standard Module (e.g., Module1):\n' Option Private Module\n'\n' Public MyPublicVar As String ' This var is public within this project only\n' Public Sub MyPublicSub()\n'   MsgBox \"This sub is public within this project only.\"\n' End Sub\n'\n' ' In another project that references this project, MyPublicVar and MyPublicSub\n' ' would NOT be accessible.", "explanation": "將 Option Private Module 放在模組頂部，可以限制該模組中所有 Public 成員的範圍，使其僅在目前專案內部可見，即使該專案被其他專案引用。"}
    ],
    "keywords": ["option private module", "module scope", "project level access", "vba library protection", "模組私有", "專案範圍"]
},
// --- Final 10 to reach 100 (total of 90+10=100) ---
{
    "name": "Workbook.ChangeLink (Excel)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.ChangeLink(Name As String, NewName As String, [Type As XlLinkType = xlLinkTypeExcelLinks])",
    "description": "變更活頁簿中連結的來源。",
    "parameters": [
        {"name": "Name", "description": "必需。要變更的連結的原始來源檔案名稱 (字串)。"},
        {"name": "NewName", "description": "必需。新的連結來源檔案名稱 (字串)。"},
        {"name": "Type", "description": "可選。XlLinkType 常數，指定連結類型。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook\nSet wb = ActiveWorkbook\n' On Error Resume Next ' Handle if link doesn't exist\n' wb.ChangeLink Name:=\"C:\\OldData\\SourceData.xlsx\", NewName:=\"C:\\NewData\\UpdatedSource.xlsx\", Type:=xlLinkTypeExcelLinks\n' If Err.Number = 0 Then MsgBox \"連結來源已更新。\" Else MsgBox \"更新連結失敗: \" & Err.Description\n' On Error GoTo 0", "explanation": "嘗試將活動活頁簿中對 \"C:\\OldData\\SourceData.xlsx\" 的連結變更為 \"C:\\NewData\\UpdatedSource.xlsx\"。"}
    ],
    "keywords": ["excel change link", "update external links", "workbook links", "變更連結來源", "更新外部連結"]
},
{
    "name": "Range.TextToColumns (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.TextToColumns(Destination As Range, DataType As XlTextParsingType, [TextQualifier As XlTextQualifier = xlTextQualifierDoubleQuote], [ConsecutiveDelimiter As Boolean = False], [Tab As Boolean = True], [Semicolon As Boolean = False], [Comma As Boolean = False], [Space As Boolean = False], [Other As Boolean = False], [OtherChar], [FieldInfo], [DecimalSeparator], [ThousandsSeparator], [TrailingMinusNumbers])",
    "description": "將包含文字的儲存格範圍解析成多個欄。",
    "parameters": [
        {"name": "Destination", "description": "必需。Range 物件，指定解析後的資料放置的左上角儲存格。"},
        {"name": "DataType", "description": "必需。XlTextParsingType 常數 (xlDelimited 或 xlFixedWidth)。"},
        {"name": "Comma", "description": "可選。True 表示使用逗號作為分隔符號。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Apple,Banana,Orange\"\n' Parse A1 into B1, C1, D1 using comma as delimiter\nRange(\"A1\").TextToColumns Destination:=Range(\"B1\"), DataType:=xlDelimited, Comma:=True", "explanation": "將儲存格 A1 中以逗號分隔的文字，解析並分別放入 B1, C1, D1 儲存格。"}
    ],
    "keywords": ["text to columns", "parse text", "split cell content", "資料剖析", "文字分欄"]
},
{
    "name": "Document.Undo / .Redo (Word)",
    "category": "Word 文件處理",
    "syntax": "canUndo = documentObject.Undo([Times As Long = 1])\ncanRedo = documentObject.Redo([Times As Long = 1])",
    "description": "Undo 方法撤銷上次使用者介面執行的動作或一系列動作。Redo 方法反轉 Undo 的效果。這些方法傳回 True 如果動作成功。",
    "parameters": [{"name": "Times", "description": "可選。要撤銷或重做的動作次數。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.Content.InsertAfter \"Some text. \"\n' If wdDoc.Undo(1) Then MsgBox \"已撤銷上次動作。\"\n' Application.Wait Now + TimeValue(\"0:00:01\")\n' If wdDoc.Redo(1) Then MsgBox \"已重做上次撤銷的動作。\"", "explanation": "在文件中插入文字，然後撤銷該插入，等待一秒，再重做該插入。"}
    ],
    "keywords": ["word undo", "word redo", "撤銷動作", "重做動作"]
},
{
    "name": "TaskItem.PercentComplete Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "taskItemObject.PercentComplete [= Single]",
    "description": "設定或傳回一個 Single 值 (0 到 1)，表示任務的完成百分比。",
    "parameters": [{"name": "Single", "description": "0.0 (0%) 到 1.0 (100%) 之間的值。"}],
    "examples": [
        {"code": "Dim olTask As Object ' Outlook.TaskItem\n' Set olTask = Application.CreateItem(olTaskItem)\n' olTask.Subject = \"撰寫報告初稿\"\n' olTask.PercentComplete = 0.5 ' 50% complete\n' If olTask.PercentComplete = 1 Then olTask.Status = olTaskComplete\n' olTask.Display", "explanation": "建立一個新任務，將其完成百分比設為 50%。如果完成百分比達到100%，則同時更新任務狀態為完成。"}
    ],
    "keywords": ["outlook task percent complete", "task progress", "任務完成百分比"]
},
{
    "name": "SlideRange.PublishSlides Method (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideRangeObject.PublishSlides(SlideLibraryUrl As String, [Overwrite As Boolean = False], [UseSlideOrder As Boolean = True])",
    "description": "將指定的投影片發佈到 SharePoint Slide Library。此功能需要 SharePoint 環境。",
    "parameters": [
        {"name": "SlideLibraryUrl", "description": "必需。SharePoint 投影片庫的 URL。"},
        {"name": "Overwrite", "description": "可選。如果投影片庫中已存在同名投影片，True 表示覆蓋。"}
    ],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\n' Set pptPres = ActivePresentation\n' ' Ensure a Slide Library URL is valid and accessible\n' Const SLIDE_LIB_URL As String = \"http://sharepoint/sites/MySite/SlideLib/\"\n' On Error Resume Next\n' pptPres.Slides.Range(Array(1, 3)).PublishSlides SLIDE_LIB_URL, True ' Publish slides 1 and 3\n' If Err.Number = 0 Then\n'   MsgBox \"選定的投影片已發佈到 SharePoint 投影片庫。\"\n' Else\n'   MsgBox \"發佈投影片失敗: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "將目前簡報中的第1張和第3張投影片發佈到指定的 SharePoint 投影片庫，並允許覆蓋。"}
    ],
    "keywords": ["powerpoint publish slides", "sharepoint slide library", "發佈投影片", "投影片庫"]
},
{
    "name": "FileSystemObject.Folder.ShortPath (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "shortPathString = folderObject.ShortPath",
    "description": "傳回資料夾的短路徑名稱 (8.3 格式)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myFolder As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Set myFolder = fso.GetFolder(\"C:\\Program Files (x86)\") ' Example path that might have short name\n' If Not myFolder Is Nothing Then\n'   MsgBox \"資料夾 '\" & myFolder.Name & \"' 的短路徑是: \" & myFolder.ShortPath\n' End If", "explanation": "獲取 \"C:\\Program Files (x86)\" 資料夾 (或類似長名稱資料夾) 的 8.3 格式短路徑。"}
    ],
    "keywords": ["fso shortpath", "8.3 path name", "dos path", "短路徑"]
},
{
    "name": "LSet Statement (String Alignment)",
    "category": "字串與文本操作",
    "syntax": "LSet StringVariable = StringExpression\nLSet UserDefinedTypeVariable.StringMember = StringExpression",
    "description": "將字串左對齊地複製到另一個固定長度字串變數中，或者將一個字串左對齊地複製到使用者定義型別中的字串成員。如果來源字串比目標短，則右邊用空格填充；如果來源字串比目標長，則右邊被截斷。",
    "parameters": [],
    "examples": [
        {"code": "Dim fixedLenStr As String * 10 ' Declare a fixed-length string of 10 chars\nDim sourceStr As String: sourceStr = \"ABC\"\nLSet fixedLenStr = sourceStr\nDebug.Print \"'\" & fixedLenStr & \"'\" ' Output: 'ABC       '\n\nDim shortFixed As String * 3\nLSet shortFixed = \"Hello\"\nDebug.Print \"'\" & shortFixed & \"'\"  ' Output: 'Hel'", "explanation": "第一個範例將 \"ABC\" 左對齊放入一個長度為10的固定長度字串，右側補空格。第二個範例將 \"Hello\" 放入長度為3的固定長度字串，導致截斷。"}
    ],
    "keywords": ["lset statement", "left align string", "fixed length string", "左對齊字串", "固定長度字串"]
},
{
    "name": "RSet Statement (String Alignment)",
    "category": "字串與文本操作",
    "syntax": "RSet StringVariable = StringExpression",
    "description": "將字串右對齊地複製到另一個固定長度字串變數中。如果來源字串比目標短，則左邊用空格填充；如果來源字串比目標長，則右邊被截斷。",
    "parameters": [],
    "examples": [
        {"code": "Dim fixedLenStr As String * 10\nDim sourceStr As String: sourceStr = \"XYZ\"\nRSet fixedLenStr = sourceStr\nDebug.Print \"'\" & fixedLenStr & \"'\" ' Output: '       XYZ'\n\nDim shortFixed As String * 2\nRSet shortFixed = \"Test\"\nDebug.Print \"'\" & shortFixed & \"'\"  ' Output: 'Te' (截斷右邊)", "explanation": "第一個範例將 \"XYZ\" 右對齊放入一個長度為10的固定長度字串，左側補空格。第二個範例將 \"Test\" 放入長度為2的固定長度字串，導致截斷。"}
    ],
    "keywords": ["rset statement", "right align string", "fixed length string", "右對齊字串", "固定長度字串"]
},
{
    "name": "Timer (Usage for Delays)",
    "category": "數學、日期與時間",
    "syntax": "Dim PauseTime, Start\nPauseTime = 2 ' Set duration in seconds\nStart = Timer ' Set start time.\nDo While Timer < Start + PauseTime\n  DoEvents ' Yield to other processes.\nLoop",
    "description": "使用 Timer 函數和一個 Do While 迴圈來創建一個指定秒數的延遲，同時在迴圈中使用 DoEvents 保持應用程式的回應性。這比 Application.Wait 更靈活，因為可以在迴圈內執行其他檢查。",
    "parameters": [{"name": "PauseTime", "description": "要延遲的秒數。"}],
    "examples": [
        {"code": "MsgBox \"程式將精確延遲 1.5 秒。\"\nDim startTime As Single, delaySeconds As Single: delaySeconds = 1.5\nstartTime = Timer\nDo While Timer < startTime + delaySeconds\n  DoEvents\nLoop\nMsgBox \"1.5 秒延遲結束。\"", "explanation": "創建一個 1.5 秒的延遲，並在等待期間允許處理其他事件。"}
    ],
    "keywords": ["timer delay", "vba pause execution", "custom delay loop", "延遲執行", "精確暫停"]
},
{
    "name": "GetSetting / SaveSetting / DeleteSetting (Registry)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "value = GetSetting(AppName, Section, Key, [Default])\nSaveSetting AppName, Section, Key, Setting\nDeleteSetting AppName, Section, [Key]",
    "description": "這些函數用於在 Windows 登錄檔中為應用程式儲存和擷取設定。AppName 通常是您的應用程式名稱。Section 是設定的分組。Key 是特定設定的名稱。Setting 是要儲存的值。僅能儲存字串值，數字會被轉換。",
    "parameters": [],
    "examples": [
        {"code": "Dim appName As String: appName = \"MyAppVBA\"\nDim lastUser As String\n' Save a setting\nSaveSetting appName, \"UserSettings\", \"LastUserName\", Application.UserName\n' Retrieve the setting\nlastUser = GetSetting(appName, \"UserSettings\", \"LastUserName\", \"DefaultUser\")\nMsgBox \"上次登錄的使用者 (從登錄檔讀取): \" & lastUser\n' Delete a specific key\n' DeleteSetting appName, \"UserSettings\", \"LastUserName\"\n' Delete a whole section\n' DeleteSetting appName, \"UserSettings\"", "explanation": "演示如何使用 SaveSetting 儲存目前 Excel 使用者名稱到登錄檔中，然後使用 GetSetting 擷取它。同時展示了如何刪除設定（註解狀態）。這些設定通常儲存在 `HKEY_CURRENT_USER\\Software\\VB and VBA Program Settings` 下。"}
    ],
    "keywords": ["getsetting", "savesetting", "deletesetting", "registry access vba", "store application settings", "讀寫登錄檔", "儲存應用程式設定"]
},
{
    "name": "Range.Cells.CountLarge",
    "category": "Excel 核心操作",
    "syntax": "countLongLong = rangeObject.Cells.CountLarge",
    "description": "傳回指定範圍中儲存格的數量，以 LongLong 資料類型表示。對於可能超過 Long 資料類型上限 (約20億) 的非常大的範圍 (例如整欄或整列的儲存格計數)，應使用此屬性而不是 .Count。",
    "parameters": [],
    "examples": [
        {"code": "Dim totalCells As LongLong\nOn Error Resume Next ' Older Excel versions might not support CountLarge\ntotalCells = Columns(\"A\").Cells.CountLarge\nIf Err.Number = 0 Then\n  MsgBox \"A欄總共有 \" & totalCells & \" 個儲存格。\"\nElse\n  MsgBox \"此Excel版本可能不支援CountLarge，或發生其他錯誤。\"\nEnd If\nOn Error GoTo 0", "explanation": "計算A欄中所有儲存格的數量。在現代Excel中，這會是一個非常大的數字。"}
    ],
    "keywords": ["儲存格計數 (大)", "範圍大小 (大)", "excel", "cell count large", "range size large", "longlong"]
},
{
    "name": "Range.Calculate",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Calculate",
    "description": "計算指定儲存格範圍中所有包含公式的儲存格。如果儲存格不包含公式，則此方法無效。",
    "parameters": [],
    "examples": [
        {"code": "Application.Calculation = xlCalculationManual\nRange(\"A1\").Formula = \"=RAND()*100\"\nRange(\"A2\").Formula = \"=RANDBETWEEN(1,1000)\"\nRange(\"A1\").Calculate ' 只重新計算 A1\nMsgBox \"A1已重新計算: \" & Range(\"A1\").Value & vbCrLf & \"A2 (未觸發計算): \" & Range(\"A2\").Value", "explanation": "將計算模式設為手動，然後僅重新計算A1儲存格中的公式。"}
    ],
    "keywords": ["計算範圍", "重新計算儲存格", "excel", "calculate range", "recalculate cell formula"]
},
{
    "name": "Range.ClearNotes",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ClearNotes",
    "description": "清除指定範圍中所有儲存格的附註 (舊版註解，與新版執行緒式註解 Comment 不同)。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").AddComment \"This is a threaded comment.\"\n' To add an old-style Note (if supported or compatibility mode):\n' On Error Resume Next\n' Range(\"B1\").NoteText \"This is an old note.\"\n' On Error GoTo 0\nRange(\"B1\").ClearNotes ' This will clear the old note from B1\nMsgBox \"B1儲存格的舊式附註 (如果存在) 已被清除。A1的新式註解不受影響。\"", "explanation": "清除B1儲存格的舊式儲存格附註。"}
    ],
    "keywords": ["清除附註", "刪除舊註解", "excel", "clear notes", "delete old comments"]
},
{
    "name": "Range.Dirty",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Dirty",
    "description": "將範圍標記為「已變動」，以便在下一次進行重新計算時，Excel 的智慧重新計算引擎會重新計算此範圍及其相依項。通常在外部資料變更或UDF的相依項變更時使用。",
    "parameters": [],
    "examples": [
        {"code": "Sub MarkRangeForRecalc()\n  ' Assume A1 is a precedent for B1, and A1's value is changed externally\n  ' This simulates that the value might have changed without Excel knowing\n  Range(\"A1\").Dirty\n  Application.Calculate ' Trigger recalculation\n  MsgBox \"範圍A1已被標記為已變動，並觸發了重新計算。\"\nEnd Sub", "explanation": "將A1儲存格標記為已變動，這樣在下一次重新計算時，依賴A1的公式會被重新計算。"}
    ],
    "keywords": ["標記重算", "智慧重算", "excel dirty range", "force recalculation"]
},
{
    "name": "Range.FormulaArray",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaArray = arrayFormulaString",
    "description": "設定或傳回範圍的陣列公式。",
    "parameters": [{"name": "arrayFormulaString", "description": "必需。R1C1 或 A1 樣式的陣列公式字串。"}],
    "examples": [
        {"code": "Range(\"C1:C3\").FormulaArray = \"=A1:A3*B1:B3\" ' Multi-cell array formula\n' For single cell array formula like {=SUM(A1:A3*B1:B3)}\nRange(\"D1\").FormulaArray = \"=SUM(A1:A3*B1:B3)\"", "explanation": "在 C1:C3 範圍內設定一個多儲存格陣列公式，並在 D1 設定一個單儲存格陣列公式。"}
    ],
    "keywords": ["陣列公式", "CSE公式", "excel array formula", "formulaarray"]
},
{
    "name": "Range.HasArray",
    "category": "Excel 核心操作",
    "syntax": "booleanResult = rangeObject.HasArray",
    "description": "如果指定的儲存格是陣列公式的一部分，則傳回 True。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1:A3\").FormulaArray = \"=ROW(1:3)\"\nIf Range(\"A1\").HasArray Then MsgBox \"A1是陣列公式的一部分。\"\nIf Range(\"A2\").HasArray Then MsgBox \"A2也是該陣列公式的一部分。\"\nIf Not Range(\"B1\").HasArray Then MsgBox \"B1不是陣列公式的一部分。\"", "explanation": "設定一個陣列公式，然後檢查範圍內的儲存格是否為該陣列公式的一部分。"}
    ],
    "keywords": ["檢查陣列公式", "是否為陣列", "excel hasarray", "is array formula"]
},
{
    "name": "Range.Hyperlinks.Count",
    "category": "Excel 核心操作",
    "syntax": "count = rangeObject.Hyperlinks.Count",
    "description": "傳回指定範圍中超連結的數量。",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Hyperlinks.Add Anchor:=Range(\"A1\"), Address:=\"http://www.example.com\"\nActiveSheet.Hyperlinks.Add Anchor:=Range(\"B1\"), Address:=\"http://www.bing.com\"\nMsgBox \"範圍 A1:C1 中有 \" & Range(\"A1:C1\").Hyperlinks.Count & \" 個超連結。\"", "explanation": "在A1和B1新增超連結後，計算A1:C1範圍內的超連結數量 (應為2)。"}
    ],
    "keywords": ["超連結計數", "範圍連結數", "excel hyperlinks count"]
},
{
    "name": "Range.Hyperlinks.Delete",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Hyperlinks.Delete",
    "description": "刪除指定範圍中的所有超連結，但保留儲存格內容和格式。",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Hyperlinks.Add Anchor:=Range(\"D1\"), Address:=\"http://www.test.com\", TextToDisplay:=\"Test Link\"\nRange(\"D1\").Hyperlinks.Delete\nMsgBox \"D1儲存格的超連結已被刪除 (文字 'Test Link' 仍保留)。\"", "explanation": "在D1新增一個超連結，然後刪除它。儲存格中顯示的文字會保留。"}
    ],
    "keywords": ["刪除超連結", "移除連結", "excel hyperlinks delete"]
},
{
    "name": "ListObject.HeaderRowRange (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "Set headerRange = listObject.HeaderRowRange",
    "description": "傳回一個 Range 物件，代表 Excel 表格 (ListObject) 的標頭列範圍。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As ListObject, hrRange As Range\n' Set tbl = ActiveSheet.ListObjects(1) ' Assume a table exists\n' If Not tbl Is Nothing And tbl.ShowHeaders Then\n'   Set hrRange = tbl.HeaderRowRange\n'   hrRange.Font.Color = vbRed\n'   MsgBox \"表格 '\" & tbl.Name & \"' 的標頭列 ('\" & hrRange.Address & \"') 字型已設為紅色。\"\n' End If", "explanation": "獲取活動工作表上第一個表格的標頭列範圍，並將其字型顏色設為紅色。"}
    ],
    "keywords": ["表格標頭範圍", "listobject headerrowrange", "excel table header"]
},
{
    "name": "ListObject.TotalsRowRange (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "Set totalsRange = listObject.TotalsRowRange",
    "description": "如果 Excel 表格 (ListObject) 顯示了總計列，則傳回代表該總計列的 Range 物件。如果未顯示總計列，則傳回 Nothing。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As ListObject, trRange As Range\n' Set tbl = ActiveSheet.ListObjects(\"SalesTable\")\n' If Not tbl Is Nothing Then\n'   tbl.ShowTotals = True ' Ensure total row is visible\n'   Set trRange = tbl.TotalsRowRange\n'   If Not trRange Is Nothing Then\n'     trRange.Font.Bold = True\n'     MsgBox \"表格 '\" & tbl.Name & \"' 的總計列 ('\" & trRange.Address & \"') 已設為粗體。\"\n'   End If\n' End If", "explanation": "確保表格顯示總計列，然後獲取總計列範圍並將其字型設為粗體。"}
    ],
    "keywords": ["表格總計列範圍", "listobject totalsrowrange", "excel table totals row"]
},
{
    "name": "ListObject.ListColumns.Add (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "Set newCol = listObject.ListColumns.Add([Position As Long])",
    "description": "在 Excel 表格 (ListObject) 中新增一欄，並傳回代表該新欄的 ListColumn 物件。",
    "parameters": [{"name": "Position", "description": "可選。新欄的插入位置 (1-based)。如果省略，則在末尾新增。"}],
    "examples": [
        {"code": "Dim tbl As ListObject, newLc As ListColumn\n' Set tbl = ActiveSheet.ListObjects(1)\n' If Not tbl Is Nothing Then\n'   Set newLc = tbl.ListColumns.Add ' Add new column at the end\n'   newLc.Name = \"NewMetric\"\n'   ' Populate data for the new column in its DataBodyRange\n'   ' newLc.DataBodyRange.Formula = \"=[@Column1]*0.1\" ' Example formula\n'   MsgBox \"新欄 '\" & newLc.Name & \"' 已新增到表格。\"\n' End If", "explanation": "在活動工作表的第一個表格末尾新增一欄，並將其命名為 \"NewMetric\"。"}
    ],
    "keywords": ["新增表格欄", "listobject addcolumn", "excel table insert column"]
},
{
    "name": "ListObject.Resize (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "listObject.Resize(Range As Range)",
    "description": "調整 Excel 表格 (ListObject) 的大小以符合新的範圍。新範圍必須在同一工作表上，且標頭必須在同一列。",
    "parameters": [{"name": "Range", "description": "必需。Range 物件，指定表格的新範圍。"}],
    "examples": [
        {"code": "Dim tbl As ListObject, newDataRange As Range\n' Set tbl = ActiveSheet.ListObjects(\"MyDataTable\")\n' ' Assume current table is A1:C10, new data extends to D15\n' Set newDataRange = Range(tbl.Range.Cells(1, 1), Cells(15, 4)) ' New range A1:D15\n' On Error Resume Next\n' tbl.Resize newDataRange\n' If Err.Number = 0 Then\n'   MsgBox \"表格 '\" & tbl.Name & \"' 已調整大小為 \" & tbl.Range.Address\n' Else\n'   MsgBox \"調整表格大小失敗: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "嘗試將名為 \"MyDataTable\" 的表格調整大小以包含 A1:D15 範圍。"}
    ],
    "keywords": ["調整表格大小", "listobject resize", "excel table resize", "expand table"]
},
{
    "name": "ListObject.TableStyle (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "listObject.TableStyle [= styleNameOrObject]",
    "description": "設定或傳回 Excel 表格 (ListObject) 的表格樣式。",
    "parameters": [{"name": "styleNameOrObject", "description": "表格樣式的名稱 (字串，例如 \"TableStyleMedium9\") 或 TableStyle 物件。"}],
    "examples": [
        {"code": "Dim tbl As ListObject\n' Set tbl = ActiveSheet.ListObjects(1)\n' If Not tbl Is Nothing Then\n'   tbl.TableStyle = \"TableStyleLight15\"\n'   MsgBox \"表格樣式已設為 TableStyleLight15。\"\n'   Debug.Print \"目前的表格樣式: \" & tbl.TableStyle\n' End If", "explanation": "將活動工作表上第一個表格的樣式設為 \"TableStyleLight15\"。"}
    ],
    "keywords": ["表格樣式", "listobject tablestyle", "excel table style", "format table"]
},
{
    "name": "ListObject.ShowTotals Property (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "listObject.ShowTotals [= Boolean]",
    "description": "設定或傳回一個布林值，指出 Excel 表格 (ListObject) 的總計列是否可見。",
    "parameters": [{"name": "Boolean", "description": "True 表示顯示總計列，False 表示隱藏。"}],
    "examples": [
        {"code": "Dim tbl As ListObject\n' Set tbl = ActiveSheet.ListObjects(1)\n' If Not tbl Is Nothing Then\n'   tbl.ShowTotals = True\n'   MsgBox \"表格 '\" & tbl.Name & \"' 的總計列已顯示。\"\n'   ' To set a total function for a column:\n'   ' tbl.ListColumns(\"Sales\").TotalsCalculation = xlTotalsCalculationSum\n' End If", "explanation": "顯示活動工作表上第一個表格的總計列。"}
    ],
    "keywords": ["顯示總計列", "listobject showtotals", "excel table total row", "表格匯總"]
},
{
    "name": "Range.CurrentArray Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set arrayRange = rangeObject.CurrentArray",
    "description": "如果指定的儲存格是陣列公式的一部分，則傳回一個代表整個陣列公式範圍的 Range 物件。如果儲存格不是陣列公式的一部分，則此屬性傳回該儲存格本身。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"C1:C3\").FormulaArray = \"=A1:A3*B1:B3\"\nDim arrRng As Range\nSet arrRng = Range(\"C2\").CurrentArray ' C2 is part of the C1:C3 array\nMsgBox \"C2所在的陣列公式範圍是: \" & arrRng.Address\narrRng.Font.Italic = True", "explanation": "在 C1:C3 設定陣列公式後，獲取 C2 儲存格所在的完整陣列公式範圍 (即 C1:C3) 並將其字型設為斜體。"}
    ],
    "keywords": ["目前陣列", "陣列公式範圍", "excel currentarray", "array formula range"]
},
// --- Word Document Processing ---
{
    "name": "Document.Fields Property / .Fields.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set flds = documentObject.Fields\nSet newField = flds.Add(Range As Range, [Type As WdFieldType = wdFieldEmpty], [Text], [PreserveFormatting As Boolean = True])",
    "description": "Fields 屬性傳回代表文件中所有功能變數的 Fields 集合。Add 方法用於在指定範圍新增功能變數。",
    "parameters": [
        {"name": "Range (Add method)", "description": "必需。功能變數插入的位置。"},
        {"name": "Type (Add method)", "description": "可選。WdFieldType 常數，指定功能變數類型 (例如 wdFieldDate, wdFieldFileName, wdFieldPage)。"},
        {"name": "Text (Add method)", "description": "可選。功能變數的額外文字或指令。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim fld As Object ' Word.Field\n' Set wdDoc = ActiveDocument\n' Set fld = wdDoc.Fields.Add(Range:=Selection.Range, Type:=wdFieldDate)\n' fld.Update ' Update to show current date\n' MsgBox \"已在目前選取位置插入日期功能變數並更新。\"", "explanation": "在 Word 文件目前選取位置插入一個日期功能變數，並更新它以顯示目前日期。"}
    ],
    "keywords": ["word fields", "insert field word", "document automation fields", "功能變數", "插入功能變數"]
},
{
    "name": "Field.Update / .Code / .Result (Word)",
    "category": "Word 文件處理",
    "syntax": "fieldObject.Update As Boolean\nSet fieldCodeRange = fieldObject.Code\nSet fieldResultRange = fieldObject.Result",
    "description": "Field 物件的屬性和方法：Update 更新功能變數結果並傳回 True 如果成功。Code 傳回包含功能變數代碼的 Range 物件。Result 傳回包含功能變數結果的 Range 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim fld As Object ' Word.Field\n' Set wdDoc = ActiveDocument\n' If wdDoc.Fields.Count > 0 Then\n'   Set fld = wdDoc.Fields(1)\n'   Debug.Print \"第一個功能變數代碼: \" & fld.Code.Text\n'   Debug.Print \"第一個功能變數結果 (更新前): \" & fld.Result.Text\n'   If fld.Update Then Debug.Print \"功能變數已更新。結果: \" & fld.Result.Text\n' End If", "explanation": "獲取文件的第一個功能變數，列印其代碼和結果，然後更新它並再次列印結果。"}
    ],
    "keywords": ["word field update", "field code", "field result", "更新功能變數", "功能變數代碼", "功能變數結果"]
},
{
    "name": "Selection.HomeKey / .EndKey (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.HomeKey([Unit As WdUnits = wdLine], [Extend As WdMovementType = wdMove])\nselectionObject.EndKey([Unit As WdUnits = wdLine], [Extend As WdMovementType = wdMove])",
    "description": "模擬按下 HOME 或 END 鍵。Unit 指定移動單位 (例如 wdLine, wdStory, wdColumn)。Extend 指定是否擴展選取範圍。",
    "parameters": [
        {"name": "Unit", "description": "WdUnits 常數。"},
        {"name": "Extend", "description": "WdMovementType 常數 (wdMove 或 wdExtend)。"}
    ],
    "examples": [
        {"code": "Dim wdApp As Object ' Word.Application\n' Set wdApp = Application ' Assuming running from Word\n' ' Move to the beginning of the current line\n' wdApp.Selection.HomeKey Unit:=wdLine\n' ' Select from current position to the end of the document\n' wdApp.Selection.EndKey Unit:=wdStory, Extend:=wdExtend", "explanation": "將插入點移動到目前行的開頭，然後選取從目前位置到文件末尾的所有內容。"}
    ],
    "keywords": ["word homekey", "word endkey", "move cursor word", "select text programmatically", "移動游標", "選取文字"]
},
{
    "name": "Range.SetRange Method (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.SetRange(Start As Long, End As Long)",
    "description": "設定現有 Range 物件的起始和結束字元位置，以重新定義其範圍。",
    "parameters": [
        {"name": "Start", "description": "必需。新的起始字元位置。"},
        {"name": "End", "description": "必需。新的結束字元位置。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim myRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' Set myRange = wdDoc.Range(0, 0) ' Initially an empty range at the start\n' myRange.InsertAfter \"This is the first sentence. This is the second.\"\n' ' Redefine myRange to only cover the first sentence (approx 28 chars)\n' myRange.SetRange Start:=myRange.Start, End:=myRange.Start + 28\n' myRange.Font.Bold = True\n' MsgBox \"第一個句子 ('\" & myRange.Text & \"') 已設為粗體。\"", "explanation": "建立一個範圍，插入文字，然後使用 SetRange 重新定義該範圍以僅包含第一個句子，並將其設為粗體。"}
    ],
    "keywords": ["word setrange", "redefine range", "change range boundaries", "重新定義範圍"]
},
{
    "name": "ParagraphFormat.TabStops.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newTabStop = paragraphFormatObject.TabStops.Add(Position As Single, [Alignment As WdTabAlignment = wdAlignTabLeft], [Leader As WdTabLeader = wdTabLeaderSpaces])",
    "description": "新增一個定位停駐點到 TabStops 集合中。",
    "parameters": [
        {"name": "Position", "description": "必需。定位停駐點的位置 (以點為單位)，相對於左邊界。"},
        {"name": "Alignment", "description": "可選。WdTabAlignment 常數。"},
        {"name": "Leader", "description": "可選。WdTabLeader 常數 (例如 wdTabLeaderDots)。"}
    ],
    "examples": [
        {"code": "Dim paraFmt As Object ' Word.ParagraphFormat\n' Set paraFmt = Selection.ParagraphFormat\n' paraFmt.TabStops.ClearAll ' Clear existing tabs\n' paraFmt.TabStops.Add Position:=InchesToPoints(1.5), Alignment:=wdAlignTabDecimal\n' paraFmt.TabStops.Add Position:=InchesToPoints(3.0), Alignment:=wdAlignTabRight, Leader:=wdTabLeaderDots\n' MsgBox \"已為選取段落設定新的定位停駐點。\"", "explanation": "清除目前選取段落的所有現有定位停駐點，然後在1.5英吋處新增一個小數點對齊的定位停駐點，並在3.0英吋處新增一個帶點狀前導字元的右對齊定位停駐點。"}
    ],
    "keywords": ["word add tabstop", "custom tabs word", "paragraph tab settings", "新增定位停駐點"]
},
// --- Outlook Mail & Item Management ---
{
    "name": "MailItem.Attachments.Count Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "numberOfAttachments = mailItemObject.Attachments.Count",
    "description": "傳回一個 Long，表示 Outlook 郵件項目中附件的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   If olMail.Attachments.Count > 0 Then\n'     MsgBox \"此郵件包含 \" & olMail.Attachments.Count & \" 個附件。\"\n'   Else\n'     MsgBox \"此郵件沒有附件。\"\n'   End If\n' End If", "explanation": "檢查所選郵件是否包含附件，並顯示附件的數量。"}
    ],
    "keywords": ["outlook attachment count", "number of attachments", "附件數量"]
},
{
    "name": "Attachment.Delete Method (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "attachmentObject.Delete",
    "description": "從 Outlook 項目的 Attachments 集合中刪除指定的附件。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\nDim att As Object ' Outlook.Attachment\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   If olMail.Attachments.Count > 0 Then\n'     Set att = olMail.Attachments.Item(1) ' Get the first attachment\n'     If MsgBox(\"是否要刪除附件 '\" & att.DisplayName & \"'？\", vbYesNo) = vbYes Then\n'       att.Delete\n'       olMail.Save ' Save changes to the email item\n'       MsgBox \"第一個附件已刪除。\"\n'     End If\n'   End If\n' End If", "explanation": "獲取所選郵件的第一個附件，並在使用者確認後刪除它，然後儲存對郵件的變更。"}
    ],
    "keywords": ["outlook delete attachment", "remove attachment", "刪除附件"]
},
// --- PowerPoint Presentation Creation ---
{
    "name": "Slide.CustomLayout Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set custLayout = slideObject.CustomLayout",
    "description": "傳回或設定一個 CustomLayout 物件，代表與指定投影片關聯的自訂版面配置。",
    "parameters": [{"name": "CustomLayout Object", "description": "要套用於投影片的 CustomLayout 物件。"}],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim targetLayout As Object ' PowerPoint.CustomLayout\n' Set pptSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, ppLayoutBlank)\n' On Error Resume Next ' In case specific custom layout doesn't exist in the master\n' Set targetLayout = ActivePresentation.SlideMaster.CustomLayouts(\"我的自訂標題與內容版面\") ' By name\n' If Not targetLayout Is Nothing Then\n'   pptSlide.CustomLayout = targetLayout\n'   MsgBox \"新投影片已套用自訂版面。\"\n' Else\n'   MsgBox \"未找到名為 '我的自訂標題與內容版面' 的自訂版面。\"\n' End If\n' On Error GoTo 0", "explanation": "新增一張空白投影片，然後嘗試將其版面配置設定為簡報母片中名為 \"我的自訂標題與內容版面\" 的自訂版面。"}
    ],
    "keywords": ["powerpoint custom layout", "slide layout master", "套用自訂版面", "母片版面"]
},
{
    "name": "Shape.PlaceholderFormat Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set phFormat = shapeObject.PlaceholderFormat",
    "description": "如果指定的圖案是預留位置，則傳回代表預留位置屬性的 PlaceholderFormat 物件。如果圖案不是預留位置，則會產生錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim shp As Object ' PowerPoint.Shape\nDim phf As Object ' PowerPoint.PlaceholderFormat\n' Set pptSlide = ActivePresentation.Slides(1)\n' For Each shp In pptSlide.Shapes\n'   If shp.Type = msoPlaceholder Then\n'     Set phf = shp.PlaceholderFormat\n'     Debug.Print \"預留位置名稱: \" & shp.Name & \", 類型: \" & phf.Type\n'     If phf.Type = ppPlaceholderTitle Then shp.TextFrame.TextRange.Text = \"這是標題預留位置\"\n'   End If\n' Next shp", "explanation": "遍歷第一張投影片上的所有圖案，如果圖案是預留位置，則列印其名稱和預留位置類型，並修改標題預留位置的文字。"}
    ],
    "keywords": ["powerpoint placeholder format", "shape placeholder type", "預留位置格式", "圖案預留位置"]
},
// --- File & Folder Management (FSO) ---
{
    "name": "FileSystemObject.Drives Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "Set drivesCollection = fso.Drives",
    "description": "傳回一個 Drives 集合，其中包含系統上所有可用磁碟機的 Drive 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, drives As Object, drv As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet drives = fso.Drives\nMsgBox \"系統上共有 \" & drives.Count & \" 個磁碟機。\"\nFor Each drv In drives\n  If drv.IsReady Then\n    Debug.Print \"磁碟機: \" & drv.DriveLetter & \": (\" & drv.VolumeName & \"), 類型: \" & drv.DriveType\n  Else\n    Debug.Print \"磁碟機: \" & drv.DriveLetter & \": 未就緒\"\n  End If\nNext drv", "explanation": "獲取系統上所有磁碟機的集合，並遍歷它們，列印每個就緒磁碟機的代號、磁碟區名稱和類型。"}
    ],
    "keywords": ["fso drives collection", "list drives", "available drives", "磁碟機集合", "列出磁碟"]
},
// --- String & Text Manipulation ---
{
    "name": "Space$ Function (Typed String)",
    "category": "字串與文本操作",
    "syntax": "resultString$ = Space$(Number As Long)",
    "description": "傳回一個由指定數量空格組成的字串。函式名稱中的 `$` 表示它傳回 String 資料類型 (與傳回 Variant 的 `Space` 相比，雖然在現代VBA中差異通常很小)。",
    "parameters": [{"name": "Number", "description": "必需。字串中包含的空格數。"}],
    "examples": [
        {"code": "Dim mySpaces As String\nmySpaces = Space$(10) ' Creates a string of 10 spaces\nMsgBox \"'\" & \"Start\" & mySpaces & \"End\" & \"'\"", "explanation": "建立一個包含10個空格的字串，並將其插入到其他文字之間顯示。"}
    ],
    "keywords": ["space string typed", "string of spaces", "typed string function", "空格字串 (強型別)"]
},
// --- Math, Date & Time ---
{
    "name": "WorksheetFunction.RoundUp (Excel)",
    "category": "數學、日期與時間",
    "syntax": "roundedValue = Application.WorksheetFunction.RoundUp(Number As Double, Num_digits As Double)",
    "description": "將數字朝遠離零的方向四捨五入 (無條件進位)。",
    "parameters": [
        {"name": "Number", "description": "必需。要四捨五入的數字。"},
        {"name": "Num_digits", "description": "必需。要四捨五入到的位數。"}
    ],
    "examples": [
        {"code": "Debug.Print Application.WorksheetFunction.RoundUp(123.456, 2) ' Output: 123.46\nDebug.Print Application.WorksheetFunction.RoundUp(123.451, 2) ' Output: 123.46\nDebug.Print Application.WorksheetFunction.RoundUp(123, -1)    ' Output: 130 (round up to nearest 10)", "explanation": "演示 RoundUp 函數如何將數字無條件進位到指定的小數位數或整數位數。"}
    ],
    "keywords": ["roundup function", "excel roundup vba", "ceiling number", "無條件進位"]
},
{
    "name": "WorksheetFunction.RoundDown (Excel)",
    "category": "數學、日期與時間",
    "syntax": "roundedValue = Application.WorksheetFunction.RoundDown(Number As Double, Num_digits As Double)",
    "description": "將數字朝向零的方向四捨五入 (無條件捨去)。",
    "parameters": [
        {"name": "Number", "description": "必需。要四捨五入的數字。"},
        {"name": "Num_digits", "description": "必需。要四捨五入到的位數。"}
    ],
    "examples": [
        {"code": "Debug.Print Application.WorksheetFunction.RoundDown(123.456, 2) ' Output: 123.45\nDebug.Print Application.WorksheetFunction.RoundDown(123.459, 2) ' Output: 123.45\nDebug.Print Application.WorksheetFunction.RoundDown(128, -1)    ' Output: 120 (round down to nearest 10)", "explanation": "演示 RoundDown 函數如何將數字無條件捨去到指定的小數位數或整數位數。"}
    ],
    "keywords": ["rounddown function", "excel rounddown vba", "floor number", "無條件捨去"]
},
// --- Data Types, Conversion & Validation ---
{
    "name": "IsEmpty vs IsNull vs Empty String",
    "category": "資料類型、轉換與驗證",
    "description": "詳細區分 VBA 中三種「空」的狀態：\nIsEmpty(Expression)：傳回 True 如果 Variant 變數從未被初始化，或被明確設為 Empty 關鍵字。數字變數初始化為0，字串初始化為\"\"，所以對它們 IsEmpty 為 False。\nIsNull(Expression)：傳回 True 如果 Variant 變數包含 Null 值。Null 通常表示未知的或遺失的資料，常見於資料庫操作。它不同於 Empty 或零長度字串。\n空字串 (\"\")：一個長度為零的字串。它是一個已初始化的字串值。",
    "parameters": [],
    "examples": [
        {"code": "Dim varNotInit As Variant\nDim varIsNull As Variant: varIsNull = Null\nDim varEmptyStr As String: varEmptyStr = \"\"\nDim varZero As Integer: varZero = 0\n\nDebug.Print \"varNotInit - IsEmpty: \" & IsEmpty(varNotInit) & \", IsNull: \" & IsNull(varNotInit) & \", =\"\"\"\": \" & (varNotInit = \"\") ' True, False, False (or error depending on Option Strict)\nDebug.Print \"varIsNull - IsEmpty: \" & IsEmpty(varIsNull) & \", IsNull: \" & IsNull(varIsNull) ' False, True\nDebug.Print \"varEmptyStr - IsEmpty: \" & IsEmpty(varEmptyStr) & \", IsNull: \" & IsNull(varEmptyStr) & \", =\"\"\"\": \" & (varEmptyStr = \"\") ' False, False, True\nDebug.Print \"varZero - IsEmpty: \" & IsEmpty(varZero) ' False", "explanation": "演示對不同狀態的變數使用 IsEmpty, IsNull 以及與空字串進行比較的結果。注意，未初始化的 Variant 與空字串比較可能會因隱含轉換而出錯或得出 False。"}
    ],
    "keywords": ["isempty isnull empty string", "vba null vs empty", "variant states", "空值比較", "Nothing (for objects) vs Null vs Empty vs \"\""]
},
// --- Program Flow ---
{
    "name": "Exit Property Statement",
    "category": "程式流程與結構控制",
    "syntax": "Exit Property",
    "description": "立即退出目前正在執行的 Property 過程 (Property Get, Property Let, 或 Property Set)。",
    "parameters": [],
    "examples": [
        {"code": "Private m_Age As Integer\nPublic Property Get Age() As Integer\n  If m_Age < 0 Then\n    Debug.Print \"Age is not yet set meaningfully.\"\n    Age = 0 ' Return a default\n    Exit Property ' Exit before further processing if any\n  End If\n  Age = m_Age\nEnd Property\nPublic Property Let Age(ByVal NewAge As Integer)\n  If NewAge < 0 Or NewAge > 120 Then\n    MsgBox \"無效的年齡輸入！\"\n    Exit Property ' Do not set m_Age if invalid\n  End If\n  m_Age = NewAge\nEnd Property", "explanation": "在 Age 屬性的 Property Get 中，如果內部年齡 m_Age 小於0，則傳回預設值並使用 Exit Property 退出。在 Property Let 中，如果傳入的新年齡無效，則使用 Exit Property 阻止賦值。"}
    ],
    "keywords": ["exit property", "property procedure exit", "退出屬性過程"]
},
// --- Error Handling ---
{
    "name": "On Error GoTo -1 (Clear Error Handler)",
    "category": "錯誤處理與調試",
    "syntax": "On Error GoTo -1",
    "description": "在錯誤處理常式內部使用 `On Error GoTo -1` 可以清除該錯誤處理常式的作用，將錯誤傳播到呼叫堆疊的上一層。這與 `On Error GoTo 0` (禁用目前過程中的錯誤處理) 不同，`-1` 更像是「重新引發」當前錯誤，但讓更高層的處理器接手。然而，更常見和推薦的做法是使用 `Err.Raise Err.Number` 來明確地重新引發錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Sub OuterProcedure()\n  On Error GoTo OuterHandler\n  Debug.Print \"Outer: Calling Inner...\"\n  InnerProcedure\n  Debug.Print \"Outer: Inner completed.\"\n  Exit Sub\nOuterHandler:\n  MsgBox \"OuterHandler caught error: \" & Err.Description & \" from \" & Err.Source\nEnd Sub\n\nSub InnerProcedure()\n  On Error GoTo InnerHandler\n  Debug.Print \"Inner: Performing risky operation...\"\n  Dim x As Integer: x = 1 / 0 ' Error here\n  Exit Sub\nInnerHandler:\n  Debug.Print \"InnerHandler caught error: \" & Err.Description\n  If Err.Number = 11 Then ' Division by zero\n    ' Decide to re-throw to caller\n    MsgBox \"InnerHandler: Re-throwing error to caller.\"\n    On Error GoTo -1 ' Clear local handler, error propagates up\n    ' Alternatively and often better: Err.Raise Err.Number, Err.Source, Err.Description, Err.HelpFile, Err.HelpContext\n  End If\nEnd Sub", "explanation": "InnerProcedure 中發生錯誤，其 InnerHandler 捕獲它。如果錯誤是除以零，它會使用 `On Error GoTo -1` 來清除本地錯誤處理器，使得錯誤能夠被 OuterProcedure 中的 OuterHandler 捕獲。更現代的做法是使用 `Err.Raise`。"}
    ],
    "keywords": ["on error goto -1", "rethrow error vba", "propagate error", "clear error handler specific", "清除錯誤處理器", "錯誤傳播"]
},
{
    "name": "Application.FollowHyperlink (Excel/Word/PowerPoint)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "object.FollowHyperlink(Address As String, [SubAddress], [NewWindow], [AddHistory], [ExtraInfo], [Method], [HeaderInfo])",
    "description": "顯示快取的文件 (如果已下載)，或下載並顯示超連結目標。object 通常是 Application、Workbook 或 Document。",
    "parameters": [
        {"name": "Address", "description": "必需。連結的位址 (URL、檔案路徑)。"},
        {"name": "NewWindow", "description": "可選。True 表示在新視窗中顯示。"},
        {"name": "AddHistory", "description": "可選。True 表示將連結新增到歷程記錄資料夾。"}
    ],
    "examples": [
        {"code": "On Error Resume Next ' Handle if address is invalid or cannot be opened\nApplication.FollowHyperlink \"https://www.microsoft.com\", NewWindow:=True\nIf Err.Number <> 0 Then MsgBox \"無法開啟連結: \" & Err.Description\nOn Error GoTo 0", "explanation": "嘗試在新的瀏覽器視窗中開啟 Microsoft 的網站。"}
    ],
    "keywords": ["followhyperlink", "open url vba", "open file link", "瀏覽超連結", "開啟網址", "通用"]
},
{
    "name": "Range.Address (RelativeTo)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Address(RelativeTo:=RangeObject)",
    "description": "傳回相對於指定儲存格的儲存格範圍參照。",
    "parameters": [
        {"name": "RelativeTo", "description": "必需。指定傳回相對位址的左上角儲存格的 Range 物件。"}
    ],
    "examples": [
        {"code": "MsgBox Range(\"C5\").Address(RelativeTo:=Range(\"B2\")) ' C5 相對於 B2 是 R[3]C[1] (如果用R1C1) 或 C5 (如果用A1且未跨工作表)。此例更強調 A1 相對性。", "explanation": "獲取 C5 儲存格相對於 B2 儲存格的位址。例如，如果B2是基準點，C5的相對位址會是C5。若ReferenceStyle為xlR1C1，則會是R[3]C[1]。"}
    ],
    "keywords": ["相對位址", "儲存格參照", "excel", "relative address", "cell reference relative"]
},
{
    "name": "Worksheet.ChartObjects.Count",
    "category": "Excel 核心操作",
    "syntax": "longCount = worksheetObject.ChartObjects.Count",
    "description": "傳回工作表上嵌入式圖表 (ChartObject 物件) 的數量。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox ActiveSheet.ChartObjects.Count & \" 個嵌入式圖表在此工作表上。\"", "explanation": "顯示活動工作表上嵌入式圖表的總數。"}
    ],
    "keywords": ["圖表計數", "嵌入圖表數量", "excel", "chartobject count", "number of embedded charts"]
},
{
    "name": "Workbook.Sheets.Count",
    "category": "Excel 核心操作",
    "syntax": "longCount = workbookObject.Sheets.Count",
    "description": "傳回指定活頁簿中所有類型工作表 (包括 Worksheet, Chart sheet, Dialog sheet 等) 的總數。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"此活頁簿共有 \" & ThisWorkbook.Sheets.Count & \" 個工作表 (所有類型)。\"", "explanation": "顯示目前活頁簿中所有類型工作表的總數。這與 Worksheets.Count (只計數 Worksheet 物件) 可能不同。"}
    ],
    "keywords": ["所有工作表數量", "圖表工作表計數", "sheets count", "total sheets", "excel"]
},
{
    "name": "Range.FindNext",
    "category": "Excel 核心操作",
    "syntax": "Set nextFoundCell = rangeObject.FindNext([After])",
    "description": "繼續由 Find 方法開始的搜尋。它會找到下一個符合相同條件的儲存格，並傳回代表該儲存格的 Range 物件。如果找不到，則傳回 Nothing。",
    "parameters": [
        {"name": "After", "description": "可選。指定搜尋從其後開始的儲存格。如果省略，則從上次找到的儲存格之後開始。"}
    ],
    "examples": [
        {"code": "Dim searchRange As Range, foundCell As Range, firstAddress As String, searchText As String\nSet searchRange = ActiveSheet.UsedRange\nsearchText = \"Example\"\nSet foundCell = searchRange.Find(What:=searchText)\nIf Not foundCell Is Nothing Then\n  firstAddress = foundCell.Address\n  Do\n    Debug.Print \"在 \" & foundCell.Address & \" 找到 '\" & searchText & \"'\"\n    Set foundCell = searchRange.FindNext(foundCell)\n  Loop While Not foundCell Is Nothing And foundCell.Address <> firstAddress\nElse\n  MsgBox \"'\" & searchText & \"' 未找到。\"\nEnd If", "explanation": "在已使用範圍內尋找所有出現 \"Example\" 的儲存格，並將其位址列印到立即視窗。"}
    ],
    "keywords": ["尋找下一個", "繼續搜尋", "excel", "findnext", "continue search", "find all"]
},
{
    "name": "Range.FindPrevious",
    "category": "Excel 核心操作",
    "syntax": "Set prevFoundCell = rangeObject.FindPrevious([After])",
    "description": "繼續由 Find 方法開始的搜尋，但方向與 FindNext 相反。它會找到上一個符合相同條件的儲存格。",
    "parameters": [
        {"name": "After", "description": "可選。指定搜尋從其前開始的儲存格。"}
    ],
    "examples": [
        {"code": "Dim searchRange As Range, foundCell As Range, searchText As String\nSet searchRange = ActiveSheet.UsedRange\nsearchText = \"DataPoint\"\nSet foundCell = searchRange.Find(What:=searchText, SearchDirection:=xlPrevious)\nIf Not foundCell Is Nothing Then\n  MsgBox \"從範圍尾部開始，第一個找到 '\" & searchText & \"' 的儲存格是: \" & foundCell.Address\n  ' Set foundCell = searchRange.FindPrevious(foundCell) ' To find the one before that\nEnd If", "explanation": "從範圍的末尾開始向前搜尋 \"DataPoint\"。"}
    ],
    "keywords": ["尋找上一個", "反向搜尋", "excel", "findprevious", "search backwards"]
},
// Word
{
    "name": "Range.Font.Reset (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.Reset",
    "description": "移除手動字元格式 (不是使用樣式套用的格式)，並將格式重設為基礎樣式的設定。",
    "parameters": [],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' ' Apply some manual formatting\n' selRange.Font.Bold = True\n' selRange.Font.ColorIndex = wdRed\n' ' Now reset it to the underlying style's formatting\n' selRange.Font.Reset\n' MsgBox \"選取範圍的手動字元格式已重設。\"", "explanation": "對目前選取的文字套用一些手動格式，然後使用 Font.Reset 將其恢復為套用於該範圍的樣式的預設字元格式。"}
    ],
    "keywords": ["word reset font", "clear manual formatting word", "restore style font", "重設字型", "清除手動格式"]
},
{
    "name": "Range.ParagraphFormat.Reset (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.ParagraphFormat.Reset",
    "description": "移除手動段落格式 (不是使用樣式套用的格式)，並將格式重設為基礎樣式的設定。",
    "parameters": [],
    "examples": [
        {"code": "Dim selParaFmt As Object ' Word.ParagraphFormat\n' Set selParaFmt = Selection.ParagraphFormat\n' ' Apply some manual paragraph formatting\n' selParaFmt.Alignment = wdAlignParagraphCenter\n' selParaFmt.LeftIndent = InchesToPoints(0.5)\n' ' Now reset it to the underlying style's formatting\n' selParaFmt.Reset\n' MsgBox \"選取段落的手動格式已重設。\"", "explanation": "對目前選取段落套用一些手動格式，然後使用 ParagraphFormat.Reset 將其恢復為套用於該段落的樣式的預設段落格式。"}
    ],
    "keywords": ["word reset paragraph format", "clear manual paragraph formatting", "restore style paragraph", "重設段落格式"]
},
{
    "name": "Document.Range(0,0).InsertBefore (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Range(Start:=0, End:=0).InsertBefore(Text As String)",
    "description": "在文件的最開頭插入指定的文字。",
    "parameters": [
        {"name": "Text", "description": "必需。要插入的文字。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.Range(0, 0).InsertBefore \"這是文檔的頂部標題。\" & vbCrLf", "explanation": "在活動文件的最開始處插入一行文字作為標題。"}
    ],
    "keywords": ["word insert at beginning", "add text to start of document", "prepend text word", "文件開頭插入"]
},
// Outlook
{
    "name": "MailItem.VotingResponse",
    "category": "Outlook 郵件與項目管理",
    "syntax": "responseString = mailItemObject.VotingResponse",
    "description": "傳回一個字串，指定郵件收件者的投票回應 (例如 \"Yes\", \"No\", \"Maybe\")。此屬性主要用於已收到回覆的原始投票郵件。",
    "parameters": [],
    "examples": [
        {"code": "Dim olSentMail As Object ' Outlook.MailItem, assume it's a sent item that had voting buttons\nDim olResponse As Object ' Outlook.MailItem, a response to the voting email\n' ' Need logic to find original sent mail and its responses.\n' ' For a received voting response email (olResponse):\n' If olResponse.VotingResponse <> \"\" Then\n'   MsgBox \"收件者 '\" & olResponse.SenderName & \"' 的投票回應是: \" & olResponse.VotingResponse\n' End If", "explanation": "檢查一封收到的郵件是否為投票回應，如果是，則顯示寄件者的投票選項。"}
    ],
    "keywords": ["outlook voting response", "get vote result", "郵件投票回覆"]
},
{
    "name": "MailItem.Permission Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.Permission = OlPermissionConstant\ncurrentPermission = mailItemObject.Permission",
    "description": "設定或傳回一個 OlPermission 常數，指定訊息的權限。這與資訊版權管理 (IRM) 相關。",
    "parameters": [
        {"name": "OlPermissionConstant", "description": "例如 olUnrestricted (0), olDoNotForward (1), olPermissionTemplate (2)。"}
    ],
    "examples": [
        {"code": "Dim olMail As Object\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.Subject = \"機密 - 請勿轉發\"\nolMail.Permission = 1 ' olDoNotForward\n' ' olMail.PermissionTemplateGuid = \"{GUID of a specific IRM template}\" ' If using olPermissionTemplate\nolMail.Display", "explanation": "建立一封新郵件，並將其權限設定為「請勿轉發」。這需要環境中已設定 IRM。"}
    ],
    "keywords": ["outlook irm", "email permissions", "do not forward", "information rights management", "郵件權限", "資訊版權管理"]
},
// PowerPoint
{
    "name": "Slide.Shapes.Count",
    "category": "PowerPoint 簡報製作",
    "syntax": "longCount = slideObject.Shapes.Count",
    "description": "傳回指定投影片上圖案的數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\n' Set pptSlide = ActivePresentation.Slides(1)\n' MsgBox \"第一張投影片上有 \" & pptSlide.Shapes.Count & \" 個圖案。\"", "explanation": "顯示第一張投影片上圖案的總數。"}
    ],
    "keywords": ["powerpoint shape count", "number of shapes on slide", "圖案數量PPT"]
},
{
    "name": "Shapes.Item (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set shp = slideObject.Shapes.Item(IndexOrName)",
    "description": "從 Shapes 集合中傳回單個 Shape 物件。",
    "parameters": [
        {"name": "IndexOrName", "description": "必需。圖案的索引號 (1-based) 或圖案的名稱。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, firstShape As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides(1)\n' If pptSlide.Shapes.Count > 0 Then\n'   Set firstShape = pptSlide.Shapes.Item(1)\n'   firstShape.Fill.ForeColor.RGB = RGB(255, 0, 0) ' Make first shape red\n'   MsgBox \"已將第一個圖案的填充設為紅色。名稱: \" & firstShape.Name\n' End If", "explanation": "獲取第一張投影片上的第一個圖案，並將其填充顏色設為紅色。"}
    ],
    "keywords": ["powerpoint shape item", "get shape by index", "get shape by name", "存取PPT圖案"]
},
// FSO
{
    "name": "Folder.Type Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "typeString = folderObject.Type",
    "description": "傳回有關資料夾類型的資訊。通常傳回 \"檔案資料夾\" 或本地化的等效字串。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fldr As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldr = fso.GetFolder(\"C:\\Windows\")\nMsgBox \"'\" & fldr.Name & \"' 的類型是: \" & fldr.Type", "explanation": "顯示 C:\\Windows 資料夾的類型描述。"}
    ],
    "keywords": ["fso folder type", "directory type description", "資料夾類型描述"]
},
{
    "name": "File.Type Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "typeString = fileObject.Type",
    "description": "傳回有關檔案類型的描述性字串 (例如，「文字文件」、「Microsoft Excel 工作表」)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fle As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fle = fso.GetFile(\"C:\\Windows\\notepad.exe\")\nMsgBox \"'\" & fle.Name & \"' 的類型是: \" & fle.Type", "explanation": "顯示 notepad.exe 檔案的類型描述。"}
    ],
    "keywords": ["fso file type", "file type description", "檔案類型描述"]
},
// String
{
    "name": "vbNewLine Constant",
    "category": "字串與文本操作",
    "syntax": "vbNewLine",
    "description": "一個內建常數，代表平台特定的新行字元。在 Windows 上，它等同於 vbCrLf。在其他系統上可能不同。",
    "parameters": [],
    "examples": [
        {"code": "Dim message As String\nmessage = \"第一行.\" & vbNewLine & \"這是新的一行。\"\nMsgBox message", "explanation": "使用 vbNewLine 創建一個包含換行符的多行字串。"}
    ],
    "keywords": ["vbnewline", "newline constant", "platform newline", "新行常數"]
},
// Math
{
    "name": "WorksheetFunction.Max (Excel)",
    "category": "數學、日期與時間",
    "syntax": "maxValue = Application.WorksheetFunction.Max(Arg1, [Arg2], ...)",
    "description": "使用 Excel 的 MAX 工作表函數傳回一組值中的最大值。",
    "parameters": [
        {"name": "Arg1, Arg2, ...", "description": "必需/可選。要从中找出最大值的一個或多個數字、儲存格範圍或陣列。"}
    ],
    "examples": [
        {"code": "Dim dataRange As Range\nSet dataRange = Range(\"A1:A10\")\n' Fill range with random numbers for example\nRandomize\nDim i As Long\nFor i = 1 To 10: dataRange.Cells(i, 1).Value = Int(Rnd() * 100): Next i\n\nMsgBox \"A1:A10 中的最大值是: \" & Application.WorksheetFunction.Max(dataRange)", "explanation": "計算A1:A10範圍內的最大值。"}
    ],
    "keywords": ["max function", "excel max vba", "find largest value", "最大值"]
},
{
    "name": "WorksheetFunction.Min (Excel)",
    "category": "數學、日期與時間",
    "syntax": "minValue = Application.WorksheetFunction.Min(Arg1, [Arg2], ...)",
    "description": "使用 Excel 的 MIN 工作表函數傳回一組值中的最小值。",
    "parameters": [
        {"name": "Arg1, Arg2, ...", "description": "必需/可選。要从中找出最小值的一個或多個數字、儲存格範圍或陣列。"}
    ],
    "examples": [
        {"code": "Dim numbers As Variant\nnumbers = Array(10, 5, 25, 2, 18)\nMsgBox \"陣列中的最小值是: \" & Application.WorksheetFunction.Min(numbers)", "explanation": "找出一個 VBA 陣列中的最小值。"}
    ],
    "keywords": ["min function", "excel min vba", "find smallest value", "最小值"]
},
// Data Types
{
    "name": "Is Nothing (Detailed)",
    "category": "資料類型、轉換與驗證",
    "description": "Is Nothing 運算子用於判斷一個物件變數是否未被指派任何物件參考，即它是否指向 Nothing。它不能用於非物件變數。與 IsEmpty (用於未初始化的 Variant) 和 IsNull (用於包含 Null 值的 Variant) 不同。",
    "parameters": [{"name": "ObjectVariable", "description": "要檢查的物件變數。"}],
    "examples": [
        {"code": "Dim mySheet As Worksheet, myRange As Range\n' mySheet is Nothing at this point\nIf mySheet Is Nothing Then Debug.Print \"mySheet is Nothing (unassigned).\"\nSet mySheet = ThisWorkbook.Sheets(1)\nIf Not mySheet Is Nothing Then Debug.Print \"mySheet now refers to: \" & mySheet.Name\n\nSet myRange = mySheet.Range(\"Z999\") ' This range exists, but let's test for a non-existent one\n' Set myRange = mySheet.Range(\"NonExistentNamedRange\") ' This would error if name doesn't exist, unless On Error\n' If a Find operation returns Nothing:\nDim foundCell As Range\nSet foundCell = mySheet.Cells.Find(\"SomeValueThatDoesNotExist\")\nIf foundCell Is Nothing Then Debug.Print \"Value not found, foundCell is Nothing.\"\n\nSet mySheet = Nothing ' Release the object reference\nIf mySheet Is Nothing Then Debug.Print \"mySheet is Nothing again after being set to Nothing.\"", "explanation": "演示 Is Nothing 的各種使用情境：檢查未指派的物件變數、已指派的物件變數、Find 方法的結果以及將物件變數設回 Nothing 之後的狀態。"}
    ],
    "keywords": ["is nothing", "object variable check", "unassigned object", "null object reference", "object state", "檢查物件是否為空", "物件未初始化"]
},
// Program Flow
{
    "name": "GoTo LineLabel (Usage)",
    "category": "程式流程與結構控制",
    "description": "GoTo 語句將執行無條件轉移到過程中指定的行標籤或行號。雖然它可以用於跳出深層巢狀結構或實現某些流程控制，但過度使用會導致「義大利麵式程式碼」，使程式難以閱讀、理解和維護。現代程式設計通常建議使用結構化的控制流程語句 (If...Then...Else, For...Next, Do...Loop, Select Case) 來替代 GoTo。",
    "parameters": [{"name": "LineLabel", "description": "一個以冒號結尾的識別碼，標記程式中的一行。"}],
    "examples": [
        {"code": "Sub ProcessDataWithGoTo(dataValue As Integer)\n    If dataValue < 0 Then\n        GoTo NegativeHandler\n    ElseIf dataValue = 0 Then\n        GoTo ZeroHandler\n    Else\n        GoTo PositiveHandler\n    End If\n    ' This part might be skipped if GoTo occurs\n    Debug.Print \"Continuing after initial checks... (This might not print)\"\nPositiveHandler:\n    Debug.Print \"Value is positive: \" & dataValue\n    GoTo EndProcessing ' Jump to the end\nNegativeHandler:\n    Debug.Print \"Value is negative: \" & dataValue\n    GoTo EndProcessing\nZeroHandler:\n    Debug.Print \"Value is zero.\"\n    ' Falls through to EndProcessing implicitly if no GoTo\nEndProcessing:\n    Debug.Print \"Processing complete.\"\nEnd Sub\n' ProcessDataWithGoTo(10)\n' ProcessDataWithGoTo(-5)\n' ProcessDataWithGoTo(0)", "explanation": "演示使用 GoTo 將控制流轉移到不同的處理區塊。注意使用 GoTo 可能使程式流程變得不清晰。此範例可以用 Select Case 或 If...ElseIf 更清晰地實現。"}
    ],
    "keywords": ["goto statement", "line label", "unconditional jump", "spaghetti code", "flow control", "跳轉語句", "行標籤"]
},
// External
{
    "name": "Application.OperatingSystem Property (Excel/Word/PPT)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "osString = Application.OperatingSystem",
    "description": "傳回一個字串，包含執行中應用程式所在作業系統的名稱和版本。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"目前作業系統資訊: \" & Application.OperatingSystem", "explanation": "顯示作業系統的詳細資訊，例如 \"Windows (64-bit) NT 10.00\"。"}
    ],
    "keywords": ["operating system info", "get os version", "system details", "作業系統版本", "通用"]
},
{
    "name": "Range.Row",
    "category": "Excel 核心操作",
    "syntax": "longRowNumber = rangeObject.Row",
    "description": "傳回指定範圍中第一列的列號。唯讀 Long。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox Range(\"C5\").Row ' 傳回 5", "explanation": "獲取儲存格C5所在的列號。"},
        {"code": "Dim myRange As Range\nSet myRange = Range(\"B10:D15\")\nMsgBox \"範圍的第一列是第 \" & myRange.Row & \" 列。\"", "explanation": "獲取範圍B10:D15中第一列的列號 (即10)。"}
    ],
    "keywords": ["列號", "儲存格列", "excel", "row number", "cell row"]
},
{
    "name": "Range.Column",
    "category": "Excel 核心操作",
    "syntax": "longColumnNumber = rangeObject.Column",
    "description": "傳回指定範圍中第一欄的欄號。唯讀 Long。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox Range(\"C5\").Column ' 傳回 3", "explanation": "獲取儲存格C5所在的欄號 (C是第3欄)。"},
        {"code": "Dim myRange As Range\nSet myRange = Range(\"B10:D15\")\nMsgBox \"範圍的第一欄是第 \" & myRange.Column & \" 欄。\"", "explanation": "獲取範圍B10:D15中第一欄的欄號 (即2，因為B是第2欄)。"}
    ],
    "keywords": ["欄號", "儲存格欄", "excel", "column number", "cell column"]
},
{
    "name": "Range.CountA (WorksheetFunction)",
    "category": "Excel 核心操作",
    "syntax": "countNonBlank = Application.WorksheetFunction.CountA(rangeObjectOrValues)",
    "description": "使用 Excel 的 COUNTA 工作表函數來計算範圍中不為空的儲存格數量。",
    "parameters": [
        {"name": "rangeObjectOrValues", "description": "必需。一個或多個要計數的儲存格範圍，或直接的值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Text\"\nRange(\"A2\").Value = 123\nRange(\"A4\").Value = Date\nMsgBox Application.WorksheetFunction.CountA(Range(\"A1:A5\")) ' 傳回 3", "explanation": "計算A1:A5範圍內非空儲存格的數量。"}
    ],
    "keywords": ["counta", "非空儲存格計數", "excel function", "non-blank cells", "worksheetfunction counta"]
},
{
    "name": "Range.RemoveDuplicates",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.RemoveDuplicates(Columns, [Header As XlYesNoGuess = xlNo])",
    "description": "從儲存格範圍中移除重複的列。",
    "parameters": [
        {"name": "Columns", "description": "必需。一個Variant，可以是單一欄索引號，或包含多個欄索引號的陣列，用於判斷重複。"},
        {"name": "Header", "description": "可選。XlYesNoGuess 常數，指定範圍是否包含標頭。"}
    ],
    "examples": [
        {"code": "' Assume data in A1:C10 with headers in row 1\n' Range(\"A1:C10\").RemoveDuplicates Columns:=Array(1, 2), Header:=xlYes\n' MsgBox \"已基於第1和第2欄移除重複項。\"", "explanation": "基於範圍A1:C10中的第一欄和第二欄來移除重複的列，並假設第一列是標頭。"}
    ],
    "keywords": ["移除重複", "刪除重複項", "excel", "remove duplicates", "unique records"]
},
{
    "name": "Range.Insert (Shift Options)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Insert([Shift As XlInsertShiftDirection = xlShiftDown], [CopyOrigin As XlInsertFormatOrigin = xlFormatFromLeftOrAbove])",
    "description": "在指定範圍插入儲存格或儲存格範圍，並將其他儲存格移開以騰出空間。",
    "parameters": [
        {"name": "Shift", "description": "可選。XlInsertShiftDirection 常數 (xlShiftDown 或 xlShiftToRight)。如果省略，Excel 會根據範圍形狀決定。"},
        {"name": "CopyOrigin", "description": "可選。XlInsertFormatOrigin 常數，指定新儲存格的格式來源。"}
    ],
    "examples": [
        {"code": "Range(\"B2\").Insert Shift:=xlShiftDown ' 在B2插入一個儲存格，B2及下方儲存格下移", "explanation": "在B2儲存格插入一個新儲存格，並將原B2及下方的儲存格向下移動。"},
        {"code": "Range(\"C1:C5\").EntireColumn.Insert Shift:=xlShiftToRight", "explanation": "在C欄前插入一個新欄，原C欄及右側欄向右移動。"}
    ],
    "keywords": ["插入儲存格", "插入列", "插入欄", "excel", "insert cells", "insert rows", "insert columns", "shift cells"]
},
{
    "name": "Range.Delete (Shift Options)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Delete([Shift As XlDeleteShiftDirection = xlShiftUp])",
    "description": "刪除指定的儲存格、列或欄，並可選擇移動周圍儲存格以填補空間。",
    "parameters": [
        {"name": "Shift", "description": "可選。XlDeleteShiftDirection 常數 (xlShiftUp 或 xlShiftToLeft)。如果省略，Excel 會根據範圍形狀決定。"}
    ],
    "examples": [
        {"code": "Range(\"A5\").Delete Shift:=xlShiftUp ' 刪除A5儲存格，其下方的儲存格上移", "explanation": "刪除A5儲存格，並將其下方的儲存格向上移動。"},
        {"code": "Range(\"D1:D10\").EntireColumn.Delete Shift:=xlShiftToLeft", "explanation": "刪除整個D欄，其右側的欄向左移動。"}
    ],
    "keywords": ["刪除儲存格", "刪除列", "刪除欄", "excel", "delete cells", "delete rows", "delete columns", "shift cells"]
},
{
    "name": "Range.Dependents",
    "category": "Excel 核心操作",
    "syntax": "Set dependentsRange = rangeObject.Dependents",
    "description": "傳回一個 Range 物件，代表該儲存格的所有直接或間接引用儲存格 (追蹤引用儲存格)。如果沒有引用儲存格，則傳回 Nothing。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = 10\nRange(\"B1\").Formula = \"=A1*2\"\nRange(\"C1\").Formula = \"=B1+5\"\nDim deps As Range\nOn Error Resume Next\nSet deps = Range(\"A1\").Dependents\nOn Error GoTo 0\nIf Not deps Is Nothing Then\n  MsgBox \"A1的引用儲存格是: \" & deps.Address\n  deps.Font.Color = vbBlue\nElse\n  MsgBox \"A1沒有引用儲存格。\"\nEnd If", "explanation": "找出A1儲存格的所有引用儲存格 (直接和間接，即B1和C1)，並將它們的字型顏色設為藍色。"}
    ],
    "keywords": ["追蹤引用儲存格", "公式相依", "excel", "trace dependents", "formula dependencies"]
},
{
    "name": "Range.Precedents",
    "category": "Excel 核心操作",
    "syntax": "Set precedentsRange = rangeObject.Precedents",
    "description": "傳回一個 Range 物件，代表該儲存格的所有直接或間接前導儲存格 (追蹤前導儲存格)。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = 10\nRange(\"B1\").Value = 20\nRange(\"C1\").Formula = \"=A1+B1\"\nDim precs As Range\nOn Error Resume Next\nSet precs = Range(\"C1\").Precedents\nOn Error GoTo 0\nIf Not precs Is Nothing Then\n  MsgBox \"C1的前導儲存格是: \" & precs.Address\n  precs.Interior.Color = vbYellow\nElse\n  MsgBox \"C1沒有前導儲存格。\"\nEnd If", "explanation": "找出C1儲存格 (其公式為=A1+B1) 的所有前導儲存格 (A1和B1)，並將它們的背景設為黃色。"}
    ],
    "keywords": ["追蹤前導儲存格", "公式來源", "excel", "trace precedents", "formula sources"]
},
{
    "name": "Name Object (Named Range)",
    "category": "Excel 核心操作",
    "syntax": "Set nameObj = workbookOrWorksheet.Names(IndexOrName)\nnameObj.Name = newNameString\nnameObj.RefersTo = newReferenceString\nnameObj.Delete",
    "description": "代表活頁簿或工作表中的已定義名稱。可以使用 Names 集合來存取和管理這些名稱。",
    "parameters": [
        {"name": ".Name", "description": "屬性：傳回或設定名稱的文字。"},
        {"name": ".RefersTo", "description": "屬性：傳回或設定名稱所參照的公式 (A1樣式)。"},
        {"name": ".RefersToR1C1", "description": "屬性：傳回或設定名稱所參照的公式 (R1C1樣式)。"},
        {"name": ".Visible", "description": "屬性：True 表示名稱在「名稱管理員」中可見。"},
        {"name": ".Delete", "description": "方法：刪除此名稱。"}
    ],
    "examples": [
        {"code": "Dim myNamedRange As Name\nOn Error Resume Next\nSet myNamedRange = ThisWorkbook.Names(\"SalesTotal\")\nIf myNamedRange Is Nothing Then\n  Set myNamedRange = ThisWorkbook.Names.Add(Name:=\"SalesTotal\", RefersTo:=\"=SUM(Sheet1!A1:A10)\")\n  MsgBox \"已建立名稱 'SalesTotal'。\"\nElse\n  MsgBox \"名稱 'SalesTotal' 已存在，參照: \" & myNamedRange.RefersTo\n  myNamedRange.RefersTo = \"=SUM(Sheet1!B1:B20)\" ' Update reference\n  MsgBox \"'SalesTotal' 的參照已更新為: \" & myNamedRange.RefersTo\nEnd If\n' To delete: myNamedRange.Delete\nSet myNamedRange = Nothing", "explanation": "檢查名為 \"SalesTotal\" 的已命名範圍是否存在。如果不存在，則建立它；如果存在，則顯示其參照並更新它。"}
    ],
    "keywords": ["已命名範圍", "定義名稱", "名稱管理員", "excel", "named range", "defined name", "name object"]
},
// Word
{
    "name": "Selection.TypeBackspace (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.TypeBackspace",
    "description": "模擬按下 BACKSPACE 鍵。如果選取了內容，則刪除選取的內容；如果是一個插入點，則刪除插入點前的字元。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdApp As Object ' Word.Application\n' Set wdApp = Application ' Assuming running from Word\n' wdApp.Selection.TypeText \"ErrorText\"\n' ' Simulate pressing Backspace 4 times to delete 'Text'\n' Dim i As Integer\n' For i = 1 To 4\n'   wdApp.Selection.TypeBackspace\n'   Application.Wait Now + TimeValue(\"00:00:00.2\") ' Short pause to see effect\n' Next i", "explanation": "在插入點輸入 \"ErrorText\"，然後模擬按下4次 Backspace 鍵以刪除 \"Text\"。"}
    ],
    "keywords": ["word typebackspace", "delete character word", "simulate backspace", "刪除字元"]
},
{
    "name": "Selection.MoveLeft / .MoveRight (Word)",
    "category": "Word 文件處理",
    "syntax": "longCharsMoved = selectionObject.MoveLeft([Unit As WdUnits = wdCharacter], [Count As Long = 1], [Extend As WdMovementType = wdMove])\nlongCharsMoved = selectionObject.MoveRight([Unit As WdUnits = wdCharacter], [Count As Long = 1], [Extend As WdMovementType = wdMove])",
    "description": "向左或向右移動選取範圍或插入點。傳回實際移動的單位數。",
    "parameters": [
        {"name": "Unit", "description": "WdUnits 常數 (例如 wdCharacter, wdWord, wdSentence, wdLine)。"},
        {"name": "Count", "description": "要移動的單位數。"},
        {"name": "Extend", "description": "WdMovementType 常數 (wdMove 或 wdExtend)。"}
    ],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\n' Set sel = Application.Selection\n' sel.MoveRight Unit:=wdWord, Count:=2 ' Move insertion point two words to the right\n' sel.MoveLeft Unit:=wdCharacter, Count:=5, Extend:=wdExtend ' Select 5 characters to the left", "explanation": "將插入點向右移動兩個單字，然後向左選取5個字元。"}
    ],
    "keywords": ["word move cursor", "selection moveleft", "selection moveright", "移動游標Word"]
},
{
    "name": "InlineShape Object Properties (Word)",
    "category": "Word 文件處理",
    "syntax": "inlineShapeObject.Width | .Height | .ScaleHeight | .ScaleWidth | .ConvertToShape() | .Type",
    "description": "代表以內嵌方式 (與文字同行) 插入到文件中的圖形、圖片或 OLE 物件。",
    "parameters": [
        {"name": ".Width / .Height", "description": "讀取/寫入。內嵌圖形的寬度和高度 (以點為單位)。"},
        {"name": ".ScaleHeight / .ScaleWidth", "description": "讀取/寫入。相對於原始大小縮放內嵌圖形的高度/寬度 (百分比)。"},
        {"name": ".ConvertToShape()", "description": "方法：將內嵌圖形轉換為浮動圖形 (Shape 物件)。"},
        {"name": ".Type", "description": "傳回 WdInlineShapeType 常數。"}
    ],
    "examples": [
        {"code": "Dim ils As Object ' Word.InlineShape\n' If ActiveDocument.InlineShapes.Count > 0 Then\n'   Set ils = ActiveDocument.InlineShapes(1)\n'   ils.Height = InchesToPoints(1) ' Set height to 1 inch\n'   ils.Width = InchesToPoints(1.5) ' Set width to 1.5 inches\n'   Debug.Print \"InlineShape type: \" & ils.Type\n'   ' Dim shp As Object: Set shp = ils.ConvertToShape() ' Convert to floating shape\n' End If", "explanation": "獲取文件的第一個內嵌圖形，設定其高度和寬度，並列印其類型。同時顯示了如何將其轉換為浮動圖形 (註解中)。"}
    ],
    "keywords": ["word inlineshape", "format inline picture", "resize inline image", "內嵌圖形", "調整內嵌圖片大小"]
},
{
    "name": "HeaderFooter Object (Word)",
    "category": "Word 文件處理",
    "syntax": "Set hf = sectionObject.Headers(WdHeaderFooterIndexConstant)\nSet hf = sectionObject.Footers(WdHeaderFooterIndexConstant)",
    "description": "代表頁首或頁尾。可以通過 Section 物件的 Headers 或 Footers 集合來存取。",
    "parameters": [
        {"name": "WdHeaderFooterIndexConstant", "description": "例如 wdHeaderFooterPrimary, wdHeaderFooterFirstPage, wdHeaderFooterEvenPages。"},
        {"name": ".Range", "description": "屬性：傳回代表頁首/頁尾內容的 Range 物件。"},
        {"name": ".LinkToPrevious", "description": "屬性 (Boolean)：True 表示此頁首/頁尾與上一節的相同。"},
        {"name": ".Exists", "description": "屬性 (Boolean)：True 表示頁首/頁尾存在。"}
    ],
    "examples": [
        {"code": "Dim sec As Object ' Word.Section\nDim mainFooter As Object ' Word.HeaderFooter\n' Set sec = ActiveDocument.Sections(1)\n' Set mainFooter = sec.Footers(wdHeaderFooterPrimary) ' 1 = wdHeaderFooterPrimary\n' mainFooter.Range.ParagraphFormat.Alignment = wdAlignParagraphCenter\n' mainFooter.Range.Text = \"第 \"\n' mainFooter.Range.Fields.Add Range:=mainFooter.Range.Characters.Last, Type:=wdFieldPage\n' mainFooter.Range.InsertAfter \" 頁\"\n' MsgBox \"已設定主要頁尾內容。\"", "explanation": "獲取文件第一節的主要頁尾，將其內容置中對齊，並插入「第 [頁碼] 頁」的文字。"}
    ],
    "keywords": ["word header footer", "page number word", "edit footer", "頁首頁尾", "頁碼"]
},
// Outlook
{
    "name": "MailItem.ReadReceiptRequested",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.ReadReceiptRequested [= Boolean]",
    "description": "如果寄件者要求已讀回條，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "Boolean", "description": "True 表示要求已讀回條。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\n' olMail.Subject = \"請確認收到\"\n' olMail.To = \"someone@example.com\"\n' olMail.ReadReceiptRequested = True\n' olMail.Display", "explanation": "建立一封新郵件並設定要求已讀回條。"}
    ],
    "keywords": ["outlook read receipt", "request receipt", "已讀回條"]
},
{
    "name": "NameSpace.Folders (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set topLevelFolders = olNamespace.Folders",
    "description": "傳回一個 Folders 集合，代表目前設定檔中所有 MAPI 資料夾的頂層集合 (例如，您的郵箱根目錄下的資料夾、公用資料夾、存檔 PST 文件等)。",
    "parameters": [],
    "examples": [
        {"code": "Dim olNS As Object, fldrStore As Object ' Outlook.Folder (represents a message store)\nDim subFldr As Object ' Outlook.Folder\nSet olNS = CreateObject(\"Outlook.Application\").GetNamespace(\"MAPI\")\nDebug.Print \"頂層資料夾/郵箱儲存區:\"\nFor Each fldrStore In olNS.Folders\n  Debug.Print \"  - \" & fldrStore.Name & \" (路徑: \" & fldrStore.FolderPath & \")\"\n  ' To list subfolders of a specific store, e.g., your main mailbox\n  ' If fldrStore.Name = olNS.CurrentUser.Name Then ' Or your email address\n  '   For Each subFldr In fldrStore.Folders\n  '     Debug.Print \"    -- \" & subFldr.Name\n  '   Next subFldr\n  ' End If\nNext fldrStore", "explanation": "遍歷 Outlook 中的所有頂層資料夾 (通常是不同的郵箱儲存區) 並列印其名稱和路徑。"}
    ],
    "keywords": ["outlook top level folders", "all mailboxes outlook", "iterate stores", "頂層資料夾", "郵箱儲存區"]
},
{
    "name": "MAPIFolder.MoveTo (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "sourceMAPIFolderObject.MoveTo(DestinationFolder As MAPIFolder)",
    "description": "將目前的資料夾移動到指定的目標資料夾中。",
    "parameters": [{"name": "DestinationFolder", "description": "必需。MAPIFolder 物件，代表要將目前資料夾移動到的目標資料夾。"}],
    "examples": [
        {"code": "Dim olNS As Object, inbox As Object, archiveRoot As Object, targetSub As Object\nSet olNS = CreateObject(\"Outlook.Application\").GetNamespace(\"MAPI\")\nSet inbox = olNS.GetDefaultFolder(6) ' olFolderInbox\n' Assume an archive PST or another mailbox is already added and visible\n' Set archiveRoot = olNS.Folders(\"個人資料夾\") ' Or \"Archive Folders\"\n' If archiveRoot Is Nothing Then MsgBox \"未找到存檔資料夾根目錄。\": Exit Sub\n' On Error Resume Next\n' Set targetSub = inbox.Folders(\"Old Projects\") ' Folder to move\n' If targetSub Is Nothing Then MsgBox \"未找到 'Old Projects' 子資料夾。\": Exit Sub\n' On Error GoTo 0\n' targetSub.MoveTo archiveRoot ' Move \"Old Projects\" under the root of \"Archive Folders\"\n' MsgBox \"'Old Projects' 資料夾已移動到存檔根目錄。\"", "explanation": "演示如何將收件匣中的一個名為 \"Old Projects\" 的子資料夾移動到另一個頂層資料夾 (例如 \"個人資料夾\" 或 \"存檔資料夾\") 的根目錄下。"}
    ],
    "keywords": ["outlook move folder", "relocate folder", "移動資料夾Outlook"]
},
// PowerPoint
{
    "name": "Slide.Master Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set masterObj = slideObject.Master",
    "description": "傳回一個 Master 物件，代表指定投影片的投影片母片。此母片決定了投影片的背景、色彩配置、預留位置等。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object, sldMaster As Object ' PowerPoint.Master\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set sldMaster = pptSlide.Master\n' ' Example: Change background of the master for this slide (affects all slides using this master)\n' sldMaster.Background.Fill.ForeColor.RGB = RGB(240, 240, 240) ' Light grey\n' ' Or apply a specific design to the master:\n' ' sldMaster.Design = ActivePresentation.Designs(\"MyCustomDesignName\")\n' MsgBox \"第一張投影片的母片背景已嘗試更改。\"", "explanation": "獲取第一張投影片的母片物件，並嘗試更改其背景填充色。這會影響所有使用相同母片的投影片。"}
    ],
    "keywords": ["powerpoint slide master access", "get slide master", "投影片母片物件"]
},
{
    "name": "Slide.HeadersFooters Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set hfCollection = slideObject.HeadersFooters",
    "description": "傳回一個 HeadersFooters 集合，代表與指定投影片相關聯的頁首、頁尾、日期和時間以及投影片編號。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object, hf As Object ' PowerPoint.HeadersFooters\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set hf = pptSlide.HeadersFooters\n' With hf\n'   .DateAndTime.Visible = msoTrue\n'   .DateAndTime.UseFormat = msoTrue\n'   .DateAndTime.Format = ppDateTimeMMddyy ' Example format\n'   .Footer.Visible = msoTrue\n'   .Footer.Text = \"公司內部資料\"\n'   .SlideNumber.Visible = msoTrue\n' End With\n' MsgBox \"第一張投影片的頁首/頁尾資訊已設定。\"", "explanation": "獲取第一張投影片的 HeadersFooters 集合，並設定顯示日期時間 (特定格式)、頁尾文字和投影片編號。"}
    ],
    "keywords": ["powerpoint headers footers", "slide date time", "slide footer", "slide number ppt", "投影片頁首頁尾"]
},
// FSO
{
    "name": "Folder.IsRootFolder Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "booleanResult = folderObject.IsRootFolder",
    "description": "如果指定的資料夾是根資料夾，則傳回 True；否則傳回 False。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fldrC As Object, fldrWin As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldrC = fso.GetFolder(\"C:\\\")\nSet fldrWin = fso.GetFolder(\"C:\\Windows\")\nIf fldrC.IsRootFolder Then Debug.Print fldrC.Path & \" 是根資料夾。\"\nIf Not fldrWin.IsRootFolder Then Debug.Print fldrWin.Path & \" 不是根資料夾。\"", "explanation": "檢查 C:\\ 和 C:\\Windows 是否為根資料夾。"}
    ],
    "keywords": ["fso isrootfolder", "check root directory", "是否為根目錄"]
},
// String
{
    "name": "vbCr Constant",
    "category": "字串與文本操作",
    "syntax": "vbCr",
    "description": "一個內建常數，代表回車符 (Carriage Return, ASCII 字元碼 13)。在某些系統或情境下單獨使用，或與 vbLf (vbCrLf) 結合使用表示新行。",
    "parameters": [],
    "examples": [
        {"code": "Dim textWithCR As String\ntextWithCR = \"Line 1\" & vbCr & \"Line 2 (on some systems, CR alone moves to start of line, next char overwrites)\"\n' Debug.Print textWithCR\nMsgBox \"vbCr is ASCII \" & Asc(vbCr)", "explanation": "演示 vbCr 常數代表回車符。在現代 Windows 系統中，新行通常是 vbCrLf。"}
    ],
    "keywords": ["vbcr", "carriage return", "newline character", "回車符"]
},
{
    "name": "vbLf Constant",
    "category": "字串與文本操作",
    "syntax": "vbLf",
    "description": "一個內建常數，代表換行符 (Line Feed, ASCII 字元碼 10)。在 Unix/Linux 系統中，vbLf 單獨表示新行。",
    "parameters": [],
    "examples": [
        {"code": "Dim textWithLF As String\ntextWithLF = \"Paragraph 1.\" & vbLf & \"Paragraph 2.\"\n' Debug.Print textWithLF\nMsgBox \"vbLf is ASCII \" & Asc(vbLf)", "explanation": "演示 vbLf 常數代表換行符。"}
    ],
    "keywords": ["vblf", "line feed", "newline character", "換行符"]
},
// Program Flow
{
    "name": "Property Get/Let/Set Statements (Class Module)",
    "category": "程式流程與結構控制",
    "description": "在類別模組中定義類別的屬性。Property Get 用於讀取屬性值，Property Let 用於設定值類型屬性值，Property Set 用於設定物件類型屬性值。",
    "syntax": "Public Property Get PropertyName() As DataType\n  PropertyName = privateMemberVariable\nEnd Property\n\nPublic Property Let PropertyName(Value As DataType)\n  privateMemberVariable = Value\nEnd Property\n\nPublic Property Set ObjectProperty(obj As ObjectType)\n  Set privateObjectMember = obj\nEnd Property",
    "parameters": [
        {"name": "PropertyName", "description": "屬性的名稱。"},
        {"name": "DataType / ObjectType", "description": "屬性的資料類型或物件類型。"},
        {"name": "privateMemberVariable", "description": "類別模組內部用於儲存屬性值的私有變數。"}
    ],
    "examples": [
        {"code": "' --- In a Class Module named 'clsEmployee' ---\n' Private m_Name As String\n' Private m_Salary As Currency\n' Private m_Manager As clsEmployee ' Example of object property\n'\n' Public Property Get Name() As String\n'   Name = m_Name\n' End Property\n'\n' Public Property Let Name(ByVal NewName As String)\n'   If Len(NewName) > 0 Then m_Name = NewName\n' End Property\n'\n' Public Property Get Salary() As Currency\n'   Salary = m_Salary\n' End Property\n'\n' ' Read-only after initial set in a method, or could have Let\n' Friend Property Let InternalSalary(NewSalary As Currency) ' Friend scope for controlled write\n'    If NewSalary >= 0 Then m_Salary = NewSalary\n' End Property\n'\n' Public Property Get Manager() As clsEmployee\n'   Set Manager = m_Manager\n' End Property\n'\n' Public Property Set Manager(NewManager As clsEmployee)\n'   Set m_Manager = NewManager\n' End Property\n'\n' ' --- In a Standard Module to test ---\n' Sub TestEmployeeClass()\n'   Dim emp1 As New clsEmployee, emp2 As New clsEmployee\n'   emp1.Name = \"John Doe\"\n'   emp1.InternalSalary = 50000 ' Using Friend Let\n'   emp2.Name = \"Jane Smith\"\n'   Set emp1.Manager = emp2\n'   MsgBox emp1.Name & \"'s salary: \" & emp1.Salary & \", Manager: \" & emp1.Manager.Name\n' End Sub", "explanation": "clsEmployee 類別模組定義了 Name (讀/寫字串)、Salary (透過 Friend Let 進行內部寫入，外部唯讀Get) 和 Manager (讀/寫物件) 屬性。標準模組中的測試過程演示如何使用這些屬性。"}
    ],
    "keywords": ["property get", "property let", "property set", "class properties", "object properties", "屬性過程", "類別屬性"]
},
{
    "name": "Static Sub / Function",
    "category": "程式流程與結構控制",
    "syntax": "Static Sub ProcedureName([args])\n  ' Statements\nEnd Sub\n\nStatic Function FunctionName([args]) As ReturnType\n  ' Statements\nEnd Function",
    "description": "當一個過程 (Sub 或 Function) 被宣告為 Static 時，該過程內所有區域變數 (除非它們自己也被宣告為 Static) 的值會在過程呼叫之間被保留。這與在過程內部使用 Static 關鍵字宣告單個變數的效果不同，後者只影響該特定變數。整個過程宣告為 Static 意味著所有未明確指定儲存類型的區域變數都表現為靜態變數。然而，VBA 中 `Static Sub` 或 `Static Function` 的主要效果是，如果該過程位於非類別模組中，它會限制該過程的範圍僅為其所在的模組 (類似於 Private)，並且其所有局部變數在調用之間保留它們的值。在類別模組中，Static過程的行為與標準模組中的Private過程類似，但其局部變數依然是靜態的。這個特性用得較少，通常建議明確使用 `Static` 關鍵字來聲明需要保留值的變數。",
    "parameters": [],
    "examples": [
        {"code": "' In a Standard Module\nStatic Sub StaticProcedureDemo()\n    Dim regularVar As Integer ' This behaves like a Static variable due to Static Sub\n    Static staticVar As Integer ' Explicitly Static, same behavior here\n    regularVar = regularVar + 1\n    staticVar = staticVar + 5\n    Debug.Print \"Static Sub - RegularVar: \" & regularVar & \", StaticVar: \" & staticVar\nEnd Sub\n\nSub CallStaticProcMultipleTimes()\n    StaticProcedureDemo ' Call 1: RegularVar=1, StaticVar=5\n    StaticProcedureDemo ' Call 2: RegularVar=2, StaticVar=10\n    StaticProcedureDemo ' Call 3: RegularVar=3, StaticVar=15\nEnd Sub", "explanation": "由於 StaticProcedureDemo 被宣告為 Static Sub，其內部的 regularVar (即使沒有用 Static 關鍵字宣告) 也會在多次呼叫之間保留其值並遞增。明確宣告的 staticVar 也是如此。"}
    ],
    "keywords": ["static sub", "static function", "preserve local variables", "procedure scope", "靜態過程", "保留局部變數值"]
},
// --- Final command to make it 100 ---
{
    "name": "Application.RecentFiles Property (Excel/Word/PowerPoint)",
    "category": "綜合應用案例與技巧",
    "syntax": "Set rfs = Application.RecentFiles",
    "description": "傳回一個 RecentFiles 集合，代表最近使用的檔案清單。",
    "parameters": [
        {"name": ".Count", "description": "屬性：傳回集合中的檔案數量。"},
        {"name": ".Item(Index)", "description": "屬性：傳回集合中特定索引的 RecentFile 物件。"},
        {"name": ".Maximum", "description": "屬性：設定或傳回最近使用檔案清單中允許的最大檔案數。"},
        {"name": "RecentFile.Name", "description": "屬性：傳回檔案的名稱。"},
        {"name": "RecentFile.Path", "description": "屬性：傳回檔案的完整路徑。"},
        {"name": "RecentFile.Open()", "description": "方法：開啟此最近使用的檔案。"}
    ],
    "examples": [
        {"code": "Dim rf As Object ' RecentFile\nDim recentFileMsg As String\nIf Application.RecentFiles.Count > 0 Then\n    recentFileMsg = \"最近使用的前3個檔案:\\n\"\n    Dim i As Integer\n    For i = 1 To Application.RecentFiles.Count\n        If i > 3 Then Exit For ' Display only top 3\n        Set rf = Application.RecentFiles(i)\n        recentFileMsg = recentFileMsg & i & \". \" & rf.Name & \" (\" & rf.Path & \")\\n\"\n    Next i\n    MsgBox recentFileMsg\n    ' Example to open the most recent file:\n    ' If MsgBox(\"是否開啟最新的檔案: \" & Application.RecentFiles(1).Name & \"?\", vbYesNo) = vbYes Then\n    '   Application.RecentFiles(1).Open\n    ' End If\nElse\n    MsgBox \"沒有最近使用的檔案記錄。\"\nEnd If\nSet rf = Nothing", "explanation": "遍歷 Office 應用程式（如 Excel）的最近使用檔案列表，並顯示前三個檔案的名稱和路徑。同時，註解中展示了如何打開列表中的第一個檔案。"}
    ],
    "keywords": ["recent files", "mru list", "recently used files", "application recent documents", "最近使用的檔案", "MRU列表", "通用"]
},
{
    "name": "Range.Show (Outline)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Show",
    "description": "如果範圍是可展開或摺疊大綱的一部分，則展開該大綱以顯示詳細資料。",
    "parameters": [],
    "examples": [
        {"code": "' Assuming Rows 2-5 are grouped and collapsed under Row 1\n' Rows(1).Show ' Expands the group under row 1\n' Columns(\"A\").Show ' If column A is part of a collapsed group, expands it", "explanation": "展開包含在指定範圍內已摺疊的任何大綱級別。"}
    ],
    "keywords": ["展開大綱顯示", "show outline excel", "expand group"]
},
{
    "name": "Range.ColumnDifferences",
    "category": "Excel 核心操作",
    "syntax": "Set diffCells = rangeObject.ColumnDifferences(Comparison As Range)",
    "description": "傳回一個 Range 物件，代表指定範圍中所有其內容與比較儲存格 (Comparison) 不同的儲存格。比較是逐欄進行的。",
    "parameters": [
        {"name": "Comparison", "description": "必需。Range 物件，指定每欄中要與之比較的儲存格。通常是該欄的第一個儲存格。"}
    ],
    "examples": [
        {"code": "Dim myRange As Range, diffs As Range\nSet myRange = Range(\"A1:A10\") ' Column to check\n' Compare each cell in A2:A10 with A1\nOn Error Resume Next ' If all cells are same, diffs will be Nothing\nSet diffs = myRange.ColumnDifferences(Comparison:=myRange.Cells(1, 1))\nOn Error GoTo 0\nIf Not diffs Is Nothing Then\n  MsgBox \"A欄中與A1不同的儲存格有: \" & diffs.Address\n  diffs.Font.Color = vbRed\nElse\n  MsgBox \"A欄中所有儲存格 (A2:A10) 都與A1相同，或範圍只有一行。\"\nEnd If", "explanation": "找出A欄 (A2:A10) 中與A1儲存格內容不同的所有儲存格，並將其字型設為紅色。"}
    ],
    "keywords": ["欄差異", "比較儲存格", "不同儲存格", "excel", "column differences", "compare cells"]
},
{
    "name": "Range.RowDifferences",
    "category": "Excel 核心操作",
    "syntax": "Set diffCells = rangeObject.RowDifferences(Comparison As Range)",
    "description": "傳回一個 Range 物件，代表指定範圍中所有其內容與比較儲存格 (Comparison) 不同的儲存格。比較是逐列進行的。",
    "parameters": [
        {"name": "Comparison", "description": "必需。Range 物件，指定每列中要與之比較的儲存格。通常是該列的第一個儲存格。"}
    ],
    "examples": [
        {"code": "Dim myRange As Range, diffs As Range\nSet myRange = Range(\"A1:E1\") ' Row to check\n' Compare each cell in B1:E1 with A1\nOn Error Resume Next\nSet diffs = myRange.RowDifferences(Comparison:=myRange.Cells(1, 1))\nOn Error GoTo 0\nIf Not diffs Is Nothing Then\n  MsgBox \"第1列中與A1不同的儲存格有: \" & diffs.Address\n  diffs.Interior.Color = vbYellow\nElse\n  MsgBox \"第1列中所有儲存格 (B1:E1) 都與A1相同，或範圍只有一欄。\"\nEnd If", "explanation": "找出第1列 (B1:E1) 中與A1儲存格內容不同的所有儲存格，並將其背景設為黃色。"}
    ],
    "keywords": ["列差異", "比較儲存格", "excel", "row differences", "compare cells"]
},
{
    "name": "Range.Replace (Detailed)",
    "category": "Excel 核心操作",
    "syntax": "booleanResult = rangeObject.Replace(What, Replacement, [LookAt As XlLookAt = xlPart], [SearchOrder As XlSearchOrder = xlByRows], [MatchCase As Boolean = False], [MatchByte], [SearchFormat As Boolean = False], [ReplaceFormat As Boolean = False])",
    "description": "在指定的儲存格範圍內尋找並取代字元。如果找到並取代了任何資訊，則傳回 True。",
    "parameters": [
        {"name": "What", "description": "必需。要搜尋的字串。"},
        {"name": "Replacement", "description": "必需。取代字串。"},
        {"name": "LookAt", "description": "可選。xlPart (預設，部分符合) 或 xlWhole (完全符合)。"},
        {"name": "SearchOrder", "description": "可選。xlByRows (預設) 或 xlByColumns。"},
        {"name": "MatchCase", "description": "可選。False (預設，不區分大小寫) 或 True (區分大小寫)。"},
        {"name": "SearchFormat/ReplaceFormat", "description": "可選。用於基於格式進行搜尋/取代。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A10\").Replace What:=\"OldText\", Replacement:=\"NewText\", LookAt:=xlWhole, MatchCase:=True\nMsgBox \"A1:A10中所有'OldText'(區分大小寫，完全符合)已取代為'NewText'。\"", "explanation": "在A1:A10範圍內，將所有完全符合且區分大小寫的 \"OldText\" 取代為 \"NewText\"。"}
    ],
    "keywords": ["取代文字", "尋找並取代", "excel range replace", "find and replace"]
},
{
    "name": "Range.PrintOut (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.PrintOut([From], [To], [Copies], [Preview], [ActivePrinter], [PrintToFile], [Collate], [PrToFileName])",
    "description": "列印指定的物件 (可以是儲存格範圍、整個工作表、整個活頁簿)。",
    "parameters": [
        {"name": "From", "description": "可選。要開始列印的頁碼。"},
        {"name": "To", "description": "可選。要結束列印的頁碼。"},
        {"name": "Copies", "description": "可選。要列印的份數。"},
        {"name": "Preview", "description": "可選。True 表示在列印前預覽。"}
    ],
    "examples": [
        {"code": "Range(\"A1:D20\").PrintOut Copies:=2, Preview:=True", "explanation": "預覽列印範圍 A1:D20，並設定列印兩份。"},
        {"code": "ActiveSheet.PrintOut From:=1, To:=1 ' Print only the first page of the active sheet", "explanation": "僅列印活動工作表的第一頁。"}
    ],
    "keywords": ["列印範圍", "列印工作表", "excel print", "print range", "print sheet"]
},
// Word
{
    "name": "Document.Words(Index).Text (Word)",
    "category": "Word 文件處理",
    "syntax": "wordText = documentObject.Words(Index).Text",
    "description": "傳回文件中指定索引位置的單字的文字內容 (String)。Words 集合中的單字包含其後的空格。",
    "parameters": [
        {"name": "Index", "description": "必需。Words 集合中的單字索引 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Words.Count >= 3 Then\n'   MsgBox \"文件的第三個單字 (含空格) 是: '\" & wdDoc.Words(3).Text & \"'\"\n'   Debug.Print \"(去除前後空格後: '\" & Trim(wdDoc.Words(3).Text) & \"')\"\n' End If", "explanation": "如果文件至少有三個單字，則顯示第三個單字的文字 (它會包含單字後的空格)。"}
    ],
    "keywords": ["word get word text", "access specific word", "讀取特定單字"]
},
{
    "name": "Range.Collapse (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Collapse(Direction As WdCollapseDirection)",
    "description": "將指定的範圍摺疊到其起始或結束位置，使其成為一個插入點。",
    "parameters": [
        {"name": "Direction", "description": "必需。WdCollapseDirection 常數 (wdCollapseStart 或 wdCollapseEnd)。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' If selRange.Type <> wdSelectionIP Then ' If something is selected\n'   selRange.Collapse Direction:=1 ' 1 = wdCollapseEnd (collapse to end of selection)\n'   selRange.InsertAfter \" (已摺疊到選取範圍末尾並插入文字)\"\n' End If", "explanation": "如果使用者選取了文字，則將選取範圍摺疊到其結束位置 (變成一個插入點)，然後在該位置後插入文字。"}
    ],
    "keywords": ["word collapse range", "make range insertion point", "摺疊範圍", "變成插入點"]
},
{
    "name": "Font.Superscript / .Subscript (Word/Excel/PPT Text)",
    "category": "Word 文件處理",
    "syntax": "fontObject.Superscript = True | False\nfontObject.Subscript = True | False",
    "description": "設定或傳回文字是否格式化為上標或下標。這些屬性是互斥的。",
    "parameters": [{"name": "True | False", "description": "讀取/寫入布林值。"}],
    "examples": [
        {"code": "' In Word, for selected text:\n' With Selection.Font\n'   .Superscript = True ' Make text superscript\n'   ' .Subscript = True ' This would turn off superscript and turn on subscript\n' End With\n' MsgBox \"選取文字已設為上標。\"", "explanation": "將目前選取的文字格式化為上標。注意在 Word、Excel (儲存格文字) 和 PowerPoint (文字框文字) 的 Font 物件中均可使用。"}
    ],
    "keywords": ["superscript", "subscript", "text formatting", "上標", "下標", "文字格式", "通用"]
},
// Outlook
{
    "name": "MailItem.DeferredDeliveryTime",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.DeferredDeliveryTime = DateTimeValue",
    "description": "設定或傳回一個 Date，表示郵件的延遲傳送日期和時間。",
    "parameters": [{"name": "DateTimeValue", "description": "郵件應傳送的未來日期和時間。"}],
    "examples": [
        {"code": "Dim olMail As Object\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.To = \"recipient@example.com\"\nolMail.Subject = \"Scheduled Email\"\nolMail.Body = \"This email is scheduled to be sent later.\"\nolMail.DeferredDeliveryTime = Now + TimeValue(\"02:00:00\") ' Send in 2 hours\n' olMail.Send ' This will place it in Outbox until delivery time\nMsgBox \"郵件已設定為2小時後傳送。\"", "explanation": "建立一封新郵件，並將其設定為從現在起2小時後延遲傳送。調用 .Send 後，郵件會進入寄件匣等待。"}
    ],
    "keywords": ["outlook deferred delivery", "schedule email", "delay sending", "延遲傳送", "排程郵件"]
},
{
    "name": "MailItem.ExpiryTime",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.ExpiryTime = DateTimeValue",
    "description": "設定或傳回一個 Date，表示 Outlook 項目的到期日期和時間，之後該項目可能被視為過期或自動刪除 (取決於用戶端和伺服器設定)。",
    "parameters": [{"name": "DateTimeValue", "description": "項目的到期日期和時間。"}],
    "examples": [
        {"code": "Dim olMail As Object\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.Subject = \"Limited Time Offer - Expires Soon!\"\nolMail.To = \"customer@example.com\"\nolMail.Body = \"This offer expires in 3 days.\"\nolMail.ExpiryTime = Now + 3 ' Expires in 3 days from now\nolMail.Display", "explanation": "建立一封新郵件，並將其設定為3天後到期。"}
    ],
    "keywords": ["outlook email expiry", "message expiration", "郵件到期時間"]
},
// PowerPoint
{
    "name": "Shapes.AddChart (PowerPoint - Legacy)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set shpChart = slideObject.Shapes.AddChart([Type As XlChartType = xlColumnClustered], [Left], [Top], [Width], [Height])",
    "description": "在投影片上新增一個圖表。這是較舊的新增圖表方法，AddChart2 提供了更多選項。此方法通常會開啟一個 Excel 視窗供編輯資料。",
    "parameters": [
        {"name": "Type", "description": "可選。XlChartType 常數。"},
        {"name": "Left, Top, Width, Height", "description": "可選。圖表的位置和大小。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, chartShape As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, 12) ' ppLayoutBlank\n' Set chartShape = pptSlide.Shapes.AddChart(Type:=xlLine, Left:=50, Top:=50, Width:=400, Height:=250)\n' ' To access chart data (opens an Excel instance):\n' Dim chartData As Object ' Excel.ChartData\n' Dim wbChart As Object   ' Excel.Workbook\n' Dim wsChart As Object   ' Excel.Worksheet\n' Set chartData = chartShape.Chart.ChartData\n' chartData.Activate ' This makes the Excel data grid visible\n' Set wbChart = chartData.Workbook\n' Set wsChart = wbChart.Worksheets(1)\n' wsChart.Range(\"A1:B5\").Value = Application.Transpose(Array(Array(\"Category\", \"Value\"), Array(\"A\", 10), Array(\"B\", 20), Array(\"C\", 15), Array(\"D\", 25)))\n' wbChart.Close SaveChanges:=False ' Close the Excel data window\n' chartShape.Chart.HasTitle = True\n' chartShape.Chart.ChartTitle.Text = \"舊版圖表範例\"", "explanation": "在新投影片上使用舊版 AddChart 方法新增一個折線圖，並示範如何存取和修改其關聯的 Excel 資料工作表。"}
    ],
    "keywords": ["powerpoint addchart legacy", "insert chart old method", "ppt excel chart data", "新增圖表 (舊版)"]
},
{
    "name": "Shapes.AddSmartArt (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set saShape = slideObject.Shapes.AddSmartArt(Layout As SmartArtLayout, [Left], [Top], [Width], [Height])",
    "description": "將 SmartArt 圖形新增至投影片。",
    "parameters": [
        {"name": "Layout", "description": "必需。SmartArtLayout 物件，指定要新增的 SmartArt 圖形版面配置。"},
        {"name": "Left, Top, Width, Height", "description": "可選。SmartArt 圖形的位置和大小。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, smArt As Object ' PowerPoint.Shape\nDim saLayout As Object ' SmartArtLayout\n' Set pptSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, ppLayoutBlank)\n' ' Get a specific SmartArt layout (e.g., Organization Chart)\n' ' Need to ensure PowerPoint application object is available for Application.SmartArtLayouts\n' Dim pptApp As Object: Set pptApp = CreateObject(\"PowerPoint.Application\")\n' Set saLayout = pptApp.SmartArtLayouts(109) ' 109 is an example ID for an org chart type\n' If Not saLayout Is Nothing Then\n'   Set smArt = pptSlide.Shapes.AddSmartArt(Layout:=saLayout, Left:=50, Top:=50, Width:=500, Height:=300)\n'   ' Populate SmartArt nodes (this is complex and depends on the layout)\n'   ' smArt.SmartArt.Nodes(1).TextFrame2.TextRange.Text = \"CEO\"\n'   ' smArt.SmartArt.Nodes(1).Nodes.Add.TextFrame2.TextRange.Text = \"VP1\"\n'   MsgBox \"SmartArt 圖形 ('\" & saLayout.Name & \"') 已新增。\"\n' Else\n'   MsgBox \"未找到指定的SmartArt版面配置。\"\n' End If", "explanation": "在新投影片上新增一個 SmartArt 圖形 (此處以組織圖為例的概念性 ID)。填充 SmartArt 節點需要額外的代碼。"}
    ],
    "keywords": ["powerpoint add smartart", "insert smartart graphic", "ppt smartart", "新增SmartArt圖形"]
},
// FSO
{
    "name": "Folder.DateCreated Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "dateValue = folderObject.DateCreated",
    "description": "傳回指定資料夾的建立日期和時間。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fldr As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldr = fso.GetFolder(\"C:\\Windows\")\nMsgBox \"資料夾 '\" & fldr.Name & \"' 建立於: \" & fldr.DateCreated", "explanation": "顯示 C:\\Windows 資料夾的建立日期和時間。"}
    ],
    "keywords": ["fso folder datecreated", "directory creation time", "資料夾建立日期"]
},
{
    "name": "Folder.DateLastAccessed Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "dateValue = folderObject.DateLastAccessed",
    "description": "傳回指定資料夾的上次存取日期和時間。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fldr As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldr = fso.GetFolder(\"C:\\Users\")\nMsgBox \"資料夾 '\" & fldr.Name & \"' 上次存取於: \" & fldr.DateLastAccessed", "explanation": "顯示 C:\\Users 資料夾的上次存取日期和時間。"}
    ],
    "keywords": ["fso folder datelastaccessed", "directory access time", "資料夾上次存取日期"]
},
{
    "name": "Folder.DateLastModified Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "dateValue = folderObject.DateLastModified",
    "description": "傳回指定資料夾的上次修改日期和時間。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fldr As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldr = fso.GetFolder(\"C:\\Program Files\")\nMsgBox \"資料夾 '\" & fldr.Name & \"' 上次修改於: \" & fldr.DateLastModified", "explanation": "顯示 C:\\Program Files 資料夾的上次修改日期和時間。"}
    ],
    "keywords": ["fso folder datelastmodified", "directory modification time", "資料夾上次修改日期"]
},
// String
{
    "name": "ChrW / AscW (Unicode)",
    "category": "字串與文本操作",
    "syntax": "charString = ChrW(CharCode As Long)\ncharCodeLong = AscW(String As String)",
    "description": "ChrW 返回與指定 Unicode (寬字元) 字元碼相關聯的字元。AscW 返回字串第一個字元的 Unicode 字元碼。這些函數用於處理超出標準 ANSI (0-255) 範圍的 Unicode 字元。",
    "parameters": [
        {"name": "CharCode (ChrW)", "description": "必需。Unicode 字元碼。"},
        {"name": "String (AscW)", "description": "必需。任何有效的字串表達式。"}
    ],
    "examples": [
        {"code": "Dim unicodeChar As String, unicodeCode As Long\n' Example: Euro symbol € (Unicode U+20AC, Decimal 8364)\nunicodeChar = ChrW(8364)\nMsgBox \"ChrW(8364) = \" & unicodeChar\n\nunicodeCode = AscW(unicodeChar)\nMsgBox \"AscW(\" & unicodeChar & \") = \" & unicodeCode", "explanation": "演示如何使用 ChrW 從 Unicode 碼點創建歐元符號 (€)，以及如何使用 AscW 獲取其 Unicode 碼點。"}
    ],
    "keywords": ["chrw", "ascw", "unicode characters", "wide characters", "Unicode字元", "寬字元"]
},
// Math
{
    "name": "WorksheetFunction.SumIf (Excel)",
    "category": "數學、日期與時間",
    "syntax": "sumResult = Application.WorksheetFunction.SumIf(Range, Criteria, [Sum_Range])",
    "description": "使用 Excel 的 SUMIF 工作表函數，對符合指定條件的儲存格進行加總。",
    "parameters": [
        {"name": "Range", "description": "必需。要評估條件的儲存格範圍。"},
        {"name": "Criteria", "description": "必需。決定哪些儲存格將被加總的條件 (數字、表達式或文字)。"},
        {"name": "Sum_Range", "description": "可選。要加總的實際儲存格。如果省略，則對 Range 中的儲存格進行加總。"}
    ],
    "examples": [
        {"code": "' Assume A1:A5 contains product names, B1:B5 contains sales amounts\n' Range(\"A1:B5\").Value = Application.Transpose(Array(Array(\"Apple\", 100), Array(\"Banana\", 150), Array(\"Apple\", 200), Array(\"Orange\", 50), Array(\"Apple\", 120)))\nDim totalAppleSales As Double\ntotalAppleSales = Application.WorksheetFunction.SumIf(Range(\"A1:A5\"), \"Apple\", Range(\"B1:B5\"))\nMsgBox \"Apple產品的總銷售額是: \" & totalAppleSales ' Should be 100+200+120 = 420", "explanation": "計算A欄中產品名稱為 \"Apple\" 的所有對應B欄銷售額的總和。"}
    ],
    "keywords": ["sumif", "conditional sum", "excel sumif vba", "條件加總"]
},
{
    "name": "WorksheetFunction.CountIf (Excel)",
    "category": "數學、日期與時間",
    "syntax": "countResult = Application.WorksheetFunction.CountIf(Range, Criteria)",
    "description": "使用 Excel 的 COUNTIF 工作表函數，計算範圍中符合指定條件的非空儲存格數量。",
    "parameters": [
        {"name": "Range", "description": "必需。要計數的儲存格範圍。"},
        {"name": "Criteria", "description": "必需。決定哪些儲存格將被計數的條件。"}
    ],
    "examples": [
        {"code": "' Range(\"A1:A10\").Value = Application.Transpose(Array(10,20,5,25,10,15,30,10,8,22))\nDim countOver15 As Long\ncountOver15 = Application.WorksheetFunction.CountIf(Range(\"A1:A10\"), \">15\")\nMsgBox \"A1:A10 中大於15的數字有 \" & countOver15 & \" 個。\"", "explanation": "計算A1:A10範圍內值大於15的儲存格數量。"}
    ],
    "keywords": ["countif", "conditional count", "excel countif vba", "條件計數"]
},
// Data Types
{
    "name": "Empty Keyword (Variant)",
    "category": "資料類型、轉換與驗證",
    "syntax": "variantVariable = Empty",
    "description": "Empty 是一個關鍵字，用於指示一個 Variant 變數尚未被初始化 (即未賦予任何值)。它是 Variant 變數的預設初始狀態。可以使用 IsEmpty 函數檢查變數是否為 Empty。",
    "parameters": [],
    "examples": [
        {"code": "Dim myVar As Variant ' myVar is Empty at this point\nDim anotherVar As Variant\nIf IsEmpty(myVar) Then Debug.Print \"myVar is Empty.\"\nmyVar = 100\nIf Not IsEmpty(myVar) Then Debug.Print \"myVar is now \" & myVar\nanotherVar = Empty ' Explicitly set to Empty\nIf IsEmpty(anotherVar) Then Debug.Print \"anotherVar has been set to Empty.\"", "explanation": "演示 Variant 變數的預設 Empty 狀態，以及如何明確地將 Variant 變數設為 Empty。"}
    ],
    "keywords": ["empty keyword", "uninitialized variant", "variant state", "isempty", "未初始化Variant"]
},
// Program Flow
{
    "name": "On...GoTo Statement (Legacy)",
    "category": "程式流程與結構控制",
    "syntax": "On expression GoTo destinationlist",
    "description": "根據運算式的值，分支到指定的幾個行標籤或行號之一。如果 expression 的值是 1，則跳轉到 destinationlist 中的第一個標籤/行號；如果是 2，則跳轉到第二個，依此類推。這是較舊的 BASIC 結構，通常被 Select Case 取代。",
    "parameters": [
        {"name": "expression", "description": "必需。任何評估為小範圍正整數的數值運算式。"},
        {"name": "destinationlist", "description": "必需。以逗號分隔的行號或行標籤列表。"}
    ],
    "examples": [
        {"code": "Sub TestOnGoTo()\n  Dim choice As Integer\n  choice = CInt(InputBox(\"輸入 1 (顯示訊息), 2 (顯示時間), 或 3 (結束):\"))\n  If choice < 1 Or choice > 3 Then GoTo InvalidChoice\n  On choice GoTo ShowMessage, ShowTime, EndProgram\nShowMessage:\n  MsgBox \"您選擇了顯示訊息。\"\n  GoTo EndProcessing\nShowTime:\n  MsgBox \"目前時間是: \" & Time\n  GoTo EndProcessing\nInvalidChoice:\n  MsgBox \"無效的選擇。\"\nEndProgram:\n  Debug.Print \"程式即將結束或已處理。\"\nEndProcessing:\n  Debug.Print \"處理完成。\"\nEnd Sub", "explanation": "根據使用者輸入的數字 (1, 2, 或 3)，程式會跳轉到相應的標籤。此範例顯示了 GoTo 如何使流程控制變得複雜。"}
    ],
    "keywords": ["on goto", "computed goto", "legacy control flow", "分支", "多路跳轉"]
},
// External API
{
    "name": "CreateShortcut (WScript.Shell)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "Set shortcutObj = wshShell.CreateShortcut(PathLink As String)",
    "description": "使用 Windows Script Host Shell 物件的 CreateShortcut 方法來建立捷徑 (.lnk) 檔案。",
    "parameters": [
        {"name": "PathLink", "description": "必需。字串，指定要建立的捷徑檔案的完整路徑和名稱。"},
        {"name": "Shortcut Object Properties", "description": ".TargetPath (要指向的檔案/程式)、.Arguments (參數)、.WorkingDirectory、.IconLocation、.WindowStyle、.Description、.Hotkey。"},
        {"name": "Shortcut Object .Save() Method", "description": "儲存捷徑檔案。"}
    ],
    "examples": [
        {"code": "Sub CreateDesktopShortcutToNotepad()\n    Dim wshShell As Object, oShellLink As Object\n    Dim desktopPath As String\n\n    Set wshShell = CreateObject(\"WScript.Shell\")\n    desktopPath = wshShell.SpecialFolders(\"Desktop\") ' Get path to desktop\n    \n    If desktopPath = \"\" Then\n        MsgBox \"無法獲取桌面路徑。\", vbCritical\n        Exit Sub\n    End If\n\n    Set oShellLink = wshShell.CreateShortcut(desktopPath & \"\\記事本捷徑.lnk\")\n    With oShellLink\n        .TargetPath = Environ(\"SystemRoot\") & \"\\System32\\notepad.exe\"\n        .Arguments = \"C:\\Temp\\MyFile.txt\" ' Optional: file to open with notepad\n        .WorkingDirectory = Environ(\"SystemRoot\") & \"\\System32\"\n        .WindowStyle = 1 ' 1 = Normal, 3 = Maximized, 7 = Minimized\n        .IconLocation = Environ(\"SystemRoot\") & \"\\System32\\notepad.exe, 0\"\n        .Description = \"開啟記事本並載入MyFile.txt\"\n        ' .Hotkey = \"CTRL+SHIFT+N\" ' Example Hotkey (use with caution)\n        .Save\n    End With\n    MsgBox \"記事本的捷徑已創建在您的桌面上！\"\n    Set oShellLink = Nothing\n    Set wshShell = Nothing\nEnd Sub", "explanation": "此子程序在用戶桌面上創建一個名為“記事本捷徑.lnk”的捷徑。該捷徑指向 Windows 的記事本程式 (notepad.exe)，並設定了它打開時可以加載的可選文件、工作目錄、圖標、描述等屬性。"}
    ],
    "keywords": ["wscript.shell createshortcut", "vba create lnk file", "desktop shortcut vba", "windows scripting host", "創建捷徑", "桌面快捷方式"]
},
{
    "name": "SpecialFolders Property (WScript.Shell)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "folderPath = wshShell.SpecialFolders(SpecialFolderName As String)",
    "description": "傳回 Windows 特殊資料夾的路徑 (例如 Desktop, MyDocuments, StartMenu, Favorites)。",
    "parameters": [
        {"name": "SpecialFolderName", "description": "必需。字串，指定特殊資料夾的名稱 (例如 \"Desktop\", \"MyDocuments\", \"AppData\", \"StartMenu\", \"Favorites\", \"Startup\", \"Recent\", \"SendTo\", \"Templates\", \"Fonts\", \"ProgramFiles\", \"System\")。"}
    ],
    "examples": [
        {"code": "Dim wshShell As Object\nSet wshShell = CreateObject(\"WScript.Shell\")\nDebug.Print \"Desktop: \" & wshShell.SpecialFolders(\"Desktop\")\nDebug.Print \"My Documents: \" & wshShell.SpecialFolders(\"MyDocuments\")\nDebug.Print \"Application Data: \" & wshShell.SpecialFolders(\"AppData\")\nDebug.Print \"Program Files: \" & wshShell.SpecialFolders(\"ProgramFiles\")\nSet wshShell = Nothing", "explanation": "使用 WScript.Shell 物件的 SpecialFolders 屬性獲取常用 Windows 特殊資料夾的路徑並列印到立即視窗。"}
    ],
    "keywords": ["wscript.shell specialfolders", "windows special folders vba", "get desktop path", "get mydocuments path", "特殊資料夾路徑", "系統文件夾"]
},
// Excel 核心操作
{
    "name": "Range.EntireRow.Delete",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.EntireRow.Delete([Shift As XlDeleteShiftDirection])",
    "description": "刪除包含指定範圍的整個列。下方儲存格會向上移動以填補空間。",
    "parameters": [
        {"name": "Shift", "description": "可選。通常省略，因為刪除整列時下方列會自動上移。"}
    ],
    "examples": [
        {"code": "Range(\"A5\").EntireRow.Delete ' 刪除第5列", "explanation": "刪除包含儲存格A5的整列 (即第5列)。"},
        {"code": "Selection.EntireRow.Delete ' 刪除目前選取儲存格所在的整列", "explanation": "刪除使用者目前選取範圍所在的整列或多列。"}
    ],
    "keywords": ["刪除整列", "移除列", "excel", "delete entire row", "remove row"]
},
{
    "name": "Range.EntireColumn.Delete",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.EntireColumn.Delete([Shift As XlDeleteShiftDirection])",
    "description": "刪除包含指定範圍的整個欄。右方儲存格會向左移動以填補空間。",
    "parameters": [
        {"name": "Shift", "description": "可選。通常省略，因為刪除整欄時右方欄會自動左移。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").EntireColumn.Delete ' 刪除C欄", "explanation": "刪除包含儲存格C1的整欄 (即C欄)。"},
        {"code": "Range(\"B2:D5\").EntireColumn.Delete ' 刪除B、C、D三欄", "explanation": "刪除包含範圍B2:D5的所有欄 (即B、C和D欄)。"}
    ],
    "keywords": ["刪除整欄", "移除欄", "excel", "delete entire column", "remove column"]
},
{
    "name": "Range.EntireRow.Insert",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.EntireRow.Insert([Shift As XlInsertShiftDirection = xlShiftDown], [CopyOrigin As XlInsertFormatOrigin = xlFormatFromLeftOrAbove])",
    "description": "在指定範圍的上方插入一個新的空白列 (或多列)。原來的列會向下移動。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A3\").EntireRow.Insert ' 在第3列上方插入一個新列", "explanation": "在第3列上方插入一個新的空白列，原第3列及以下各列下移。"},
        {"code": "Range(\"A5:A7\").EntireRow.Insert ' 在第5列上方插入3個新列", "explanation": "基於選取了3列的範圍，在其上方插入3個新的空白列。"}
    ],
    "keywords": ["插入整列", "新增列", "excel", "insert entire row", "add row"]
},
{
    "name": "Range.EntireColumn.Insert",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.EntireColumn.Insert([Shift As XlInsertShiftDirection = xlShiftToRight], [CopyOrigin As XlInsertFormatOrigin = xlFormatFromLeftOrAbove])",
    "description": "在指定範圍的左側插入一個新的空白欄 (或多欄)。原來的欄會向右移動。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"C1\").EntireColumn.Insert ' 在C欄左側插入一個新欄", "explanation": "在C欄左側插入一個新的空白欄，原C欄及右側各欄右移。"},
        {"code": "Range(\"D2:E5\").EntireColumn.Insert ' 在D欄左側插入2個新欄", "explanation": "基於選取了2欄的範圍，在其左側插入2個新的空白欄。"}
    ],
    "keywords": ["插入整欄", "新增欄", "excel", "insert entire column", "add column"]
},
{
    "name": "Worksheet.Move (Before/After Another Sheet)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Move([Before], [After])",
    "description": "將工作表移動到活頁簿中的另一個位置，可以指定在其前或其後的工作表。",
    "parameters": [
        {"name": "Before", "description": "可選。工作表物件，移動的工作表將置於其前。"},
        {"name": "After", "description": "可選。工作表物件，移動的工作表將置於其後。"}
    ],
    "examples": [
        {"code": "ThisWorkbook.Sheets(\"Sheet3\").Move Before:=ThisWorkbook.Sheets(1)", "explanation": "將名為 \"Sheet3\" 的工作表移動到活頁簿中第一個工作表之前。"},
        {"code": "Dim wsToMove As Worksheet, wsTarget As Worksheet\nSet wsToMove = ThisWorkbook.Sheets(\"DataInput\")\nSet wsTarget = ThisWorkbook.Sheets(\"Summary\")\nwsToMove.Move After:=wsTarget", "explanation": "將 \"DataInput\" 工作表移動到 \"Summary\" 工作表之後。"}
    ],
    "keywords": ["移動工作表位置", "重排工作表", "excel", "move sheet order", "reorder sheets"]
},
{
    "name": "Range.CurrentRegion.Select",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.CurrentRegion.Select",
    "description": "選取由空白列和空白欄包圍的目前區域。通常用於選取一個完整的資料區塊。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").CurrentRegion.Select ' 如果A1是資料區塊的左上角，則選取整個區塊", "explanation": "選取以A1儲存格為起點的連續資料區域。"},
        {"code": "Dim targetCell As Range\nSet targetCell = ActiveSheet.Cells(5, 3) ' C5\n' Select the data block that C5 belongs to\ntargetCell.CurrentRegion.Select", "explanation": "選取包含儲存格C5的連續資料區塊。"}
    ],
    "keywords": ["選取目前區域", "選取資料區塊", "excel", "select current region", "select data block"]
},
{
    "name": "Range.SpecialCells(xlCellTypeLastCell)",
    "category": "Excel 核心操作",
    "syntax": "Set lastCell = worksheetObject.Cells.SpecialCells(xlCellTypeLastCell)",
    "description": "傳回工作表上已使用範圍中的最後一個儲存格。這個儲存格可能不一定是包含資料的最後一個儲存格，而是Excel內部記錄的“已使用”區域的右下角。",
    "parameters": [],
    "examples": [
        {"code": "Dim lc As Range\nSet lc = ActiveSheet.Cells.SpecialCells(xlCellTypeLastCell)\nMsgBox \"工作表上的最後一個儲存格 (Excel內部記錄) 是: \" & lc.Address", "explanation": "獲取活動工作表上被Excel視為“最後使用”的儲存格。"},
        {"code": "' To get the true last cell with data, often better to use:\n' Dim trueLastRow As Long, trueLastCol As Long\n' If WorksheetFunction.CountA(ActiveSheet.Cells) > 0 Then\n'    trueLastRow = ActiveSheet.Cells.Find(What:=\"*\", SearchOrder:=xlByRows, SearchDirection:=xlPrevious).Row\n'    trueLastCol = ActiveSheet.Cells.Find(What:=\"*\", SearchOrder:=xlByColumns, SearchDirection:=xlPrevious).Column\n'    MsgBox \"真正包含資料的最後一個儲存格可能是: \" & ActiveSheet.Cells(trueLastRow, trueLastCol).Address\n' End If", "explanation": "演示xlCellTypeLastCell與實際包含資料的最後一個儲存格的區別，並提供後者的查找方法。"}
    ],
    "keywords": ["最後儲存格", "工作表邊界", "excel", "last cell", "worksheet bounds", "xlCellTypeLastCell"]
},
{
    "name": "Range.SpecialCells(xlCellTypeVisible)",
    "category": "Excel 核心操作",
    "syntax": "Set visibleCellsRange = rangeObject.SpecialCells(xlCellTypeVisible)",
    "description": "傳回一個 Range 物件，代表指定範圍內所有可見的儲存格。在篩選清單後，這對於僅操作可見儲存格非常有用。",
    "parameters": [],
    "examples": [
        {"code": "' Assume A1:A10 has some data and some rows are hidden by a filter\n' Range(\"A1:A10\").AutoFilter Field:=1, Criteria1:=\"<>\" ' Example filter applied\nDim visCells As Range\nOn Error Resume Next ' If all cells are hidden or no cells in range\nSet visCells = Range(\"A1:A10\").SpecialCells(xlCellTypeVisible)\nOn Error GoTo 0\nIf Not visCells Is Nothing Then\n  MsgBox \"可見儲存格的總數: \" & visCells.Cells.Count\n  visCells.Interior.Color = vbGreen ' Highlight visible cells\nElse\n  MsgBox \"範圍內沒有可見儲存格。\"\nEnd If", "explanation": "在篩選後的範圍A1:A10中，選取所有可見的儲存格並將其背景設為綠色。"}
    ],
    "keywords": ["可見儲存格", "篩選後儲存格", "excel", "visible cells", "filtered range", "xlCellTypeVisible"]
},
{
    "name": "Workbook.ActiveChart",
    "category": "Excel 核心操作",
    "syntax": "Set ch = workbookObject.ActiveChart",
    "description": "傳回一個 Chart 物件，代表活動活頁簿中活動的圖表 (可以是嵌入式圖表或圖表工作表)。如果沒有圖表處於活動狀態，則傳回 Nothing。",
    "parameters": [],
    "examples": [
        {"code": "Dim myActiveChart As Chart\nOn Error Resume Next ' In case no chart is active\nSet myActiveChart = ActiveWorkbook.ActiveChart\nOn Error GoTo 0\nIf Not myActiveChart Is Nothing Then\n  MsgBox \"活動圖表的名稱是: \" & myActiveChart.Name\n  myActiveChart.ChartTitle.Font.Bold = True\nElse\n  MsgBox \"目前沒有活動的圖表。\"\nEnd If", "explanation": "獲取目前活動活頁簿中的活動圖表，並將其標題字型設為粗體。"}
    ],
    "keywords": ["活動圖表", "目前圖表", "excel", "active chart", "current chart"]
},
{
    "name": "Chart.ChartArea",
    "category": "Excel 核心操作",
    "syntax": "Set ca = chartObject.ChartArea",
    "description": "傳回代表完整圖表區域的 ChartArea 物件。ChartArea 物件包含圖表的所有元素，如繪圖區、圖例、標題等。",
    "parameters": [],
    "examples": [
        {"code": "Dim ch As Chart\n' Set ch = ActiveChart ' Assume a chart is active\n' If Not ch Is Nothing Then\n'   With ch.ChartArea\n'     .Format.Fill.ForeColor.RGB = RGB(240, 240, 240) ' Light grey background for entire chart area\n'     .Border.Color = RGB(0, 0, 128) ' Dark blue border for chart area\n'   End With\n'   MsgBox \"活動圖表的圖表區域格式已修改。\"\n' End If", "explanation": "設定活動圖表的整個圖表區域的背景色和框線顏色。"}
    ],
    "keywords": ["圖表區域", "chart area format", "excel chart background", "excel"]
},
{
    "name": "Chart.PlotArea",
    "category": "Excel 核心操作",
    "syntax": "Set pa = chartObject.PlotArea",
    "description": "傳回代表圖表繪圖區的 PlotArea 物件。繪圖區是包含實際資料序列、座標軸和格線的區域。",
    "parameters": [],
    "examples": [
        {"code": "Dim ch As Chart\n' Set ch = ActiveChart\n' If Not ch Is Nothing Then\n'   With ch.PlotArea\n'     .Interior.Color = RGB(255, 255, 200) ' Light yellow background for plot area\n'     .Format.Line.Visible = msoTrue\n'     .Format.Line.ForeColor.RGB = RGB(100, 100, 100) ' Grey border for plot area\n'   End With\n'   MsgBox \"活動圖表的繪圖區域格式已修改。\"\n' End If", "explanation": "設定活動圖表的繪圖區域的背景色和框線。"}
    ],
    "keywords": ["繪圖區", "chart plot area", "excel chart formatting", "excel"]
},
{
    "name": "SeriesCollection.Add (Chart)",
    "category": "Excel 核心操作",
    "syntax": "Set newSeries = chartObject.SeriesCollection.Add(Source, [Rowcol As XlRowCol = xlColumns], [SeriesLabels As Boolean], [CategoryLabels As Boolean], [Replace])",
    "description": "將一個或多個新數列新增到圖表的 SeriesCollection 集合中。",
    "parameters": [
        {"name": "Source", "description": "必需。Range 物件，包含新數列的來源資料。"},
        {"name": "Rowcol", "description": "可選。XlRowCol 常數，指定資料是按列還是按欄排列。"},
        {"name": "SeriesLabels", "description": "可選。True 表示 Source 中的第一列/列包含數列名稱。"},
        {"name": "CategoryLabels", "description": "可選。True 表示 Source 中的第一列/列包含類別 (X) 軸標籤。"}
    ],
    "examples": [
        {"code": "Dim ch As Chart, newSeries As Series\n' Set ch = ActiveSheet.ChartObjects(1).Chart ' Assume an existing chart\n' Set newSeries = ch.SeriesCollection.Add(Source:=Range(\"Sheet2!A1:B5\"), Rowcol:=xlColumns, SeriesLabels:=True, CategoryLabels:=True)\n' newSeries.Name = \"New Data Series\"\n' MsgBox \"新數列已新增到圖表。\"", "explanation": "將 Sheet2!A1:B5 範圍的資料作為一個新數列新增到現有圖表中，並假設資料按欄排列，且第一列為類別標籤，第一列為數列標籤 (數列名稱)。"}
    ],
    "keywords": ["新增圖表數列", "add chart series", "excel chart data", "seriescollection add"]
},
{
    "name": "Series.XValues / .Values (Chart)",
    "category": "Excel 核心操作",
    "syntax": "seriesObject.XValues = rangeOrArray\nseriesObject.Values = rangeOrArray",
    "description": "設定或傳回圖表數列的 X 值 (類別軸標籤) 和 Y 值 (數值)。",
    "parameters": [
        {"name": "rangeOrArray", "description": "包含 X 或 Y 值的儲存格範圍或陣列。"}
    ],
    "examples": [
        {"code": "Dim ch As Chart, srs As Series\n' Set ch = ActiveChart\n' If ch.SeriesCollection.Count > 0 Then\n'   Set srs = ch.SeriesCollection(1)\n'   ' Set X values from Sheet1 C1:C5\n'   srs.XValues = ThisWorkbook.Sheets(\"Sheet1\").Range(\"C1:C5\")\n'   ' Set Y values from Sheet1 D1:D5\n'   srs.Values = ThisWorkbook.Sheets(\"Sheet1\").Range(\"D1:D5\")\n'   MsgBox \"第一個數列的 X 和 Y 值已更新。\"\n' End If", "explanation": "修改活動圖表中第一個數列的 X 值和 Y 值來源。"}
    ],
    "keywords": ["圖表數列值", "chart series xvalues", "chart series values", "update chart data"]
},
{
    "name": "Range.Borders(xlDiagonalDown / xlDiagonalUp)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Borders(xlDiagonalDown).LineStyle = XlLineStyleConstant\nrangeObject.Borders(xlDiagonalUp).LineStyle = XlLineStyleConstant",
    "description": "設定儲存格的對角線框線。",
    "parameters": [
        {"name": "xlDiagonalDown", "description": "常數，表示從左上到右下的對角線。"},
        {"name": "xlDiagonalUp", "description": "常數，表示從左下到右上的對角線。"}
    ],
    "examples": [
        {"code": "With Range(\"A1\")\n  .Value = \"X\"\n  .Borders(xlDiagonalDown).LineStyle = xlContinuous\n  .Borders(xlDiagonalUp).LineStyle = xlContinuous\n  .Borders(xlDiagonalDown).Weight = xlThin\n  .Borders(xlDiagonalUp).Weight = xlThin\nEnd With\nMsgBox \"A1儲存格已設定交叉對角線框線。\"", "explanation": "在A1儲存格中畫一個交叉 (X) 的對角線框線。"}
    ],
    "keywords": ["對角線框線", "儲存格斜線", "excel diagonal border", "cell strikethrough diagonal"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.DataBodyRange",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set dataRange = pivotTableObject.DataBodyRange",
    "description": "傳回一個 Range 物件，代表樞紐分析表報表中的值區域 (不包括列總計和欄總計)。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, dataValuesRange As Range\n' Set pt = ActiveSheet.PivotTables(1) ' Assume a PivotTable exists\n' If Not pt Is Nothing Then\n'   Set dataValuesRange = pt.DataBodyRange\n'   If Not dataValuesRange Is Nothing Then\n'     dataValuesRange.Font.Color = vbBlue\n'     MsgBox \"樞紐分析表的數據值區域 ('\" & dataValuesRange.Address & \"') 字型已設為藍色。\"\n'   Else\n'      MsgBox \"樞紐分析表沒有數據值。\"\n'   End If\n' End If", "explanation": "獲取活動工作表上第一個樞紐分析表的數據值區域，並將其字型顏色設為藍色。"}
    ],
    "keywords": ["pivottable databodyrange", "pivot values range", "樞紐分析表數據區域", "值範圍"]
},
{
    "name": "PivotTable.RowRange / .ColumnRange",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set rowHeaderRange = pivotTableObject.RowRange\nSet colHeaderRange = pivotTableObject.ColumnRange",
    "description": "RowRange 傳回包含樞紐分析表報表中列標題的 Range 物件。ColumnRange 傳回包含欄標題的 Range 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(\"SalesSummary\")\n' If Not pt Is Nothing Then\n'   If Not pt.RowRange Is Nothing Then pt.RowRange.Interior.Color = RGB(220, 220, 220) ' Light grey for row headers\n'   If Not pt.ColumnRange Is Nothing Then pt.ColumnRange.Font.Italic = True ' Italicize column headers\n'   MsgBox \"樞紐分析表的列標題和欄標題已格式化。\"\n' End If", "explanation": "格式化樞紐分析表的列標題背景和欄標題字型。"}
    ],
    "keywords": ["pivottable rowrange", "pivottable columnrange", "pivot row headers", "pivot column headers", "樞紐分析表列標題", "樞紐分析表欄標題"]
},
{
    "name": "PivotField.CurrentPage",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.CurrentPage = pageNameString\ncurrentPageName = pivotFieldObject.CurrentPageName",
    "description": "設定或傳回頁面欄位 (篩選欄位) 的目前顯示頁面。CurrentPageName 傳回目前頁面的名稱。",
    "parameters": [
        {"name": "pageNameString", "description": "要顯示的頁面項目的名稱。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Year As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Year = pt.PageFields(\"Year\") ' Assume \"Year\" is a page field\n' On Error Resume Next ' If \"2023\" is not a valid page item\n' pf_Year.CurrentPage = \"2023\"\n' If Err.Number = 0 Then\n'   MsgBox \"樞紐分析表已篩選顯示年份: \" & pf_Year.CurrentPageName\n' Else\n'   MsgBox \"無法設定頁面欄位 'Year' 到 '2023': \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "將樞紐分析表中名為 \"Year\" 的頁面欄位篩選為顯示 \"2023\" 年的數據。"}
    ],
    "keywords": ["pivotfield currentpage", "filter page field", "pivottable filter", "頁面欄位篩選", "目前頁面"]
},
{
    "name": "PivotTable.PivotSelect",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.PivotSelect(Name As String, Mode As XlPTSelectionMode, [UseStandardName As Boolean])",
    "description": "選取樞紐分析表報表的一部分。",
    "parameters": [
        {"name": "Name", "description": "必需。要選取的樞紐分析表結構部分的名稱或路徑 (字串)。"},
        {"name": "Mode", "description": "必需。XlPTSelectionMode 常數，指定如何選取 (例如，xlDataAndLabel, xlLabelOnly, xlButton, xlBlanks)。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' ' Select the data and label for 'Grand Total' row\n' On Error Resume Next\n' pt.PivotSelect \"'Grand Total'\", xlDataAndLabel, True ' UseStandardName might be needed for localized versions\n' If Err.Number <> 0 Then\n'   ' Try localized name if English standard name fails\n'   pt.PivotSelect \"'總計'\", xlDataAndLabel\n' End If\n' On Error GoTo 0\n' If Not Selection Is Nothing And TypeName(Selection) = \"Range\" Then\n'   Selection.Font.Bold = True\n'   MsgBox \"樞紐分析表的總計列已選取並設為粗體。\"\n' End If", "explanation": "嘗試選取樞紐分析表中的「總計」列 (包括其標籤和數據)，並將其字型設為粗體。"}
    ],
    "keywords": ["pivotselect", "select pivot part", "pivottable selection", "選取樞紐分析表部分"]
},
{
    "name": "PivotTable.GetPivotData",
    "category": "Excel 資料分析與樞紐",
    "syntax": "value = pivotTableObject.GetPivotData(DataField As String, [Field1, Item1], [Field2, Item2], ...)",
    "description": "從樞紐分析表報表中擷取資料。類似於工作表中的 GETPIVOTDATA 函數。",
    "parameters": [
        {"name": "DataField", "description": "必需。要擷取資料的資料欄位名稱 (字串)。"},
        {"name": "FieldN, ItemN", "description": "可選。成對的欄位名稱和項目名稱，用於指定要擷取資料的交叉點。最多14對。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, salesForApples As Variant\n' Set pt = ActiveSheet.PivotTables(\"ProductSales\")\n' ' Get total sales for 'Apples' in the 'East' region from 'Sum of SalesAmount' data field\n' On Error Resume Next ' In case items/fields don't exist or data is not available\n' salesForApples = pt.GetPivotData(\"Sum of SalesAmount\", \"Product\", \"Apples\", \"Region\", \"East\")\n' If Err.Number = 0 And Not IsEmpty(salesForApples) Then\n'   MsgBox \"東區蘋果的銷售總額是: \" & salesForApples\n' ElseIf IsEmpty(salesForApples) Then\n'   MsgBox \"未找到東區蘋果的銷售數據 (GetPivotData傳回Empty)。\"\n' Else\n'   MsgBox \"使用 GetPivotData 時發生錯誤: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "從名為 \"ProductSales\" 的樞紐分析表中擷取 \"Product\" 為 \"Apples\" 且 \"Region\" 為 \"East\" 的 \"Sum of SalesAmount\" 資料欄位的值。"}
    ],
    "keywords": ["getpivotdata", "retrieve pivot data", "pivottable value lookup", "擷取樞紐分析表資料"]
},
{
    "name": "PivotTable.CalculatedItems.Add (OLAP only)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set ci = pivotFieldObject.CalculatedItems.Add(Name As String, Formula As String, [UseStandardFormula As Boolean])",
    "description": "在 OLAP 樞紐分析表的欄位中建立一個新的計算項目。對於非 OLAP 來源，計算項目是透過在來源資料中新增欄位或使用樞紐分析表中的計算欄位來實現的。",
    "parameters": [
        {"name": "Name", "description": "必需。新計算項目的名稱。"},
        {"name": "Formula", "description": "必需。計算項目的 MDX (多維運算式) 公式。"}
    ],
    "examples": [
        {"code": "' This is primarily for OLAP PivotTables.\n' Dim pt As PivotTable, pf_Product As PivotField, calcItem As CalculatedItem\n' ' Set pt = ActiveSheet.PivotTables(\"OLAPSalesCube\")\n' ' If pt.PivotCache.OLAP Then\n' '   Set pf_Product = pt.PivotFields(\"[Product].[Category]\") ' Example OLAP field\n' '   On Error Resume Next\n' '   Set calcItem = pf_Product.CalculatedItems.Add(\"ElectronicsPlusAppliances\", _\n' '                     \"[Product].[Category].[Electronics] + [Product].[Category].[Appliances]\")\n' '   If Err.Number = 0 Then\n' '     MsgBox \"計算項目 'ElectronicsPlusAppliances' 已新增。\"\n' '   Else\n' '     MsgBox \"新增計算項目失敗: \" & Err.Description\n' '   End If\n' '   On Error GoTo 0\n' ' Else\n' '   MsgBox \"此樞紐分析表不是基於OLAP資料來源。\"\n' ' End If", "explanation": "如果樞紐分析表是基於 OLAP 資料來源，則在產品類別欄位中新增一個名為 \"ElectronicsPlusAppliances\" 的計算項目，其值為 \"Electronics\" 和 \"Appliances\" 類別的總和。"}
    ],
    "keywords": ["pivottable calculated item", "olap calculated member", "mdx formula", "計算項目OLAP"]
},
{
    "name": "SlicerCache.Slicers.Add",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set sl = slicerCacheObject.Slicers.Add(SlicerDestination, [Level], [Name], [Caption], [Top], [Left], [Width], [Height])",
    "description": "根據指定的 SlicerCache 物件建立一個新的交叉分析篩選器 (Slicer)。",
    "parameters": [
        {"name": "SlicerDestination", "description": "必需。Worksheet 物件或字串，指定交叉分析篩選器放置的工作表。"},
        {"name": "Name", "description": "可選。交叉分析篩選器的名稱。"},
        {"name": "Caption", "description": "可選。交叉分析篩選器頂部顯示的標題。"}
    ],
    "examples": [
        {"code": "Dim sc As SlicerCache, newSlicer As Slicer\n' Assume a PivotTable 'SalesPivot' exists and has a SlicerCache for 'Region' field\n' You first need to create a SlicerCache if one doesn't exist for the field\n' Set sc = ThisWorkbook.SlicerCaches.Add(ActiveSheet.PivotTables(\"SalesPivot\"), \"Region\")\n'\n' Or get an existing SlicerCache\n' Set sc = ThisWorkbook.SlicerCaches(\"Slicer_Region\") ' Name might be Slicer_Region, Slicer_Region1 etc.\n'\n' If Not sc Is Nothing Then\n'   Set newSlicer = sc.Slicers.Add(SlicerDestination:=ActiveSheet, Name:=\"RegionSlicer\", Caption:=\"按區域篩選\", _\n'                                   Top:=10, Left:=500, Width:=150, Height:=200)\n'   MsgBox \"名為 '\" & newSlicer.Name & \"' 的交叉分析篩選器已新增。\"\n' End If", "explanation": "為樞紐分析表的 \"Region\" 欄位建立一個新的 SlicerCache (如果不存在)，然後根據該快取新增一個交叉分析篩選器到活動工作表上。"}
    ],
    "keywords": ["add slicer", "pivottable slicer", "excel slicer vba", "新增交叉分析篩選器"]
},
{
    "name": "Slicer.SlicerCacheLevel.SlicerItems",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set siColl = slicerObject.SlicerCache.SlicerCacheLevels(1).SlicerItems ' For non-OLAP, usually one level",
    "description": "傳回一個 SlicerItems 集合，代表交叉分析篩選器中的項目。可以設定 SlicerItem 的 .Selected 屬性來篩選資料。",
    "parameters": [],
    "examples": [
        {"code": "Dim sl As Slicer, si As SlicerItem\n' Set sl = ActiveSheet.Slicers(\"RegionSlicer\") ' Assume slicer exists\n' If Not sl Is Nothing Then\n'   ' Clear previous selections\n'   sl.SlicerCache.ClearAllFilters\n'   ' Select specific items\n'   On Error Resume Next ' Item may not exist\n'   sl.SlicerCache.SlicerCacheLevels(1).SlicerItems(\"East\").Selected = True\n'   sl.SlicerCache.SlicerCacheLevels(1).SlicerItems(\"West\").Selected = True\n'   ' To deselect all others, one common way is to select the first one, then others, then deselect the first if it's not wanted.\n'   ' Or iterate and set Selected = False for items not in your desired list.\n'   On Error GoTo 0\n'   MsgBox \"交叉分析篩選器已設定為選取 'East' 和 'West'。\"\n' End If", "explanation": "獲取名為 \"RegionSlicer\" 的交叉分析篩選器，清除其目前篩選，然後設定為僅選取 \"East\" 和 \"West\" 項目。"}
    ],
    "keywords": ["slicer items", "filter with slicer vba", "sliceritem selected", "交叉分析篩選器項目"]
},
{
    "name": "PivotField.ClearAllFilters (PivotTable Filter)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.ClearAllFilters",
    "description": "清除套用於指定 PivotField 的任何篩選 (包括手動篩選、標籤篩選、值篩選或頁面欄位篩選)。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Category As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Category = pt.PivotFields(\"Product Category\")\n' ' Apply some filter first for demonstration (e.g., through UI or code)\n' ' ...\n' pf_Category.ClearAllFilters\n' pt.RefreshTable ' Refresh table to see effect if data source changed or for some filter types\n' MsgBox \"'Product Category' 欄位的所有篩選已被清除。\"", "explanation": "清除樞紐分析表中 \"Product Category\" 欄位上的所有篩選。"}
    ],
    "keywords": ["clear pivotfield filter", "reset field filter", "清除欄位篩選"]
},
{
    "name": "PivotTable.ManualUpdate Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.ManualUpdate = True | False",
    "description": "如果樞紐分析表報表僅在使用者要求時才重新計算 (設為 True)，則為 True。預設為 False (自動更新)。將其設為 True 可以在進行多項更改時提高效能，然後再呼叫 RefreshTable。",
    "parameters": [{"name": "True | False", "description": "True 表示手動更新，False 表示自動更新。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(\"MyPivot\")\n' pt.ManualUpdate = True ' Defer updates\n' ' ... Make multiple changes to pivot table layout or fields ...\n' pt.PivotFields(\"Region\").Orientation = xlRowField\n' pt.PivotFields(\"Sales\").Orientation = xlDataField\n' pt.ManualUpdate = False ' Re-enable auto-update AND triggers a refresh\n' ' Or: pt.RefreshTable ' explicitly refresh if needed before setting ManualUpdate to False\n' MsgBox \"樞紐分析表已在手動更新模式下修改，然後重新啟用自動更新。\"", "explanation": "在對樞紐分析表進行多項結構性更改前，將其設定為手動更新模式以避免每次更改都觸發重算，完成更改後再恢復自動更新 (通常會觸發一次刷新)。"}
    ],
    "keywords": ["pivottable manual update", "defer pivot refresh", "pivottable performance", "樞紐分析表手動更新"]
},
// FSO
{
    "name": "FileSystemObject.GetFileVersion (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "versionString = fso.GetFileVersion(FilePath)",
    "description": "傳回指定檔案的版本號 (字串)。如果檔案沒有版本資訊，則傳回空字串。",
    "parameters": [{"name": "FilePath", "description": "必需。檔案的完整路徑。"}],
    "examples": [
        {"code": "Dim fso As Object, ver As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nver = fso.GetFileVersion(Environ(\"SystemRoot\") & \"\\System32\\notepad.exe\")\nIf ver <> \"\" Then\n  MsgBox \"Notepad.exe 的檔案版本是: \" & ver\nElse\n  MsgBox \"無法獲取 Notepad.exe 的檔案版本資訊。\"\nEnd If\nSet fso = Nothing", "explanation": "獲取 Windows 記事本程式 (notepad.exe) 的檔案版本號。"}
    ],
    "keywords": ["fso getfileversion", "file version info", "獲取檔案版本"]
},
// Math
{
    "name": "WorksheetFunction.AverageIf (Excel)",
    "category": "數學、日期與時間",
    "syntax": "avgResult = Application.WorksheetFunction.AverageIf(Range, Criteria, [Average_Range])",
    "description": "使用 Excel 的 AVERAGEIF 工作表函數，計算範圍中符合指定條件的所有儲存格的平均值。",
    "parameters": [
        {"name": "Range", "description": "必需。要評估條件的一個或多個儲存格。"},
        {"name": "Criteria", "description": "必需。定義哪些儲存格將被平均的條件。"},
        {"name": "Average_Range", "description": "可選。要計算平均值的實際儲存格集。如果省略，則使用 Range。"}
    ],
    "examples": [
        {"code": "' Assume A1:A5 has categories, B1:B5 has values\n' Range(\"A1:B5\").Value = Application.Transpose(Array(Array(\"Fruit\",10),Array(\"Veg\",20),Array(\"Fruit\",15),Array(\"Dairy\",25),Array(\"Fruit\",12)))\nDim avgFruit As Double\nOn Error Resume Next ' Handle if no matching criteria\navgFruit = Application.WorksheetFunction.AverageIf(Range(\"A1:A5\"), \"Fruit\", Range(\"B1:B5\"))\nIf Err.Number = 0 Then\n  MsgBox \"水果類別的平均值是: \" & Format(avgFruit, \"0.00\") ' (10+15+12)/3 = 12.33\nElse\n  MsgBox \"無法計算平均值 (例如，沒有符合條件的水果)。\"\nEnd If\nOn Error GoTo 0", "explanation": "計算A欄中類別為 \"Fruit\" 的所有對應B欄值的平均值。"}
    ],
    "keywords": ["averageif", "conditional average", "excel averageif vba", "條件平均"]
},
{
    "name": "WorksheetFunction.SumIfs (Excel)",
    "category": "數學、日期與時間",
    "syntax": "sumResult = Application.WorksheetFunction.SumIfs(Sum_Range, Criteria_Range1, Criteria1, [Criteria_Range2, Criteria2], ...)",
    "description": "使用 Excel 的 SUMIFS 工作表函數，對一組儲存格中符合多個條件的儲存格進行加總。",
    "parameters": [
        {"name": "Sum_Range", "description": "必需。要加總的實際儲存格範圍。"},
        {"name": "Criteria_Range1", "description": "必需。第一個要評估條件的範圍。"},
        {"name": "Criteria1", "description": "必需。應用於 Criteria_Range1 的第一個條件。"},
        {"name": "Criteria_RangeN, CriteriaN", "description": "可選。額外的條件範圍和條件。"}
    ],
    "examples": [
        {"code": "' A=Region, B=Product, C=Sales\n' Range(\"A1:C5\").Value = Application.Transpose(Array(Array(\"East\",\"Apple\",100),Array(\"West\",\"Apple\",150),Array(\"East\",\"Banana\",200),Array(\"East\",\"Apple\",50),Array(\"West\",\"Banana\",120)))\nDim totalEastApples As Double\ntotalEastApples = Application.WorksheetFunction.SumIfs(Range(\"C1:C5\"), Range(\"A1:A5\"), \"East\", Range(\"B1:B5\"), \"Apple\")\nMsgBox \"東區Apple的總銷售額是: \" & totalEastApples ' Should be 100+50=150", "explanation": "計算A欄為 \"East\" 且B欄為 \"Apple\" 的所有對應C欄銷售額的總和。"}
    ],
    "keywords": ["sumifs", "multiple criteria sum", "excel sumifs vba", "多條件加總"]
},
{
    "name": "WorksheetFunction.AverageIfs (Excel)",
    "category": "數學、日期與時間",
    "syntax": "avgResult = Application.WorksheetFunction.AverageIfs(Average_Range, Criteria_Range1, Criteria1, [Criteria_Range2, Criteria2], ...)",
    "description": "使用 Excel 的 AVERAGEIFS 工作表函數，計算一組儲存格中符合多個條件的所有儲存格的平均值。",
    "parameters": [
        {"name": "Average_Range", "description": "必需。要計算平均值的實際儲存格範圍。"},
        {"name": "Criteria_Range1", "description": "必需。第一個條件範圍。"},
        {"name": "Criteria1", "description": "必需。第一個條件。"}
    ],
    "examples": [
        {"code": "' Assume previous SumIfs example data\nDim avgEastApples As Double\nOn Error Resume Next\navgEastApples = Application.WorksheetFunction.AverageIfs(Range(\"C1:C5\"), Range(\"A1:A5\"), \"East\", Range(\"B1:B5\"), \"Apple\")\nIf Err.Number = 0 Then\n  MsgBox \"東區Apple的平均銷售額是: \" & Format(avgEastApples, \"0.00\") ' (100+50)/2 = 75\nElse\n  MsgBox \"無法計算平均值。\"\nEnd If\nOn Error GoTo 0", "explanation": "計算A欄為 \"East\" 且B欄為 \"Apple\" 的所有對應C欄銷售額的平均值。"}
    ],
    "keywords": ["averageifs", "multiple criteria average", "excel averageifs vba", "多條件平均"]
},
// Data Types
{
    "name": "Type Mismatch Error (Runtime Error 13)",
    "category": "資料類型、轉換與驗證",
    "description": "當嘗試在不相容的資料類型之間執行操作或賦值時，會發生執行階段錯誤 13「類型不符」。例如，試圖將文字字串與數字相加，或將非日期格式的字串直接賦給 Date 類型變數。",
    "parameters": [],
    "examples": [
        {"code": "Sub TypeMismatchExample()\n  Dim num As Integer\n  Dim strVal As String: strVal = \"abc\"\n  On Error Resume Next ' To catch the error for demonstration\n  num = 10 + strVal ' This will cause Error 13\n  If Err.Number = 13 Then\n    MsgBox \"發生類型不符錯誤! 無法將數字與字串相加。\"\n    Err.Clear\n  End If\n  On Error GoTo 0\nEnd Sub", "explanation": "演示一個典型的類型不符錯誤：試圖將一個整數和一個字串相加。使用 On Error Resume Next 來捕獲並處理此錯誤。"}
    ],
    "keywords": ["type mismatch error", "runtime error 13", "data type compatibility", "vba error 13", "類型不符錯誤", "執行階段錯誤13"]
},
// Program Flow
{
    "name": "WithEvents (Usage in UserForm)",
    "category": "程式流程與結構控制",
    "syntax": "Private WithEvents MyButton As MSForms.CommandButton",
    "description": "在 UserForm 的程式碼模組中，使用 WithEvents 宣告窗體上的控制項 (例如按鈕、文字方塊)，以便為這些控制項撰寫事件處理程序 (例如 Click, Change)。",
    "parameters": [
        {"name": "MyButton", "description": "在程式碼中代表窗體上某個控制項的變數名稱。"},
        {"name": "MSForms.CommandButton", "description": "控制項的實際類型 (例如，CommandButton, TextBox, ComboBox)。"}
    ],
    "examples": [
        {"code": "' --- In a UserForm's code module (e.g., UserForm1) ---\n' ' Assume there is a CommandButton named 'CommandButton1' on the UserForm.\n' Private WithEvents MySpecialButton As MSForms.CommandButton\n'\n' Private Sub UserForm_Initialize()\n'   Set MySpecialButton = Me.CommandButton1 ' Link the WithEvents variable to the actual control\n' End Sub\n'\n' Private Sub MySpecialButton_Click()\n'   MsgBox \"MySpecialButton (CommandButton1) was clicked!\"\n' End Sub\n'\n' ' To show the form:\n' ' Sub ShowMyForm()\n' '   UserForm1.Show\n' ' End Sub", "explanation": "演示如何在 UserForm 的程式碼模組中使用 WithEvents 關鍵字來宣告一個 CommandButton，然後為其 Click 事件撰寫一個事件處理程序。在 UserForm_Initialize 事件中，將 WithEvents 變數與窗體上實際的控制項連結起來。"}
    ],
    "keywords": ["withevents userform", "form control events", "handle button click vba", "userform event procedure", "UserForm事件處理"]
},
// Excel 核心操作
{
    "name": "Range.Offset(0,0) Behavior",
    "category": "Excel 核心操作",
    "syntax": "Set sameRange = rangeObject.Offset(0, 0)",
    "description": "當 Offset 方法的 RowOffset 和 ColumnOffset 引數都為 0 時，它會傳回原始的 Range 物件本身。",
    "parameters": [
        {"name": "RowOffset", "description": "設為 0。"},
        {"name": "ColumnOffset", "description": "設為 0。"}
    ],
    "examples": [
        {"code": "Dim rng1 As Range, rng2 As Range\nSet rng1 = Range(\"A1\")\nSet rng2 = rng1.Offset(0, 0)\nMsgBox \"rng1 address: \" & rng1.Address & vbCrLf & \"rng2 address: \" & rng2.Address & vbCrLf & \"Are they the same object? \" & (rng1 Is rng2)", "explanation": "演示 Offset(0,0) 傳回與原始範圍相同的物件參考 (通常為 True，但嚴格的物件比較可能因 Excel 內部實現而異，傳回的 Range 物件具有相同的位址和內容)。最重要的結果是位址相同。"}
    ],
    "keywords": ["offset zero", "identity range", "excel", "no offset"]
},
{
    "name": "Workbook.ActiveSheet Property (Workbook Level)",
    "category": "Excel 核心操作",
    "syntax": "Set actSheet = workbookObject.ActiveSheet",
    "description": "傳回一個物件，代表指定活頁簿中的活動工作表。如果沒有工作表處於活動狀態 (例如，活頁簿剛開啟且沒有任何工作表被選取)，則可能傳回 Nothing 或第一個工作表，取決於情境。",
    "parameters": [],
    "examples": [
        {"code": "Dim wb As Workbook, currentSheet As Worksheet\nSet wb = ThisWorkbook\n' Ensure a sheet is active by selecting one if needed\n' wb.Sheets(1).Activate ' Uncomment if needed\nOn Error Resume Next ' In case no sheet is truly active\nSet currentSheet = wb.ActiveSheet\nOn Error GoTo 0\nIf Not currentSheet Is Nothing Then\n  MsgBox \"活頁簿 '\" & wb.Name & \"' 的活動工作表是: \" & currentSheet.Name\nElse\n  MsgBox \"活頁簿 '\" & wb.Name & \"' 當前沒有活動的工作表。\"\nEnd If", "explanation": "獲取特定活頁簿物件 (此處為 ThisWorkbook) 中的活動工作表。"}
    ],
    "keywords": ["workbook activesheet", "current sheet in workbook", "excel", "active sheet specific workbook"]
},
{
    "name": "Range.Address (RelativeTo in R1C1)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Address(ReferenceStyle:=xlR1C1, RelativeTo:=RangeObject)",
    "description": "以 R1C1 樣式傳回相對於指定儲存格的儲存格範圍參照。",
    "parameters": [
        {"name": "ReferenceStyle:=xlR1C1", "description": "指定 R1C1 樣式。"},
        {"name": "RelativeTo", "description": "必需。指定傳回相對位址的基準儲存格。"}
    ],
    "examples": [
        {"code": "MsgBox Range(\"C5\").Address(ReferenceStyle:=xlR1C1, RelativeTo:=Range(\"A1\")) ' C5相對於A1是R[4]C[2]", "explanation": "獲取儲存格C5相對於儲存格A1的R1C1樣式相對位址。C是A右邊2欄 (C[2])，5是1下面4列 (R[4])。"},
        {"code": "MsgBox Range(\"A1\").Address(ReferenceStyle:=xlR1C1, RelativeTo:=Range(\"C5\")) ' A1相對於C5是R[-4]C[-2]", "explanation": "獲取儲存格A1相對於儲存格C5的R1C1樣式相對位址。A是C左邊2欄 (C[-2])，1是5上面4列 (R[-4])。"}
    ],
    "keywords": ["r1c1 relative address", "relative r1c1", "excel", "address r1c1 relative"]
},
{
    "name": "Range.Borders.LineStyle (Various Styles)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Borders(BorderIndex).LineStyle = XlLineStyleConstant",
    "description": "設定框線的線條樣式。XlLineStyleConstant 可以是 xlContinuous, xlDot, xlDash, xlDashDot, xlDashDotDot, xlDouble, xlSlantDashDot, xlLineStyleNone 等。",
    "parameters": [
        {"name": "BorderIndex", "description": "XlBordersIndex 常數 (例如 xlEdgeBottom, xlInsideVertical)。"},
        {"name": "XlLineStyleConstant", "description": "線條樣式常數。"}
    ],
    "examples": [
        {"code": "With Range(\"A1\")\n  .Borders(xlEdgeBottom).LineStyle = xlDouble ' 底部雙線\n  .Borders(xlEdgeBottom).Color = vbRed\n  .Borders(xlEdgeLeft).LineStyle = xlDashDot ' 左側點破折線\n  .Borders(xlEdgeLeft).Weight = xlThick\nEnd With\nMsgBox \"A1儲存格已設定不同樣式的框線。\"", "explanation": "為A1儲存格的底部設定紅色雙實線框線，為左側設定粗點破折線框線。"}
    ],
    "keywords": ["border linestyle", "excel line styles", "dashed border", "dotted border", "框線樣式", "虛線框線"]
},
{
    "name": "Range.CommentThreaded Property (Excel - Modern Comments)",
    "category": "Excel 核心操作",
    "syntax": "Set cmtThread = rangeObject.CommentThreaded\ncmtThread.AddReply \"This is a reply.\"",
    "description": "傳回代表附加到儲存格的執行緒式註解 (新式註解) 的 CommentThreaded 物件。如果儲存格沒有執行緒式註解，則傳回 Nothing。",
    "parameters": [],
    "examples": [
        {"code": "Dim cmtTh As CommentThreaded\n' Ensure A1 has a modern threaded comment first (add manually or via VBA)\n' Range(\"A1\").AddCommentThreaded \"Initial threaded comment.\"\nOn Error Resume Next ' If no threaded comment\nSet cmtTh = Range(\"A1\").CommentThreaded\nOn Error GoTo 0\nIf Not cmtTh Is Nothing Then\n  MsgBox \"A1的第一條執行緒式註解: \" & cmtTh.Replies(1).Text\n  cmtTh.AddReply \"VBA 自動回覆!\"\n  MsgBox \"已向A1的執行緒式註解新增回覆。\"\nElse\n  MsgBox \"A1儲存格沒有執行緒式註解。\"\nEnd If", "explanation": "如果A1儲存格有新式執行緒註解，則獲取其第一個回覆的內容，並新增一個新的自動回覆。"}
    ],
    "keywords": ["threaded comment", "modern comments excel", "comment replies", "執行緒式註解", "新式註解"]
},
{
    "name": "Application.CheckSpelling (Excel)",
    "category": "Excel 核心操作",
    "syntax": "isCorrect = Application.CheckSpelling(Word As String, [CustomDictionary], [IgnoreUppercase As Boolean = False])",
    "description": "檢查單字的拼字。傳回 True 如果單字拼字正確或在字典中找到，否則傳回 False。",
    "parameters": [
        {"name": "Word", "description": "必需。要檢查的單字。"},
        {"name": "CustomDictionary", "description": "可選。要使用的自訂字典檔案名稱。"},
        {"name": "IgnoreUppercase", "description": "可選。True 表示忽略全大寫單字。"}
    ],
    "examples": [
        {"code": "If Application.CheckSpelling(\"Aplle\") = False Then\n  MsgBox \"'Aplle' 拼字錯誤。\"\nElse\n  MsgBox \"'Aplle' 拼字正確 (或不在檢查範圍)。\"\nEnd If\nIf Application.CheckSpelling(\"Excel\", IgnoreUppercase:=True) Then\n  MsgBox \"'Excel' 拼字正確 (大寫被忽略)。\"", "explanation": "檢查 \"Aplle\" (錯誤) 和 \"Excel\" (正確，但可忽略大寫) 的拼字。"}
    ],
    "keywords": ["check spelling", "spell check excel", "validate word", "拼字檢查"]
},
{
    "name": "Workbook.ChangeFileAccess (Excel)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.ChangeFileAccess(Mode As XlFileAccess, [WritePassword], [Notify])",
    "description": "變更活頁簿的存取模式。例如，可以將唯讀活頁簿變更為讀寫模式 (如果可能)。",
    "parameters": [
        {"name": "Mode", "description": "必需。XlFileAccess 常數 (例如 xlReadOnly, xlReadWrite)。"},
        {"name": "WritePassword", "description": "可選。如果活頁簿有寫入保護密碼，則為該密碼。"},
        {"name": "Notify", "description": "可選。如果檔案無法立即存取，True 表示通知使用者。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook\n' Set wb = Workbooks.Open(\"C:\\Path\\ReadOnlyFile.xlsx\", ReadOnly:=True)\n' If wb.ReadOnly Then\n'   On Error Resume Next ' May fail if file is locked by another process\n'   wb.ChangeFileAccess Mode:=xlReadWrite, WritePassword:=\"password_if_any\"\n'   If Err.Number = 0 And Not wb.ReadOnly Then\n'     MsgBox wb.Name & \" 現在是讀寫模式。\"\n'     ' wb.Save ' Now you can save changes\n'   Else\n'     MsgBox \"無法變更檔案存取模式為讀寫。錯誤: \" & Err.Description\n'   End If\n'   On Error GoTo 0\n' End If", "explanation": "如果一個活頁簿是以唯讀模式開啟的，此範例嘗試將其變更為讀寫模式。"}
    ],
    "keywords": ["change file access", "readonly to readwrite", "excel file mode", "變更檔案存取"]
},
{
    "name": "Worksheet.CircularReference Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set circRefCell = worksheetObject.CircularReference",
    "description": "傳回一個 Range 物件，代表工作表上第一個包含循環參照的儲存格。如果工作表上沒有循環參照，則傳回 Nothing。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim circRef As Range\nOn Error Resume Next ' If no circular reference, this causes an error without this line\nSet circRef = ActiveSheet.CircularReference\nOn Error GoTo 0\nIf Not circRef Is Nothing Then\n  MsgBox \"在 \" & ActiveSheet.Name & \" 中找到循環參照，第一個位於: \" & circRef.Address\n  circRef.Select\nElse\n  MsgBox \"在 \" & ActiveSheet.Name & \" 中沒有找到循環參照。\"\nEnd If", "explanation": "檢查活動工作表是否有循環參照，如果有，則顯示第一個包含循環參照的儲存格位址並選取它。"}
    ],
    "keywords": ["circular reference", "find circular reference", "excel formula error", "循環參照"]
},
{
    "name": "Range.DirectDependents / .DirectPrecedents (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set directDeps = rangeObject.DirectDependents\nSet directPrecs = rangeObject.DirectPrecedents",
    "description": "DirectDependents 傳回一個 Range 物件，代表該儲存格的所有直接引用儲存格。DirectPrecedents 傳回一個 Range 物件，代表該儲存格的所有直接前導儲存格。僅追蹤活動工作表上的儲存格。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = 1\nRange(\"A2\").Value = 2\nRange(\"B1\").Formula = \"=A1*10\"\nRange(\"B2\").Formula = \"=A2*10\"\nRange(\"C1\").Formula = \"=B1+B2\"\nDim dDeps As Range, dPrecs As Range\n' Direct Dependents of A1\nSet dDeps = Range(\"A1\").DirectDependents: If Not dDeps Is Nothing Then Debug.Print \"A1 Direct Deps: \" & dDeps.Address ' B1\n' Direct Precedents of C1\nSet dPrecs = Range(\"C1\").DirectPrecedents: If Not dPrecs Is Nothing Then Debug.Print \"C1 Direct Precs: \" & dPrecs.Address ' B1:B2", "explanation": "演示如何獲取A1的直接引用儲存格 (B1) 和C1的直接前導儲存格 (B1和B2)。"}
    ],
    "keywords": ["direct dependents", "direct precedents", "formula trace", "直接引用", "直接前導"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.RowGrand / .ColumnGrand Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.RowGrand = BooleanValue\npivotTableObject.ColumnGrand = BooleanValue",
    "description": "設定或傳回樞紐分析表報表是否顯示列總計 (RowGrand) 或欄總計 (ColumnGrand)。讀取/寫入布林值。",
    "parameters": [{"name": "BooleanValue", "description": "True 表示顯示總計，False 表示隱藏。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' If Not pt Is Nothing Then\n'   pt.RowGrand = True    ' Show grand totals for rows\n'   pt.ColumnGrand = False ' Hide grand totals for columns\n'   MsgBox \"樞紐分析表已設定顯示列總計並隱藏欄總計。\"\n' End If", "explanation": "設定樞紐分析表以顯示列的總計，但隱藏欄的總計。"}
    ],
    "keywords": ["pivottable grand total", "rowgrand", "columngrand", "show totals pivot", "樞紐分析表總計"]
},
{
    "name": "PivotField.Subtotals Property (Array)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.Subtotals = Array(Boolean, Boolean, ..., Boolean) ' Array of 12 booleans\npivotFieldObject.Subtotals(Index As XlSubtotalLocationType) = Boolean",
    "description": "設定或傳回樞紐分析表欄位的小計類型。可以設定一個包含12個布林值的陣列，對應11種小計函數 (Sum, Count, Average, Max, Min, Product, CountNums, StDev, StDevP, Var, VarP) 外加自動小計。或者，可以透過索引 (1到11) 單獨設定特定小計函數的顯示與否。",
    "parameters": [
        {"name": "Array(Boolean...)", "description": "12個布林值的陣列。第一個元素對應自動小計，後續11個對應各種函數。"},
        {"name": "Subtotals(Index)", "description": "索引1=Sum, 2=Count, ..., 11=VarP。設為True以顯示該小計。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\") ' Assume Region is a row or column field\n' ' Show only Sum and Count subtotals for Region field\n' Dim subtotalFlags(1 To 12) As Boolean\n' ' Index 1 for Sum, Index 2 for Count. All others false.\n' subtotalFlags(1) = True ' Sum\n' subtotalFlags(2) = True ' Count\n' ' (all others default to False if array is freshly Dim'd)\n' pf_Region.Subtotals = subtotalFlags\n' ' Alternatively, to turn off all except Sum:\n' ' pf_Region.Subtotals(1) = True ' Sum\n' ' For i = 2 To 11: pf_Region.Subtotals(i) = False: Next i\n' MsgBox \"'Region' 欄位的小計已設定為僅顯示Sum和Count。\"", "explanation": "為樞紐分析表中的 \"Region\" 欄位設定小計，使其僅顯示 Sum 和 Count 兩種小計。"}
    ],
    "keywords": ["pivotfield subtotals", "custom subtotals", "sum subtotal", "count subtotal", "欄位小計設定"]
},
{
    "name": "PivotField.DragTo Method",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.DragTo(Destination As XlPivotFieldOrientation)",
    "description": "將欄位拖曳 (移動) 到樞紐分析表報表的另一個位置 (列、欄、頁面、資料區域或隱藏)。這與設定 Orientation 屬性類似，但更直觀地模擬拖放操作。",
    "parameters": [
        {"name": "Destination", "description": "必需。XlPivotFieldOrientation 常數，指定欄位要移動到的新位置。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Salesperson As PivotField\n' Set pt = ActiveSheet.PivotTables(\"SalesPivot\")\n' Set pf_Salesperson = pt.PivotFields(\"Salesperson\")\n' ' If Salesperson field is currently, e.g., a Row field, move it to be a Page field\n' If pf_Salesperson.Orientation = xlRowField Then\n'   pf_Salesperson.DragTo xlPageField\n'   MsgBox \"'Salesperson' 欄位已從列區域拖曳到頁面/篩選區域。\"\n' End If", "explanation": "如果 \"Salesperson\" 欄位目前位於列區域，則將其拖曳 (移動) 到頁面/篩選區域。"}
    ],
    "keywords": ["pivotfield dragto", "move pivot field", "rearrange pivottable", "拖曳欄位", "重排樞紐分析表"]
},
{
    "name": "SlicerCache.ClearManualFilter",
    "category": "Excel 資料分析與樞紐",
    "syntax": "slicerCacheObject.ClearManualFilter",
    "description": "清除套用於指定 SlicerCache 的任何手動篩選。這會重設交叉分析篩選器以顯示所有項目 (除非有其他篩選，例如來自其他交叉分析篩選器或報表篩選的交叉篩選)。",
    "parameters": [],
    "examples": [
        {"code": "Dim sc_Product As SlicerCache\n' On Error Resume Next ' In case SlicerCache doesn't exist\n' Set sc_Product = ThisWorkbook.SlicerCaches(\"Slicer_Product_Name\") ' Name depends on field\n' If Not sc_Product Is Nothing Then\n'   sc_Product.ClearManualFilter\n'   MsgBox \"產品交叉分析篩選器的手動篩選已清除。\"\n' Else\n'   MsgBox \"未找到名為 'Slicer_Product_Name' 的 SlicerCache。\"\n' End If\n' On Error GoTo 0", "explanation": "清除名為 \"Slicer_Product_Name\" 的 SlicerCache 上的所有手動篩選，使關聯的交叉分析篩選器顯示所有可用項目。"}
    ],
    "keywords": ["slicercache clear filter", "reset slicer", "clear manual filter", "清除交叉分析篩選器"]
},
{
    "name": "SlicerItem.HasData Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "booleanResult = slicerItemObject.HasData",
    "description": "如果交叉分析篩選器項目在套用所有目前交叉分析篩選器後仍包含資料，則傳回 True。如果項目因其他交叉分析篩選器的篩選而變暗 (沒有可用資料)，則傳回 False。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim sl As Slicer, si As SlicerItem\n' Set sl = ActiveSheet.Slicers(\"ProductCategorySlicer\")\n' If Not sl Is Nothing Then\n'   For Each si In sl.SlicerCache.SlicerCacheLevels(1).SlicerItems\n'     If Not si.HasData Then\n'       Debug.Print \"交叉分析篩選器項目 '\" & si.Name & \"' 當前沒有可用資料 (可能因其他篩選器而變暗)。\"\n'       ' si.Selected = False ' Optionally deselect items with no data\n'     End If\n'   Next si\n' End If", "explanation": "遍歷 \"ProductCategorySlicer\" 交叉分析篩選器中的所有項目，並檢查哪些項目因為其他篩選器的作用而沒有可用數據 (在UI中顯示為灰色)。"}
    ],
    "keywords": ["sliceritem hasdata", "slicer item disabled", "check slicer data", "交叉分析篩選器項目是否有資料"]
},
// FSO
{
    "name": "Folder.Files.Count Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "numberOfFiles = folderObject.Files.Count",
    "description": "傳回指定資料夾中檔案的數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myFolder As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFolder = fso.GetFolder(\"C:\\Windows\")\nMsgBox \"C:\\Windows 資料夾包含 \" & myFolder.Files.Count & \" 個檔案 (不含子資料夾中的檔案)。\"", "explanation": "顯示 C:\\Windows 資料夾中直接包含的檔案數量。"}
    ],
    "keywords": ["fso folder files count", "number of files in folder", "資料夾檔案數量"]
},
{
    "name": "Folder.SubFolders.Count Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "numberOfSubFolders = folderObject.SubFolders.Count",
    "description": "傳回指定資料夾中子資料夾的數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myFolder As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFolder = fso.GetFolder(\"C:\\Program Files\")\nMsgBox \"C:\\Program Files 資料夾包含 \" & myFolder.SubFolders.Count & \" 個子資料夾。\"", "explanation": "顯示 C:\\Program Files 資料夾中直接包含的子資料夾數量。"}
    ],
    "keywords": ["fso folder subfolders count", "number of subfolders", "資料夾子資料夾數量"]
},
// String
{
    "name": "Like Operator (# Wildcard)",
    "category": "字串與文本操作",
    "syntax": "stringResult Like \"pattern#pattern\"",
    "description": "Like 運算子中的井號 (#) 萬用字元匹配任何單個數字 (0–9)。",
    "parameters": [{"name": "#", "description": "匹配0到9之間的任何單個數字。"}],
    "examples": [
        {"code": "Debug.Print \"ID-007\" Like \"ID-###\"   ' True\nDebug.Print \"ProductA5\" Like \"ProductA#\" ' True\nDebug.Print \"CodeX\" Like \"Code#\"       ' False (X is not a digit)", "explanation": "演示如何使用 # 萬用字元來匹配字串中的特定數字位置。"}
    ],
    "keywords": ["like operator digit", "pattern matching number", "# wildcard", "數字萬用字元"]
},
// Data Types
{
    "name": "Object Variable Assignment (Is vs =)",
    "category": "資料類型、轉換與驗證",
    "description": "比較兩個物件變數時，應使用 Is 運算子來判斷它們是否參考同一個物件實例。使用等號 (=) 比較物件變數通常會比較它們的預設屬性 (如果有的話)，或者產生類型不符錯誤，而不是比較物件參考本身。",
    "parameters": [
        {"name": "Is Operator", "description": "比較兩個物件變數是否指向記憶體中的同一個物件。"},
        {"name": "= Operator", "description": "用於比較值類型變數或物件的預設屬性 (不建議用於比較物件參考)。"}
    ],
    "examples": [
        {"code": "Dim ws1 As Worksheet, ws2 As Worksheet, ws3 As Worksheet\nSet ws1 = ThisWorkbook.Sheets(1)\nSet ws2 = ThisWorkbook.Sheets(1)\nSet ws3 = ThisWorkbook.Sheets(2)\n\nIf ws1 Is ws2 Then Debug.Print \"ws1 和 ws2 參考同一個工作表物件。\"\nIf ws1 Is ws3 Then Debug.Print \"ws1 和 ws3 參考同一個工作表物件。\" Else Debug.Print \"ws1 和 ws3 參考不同的工作表物件。\"\n\n' Avoid using '=' for object comparison of reference:\n' On Error Resume Next ' This would likely error or give misleading result\n' If ws1 = ws2 Then Debug.Print \"(Using =) ws1 equals ws2 (default property comparison)\"\n' On Error GoTo 0", "explanation": "演示 Is 運算子如何正確比較物件參考。ws1 和 ws2 都指向第一個工作表，所以 `ws1 Is ws2` 為 True。ws3 指向第二個工作表，所以 `ws1 Is ws3` 為 False。不建議使用等號比較物件參考。"}
    ],
    "keywords": ["object comparison", "is operator", "object reference equality", "comparing objects", "物件比較", "Is運算子"]
},
// Program Flow
{
    "name": "Stop Statement (Conditional)",
    "category": "程式流程與結構控制",
    "syntax": "If condition Then Stop",
    "description": "在滿足特定條件時暫停程式執行，進入中斷模式。這對於在複雜邏輯中特定點進行調試非常有用。",
    "parameters": [{"name": "condition", "description": "一個布林表達式。"}],
    "examples": [
        {"code": "Sub ProcessItems(itemsCount As Long)\n  Dim i As Long\n  For i = 1 To itemsCount\n    ' Some processing for each item\n    If i = 500 And itemsCount > 1000 Then\n      Debug.Print \"達到第500個項目，且總數大於1000，暫停檢查。\"\n      Stop ' Execution pauses here if condition met\n    End If\n    ' Continue processing\n  Next i\nEnd Sub\n' ProcessItems 1200 ' This call will trigger the Stop statement", "explanation": "如果迴圈變數 i 達到500且總項目數大於1000，則 Stop 語句會使程式在中斷模式下暫停，允許開發者檢查當時的變數狀態。"}
    ],
    "keywords": ["conditional stop", "debug break condition", "pause on condition", "條件暫停", "調試中斷"]
},
// Excel 核心操作
{
    "name": "Range.Validation.Modify",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.Modify([Type As XlDVType], [AlertStyle As XlDVAlertStyle], [Operator As XlFormatConditionOperator], [Formula1], [Formula2])",
    "description": "修改現有的資料驗證規則。如果範圍中有多種驗證規則，則會修改第一個驗證規則。",
    "parameters": [
        {"name": "Type", "description": "可選。XlDVType 常數，指定新的驗證類型。"},
        {"name": "Formula1", "description": "可選。新的 Formula1。"}
    ],
    "examples": [
        {"code": "' Assume A1 has existing validation (e.g., whole number between 1 and 10)\n' On Error Resume Next ' If no validation exists, this will error\n' Range(\"A1\").Validation.Modify Type:=xlValidateWholeNumber, Formula1:=\"5\", Formula2:=\"20\"\n' If Err.Number = 0 Then MsgBox \"A1的資料驗證已修改為介於5和20之間的整數。\" Else MsgBox \"A1沒有資料驗證或修改失敗。\"\n' On Error GoTo 0", "explanation": "修改A1儲存格的現有資料驗證，將其條件更改為允許介於5和20之間的整數。"}
    ],
    "keywords": ["修改資料驗證", "更新驗證規則", "excel", "modify data validation", "update validation"]
},
{
    "name": "Range.Phonetic Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set phoneticObject = rangeObject.Phonetic",
    "description": "傳回代表儲存格中特定注音假名文字字串的 Phonetic 物件。主要用於日文版 Excel。",
    "parameters": [],
    "examples": [
        {"code": "Dim phText As Phonetic\n' Range(\"A1\").Value = \"日本語\" ' Add Japanese text\n' Range(\"A1\").Phonetics.Add Start:=1, Length:=3, Text:=\"ニホンゴ\" ' Add phonetic info\n' Set phText = Range(\"A1\").Phonetic\n' If Not phText Is Nothing Then\n'   MsgBox \"A1的注音文字: \" & phText.Text & \" (可見性: \" & phText.Visible & \")\"\n'   phText.Visible = True ' Make phonetic text visible above the characters\n' End If", "explanation": "獲取A1儲存格的 Phonetic 物件，並顯示其注音文字及其可見性狀態。"}
    ],
    "keywords": ["phonetic object", "furigana excel", "japanese phonetic", "注音假名物件"]
},
{
    "name": "ActiveWindow.DisplayGridlines Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "ActiveWindow.DisplayGridlines [= Boolean]",
    "description": "如果顯示格線，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "Boolean", "description": "True 表示顯示格線，False 表示隱藏。"}],
    "examples": [
        {"code": "If ActiveWindow.DisplayGridlines Then\n  MsgBox \"格線目前是可見的。現在隱藏它們。\"\n  ActiveWindow.DisplayGridlines = False\nElse\n  MsgBox \"格線目前是隱藏的。現在顯示它們。\"\n  ActiveWindow.DisplayGridlines = True\nEnd If", "explanation": "切換活動視窗中格線的顯示狀態。"}
    ],
    "keywords": ["顯示格線", "隱藏格線", "excel gridlines", "toggle gridlines"]
},
{
    "name": "ActiveWindow.DisplayHeadings Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "ActiveWindow.DisplayHeadings [= Boolean]",
    "description": "如果顯示列和欄標題，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "Boolean", "description": "True 表示顯示標題，False 表示隱藏。"}],
    "examples": [
        {"code": "ActiveWindow.DisplayHeadings = False\nMsgBox \"列和欄標題已隱藏。\"\nActiveWindow.DisplayHeadings = True\nMsgBox \"列和欄標題已重新顯示。\"", "explanation": "隱藏然後再顯示活動視窗的列和欄標題。"}
    ],
    "keywords": ["顯示標題", "隱藏標題", "excel headings", "row column headers"]
},
{
    "name": "Workbook.Names.Item().Delete (Excel Named Range)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.Names.Item(IndexOrName).Delete",
    "description": "從活頁簿的 Names 集合中刪除指定的已定義名稱。",
    "parameters": [{"name": "IndexOrName", "description": "必需。名稱的索引號或名稱本身 (字串)。"}],
    "examples": [
        {"code": "On Error Resume Next ' In case the name doesn't exist\nThisWorkbook.Names(\"ObsoleteNamedRange\").Delete\nIf Err.Number = 0 Then\n  MsgBox \"名稱 'ObsoleteNamedRange' 已被刪除。\"\nElse\n  MsgBox \"名稱 'ObsoleteNamedRange' 未找到或無法刪除。\"\nEnd If\nOn Error GoTo 0", "explanation": "嘗試刪除活頁簿中名為 \"ObsoleteNamedRange\" 的已定義名稱。"}
    ],
    "keywords": ["刪除名稱", "移除已命名範圍", "excel delete named range", "names collection delete"]
},
{
    "name": "Range.MergeArea Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set mergedAreaRange = rangeObject.MergeArea",
    "description": "如果指定的儲存格位於一個合併區域中，則傳回代表該整個合併區域的 Range 物件。如果儲存格未合併，則傳回該儲存格本身。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1:C1\").Merge\nDim ma As Range\nSet ma = Range(\"B1\").MergeArea\nMsgBox \"B1所在的合併區域是: \" & ma.Address ' 傳回 \"$A$1:$C$1\"", "explanation": "合併A1:C1，然後獲取B1儲存格所在的合併區域 (即A1:C1)。"},
        {"code": "If Not Range(\"D5\").MergeCells Then\n  MsgBox \"D5不是合併儲存格，MergeArea將只傳回D5本身: \" & Range(\"D5\").MergeArea.Address\nEnd If", "explanation": "如果D5未合併，則其MergeArea屬性將只傳回D5本身。"}
    ],
    "keywords": ["合併區域", "獲取合併範圍", "excel mergearea", "merged cell range"]
},
{
    "name": "Range.Cells(RowIndex, ColumnIndex) (Specific Access)",
    "category": "Excel 核心操作",
    "syntax": "Set specificCell = rangeObject.Cells(RowIndex, ColumnIndex)",
    "description": "在一個現有的 Range 物件內，按相對的列和欄索引存取特定的單個儲存格。",
    "parameters": [
        {"name": "RowIndex", "description": "必需。相對於 rangeObject 左上角的列索引 (1-based)。"},
        {"name": "ColumnIndex", "description": "必需。相對於 rangeObject 左上角的欄索引 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim myBlock As Range, cell_2_3 As Range\nSet myBlock = Range(\"B5:D10\")\n' Get the cell at 2nd row, 3rd column *within* myBlock (i.e., D6)\nSet cell_2_3 = myBlock.Cells(2, 3)\nMsgBox \"myBlock中第2列第3欄的儲存格是: \" & cell_2_3.Address ' 傳回 $D$6\ncell_2_3.Value = \"Relative Access\"", "explanation": "定義一個範圍B5:D10，然後使用 .Cells(2,3) 存取該範圍內的第二列第三欄 (即儲存格D6)。"}
    ],
    "keywords": ["range relative cell", "cells within range", "excel specific cell in range", "相對儲存格存取"]
},
{
    "name": "Range.Hyperlinks(Index).Follow (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Hyperlinks(Index).Follow([NewWindow], [AddHistory], [ExtraInfo], [Method], [HeaderInfo])",
    "description": "開啟 (追蹤) 指定儲存格中特定索引的超連結。",
    "parameters": [{"name": "Index", "description": "必需。儲存格中超連結的索引號 (如果一個儲存格有多個超連結，通常是1)。"}],
    "examples": [
        {"code": "' Assume A1 has a hyperlink\n' If Range(\"A1\").Hyperlinks.Count > 0 Then\n'   On Error Resume Next ' In case hyperlink is invalid\n'   Range(\"A1\").Hyperlinks(1).Follow NewWindow:=True\n'   If Err.Number <> 0 Then MsgBox \"無法開啟超連結: \" & Err.Description\n'   On Error GoTo 0\n' End If", "explanation": "如果A1儲存格包含超連結，則嘗試在新視窗中開啟第一個超連結。"}
    ],
    "keywords": ["follow hyperlink vba", "open link from cell", "excel hyperlink follow", "追蹤超連結"]
},
{
    "name": "Worksheet.Shapes.SelectAll (Excel)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Shapes.SelectAll",
    "description": "選取工作表上的所有圖案。選取後，可以使用 Selection 物件對所有選取的圖案進行操作。",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Shapes.SelectAll\nIf TypeName(Selection) = \"DrawingObjects\" Then\n  MsgBox Selection.Count & \" 個圖案已被選取。\"\n  ' Selection.Delete ' Example: delete all selected shapes\n  Range(\"A1\").Select ' Deselect shapes\nElse\n  MsgBox \"沒有圖案被選取或選取失敗。\"\nEnd If", "explanation": "選取活動工作表上的所有圖案，然後顯示選取的圖案數量。"}
    ],
    "keywords": ["select all shapes", "excel shapes selection", "選取所有圖案"]
},
{
    "name": "Range.InsertIndent (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.InsertIndent(InsertAmount As Long)",
    "description": "將指定範圍的內容縮排指定的層級數。每層縮排對應於標準字型大小的一個字元寬度。",
    "parameters": [
        {"name": "InsertAmount", "description": "必需。要增加的縮排層級數。可以是正數 (增加縮排) 或負數 (減少縮排)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"層級1\"\nRange(\"A2\").Value = \"層級2\"\nRange(\"A3\").Value = \"層級3\"\nRange(\"A2\").InsertIndent 1 ' Indent A2 by 1 level\nRange(\"A3\").InsertIndent 2 ' Indent A3 by 2 levels\nMsgBox \"A2和A3儲存格已設定縮排。\"", "explanation": "為A2儲存格增加1級縮排，為A3儲存格增加2級縮排。"}
    ],
    "keywords": ["縮排", "儲存格縮排", "excel indent", "text indentation"]
},
{
    "name": "Range.FormatConditions.Add (Excel Conditional Formatting)",
    "category": "Excel 核心操作",
    "syntax": "Set fc = rangeObject.FormatConditions.Add(Type As XlFormatConditionType, [Operator], [Formula1], [Formula2], [String], [TextOperator], [DateOperator], [ScopeType])",
    "description": "將新的條件格式新增到指定的範圍。傳回一個代表新條件格式的 FormatCondition 物件。",
    "parameters": [
        {"name": "Type", "description": "必需。XlFormatConditionType 常數 (例如，xlCellValue, xlExpression, xlTop10, xlUniqueValues, xlTextString)。"},
        {"name": "Operator", "description": "可選 (但通常與 Type 一起使用)。XlFormatConditionOperator 常數 (例如，xlBetween, xlGreater, xlEqual)。"},
        {"name": "Formula1", "description": "可選。條件的第一個值或公式。"},
        {"name": "Formula2", "description": "可選。條件的第二個值或公式 (如果 Operator 需要)。"}
    ],
    "examples": [
        {"code": "Dim dataRange As Range, fc As FormatCondition\nSet dataRange = Range(\"A1:A10\")\ndataRange.FormatConditions.Delete ' Clear existing conditions\n' Highlight cells with values greater than 50\nSet fc = dataRange.FormatConditions.Add(Type:=xlCellValue, Operator:=xlGreater, Formula1:=\"50\")\nWith fc.Interior\n  .Color = RGB(255, 100, 100) ' Light red fill\nEnd With\nMsgBox \"A1:A10中大於50的儲存格已設定條件格式。\"", "explanation": "為範圍A1:A10新增一個條件格式，將值大於50的儲存格背景設為淺紅色。"}
    ],
    "keywords": ["條件格式", "新增條件格式", "excel conditional formatting", "formatcondition add"]
},
{
    "name": "FormatCondition.Modify (Excel Conditional Formatting)",
    "category": "Excel 核心操作",
    "syntax": "formatConditionObject.Modify(Type As XlFormatConditionType, [Operator], [Formula1], [Formula2], [String], [TextOperator], [DateOperator])",
    "description": "修改現有的條件格式規則。",
    "parameters": [
        {"name": "Type", "description": "必需。XlFormatConditionType 常數。"},
        {"name": "Formula1", "description": "可選。新的 Formula1。"}
    ],
    "examples": [
        {"code": "Dim fcToModify As FormatCondition\n' Assume Range(\"A1\") has one conditional format already applied\nIf Range(\"A1\").FormatConditions.Count > 0 Then\n  Set fcToModify = Range(\"A1\").FormatConditions(1)\n  ' Modify it to highlight if value is less than 20\n  fcToModify.Modify Type:=xlCellValue, Operator:=xlLess, Formula1:=\"20\"\n  fcToModify.Font.Bold = True\n  fcToModify.Interior.Color = vbYellow\n  MsgBox \"A1的條件格式已修改。\"\nElse\n  MsgBox \"A1沒有條件格式可修改。\"\nEnd If", "explanation": "如果A1儲存格有條件格式，則修改第一個條件格式規則，使其在值小於20時將字型設為粗體且背景為黃色。"}
    ],
    "keywords": ["修改條件格式", "更新條件格式", "excel formatcondition modify"]
},
{
    "name": "Range.FormatConditions.Delete (Excel Conditional Formatting)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormatConditions.Delete",
    "description": "刪除指定範圍上的所有條件格式規則。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"B1:B10\").FormatConditions.Delete\nMsgBox \"範圍B1:B10上的所有條件格式已被刪除。\"", "explanation": "刪除B1:B10範圍內所有儲存格的條件格式設定。"}
    ],
    "keywords": ["刪除條件格式", "清除條件格式", "excel formatconditions delete"]
},
{
    "name": "Workbook.Connections Property (Excel Data Connections)",
    "category": "Excel 核心操作",
    "syntax": "Set conns = workbookObject.Connections",
    "description": "傳回代表活頁簿中所有資料連線的 Connections 集合。每個連線都是一個 WorkbookConnection 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As WorkbookConnection\nIf ThisWorkbook.Connections.Count > 0 Then\n  MsgBox \"此活頁簿共有 \" & ThisWorkbook.Connections.Count & \" 個資料連線。\"\n  For Each conn In ThisWorkbook.Connections\n    Debug.Print \"連線名稱: \" & conn.Name & \", 類型: \" & conn.Type & \", 描述: \" & conn.Description\n    ' conn.Refresh ' To refresh the connection\n  Next conn\nElse\n  MsgBox \"此活頁簿沒有資料連線。\"\nEnd If", "explanation": "遍歷目前活頁簿中的所有資料連線，並列印其名稱、類型和描述。"}
    ],
    "keywords": ["資料連線", "excel data connections", "workbook connections", "connection object"]
},
{
    "name": "Range.FillDown / .FillRight / .FillUp / .FillLeft (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FillDown\nrangeObject.FillRight\nrangeObject.FillUp\nrangeObject.FillLeft",
    "description": "從指定範圍的頂部儲存格向下填充 (FillDown)，從左側儲存格向右填充 (FillRight)，依此類推。填充內容包括值和格式。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Sample\"\nRange(\"A1:A5\").FillDown ' Fills A2:A5 with the value and format of A1\nRange(\"B1\").Formula = \"=A1*2\"\nRange(\"B1:E1\").FillRight ' Fills C1:E1 with formulas relative to B1\nMsgBox \"A1:A5已向下填充，B1:E1已向右填充。\"", "explanation": "演示FillDown和FillRight的用法。FillDown將A1的值和格式複製到A2:A5。FillRight將B1的公式（相對調整）複製到C1:E1。"}
    ],
    "keywords": ["向下填充", "向右填充", "excel filldown", "excel fillright", "autofill range"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.PivotFields.Count",
    "category": "Excel 資料分析與樞紐",
    "syntax": "longCount = pivotTableObject.PivotFields.Count",
    "description": "傳回 PivotTable 物件中 PivotField 物件的數量 (包括隱藏的欄位)。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' If Not pt Is Nothing Then\n'   MsgBox \"樞紐分析表 '\" & pt.Name & \"' 共有 \" & pt.PivotFields.Count & \" 個欄位。\"\n' End If", "explanation": "顯示活動工作表上第一個樞紐分析表包含的欄位總數。"}
    ],
    "keywords": ["pivotfields count", "number of pivot fields", "樞紐分析表欄位數"]
},
{
    "name": "PivotField.DataRange Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set dataValueRange = pivotFieldObject.DataRange",
    "description": "傳回一個 Range 物件，代表包含樞紐分析表欄位數據值的範圍。對於列或欄欄位，這通常是其項目標籤的範圍；對於資料欄位，則是其值的範圍。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Sales As PivotField, salesValues As Range\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Sales = pt.DataFields(\"Sum of Sales\") ' Assuming 'Sum of Sales' is a data field\n' If Not pf_Sales Is Nothing Then\n'   Set salesValues = pf_Sales.DataRange\n'   If Not salesValues Is Nothing Then\n'     salesValues.NumberFormat = \"_(\"\"*\"\" #,##0.00_);_(\"\"*\"\" (#,##0.00);_(\"\"*\"\" \"\"-\"\"??_);_(@_)\" ' Accounting format\n'     MsgBox \"'Sum of Sales' 數據範圍 ('\" & salesValues.Address & \"') 已設定會計格式。\"\n'   End If\n' End If", "explanation": "獲取樞紐分析表中 \"Sum of Sales\" 資料欄位的數據範圍，並將其設定為會計數字格式。"}
    ],
    "keywords": ["pivotfield datarange", "pivot data values", "欄位數據範圍"]
},
{
    "name": "PivotField.LabelRange Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set labelCellRange = pivotFieldObject.LabelRange",
    "description": "傳回一個 Range 物件，代表包含樞紐分析表欄位標籤的儲存格。對於列、欄或頁面欄位，這是包含欄位名稱的儲存格。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField, regionLabel As Range\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\")\n' If Not pf_Region Is Nothing Then\n'   Set regionLabel = pf_Region.LabelRange\n'   If Not regionLabel Is Nothing Then\n'     regionLabel.Font.Bold = True\n'     MsgBox \"欄位 '\" & pf_Region.Name & \"' 的標籤 ('\" & regionLabel.Address & \"') 已設為粗體。\"\n'   End If\n' End If", "explanation": "獲取樞紐分析表中 \"Region\" 欄位的標籤儲存格，並將其字型設為粗體。"}
    ],
    "keywords": ["pivotfield labelrange", "pivot field header", "欄位標籤範圍"]
},
{
    "name": "Slicer.ActiveItem Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set activeSlicerItem = slicerObject.ActiveItem",
    "description": "傳回一個 SlicerItem 物件，代表交叉分析篩選器中目前具有焦點的按鈕。如果交叉分析篩選器沒有焦點或焦點不在任何按鈕上，則傳回 Nothing。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim sl As Slicer, activeSI As SlicerItem\n' On Error Resume Next ' Slicer may not exist or have focus\n' Set sl = ActiveSheet.Slicers(\"MyRegionSlicer\")\n' If Not sl Is Nothing Then\n'   sl.Activate ' Ensure slicer itself has focus for ActiveItem to be meaningful for user interaction context\n'   Set activeSI = sl.ActiveItem\n'   If Not activeSI Is Nothing Then\n'     MsgBox \"交叉分析篩選器 '\" & sl.Name & \"' 中的活動項目是: \" & activeSI.Name\n'   Else\n'     MsgBox \"交叉分析篩選器 '\" & sl.Name & \"' 中沒有活動項目，或篩選器本身沒有焦點。\"\n'   End If\n' End If\n' On Error GoTo 0", "explanation": "如果存在名為 \"MyRegionSlicer\" 的交叉分析篩選器，則嘗試獲取其活動項目並顯示其名稱。"}
    ],
    "keywords": ["slicer activeitem", "focused slicer item", "交叉分析篩選器活動項目"]
},
{
    "name": "SlicerCache.SourceType Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "slicerCacheType = slicerCacheObject.SourceType",
    "description": "傳回 SlicerCache 的資料來源類型。可以是 xlDatabase (來自工作表範圍或表格的非 OLAP 樞紐分析表)、xlExternal (來自 OLAP Cube 或 Power Pivot 的樞紐分析表)。唯讀 XlPivotTableSourceType。",
    "parameters": [],
    "examples": [
        {"code": "Dim sc As SlicerCache\n' On Error Resume Next\n' Set sc = ThisWorkbook.SlicerCaches(\"Slicer_ProductCategory\")\n' If Not sc Is Nothing Then\n'   Select Case sc.SourceType\n'     Case 1: MsgBox \"交叉分析篩選器來源類型: xlDatabase (工作表/表格)\"\n'     Case 2: MsgBox \"交叉分析篩選器來源類型: xlExternal (OLAP/Power Pivot)\"\n'     Case Else: MsgBox \"交叉分析篩選器來源類型: 其他 (\" & sc.SourceType & \")\"\n'   End Select\n' Else\n'   MsgBox \"未找到 SlicerCache。\"\n' End If", "explanation": "獲取名為 \"Slicer_ProductCategory\" 的 SlicerCache 的來源類型，並顯示其描述。"}
    ],
    "keywords": ["slicercache sourcetype", "slicer data source", "交叉分析篩選器來源類型"]
},
{
    "name": "PivotTable.DisplayNullString Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.DisplayNullString = BooleanValue\npivotTableObject.NullString = StringValue",
    "description": "DisplayNullString 決定是否在包含 Null 值的儲存格中顯示 NullString。NullString 屬性設定要顯示的字串。",
    "parameters": [
        {"name": "DisplayNullString (Boolean)", "description": "True 表示顯示 NullString，False 表示顯示空白。"},
        {"name": "NullString (String)", "description": "當 DisplayNullString 為 True 時，用於取代 Null 值的字串。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' If Not pt Is Nothing Then\n'   pt.DisplayNullString = True\n'   pt.NullString = \"(無資料)\"\n'   MsgBox \"樞紐分析表將為空值顯示 '(無資料)'。\"\n' End If", "explanation": "設定樞紐分析表，使其在包含空 (Null) 值的資料儲存格中顯示 \"(無資料)\" 字串。"}
    ],
    "keywords": ["pivottable nullstring", "display empty as pivot", "處理樞紐分析表空值"]
},
{
    "name": "PivotField.DrillTo (OLAP PivotTable)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.DrillTo(FieldName As String)",
    "description": "對於 OLAP 樞紐分析表，此方法允許從目前欄位向下鑽研到另一個相關的欄位層級。",
    "parameters": [
        {"name": "FieldName", "description": "必需。要鑽研到的欄位名稱 (在 OLAP Cube 中的層次結構名稱)。"}
    ],
    "examples": [
        {"code": "' Dim pt As PivotTable, pf_DateHierarchy As PivotField\n' ' Set pt = ActiveSheet.PivotTables(\"SalesOLAPCube\")\n' ' If pt.PivotCache.OLAP Then\n' '   Set pf_DateHierarchy = pt.PivotFields(\"[Date].[Calendar Hierarchy]\") ' Example OLAP date hierarchy\n' '   On Error Resume Next\n' '   ' Drill from Year level (assuming it's current) to Quarter level\n' '   pf_DateHierarchy.DrillTo \"[Date].[Calendar Hierarchy].[Calendar Quarter]\"\n' '   If Err.Number = 0 Then\n' '     MsgBox \"已從日期層次向下鑽研到季度層級。\"\n' '   Else\n' '     MsgBox \"向下鑽研失敗: \" & Err.Description\n' '   End If\n' '   On Error GoTo 0\n' ' Else\n' '   MsgBox \"此功能主要適用於OLAP樞紐分析表。\"\n' ' End If", "explanation": "如果樞紐分析表基於 OLAP 資料來源，並且有一個名為 \"[Date].[Calendar Hierarchy]\" 的日期層次欄位，此範例嘗試從目前層級向下鑽研到 \"[Date].[Calendar Hierarchy].[Calendar Quarter]\" 層級。"}
    ],
    "keywords": ["pivotfield drillto", "olap drill down", "pivottable olap navigation", "OLAP向下鑽研"]
},
{
    "name": "PivotTable.Allocation Property (OLAP - What-If Analysis)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.Allocation = XlAllocationValueConstant\npivotTableObject.AllocateChanges\npivotTableObject.DiscardChanges",
    "description": "設定或傳回當執行假設分析 (What-If Analysis) 時如何在 OLAP 樞紐分析表中分配值。AllocateChanges 方法執行分配。DiscardChanges 放棄變更。",
    "parameters": [
        {"name": "Allocation (XlAllocationValueConstant)", "description": "例如 xlAllocateValue, xlAllocateIncrement。"},
        {"name": "AllocateChanges()", "description": "方法：將變更寫回 OLAP 資料來源 (如果提供者支援)。"},
        {"name": "DiscardChanges()", "description": "方法：放棄在樞紐分析表中所做的所有假設分析變更。"}
    ],
    "examples": [
        {"code": "' Dim pt As PivotTable\n' ' Set pt = ActiveSheet.PivotTables(\"SalesForecastCube\")\n' ' If pt.PivotCache.OLAP And pt.EnableWriteback Then ' Requires writeback enabled OLAP cube\n' '   pt.Allocation = xlAllocateValue ' How to allocate changes\n' '   ' User makes changes to values in the PivotTable data area for what-if\n' '   ' For example, change a total and see how it might be allocated to children\n' '   On Error Resume Next\n' '   pt.PivotFields(\"Sales Amount\").DataRange.Cells(1).Value = pt.PivotFields(\"Sales Amount\").DataRange.Cells(1).Value * 1.1 ' Increase first data point by 10%\n' '   pt.AllocateChanges ' Attempt to write these changes back to the OLAP source\n' '   If Err.Number = 0 Then\n' '     MsgBox \"假設分析變更已嘗試分配。\"\n' '   Else\n' '     MsgBox \"分配變更失敗: \" & Err.Description\n' '     pt.DiscardChanges ' Rollback if allocation failed\n' '   End If\n' '   On Error GoTo 0\n' ' Else\n' '   MsgBox \"此功能需要可寫回的OLAP樞紐分析表。\"\n' ' End If", "explanation": "如果樞紐分析表基於一個支援寫回的 OLAP Cube，此範例演示如何設定值分配方法，在使用者對樞紐分析表中的資料進行假設性變更後，嘗試使用 AllocateChanges 將這些變更寫回資料來源。如果失敗，則使用 DiscardChanges 放棄變更。"}
    ],
    "keywords": ["pivottable allocation", "what-if analysis pivot", "olap writeback", "假設分析", "OLAP值分配"]
},
// Excel 核心操作
{
    "name": "Range.Copy (Destination Range)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Copy Destination:=destinationRangeObject",
    "description": "將指定的儲存格範圍複製並貼到指定的目標儲存格範圍。這是一個單一步驟的複製貼上操作。",
    "parameters": [
        {"name": "Destination", "description": "必需。Range 物件，指定複製內容要貼上的左上角儲存格或整個目標範圍。"}
    ],
    "examples": [
        {"code": "Range(\"A1:B5\").Copy Destination:=Range(\"D1\")", "explanation": "將範圍 A1:B5 的內容和格式複製並貼到以 D1 為左上角的區域 (即 D1:E5)。"},
        {"code": "Sheets(\"Sheet1\").Range(\"C1:C10\").Copy Destination:=Sheets(\"Sheet2\").Range(\"A1\")", "explanation": "將 Sheet1 上的 C1:C10 範圍複製到 Sheet2 上的 A1 開始的區域。"}
    ],
    "keywords": ["複製貼上範圍", "直接複製到", "excel", "copy paste range", "direct copy"]
},
{
    "name": "Worksheet.Calculate (Specific Sheet)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Calculate",
    "description": "計算指定工作表上的所有公式。如果 Application.Calculation 設為 xlCalculationManual，這很有用。",
    "parameters": [],
    "examples": [
        {"code": "Application.Calculation = xlCalculationManual\nSheets(\"Sheet1\").Range(\"A1\").Value = Now ' Change a value\n' Formulas on Sheet1 dependent on A1 will not update yet\nSheets(\"Sheet1\").Calculate ' Now formulas on Sheet1 are recalculated\nMsgBox \"Sheet1 上的公式已重新計算。\"\nApplication.Calculation = xlCalculationAutomatic", "explanation": "將計算模式設為手動，修改 Sheet1 上的數據，然後僅重新計算 Sheet1。"}
    ],
    "keywords": ["計算特定工作表", "recalculate sheet", "excel sheet calculate", "手動計算後刷新"]
},
{
    "name": "Workbook.SaveCopyAs (Excel)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.SaveCopyAs(Filename As String)",
    "description": "將活頁簿的副本儲存到檔案，但不修改記憶體中開啟的活頁簿。原始活頁簿的 Saved 屬性不受影響。",
    "parameters": [
        {"name": "Filename", "description": "必需。儲存副本的檔案名稱 (字串，可包含完整路徑)。"}
    ],
    "examples": [
        {"code": "Dim backupPath As String\nbackupPath = \"C:\\ExcelBackups\\\" & Left(ThisWorkbook.Name, InStrRev(ThisWorkbook.Name, \".\") - 1) & \"_Backup_\" & Format(Now, \"yyyymmddhhmmss\") & \".xlsx\"\nOn Error Resume Next\nThisWorkbook.SaveCopyAs backupPath\nIf Err.Number = 0 Then\n  MsgBox \"活頁簿副本已儲存到: \" & backupPath\nElse\n  MsgBox \"儲存副本失敗: \" & Err.Description\nEnd If\nOn Error GoTo 0\n' ThisWorkbook.Saved remains unchanged by SaveCopyAs", "explanation": "將目前活頁簿的副本以包含時間戳的新名稱儲存到備份資料夾，而不會影響目前開啟活頁簿的儲存狀態。"}
    ],
    "keywords": ["儲存副本", "另存備份", "excel savecopyas", "backup workbook"]
},
{
    "name": "Range.TextToColumns (FixedWidth Example)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.TextToColumns(Destination, DataType:=xlFixedWidth, FieldInfo, [DecimalSeparator], [ThousandsSeparator])",
    "description": "使用固定寬度將包含文字的儲存格範圍解析成多個欄。",
    "parameters": [
        {"name": "Destination", "description": "必需。Range 物件，指定解析後資料放置的左上角儲存格。"},
        {"name": "DataType:=xlFixedWidth", "description": "指定固定寬度解析。"},
        {"name": "FieldInfo", "description": "必需。一個陣列，包含解析資訊。每個二元素子陣列指定一個欄的起始位置 (0-based) 和資料類型 (例如，Array(Array(0, 1), Array(5, 1), Array(10, 2)) 表示第一欄從位置0開始，第二欄從位置5開始，都為一般格式(1)；第三欄從位置10開始，為文字格式(2))。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Part1ValuePart2\"\nRange(\"A2\").Value = \"ItemXMoreData\"\n' FieldInfo: Col1 starts at 0, Col2 at 5, Col3 at 10\nDim fieldInfoArray As Variant\nfieldInfoArray = Array(Array(0, 1), Array(5, 1), Array(10, 1)) ' All general format\nRange(\"A1:A2\").TextToColumns Destination:=Range(\"B1\"), DataType:=xlFixedWidth, FieldInfo:=fieldInfoArray\nMsgBox \"A1:A2的內容已按固定寬度分欄到B欄開始的區域。\"", "explanation": "將A1和A2儲存格的內容按固定寬度分割，第一部分從字元0開始，第二部分從字元5開始，第三部分從字元10開始，結果輸出到B1開始的區域。"}
    ],
    "keywords": ["texttocolumns fixedwidth", "固定寬度分欄", "parse fixed width", "資料剖析固定寬度"]
},
{
    "name": "Range.Consolidate (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Consolidate(Sources, [Function As XlConsolidationFunction = xlSum], [TopRow As Boolean], [LeftColumn As Boolean], [CreateLinks As Boolean])",
    "description": "從多個來源範圍合併資料到指定的目的範圍 (rangeObject)。",
    "parameters": [
        {"name": "Sources", "description": "必需。一個字串陣列，指定來源範圍的位址 (例如 `Array(\"Sheet2!A1:B5\", \"Sheet3!A1:B5\")`) 或已命名範圍的名稱。"},
        {"name": "Function", "description": "可選。XlConsolidationFunction 常數，指定合併函數 (例如 xlSum, xlAverage, xlCount)。"},
        {"name": "TopRow / LeftColumn", "description": "可選。True 表示使用來源範圍的頂端列/左側欄作為標籤。"},
        {"name": "CreateLinks", "description": "可選。True 表示建立與來源資料的連結，以便目的範圍隨來源更新。"}
    ],
    "examples": [
        {"code": "' Assume Sheet2!A1:B5 and Sheet3!A1:B5 contain numbers, and Sheet1 is active\n' Clear previous consolidation if any\n' Range(\"A1:B5\").ClearContents \n' Range(\"A1\").Consolidate Sources:=Array(\"Sheet2!R1C1:R5C2\", \"Sheet3!R1C1:R5C2\"), Function:=xlSum, TopRow:=False, LeftColumn:=False, CreateLinks:=False\n' MsgBox \"Sheet2和Sheet3的數據已匯總到Sheet1的A1開始的區域。\" ' Uses R1C1 style in Sources array for robustness", "explanation": "將 Sheet2 和 Sheet3 上 A1:B5 範圍的數據使用 SUM 函數合併到目前活動工作表的 A1 儲存格開始的區域。注意 Sources 陣列中使用 R1C1 樣式參照以避免工作表名稱可能包含空格或特殊字元的問題。"}
    ],
    "keywords": ["合併計算", "數據匯總", "excel consolidate", "data consolidation", "summarize data from multiple sheets"]
},
{
    "name": "Range.FormulaHidden and Range.Locked (Interaction)",
    "category": "Excel 核心操作",
    "description": "當工作表受保護時，`Range.FormulaHidden = True` 會隱藏資料編輯列中的公式。`Range.Locked = True` (預設) 會阻止編輯儲存格。要同時隱藏公式並允許編輯儲存格 (罕見需求)，需要 `FormulaHidden = True` 且 `Locked = False`，然後保護工作表。通常，隱藏公式的儲存格也會被鎖定以防修改。",
    "parameters": [],
    "examples": [
        {"code": "With Range(\"A1\")\n  .Formula = \"=SUM(B1:B5)\"\n  .FormulaHidden = True ' Hide formula when sheet is protected\n  .Locked = True        ' Prevent editing when sheet is protected (default)\nEnd With\nWith Range(\"A2\")\n  .Value = \"Can edit this, but formula (if any) also hidden if set\"\n  .FormulaHidden = True ' Even if no formula, this can be set\n  .Locked = False       ' Allow editing when sheet is protected\nEnd With\nActiveSheet.Protect Password:=\"secret\"\nMsgBox \"A1公式已隱藏且鎖定，A2內容可編輯但其公式(如果有)也會被隱藏。\"", "explanation": "演示 `FormulaHidden` 和 `Locked` 屬性在工作表保護下的交互作用。"}
    ],
    "keywords": ["formula hidden locked", "protect sheet formula", "excel cell protection interaction"]
},
{
    "name": "Range.Validation.InputMessage / .ErrorMessage",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.InputMessage = stringMessage\nrangeObject.Validation.ErrorMessage = stringMessage",
    "description": "設定或傳回資料驗證的輸入訊息和錯誤訊息。InputMessage 在選取儲存格時顯示。ErrorMessage 在輸入無效資料時顯示。",
    "parameters": [
        {"name": "InputMessage", "description": "選取儲存格時顯示的提示文字。"},
        {"name": "ErrorMessage", "description": "輸入無效資料時顯示的錯誤訊息文字。"}
    ],
    "examples": [
        {"code": "With Range(\"A1\").Validation\n  .Delete\n  .Add Type:=xlValidateWholeNumber, Operator:=xlBetween, Formula1:=\"1\", Formula2:=\"10\"\n  .InputTitle = \"輸入提示\"\n  .InputMessage = \"請輸入1到10之間的整數。\"\n  .ErrorTitle = \"輸入錯誤\"\n  .ErrorMessage = \"您輸入的值無效！必須是1到10之間的整數。\"\n  .ShowInput = True\n  .ShowError = True\nEnd With\nMsgBox \"A1儲存格已設定資料驗證的輸入和錯誤訊息。\"", "explanation": "為A1儲存格設定資料驗證，並自訂選取時的輸入提示訊息和輸入錯誤時的錯誤警告訊息。"}
    ],
    "keywords": ["validation input message", "validation error message", "data validation prompt", "資料驗證提示", "資料驗證錯誤"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.DataFields Property / Method",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set dataFieldsCollection = pivotTableObject.DataFields\nSet specificDataField = pivotTableObject.DataFields(IndexOrName)",
    "description": "DataFields 屬性 (不帶參數) 傳回代表樞紐分析表中所有資料欄位 (值欄位) 的 PivotFields 集合。DataFields 方法 (帶參數) 傳回集合中單個資料欄位 (PivotField 物件)。",
    "parameters": [{"name": "IndexOrName", "description": "可選。資料欄位的索引號或其目前標題。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, df As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' If pt.DataFields.Count > 0 Then\n'   MsgBox \"第一個資料欄位的名稱是: \" & pt.DataFields(1).Name\n'   For Each df In pt.DataFields\n'     Debug.Print \"資料欄位: \" & df.SourceName & \" (顯示為: \" & df.Caption & \", 函數: \" & df.Function & \")\"\n'     df.NumberFormat = \"#,##0\" ' Example: Format all data fields\n'   Next df\n' Else\n'   MsgBox \"此樞紐分析表沒有資料欄位。\"\n' End If", "explanation": "遍歷樞紐分析表中的所有資料欄位，列印其來源名稱、目前顯示標題和摘要函數，並將它們的數字格式設定為整數。"}
    ],
    "keywords": ["pivottable datafields", "pivot value fields", "access data fields", "樞紐分析表資料欄位", "值欄位"]
},
{
    "name": "PivotTable.RowFields / .ColumnFields / .PageFields Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set rowFieldsColl = pivotTableObject.RowFields\nSet colFieldsColl = pivotTableObject.ColumnFields\nSet pageFieldsColl = pivotTableObject.PageFields",
    "description": "這些屬性分別傳回代表樞紐分析表中所有列欄位、欄欄位或頁面/篩選欄位的 PivotFields 集合。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf As PivotField\n' Set pt = ActiveSheet.PivotTables(\"SalesSummary\")\n' Debug.Print \"--- 列欄位 ---\"\n' For Each pf In pt.RowFields\n'   Debug.Print pf.Name\n' Next pf\n' Debug.Print \"--- 欄欄位 ---\"\n' For Each pf In pt.ColumnFields\n'   Debug.Print pf.Name\n' Next pf\n' Debug.Print \"--- 頁面/篩選欄位 ---\"\n' For Each pf In pt.PageFields\n'   Debug.Print pf.Name\n' Next pf", "explanation": "遍歷樞紐分析表 \"SalesSummary\" 中的所有列欄位、欄欄位和頁面欄位，並將其名稱列印到立即視窗。"}
    ],
    "keywords": ["pivottable rowfields", "pivottable columnfields", "pivottable pagefields", "pivot layout fields", "樞紐分析表佈局欄位"]
},
{
    "name": "PivotField.NumberFormat Property (PivotTable Data Field)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "dataPivotFieldObject.NumberFormat = formatString",
    "description": "設定或傳回樞紐分析表資料欄位中顯示數值的格式代碼。",
    "parameters": [{"name": "formatString", "description": "表示數字格式的字串代碼 (例如 \"$#,##0.00\", \"0.0%\", \"yyyy-mm-dd\")。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, df_Revenue As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' On Error Resume Next ' In case data field doesn't exist\n' Set df_Revenue = pt.DataFields(\"Sum of Revenue\")\n' If Not df_Revenue Is Nothing Then\n'   df_Revenue.NumberFormat = \"€#,##0.00;[Red]-€#,##0.00\" ' Euro format with negative in red\n'   MsgBox \"'Sum of Revenue' 資料欄位的數字格式已更新。\"\n' Else\n'   MsgBox \"未找到名為 'Sum of Revenue' 的資料欄位。\"\n' End If\n' On Error GoTo 0", "explanation": "設定樞紐分析表中名為 \"Sum of Revenue\" 的資料欄位的數字格式為歐元，負數顯示為紅色。"}
    ],
    "keywords": ["pivotfield numberformat", "format pivot data field", "樞紐分析表數字格式"]
},
{
    "name": "PivotTable.RefreshDataSourceValues (Memory Optimization)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.PivotCache.RefreshDataSourceValues = True | False",
    "description": "RefreshDataSourceValues 是一個不直接存在於 PivotTable 或 PivotCache 物件上的屬性。然而，管理 PivotCache 的 `MissingItemsLimit` 和 `UpgradeOnRefresh` 屬性，以及正確地刷新 (`PivotCache.Refresh` / `PivotTable.RefreshTable`)，可以影響記憶體使用和效能。`MissingItemsLimit` (例如 `xlMissingItemsNone` 或 `xlMissingItemsDefault`) 控制是否保留已從資料來源中移除的舊項目。設定為 `xlMissingItemsNone` 可以在刷新時清除不再存在的項目，有助於減少快取大小和潛在的記憶體佔用。",
    "parameters": [
        {"name": "PivotCache.MissingItemsLimit", "description": "XlMissingItemsLimit 常數。`xlMissingItemsNone` 不保留已刪除項目。"},
        {"name": "PivotCache.UpgradeOnRefresh", "description": "如果可能，在刷新時將 PivotCache 升級到最新版本。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, pc As PivotCache\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pc = pt.PivotCache\n' ' To potentially reduce memory by not retaining items removed from source:\npc.MissingItemsLimit = xlMissingItemsNone ' 0 = xlMissingItemsNone\n' pc.UpgradeOnRefresh = True ' Ensure cache is up-to-date format on refresh\n' pc.Refresh ' Refresh the cache from the source\n' pt.RefreshTable ' Refresh the PivotTable report itself\n' MsgBox \"PivotCache設定已調整以優化，並已刷新。\"", "explanation": "設定 PivotCache 在刷新時不保留已從資料來源中移除的項目，並在可能的情況下升級快取格式，然後刷新快取和樞紐分析表。這有助於管理快取大小和效能。"}
    ],
    "keywords": ["pivotcache missingitemslimit", "optimize pivotcache memory", "refresh pivot data source values", "樞紐分析表快取優化"]
},
{
    "name": "PivotTable.ColumnGrand / .RowGrand (Toggle Visibility)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.ColumnGrand = True | False\npivotTableObject.RowGrand = True | False",
    "description": "設定樞紐分析表是否顯示欄總計或列總計。",
    "parameters": [{"name": "True | False", "description": "True表示顯示，False表示隱藏。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' pt.ColumnGrand = False ' Hide column grand totals\n' pt.RowGrand = True    ' Ensure row grand totals are visible\n' MsgBox \"欄總計已隱藏，列總計已顯示。\"", "explanation": "隱藏樞紐分析表的欄總計，同時確保列總計是可見的。"}
    ],
    "keywords": ["pivottable grand totals", "show hide grand totals", "總計顯示切換"]
},
{
    "name": "PivotField.LayoutBlankLine Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.LayoutBlankLine = True | False",
    "description": "如果在指定樞紐分析表欄位的每個項目之後插入一個空白列，則為 True。僅適用於以列表形式顯示的欄位。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True表示在每個項目後插入空白列。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\") ' Assume Region is a row field\n' ' Ensure the field is in Tabular or Outline form for this to have a visible effect\n' pt.RowAxisLayout xlTabularRow ' Or xlOutlineRow\n' pf_Region.LayoutBlankLine = True\n' MsgBox \"'Region' 欄位的每個項目後已插入空白列。\"", "explanation": "設定樞紐分析表的 \"Region\" 列欄位，在其每個項目後插入一個空白列，前提是樞紐分析表的報表版面配置是列表或大綱形式。"}
    ],
    "keywords": ["pivotfield layoutblankline", "insert blank row pivot", "樞紐分析表項目間隔"]
},
{
    "name": "PivotTable.RepeatAllItemLabels",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.RepeatAllItemLabels(Repeat As XlPivotFieldRepeatLabels)",
    "description": "設定樞紐分析表中的所有 PivotField 是否重複項目標籤。",
    "parameters": [
        {"name": "Repeat", "description": "必需。XlPivotFieldRepeatLabels 常數 (例如，xlRepeatLabels, xlDoNotRepeatLabels)。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' ' To repeat all item labels in the PivotTable:\n' pt.RepeatAllItemLabels xlRepeatLabels\n' MsgBox \"樞紐分析表中的所有項目標籤已設定為重複顯示。\"\n' ' To turn off repetition for all fields:\n' ' pt.RepeatAllItemLabels xlDoNotRepeatLabels", "explanation": "將樞紐分析表中所有欄位的項目標籤設定為重複顯示。"}
    ],
    "keywords": ["pivottable repeatallitemlabels", "repeat item labels", "樞紐分析表重複項目標籤"]
},
{
    "name": "PivotField.RepeatLabels Property (Individual Field)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.RepeatLabels = True | False",
    "description": "如果為指定 PivotField 重複項目標籤，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示重複標籤。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Category As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Category = pt.PivotFields(\"Category\") ' Assume Category is a row field\n' pf_Category.RepeatLabels = True\n' MsgBox \"'Category' 欄位的項目標籤已設定為重複。\"", "explanation": "單獨設定 \"Category\" 欄位的項目標籤為重複顯示。"}
    ],
    "keywords": ["pivotfield repeatlabels", "repeat specific field labels", "重複特定欄位標籤"]
},
// Word 文件處理
{
    "name": "Document.SaveAs (Word - Legacy)",
    "category": "Word 文件處理",
    "syntax": "wdDoc.SaveAs(FileName, [FileFormat], [LockComments], [Password], ...)",
    "description": "將 Word 文件以不同的名稱或格式儲存。這是較舊的 SaveAs 方法，對於新版 Word (2007+)，建議使用 SaveAs2 以獲得更完整的格式支援。",
    "parameters": [
        {"name": "FileName", "description": "必需。新檔案的名稱 (字串，可包含路徑)。"},
        {"name": "FileFormat", "description": "可選。WdSaveFormat 常數，指定檔案格式 (例如，wdFormatDocument, wdFormatText, wdFormatRTF)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument ' Assuming in Word VBA context\n' On Error Resume Next\n' wdDoc.SaveAs FileName:=\"C:\\LegacyDocs\\Report_OldFormat.doc\", FileFormat:=0 ' 0 = wdFormatDocument (for .doc)\n' If Err.Number = 0 Then MsgBox \"文件已另存為舊版 .doc 格式。\"\n' On Error GoTo 0", "explanation": "將目前文件另存為舊版 Word 97-2003 文件格式 (.doc)。"}
    ],
    "keywords": ["word saveas legacy", "save as .doc word", "wdformatdocument", "儲存為舊版Word"]
},
{
    "name": "Selection.Characters.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "charCount = selectionObject.Characters.Count",
    "description": "傳回指定選取範圍中字元的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\n' Set sel = Application.Selection\n' If sel.Type = wdSelectionNormal Then ' If text is selected\n'   MsgBox \"選取的文字包含 \" & sel.Characters.Count & \" 個字元。\"\n' Else\n'   MsgBox \"沒有文字被選取。\"\n' End If", "explanation": "如果使用者在 Word 中選取了文字，則計算並顯示選取文字的字元數。"}
    ],
    "keywords": ["word selection character count", "count selected characters", "選取字元計數"]
},
{
    "name": "Selection.Words.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "wordCount = selectionObject.Words.Count",
    "description": "傳回指定選取範圍中單字的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\n' Set sel = Application.Selection\n' If sel.Type = wdSelectionNormal Then\n'   MsgBox \"選取的文字包含 \" & sel.Words.Count & \" 個單字。\"\n' End If", "explanation": "如果使用者在 Word 中選取了文字，則計算並顯示選取文字的單字數。"}
    ],
    "keywords": ["word selection word count", "count selected words", "選取單字計數"]
},
{
    "name": "Selection.Paragraphs.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "paraCount = selectionObject.Paragraphs.Count",
    "description": "傳回指定選取範圍中段落的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\n' Set sel = Application.Selection\n' If sel.Type = wdSelectionNormal Then\n'   MsgBox \"選取的文字跨越 \" & sel.Paragraphs.Count & \" 個段落。\"\n' End If", "explanation": "如果使用者在 Word 中選取了文字，則計算並顯示選取文字所跨越的段落數。"}
    ],
    "keywords": ["word selection paragraph count", "count selected paragraphs", "選取段落計數"]
},
{
    "name": "Range.Information (Word)",
    "category": "Word 文件處理",
    "syntax": "infoValue = rangeObject.Information(Type As WdInformation)",
    "description": "傳回有關指定範圍的資訊。WdInformation 常數指定要傳回的資訊類型。",
    "parameters": [
        {"name": "Type", "description": "必需。WdInformation 常數，例如 wdActiveEndPageNumber (目前頁碼), wdFirstCharacterLineNumber (範圍內第一個字元的行號), wdHeaderFooterType (頁首/頁尾類型), wdNumberOfPagesInDocument (文件總頁數)。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' MsgBox \"選取範圍開始於第 \" & selRange.Information(wdFirstCharacterLineNumber) & \" 行。\"\n' MsgBox \"文件目前總頁數: \" & ActiveDocument.Content.Information(wdNumberOfPagesInDocument)", "explanation": "顯示目前選取範圍第一個字元所在的行號，以及文件的總頁數。"}
    ],
    "keywords": ["word range information", "get page number word", "get line number word", "wdinformation", "範圍資訊"]
},
{
    "name": "Find.HitHighlight (Word)",
    "category": "Word 文件處理",
    "syntax": "booleanResult = findObject.HitHighlight(FindText, [HighlightColor As WdColorIndex = wdYellow], [MatchCase], [MatchWholeWord], ...)",
    "description": "尋找並高亮顯示指定文字的所有實例。傳回 True 如果至少找到一個符合項。",
    "parameters": [
        {"name": "FindText", "description": "必需。要尋找並高亮的文字。"},
        {"name": "HighlightColor", "description": "可選。WdColorIndex 常數，指定高亮顏色。"},
        {"name": "MatchCase", "description": "可選。True 表示區分大小寫。"}
    ],
    "examples": [
        {"code": "Dim searchRange As Object ' Word.Range\n' Set searchRange = ActiveDocument.Content\n' If searchRange.Find.HitHighlight(FindText:=\"重要\", HighlightColor:=wdTurquoise, MatchCase:=False, MatchWholeWord:=True) Then\n'   MsgBox \"文件中所有 '重要' (不分大小寫，全字匹配) 已被高亮顯示為綠松石色。\"\n' Else\n'   MsgBox \"文件中未找到 '重要'。\"\n' End If", "explanation": "在整個文件中尋找所有出現的 \"重要\" (不區分大小寫，全字匹配)，並將其高亮顯示為綠松石色。"}
    ],
    "keywords": ["word find highlight", "hithighlight", "highlight text word", "尋找並高亮"]
},
{
    "name": "Find.ClearHitHighlight (Word)",
    "category": "Word 文件處理",
    "syntax": "findObject.ClearHitHighlight",
    "description": "移除使用 HitHighlight 方法套用的所有高亮顯示。",
    "parameters": [],
    "examples": [
        {"code": "' First, apply some highlights (see HitHighlight example)\n' ActiveDocument.Content.Find.HitHighlight FindText:=\"分析\"\n' ' Then, clear all such highlights\n' ActiveDocument.Content.Find.ClearHitHighlight\n' MsgBox \"所有透過 HitHighlight 套用的高亮已清除。\"", "explanation": "清除文件中所有由 HitHighlight 方法套用的高亮效果。"}
    ],
    "keywords": ["word clear highlight", "remove hithighlight", "清除高亮"]
},
{
    "name": "Selection.Previous / .Next (Word - Unit Based)",
    "category": "Word 文件處理",
    "syntax": "Set prevUnitRange = selectionObject.Previous(Unit As WdUnits, [Count As Long = 1])\nSet nextUnitRange = selectionObject.Next(Unit As WdUnits, [Count As Long = 1])",
    "description": "傳回一個 Range 物件，代表相對於目前選取範圍的上一個或下一個指定的單位 (例如，單字、句子、段落)。",
    "parameters": [
        {"name": "Unit", "description": "必需。WdUnits 常數 (例如 wdWord, wdSentence, wdParagraph, wdLine, wdCharacter)。"},
        {"name": "Count", "description": "可選。要移動的單位數。"}
    ],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\nDim prevPara As Object ' Word.Range\n' Set sel = Application.Selection\n' Set prevPara = sel.Previous(Unit:=wdParagraph, Count:=1)\n' If Not prevPara Is Nothing Then\n'   prevPara.Select\n'   MsgBox \"已選取上一個段落。\"\n' Else\n'   MsgBox \"沒有上一個段落。\"\n' End If", "explanation": "選取目前選取範圍之前的上一個段落。"}
    ],
    "keywords": ["word selection previous unit", "selection next unit", "navigate by word", "navigate by paragraph", "依單位導航Word"]
},
// Excel 核心操作
{
    "name": "Range.Validation.InCellDropdown Property",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.InCellDropdown = True | False",
    "description": "如果資料驗證在儲存格中顯示下拉清單，則為 True。僅當驗證類型為 xlValidateList 時適用。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示下拉箭頭，False 表示不顯示。"}],
    "examples": [
        {"code": "With Range(\"A1\").Validation\n  .Delete\n  .Add Type:=xlValidateList, Formula1:=\"Option1,Option2,Option3\"\n  .InCellDropdown = True ' Ensure dropdown arrow is visible\nEnd With\nMsgBox \"A1儲存格的清單驗證已設定並顯示下拉箭頭。\"", "explanation": "為A1儲存格設定一個清單型資料驗證，並確保儲存格內顯示下拉箭頭。"}
    ],
    "keywords": ["in-cell dropdown", "validation list arrow", "儲存格內下拉", "資料驗證清單箭頭"]
},
{
    "name": "Worksheet.OLEObjects Property / Method (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set oleObjectsCollection = worksheetObject.OLEObjects\nSet specificOleObject = worksheetObject.OLEObjects(IndexOrName)",
    "description": "OLEObjects 屬性 (不帶參數) 傳回代表工作表上所有 OLE 物件 (嵌入的物件，如Word文件、PDF，或ActiveX控制項) 的 OLEObjects 集合。OLEObjects 方法 (帶參數) 傳回單個 OLEObject。",
    "parameters": [{"name": "IndexOrName", "description": "OLE 物件的索引號或名稱。"}],
    "examples": [
        {"code": "Dim oleObj As OLEObject\n' Assume an OLE object (e.g., an embedded Word document named \"EmbedWordDoc\") exists on Sheet1\n' On Error Resume Next\n' Set oleObj = ActiveSheet.OLEObjects(\"EmbedWordDoc\")\n' If Not oleObj Is Nothing Then\n'   oleObj.Verb xlVerbPrimary ' Activate the primary verb (usually Open or Edit)\n'   MsgBox \"OLE物件 '\" & oleObj.Name & \"' 已嘗試啟動其主要動作。\"\n' Else\n'   MsgBox \"未找到名為 'EmbedWordDoc' 的OLE物件。\"\n' End If\n' On Error GoTo 0", "explanation": "嘗試獲取名為 \"EmbedWordDoc\" 的 OLE 物件，並執行其主要動作 (例如，如果是嵌入的Word文件，則可能會打開它進行編輯)。"}
    ],
    "keywords": ["ole objects", "embedded object excel", "activex control excel", "OLE物件", "嵌入物件"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.PageRange Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set pageFieldAreaRange = pivotTableObject.PageRange",
    "description": "傳回一個 Range 物件，代表包含樞紐分析表報表中頁面/篩選欄位區域的範圍。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pageArea As Range\n' Set pt = ActiveSheet.PivotTables(1)\n' If Not pt Is Nothing And pt.PageFields.Count > 0 Then\n'   Set pageArea = pt.PageRange\n'   If Not pageArea Is Nothing Then\n'     pageArea.Interior.Color = RGB(200, 255, 200) ' Light green for page field area\n'     MsgBox \"樞紐分析表的頁面/篩選欄位區域 ('\" & pageArea.Address & \"') 已設定背景色。\"\n'   End If\n' Else\n'   MsgBox \"此樞紐分析表沒有頁面/篩選欄位。\"\n' End If", "explanation": "如果樞紐分析表有頁面/篩選欄位，則獲取該區域的範圍並將其背景設為淺綠色。"}
    ],
    "keywords": ["pivottable pagerange", "pivot filter area", "樞紐分析表頁面欄位區域"]
},
{
    "name": "PivotField.PivotItems.Count",
    "category": "Excel 資料分析與樞紐",
    "syntax": "numberOfItems = pivotFieldObject.PivotItems.Count",
    "description": "傳回指定 PivotField 中 PivotItem 物件的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\")\n' MsgBox \"'Region' 欄位共有 \" & pf_Region.PivotItems.Count & \" 個不重複的項目。\"", "explanation": "顯示 \"Region\" 欄位中包含的不重複項目的數量。"}
    ],
    "keywords": ["pivotitems count", "number of unique items pivot", "樞紐分析項目數量"]
},
{
    "name": "PivotItem.RecordCount Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "count = pivotItemObject.RecordCount",
    "description": "傳回指定 PivotItem 在 PivotCache 中的記錄數。如果 PivotItem 是計算項目，則此屬性會產生錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pi_East As PivotItem\n' Set pt = ActiveSheet.PivotTables(1)\n' On Error Resume Next ' Handle if item doesn't exist\n' Set pi_East = pt.PivotFields(\"Region\").PivotItems(\"East\")\n' If Not pi_East Is Nothing Then\n'   MsgBox \"資料來源中 'East' 區域的記錄數為: \" & pi_East.RecordCount\n' Else\n'   MsgBox \"未找到項目 'East'。\"\n' End If\n' On Error GoTo 0", "explanation": "顯示 \"Region\" 欄位中 \"East\" 項目的原始資料來源中的記錄數量。"}
    ],
    "keywords": ["pivotitem recordcount", "count records for pivot item", "樞紐分析項目記錄數"]
},
{
    "name": "SlicerCache.VisibleSlicerItems Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set visibleSICollection = slicerCacheObject.VisibleSlicerItems",
    "description": "傳回一個 SlicerItems 集合，其中包含目前在 SlicerCache 中可見 (即未被篩選掉) 的所有項目。",
    "parameters": [],
    "examples": [
        {"code": "Dim sc As SlicerCache, si As SlicerItem\n' Set sc = ThisWorkbook.SlicerCaches(\"Slicer_Category\")\n' If Not sc Is Nothing Then\n'   Debug.Print \"'\" & sc.Name & \"' 中目前可見的項目:\"\n'   If sc.VisibleSlicerItems.Count > 0 Then\n'       For Each si In sc.VisibleSlicerItems\n'           Debug.Print \"  - \" & si.Name & \" (Selected: \" & si.Selected & \")\"\n'       Next si\n'   Else\n'       Debug.Print \"  (沒有可見的項目)\"\n'   End If\n' End If", "explanation": "遍歷名為 \"Slicer_Category\" 的 SlicerCache 中所有目前可見的項目，並列印其名稱和選取狀態。"}
    ],
    "keywords": ["slicercache visiblesliceritems", "visible slicer items", "可見交叉分析篩選器項目"]
},
// Excel 核心操作
{
    "name": "Range.FormulaLocal",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaLocal [= formulaStringLocal]",
    "description": "設定或傳回物件的公式，使用使用者語言的 A1 樣式參照。例如，在中文 Excel 中，SUM 函數可能是 `SUM`，但在德文 Excel 中可能是 `SUMME`。",
    "parameters": [{"name": "formulaStringLocal", "description": "本地化語言的公式字串。"}],
    "examples": [
        {"code": "Range(\"C1\").FormulaLocal = \"=SUMME(A1:B1)\" ' 如果Excel是德文版，這會設定求和公式", "explanation": "使用本地化函數名稱設定公式。效果取決於Excel的語言設定。"},
        {"code": "MsgBox Range(\"C1\").FormulaLocal", "explanation": "以本地化語言顯示C1儲存格的公式。"}
    ],
    "keywords": ["本地化公式", "語言特定公式", "excel", "formulalocal", "localized formula"]
},
{
    "name": "Range.FormulaR1C1Local",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaR1C1Local [= formulaStringLocalR1C1]",
    "description": "設定或傳回物件的公式，使用使用者語言的 R1C1 樣式參照。",
    "parameters": [{"name": "formulaStringLocalR1C1", "description": "本地化語言的 R1C1 樣式公式字串。"}],
    "examples": [
        {"code": "Range(\"C1\").FormulaR1C1Local = \"=SUMME(ZEILE()SPALTE(-2):ZEILE()SPALTE(-1))\" ' 德文R1C1的=SUM(RC[-2]:RC[-1])", "explanation": "使用本地化語言和R1C1樣式設定公式。"},
        {"code": "MsgBox Range(\"C1\").FormulaR1C1Local", "explanation": "以本地化語言和R1C1樣式顯示C1儲存格的公式。"}
    ],
    "keywords": ["本地化R1C1公式", "excel", "formular1c1local", "localized r1c1 formula"]
},
{
    "name": "Range.ShowErrors (Error Checking)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ShowErrors",
    "description": "如果範圍包含錯誤，則顯示「錯誤檢查選項」按鈕。此方法本身不傳回值，而是觸發UI行為。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = 1 / 0 ' Create a #DIV/0! error\nOn Error Resume Next ' ShowErrors might error if cell doesn't have a traceable error UI element\nRange(\"A1\").ShowErrors\nIf Err.Number <> 0 Then MsgBox \"無法顯示儲存格A1的錯誤檢查選項按鈕，或A1沒有可追蹤的錯誤。\"\nOn Error GoTo 0", "explanation": "在A1儲存格中產生一個錯誤，然後嘗試顯示該儲存格的錯誤檢查選項按鈕。"}
    ],
    "keywords": ["顯示錯誤檢查", "錯誤選項按鈕", "excel error checking options", "trace error button"]
},
{
    "name": "Range.Dirty (Usage in UDFs)",
    "category": "Excel 核心操作",
    "description": "在使用者定義函數 (UDF) 中，如果函數的結果依賴於非直接作為參數傳入的儲存格，且該儲存格的值發生變化時，Excel 的標準重新計算引擎可能不會自動重新計算此UDF。在這種情況下，可以在UDF內部或外部使用 `Application.Volatile` 使UDF易失，或更精確地，在相關儲存格變化時，使用 `Worksheet_Change` 事件來呼叫包含該UDF的儲存格的 `.Dirty` 方法，然後觸發計算，以強制其更新。",
    "parameters": [],
    "examples": [
        {"code": "' Function MyUDF_Reads_C1() As Double\n'   ' This UDF implicitly depends on cell C1\n'   MyUDF_Reads_C1 = Range(\"C1\").Value * 2\n' End Function\n'\n' ' In the Worksheet module where cells with MyUDF_Reads_C1() are located:\n' Private Sub Worksheet_Change(ByVal Target As Range)\n'   If Not Intersect(Target, Me.Range(\"C1\")) Is Nothing Then\n'     Dim cellWithUDF As Range\n'     ' Assume D1 contains =MyUDF_Reads_C1()\n'     Set cellWithUDF = Me.Range(\"D1\")\n'     cellWithUDF.Dirty ' Mark D1 as needing recalculation\n'     ' Application.Calculate ' Or specific calculation for D1\n'     ' Or if many such UDFs exist, could make the UDF Application.Volatile True\n'   End If\n' End Sub", "explanation": "如果一個UDF間接依賴C1，當C1改變時，可以通過Worksheet_Change事件將使用該UDF的儲存格(例如D1)標記為Dirty，從而確保它在下次計算時更新。"}
    ],
    "keywords": ["udf dirty", "force udf recalculation", "non-volatile udf update", "UDF強制重算"]
},
{
    "name": "Worksheet.EnableCalculation Property",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.EnableCalculation = True | False",
    "description": "如果 Microsoft Excel 在需要時自動重新計算工作表，則為 True。設為 False 可以阻止特定工作表的自動計算，即使應用程式的計算模式是自動的。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True (預設) 啟用工作表計算，False 禁用。"}],
    "examples": [
        {"code": "Sheets(\"Sheet1\").EnableCalculation = False\nMsgBox \"Sheet1 的自動計算已禁用。除非手動計算，否則其公式不會更新。\"\n' Sheets(\"Sheet1\").EnableCalculation = True ' To re-enable", "explanation": "禁用 Sheet1 的自動計算。即使 Application.Calculation 是自動的，Sheet1 上的公式也不會自動更新。"}
    ],
    "keywords": ["禁用工作表計算", "enable calculation sheet", "stop sheet recalculation", "工作表計算控制"]
},
{
    "name": "Workbook.PrecisionAsDisplayed Property",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.PrecisionAsDisplayed = True | False",
    "description": "如果此活頁簿中的計算是使用顯示的精確度完成的，則為 True。設為 True 可能會永久更改活頁簿中儲存格的值以符合顯示的格式，並可能導致數據丟失。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示以顯示精確度計算，False (預設) 表示以完整精確度計算。"}],
    "examples": [
        {"code": "MsgBox \"目前活頁簿的 '以顯示精確度為準' 設定是: \" & ThisWorkbook.PrecisionAsDisplayed\n' ThisWorkbook.PrecisionAsDisplayed = True ' CAUTION: This can lead to data loss.\n' If ThisWorkbook.PrecisionAsDisplayed Then\n'   MsgBox \"警告：活頁簿已設定為以顯示精確度計算，儲存格的基礎值可能已更改。\"\n' End If", "explanation": "顯示活頁簿是否設定為「以顯示精確度為準」進行計算。開啟此選項應非常謹慎。"}
    ],
    "keywords": ["precision as displayed", "calculation precision", "excel rounding data loss", "顯示精確度計算"]
},
{
    "name": "Range.ShowPrecedents / .ShowDependents (Trace Arrows)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ShowPrecedents([Remove As Boolean])\nrangeObject.ShowDependents([Remove As Boolean])",
    "description": "在工作表上繪製追蹤箭頭，指向指定範圍的直接前導儲存格 (ShowPrecedents) 或直接引用儲存格 (ShowDependents)。",
    "parameters": [{"name": "Remove", "description": "可選。True 表示移除指定級別的追蹤箭頭。"}],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=A1+B1\"\nRange(\"C1\").ShowPrecedents ' Draws arrows from A1 and B1 to C1\nMsgBox \"已顯示C1的前導追蹤箭頭。\"\nApplication.Wait Now + TimeValue(\"00:00:03\")\nRange(\"C1\").ShowPrecedents Remove:=True ' Removes the arrows", "explanation": "為C1儲存格顯示其直接前導儲存格的追蹤箭頭，等待3秒，然後移除這些箭頭。"}
    ],
    "keywords": ["追蹤箭頭", "顯示前導", "顯示引用", "excel trace precedents", "excel trace dependents", "formula arrows"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.ShowValuesRow Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.ShowValuesRow = True | False",
    "description": "如果樞紐分析表報表在有多個資料欄位時，將資料欄位按列顯示 (即所謂的「值」列)，則為 True。如果資料欄位按欄顯示，則為 False。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示值顯示為列，False 表示值顯示為欄。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' If pt.DataFields.Count > 1 Then\n'   pt.ShowValuesRow = True\n'   MsgBox \"樞紐分析表的多個資料欄位現在按列顯示。\"\n' Else\n'   MsgBox \"此樞紐分析表沒有多個資料欄位可供切換顯示方式。\"\n' End If", "explanation": "如果樞紐分析表有多個資料欄位，則將它們設定為按列顯示 (在UI中稱為「值」的列標籤)。"}
    ],
    "keywords": ["pivottable showvaluesrow", "pivot values as rows", "multiple data fields layout", "樞紐分析表值列顯示"]
},
{
    "name": "PivotTable.RepeatAllItemLabels (Specific Field)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.RepeatItemLabels = True | False",
    "description": "為樞紐分析表中的特定欄位設定是否重複項目標籤。這與 PivotTable.RepeatAllItemLabels 不同，後者會影響所有欄位。",
    "parameters": [{"name": "True | False", "description": "True 表示重複該欄位的項目標籤，False 表示不重複。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\") ' Assume Region is an outer row field\n' If Not pf_Region Is Nothing Then\n'   pf_Region.RepeatItemLabels = True\n'   MsgBox \"'Region' 欄位的項目標籤已設定為重複。\"\n' End If", "explanation": "設定樞紐分析表中名為 \"Region\" 的特定欄位重複其項目標籤。"}
    ],
    "keywords": ["pivotfield repeatitemlabels", "repeat labels for field", "特定欄位重複標籤"]
},
{
    "name": "SlicerCache.CrossFilterType Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "slicerCacheObject.CrossFilterType = XlSlicerCrossFilterTypeConstant\ncurrentType = slicerCacheObject.CrossFilterType",
    "description": "設定或傳回 SlicerCache 的交叉分析篩選器類型，決定交叉分析篩選器如何與其他交叉分析篩選器互動篩選樞紐分析表。",
    "parameters": [
        {"name": "XlSlicerCrossFilterTypeConstant", "description": "xlSlicerNoCrossFilter (預設，獨立篩選), xlSlicerCrossFilterShowItemsWithDataAtTop, xlSlicerCrossFilterShowItemsWithNoData."}
    ],
    "examples": [
        {"code": "Dim sc As SlicerCache\n' On Error Resume Next\n' Set sc = ThisWorkbook.SlicerCaches(\"Slicer_Product\")\n' If Not sc Is Nothing Then\n'   sc.CrossFilterType = xlSlicerCrossFilterShowItemsWithDataAtTop\n'   MsgBox \"'Product' 交叉分析篩選器現在會在頂部顯示與其他篩選器交叉後仍有數據的項目。\"\n' End If\n' On Error GoTo 0", "explanation": "將 \"Product\" 交叉分析篩選器的交叉篩選行為設定為優先顯示那些在其他相關交叉分析篩選器篩選後仍有數據的項目。"}
    ],
    "keywords": ["slicercache crossfiltertype", "slicer interaction", "交叉篩選器行為"]
},
{
    "name": "PivotTable.VisualTotals Property (OLAP)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.VisualTotals = True | False",
    "description": "如果樞紐分析表報表在篩選 OLAP 資料來源時包含篩選後項目的總計，則為 True。預設為 True。設為 False 可以僅顯示篩選後可見項目的總計，而不包括隱藏項目的貢獻。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示視覺總計。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(\"OLAP_Sales\")\n' If pt.PivotCache.OLAP Then\n'   pt.VisualTotals = False ' Show totals only for visible items after filtering\n'   MsgBox \"OLAP樞紐分析表的視覺總計已禁用 (僅匯總可見項目)。\"\n' Else\n'   MsgBox \"此樞紐分析表不是基於OLAP資料來源，VisualTotals屬性可能不適用。\"\n' End If", "explanation": "對於基於 OLAP 資料來源的樞紐分析表，將 VisualTotals 設為 False，可以使總計僅反映目前篩選後可見的項目，而不是所有基礎項目。"}
    ],
    "keywords": ["pivottable visualtotals", "olap pivot totals", "filter totals olap", "視覺總計OLAP"]
},
{
    "name": "PivotTable.CalculatedMembers Property (OLAP)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set calcMembers = pivotTableObject.CalculatedMembers",
    "description": "傳回一個 CalculatedMembers 集合，代表 OLAP 樞紐分析表中的所有計算成員。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, cm As CalculatedMember\n' Set pt = ActiveSheet.PivotTables(\"SalesCube\")\n' If pt.PivotCache.OLAP Then\n'   If pt.CalculatedMembers.Count > 0 Then\n'     MsgBox \"此OLAP樞紐分析表有 \" & pt.CalculatedMembers.Count & \" 個計算成員。\"\n'     For Each cm In pt.CalculatedMembers\n'       Debug.Print \"計算成員: \" & cm.Name & \", 公式: \" & cm.Formula\n'     Next cm\n'   Else\n'     MsgBox \"此OLAP樞紐分析表沒有計算成員。\"\n'   End If\n' End If", "explanation": "如果樞紐分析表是基於 OLAP，則遍歷其所有計算成員並列印其名稱和 MDX 公式。"}
    ],
    "keywords": ["pivottable calculatedmembers", "olap calculated members", "list calculated members", "OLAP計算成員"]
},
{
    "name": "CalculatedMember.Delete (OLAP PivotTable)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "calculatedMemberObject.Delete",
    "description": "從 OLAP 樞紐分析表中刪除指定的計算成員。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, cmToDelete As CalculatedMember\n' Set pt = ActiveSheet.PivotTables(\"SalesCube\")\n' If pt.PivotCache.OLAP Then\n'   On Error Resume Next ' In case member doesn't exist\n'   Set cmToDelete = pt.CalculatedMembers(\"MyCustomCalcMember\")\n'   If Not cmToDelete Is Nothing Then\n'     cmToDelete.Delete\n'     MsgBox \"計算成員 'MyCustomCalcMember' 已刪除。\"\n'   Else\n'     MsgBox \"未找到名為 'MyCustomCalcMember' 的計算成員。\"\n'   End If\n'   On Error GoTo 0\n' End If", "explanation": "嘗試從 OLAP 樞紐分析表中刪除一個名為 \"MyCustomCalcMember\" 的計算成員。"}
    ],
    "keywords": ["calculatedmember delete", "remove olap calculated member", "刪除計算成員"]
},
{
    "name": "PivotTable.AllocationMethod Property (OLAP What-If)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.AllocationMethod = XlAllocationMethodConstant",
    "description": "設定或傳回當執行假設分析並將值寫回 OLAP 資料來源時使用的分配方法。僅當 Allocation 屬性設為 xlWeightedAllocation 時才使用。",
    "parameters": [
        {"name": "XlAllocationMethodConstant", "description": "例如 xlEqualAllocation (平均分配), xlWeightedAllocation (按權重分配)。"}
    ],
    "examples": [
        {"code": "' Dim pt As PivotTable\n' ' Set pt = ActiveSheet.PivotTables(\"ForecastOLAP\")\n' ' If pt.PivotCache.OLAP And pt.EnableWriteback And pt.EnableAllocation Then\n' '   pt.Allocation = xlWeightedAllocation ' Set to use weights\n' '   pt.AllocationMethod = xlWeightedAllocation ' This property seems redundant with .Allocation for this specific value or contextually used.\n' '   ' For weighted allocation, you also need to set .AllocationWeightExpression\n' '   pt.AllocationWeightExpression = \"[Measures].[Previous Sales]\" ' Example: Allocate based on previous sales measure\n' '   MsgBox \"樞紐分析表已設定為按先前銷售額權重進行值分配。\"\n' ' End If", "explanation": "如果樞紐分析表設定為使用加權分配進行假設分析，此範例概念性地展示如何設定分配方法，並指出需要同時設定 AllocationWeightExpression。"}
    ],
    "keywords": ["pivottable allocationmethod", "olap what-if weighted allocation", "OLAP假設分析分配方法"]
},
// Word 文件處理
{
    "name": "Selection.Font.Name (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.Font.Name = \"FontName\"",
    "description": "設定目前選取範圍文字的字型名稱。",
    "parameters": [{"name": "FontName", "description": "字型名稱的字串，例如 \"Arial\", \"Times New Roman\"。"}],
    "examples": [
        {"code": "' Assume text is selected in Word\n' If Selection.Type = wdSelectionNormal Then\n'   Selection.Font.Name = \"Calibri Light\"\n'   MsgBox \"選取文字的字型已變更為 Calibri Light。\"\n' End If", "explanation": "將Word中目前選取文字的字型設定為 \"Calibri Light\"。"}
    ],
    "keywords": ["word font name", "change selected font", "設定選取字型"]
},
{
    "name": "Selection.Font.Size (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.Font.Size = PointValue",
    "description": "設定目前選取範圍文字的字型大小 (以點為單位)。",
    "parameters": [{"name": "PointValue", "description": "字型大小的數值。"}],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionNormal Then\n'   Selection.Font.Size = 14\n'   MsgBox \"選取文字的字型大小已設為 14 點。\"\n' End If", "explanation": "將Word中目前選取文字的字型大小設定為 14 點。"}
    ],
    "keywords": ["word font size", "change selected text size", "設定選取字型大小"]
},
{
    "name": "Selection.Font.Color (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.Font.Color = WdColorConstant Or RGB(R,G,B)",
    "description": "設定目前選取範圍文字的顏色。",
    "parameters": [
        {"name": "WdColorConstant", "description": "WdColor 常數，例如 wdColorRed, wdColorBlue。"},
        {"name": "RGB(R,G,B)", "description": "使用 RGB 函數指定的顏色值。"}
    ],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionNormal Then\n'   Selection.Font.Color = wdColorDarkBlue ' Using WdColor constant\n'   ' Or Selection.Font.Color = RGB(0, 0, 139) ' Using RGB for dark blue\n'   MsgBox \"選取文字的顏色已變更。\"\n' End If", "explanation": "將Word中目前選取文字的顏色設定為深藍色。"}
    ],
    "keywords": ["word font color", "change selected text color", "設定選取文字顏色"]
},
{
    "name": "Selection.ParagraphFormat.Alignment (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.ParagraphFormat.Alignment = WdParagraphAlignmentConstant",
    "description": "設定目前選取範圍中段落的對齊方式。",
    "parameters": [
        {"name": "WdParagraphAlignmentConstant", "description": "WdParagraphAlignment 常數，例如 wdAlignParagraphLeft, wdAlignParagraphCenter, wdAlignParagraphRight, wdAlignParagraphJustify。"}
    ],
    "examples": [
        {"code": "' Selection.ParagraphFormat.Alignment = wdAlignParagraphJustify ' Set to Justify\n' MsgBox \"選取段落已設定為左右對齊。\"", "explanation": "將Word中目前選取段落的對齊方式設定為左右對齊。"}
    ],
    "keywords": ["word paragraph alignment selected", "justify text word", "設定選取段落對齊"]
},
{
    "name": "Selection.ParagraphFormat.LeftIndent (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.ParagraphFormat.LeftIndent = PointValue",
    "description": "設定目前選取範圍中段落的左縮排 (以點為單位)。",
    "parameters": [{"name": "PointValue", "description": "縮排的點數值。可以使用 InchesToPoints() 轉換。"}],
    "examples": [
        {"code": "' Selection.ParagraphFormat.LeftIndent = Application.InchesToPoints(0.5)\n' MsgBox \"選取段落的左縮排已設定為 0.5 英吋。\"", "explanation": "將Word中目前選取段落的左縮排設定為 0.5 英吋。"}
    ],
    "keywords": ["word paragraph leftindent", "set indentation word", "設定段落左縮排"]
},
{
    "name": "Selection.ParagraphFormat.SpaceAfter (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.ParagraphFormat.SpaceAfter = PointValue",
    "description": "設定目前選取範圍中段落的段後間距 (以點為單位)。",
    "parameters": [{"name": "PointValue", "description": "間距的點數值。"}],
    "examples": [
        {"code": "' Selection.ParagraphFormat.SpaceAfter = 12 ' Set to 12 points\n' MsgBox \"選取段落的段後間距已設定為 12 點。\"", "explanation": "將Word中目前選取段落的段後間距設定為 12 點。"}
    ],
    "keywords": ["word paragraph spaceafter", "set paragraph spacing word", "設定段落後間距"]
},
{
    "name": "Document.Paragraphs(Index).Range (Word)",
    "category": "Word 文件處理",
    "syntax": "Set paraRange = documentObject.Paragraphs(Index).Range",
    "description": "傳回一個 Range 物件，代表文件中指定索引的段落的內容 (包括段落標記)。",
    "parameters": [{"name": "Index", "description": "必需。Paragraphs 集合中的段落索引 (1-based)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object, pRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' If wdDoc.Paragraphs.Count >= 2 Then\n'   Set pRange = wdDoc.Paragraphs(2).Range\n'   pRange.Font.Bold = True\n'   MsgBox \"第二個段落 ('\" & Left(pRange.Text, Len(pRange.Text)-1) & \"') 已設為粗體。\"\n' End If", "explanation": "如果文件至少有兩個段落，則獲取第二個段落的範圍並將其設為粗體。"}
    ],
    "keywords": ["word specific paragraph range", "get paragraph by index", "獲取特定段落範圍"]
},
{
    "name": "Document.Characters(Index) (Word)",
    "category": "Word 文件處理",
    "syntax": "Set charRange = documentObject.Characters(Index)",
    "description": "傳回一個 Range 物件，代表文件中指定索引的單個字元。",
    "parameters": [{"name": "Index", "description": "必需。Characters 集合中的字元索引 (1-based)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object, firstChar As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' If wdDoc.Characters.Count > 0 Then\n'   Set firstChar = wdDoc.Characters(1)\n'   MsgBox \"文件的第一個字元是: '\" & firstChar.Text & \"'\"\n'   firstChar.Font.Size = 20\n' End If", "explanation": "獲取文件的第一個字元，顯示它，並將其字型大小更改為20。"}
    ],
    "keywords": ["word specific character", "get character by index", "獲取特定字元"]
},
{
    "name": "Table.Rows.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newRow = tableObject.Rows.Add([BeforeRow As Row])",
    "description": "在表格中新增一列。如果指定 BeforeRow，則新列會插入到該列之前；否則，新列會新增到表格末尾。",
    "parameters": [{"name": "BeforeRow", "description": "可選。Row 物件，新列將插入其前。"}],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\nDim newAddedRow As Object ' Word.Row\n' Set tbl = ActiveDocument.Tables(1) ' Assume a table exists\n' Set newAddedRow = tbl.Rows.Add ' Add row at the end\n' newAddedRow.Cells(1).Range.Text = \"新列數據\"\n' MsgBox \"新列已新增到表格末尾。\"", "explanation": "在活動文件的第一個表格末尾新增一列，並在新列的第一個儲存格填入文字。"}
    ],
    "keywords": ["word table add row", "insert row in table word", "表格新增列Word"]
},
{
    "name": "Table.Columns.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newCol = tableObject.Columns.Add([BeforeColumn As Column])",
    "description": "在表格中新增一欄。如果指定 BeforeColumn，則新欄會插入到該欄之前；否則，新欄會新增到表格右側。",
    "parameters": [{"name": "BeforeColumn", "description": "可選。Column 物件，新欄將插入其前。"}],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\nDim newAddedCol As Object ' Word.Column\n' Set tbl = ActiveDocument.Tables(1)\n' Set newAddedCol = tbl.Columns.Add ' Add column at the end (right)\n' tbl.Cell(1, newAddedCol.Index).Range.Text = \"新欄標題\"\n' MsgBox \"新欄已新增到表格右側。\"", "explanation": "在活動文件的第一個表格右側新增一欄，並在新欄的第一個儲存格填入文字。"}
    ],
    "keywords": ["word table add column", "insert column in table word", "表格新增欄Word"]
},
{
    "name": "Cell.Merge (Word Table)",
    "category": "Word 文件處理",
    "syntax": "cellObject.Merge(MergeTo As Cell)",
    "description": "將指定的表格儲存格與另一個儲存格合併。",
    "parameters": [{"name": "MergeTo", "description": "必需。Cell 物件，代表要與 cellObject 合併的儲存格。"}],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\n' Set tbl = ActiveDocument.Tables(1)\n' If tbl.Cell(1,1).Range.Text <> \"\" And tbl.Cell(1,2).Range.Text <> \"\" Then ' Ensure cells are not already part of a merge\n'   tbl.Cell(1, 1).Merge MergeTo:=tbl.Cell(1, 2) ' Merge cell(1,1) with cell(1,2)\n'   MsgBox \"表格中 (1,1) 和 (1,2) 儲存格已合併。\"\n' Else\n'   MsgBox \"無法合併，儲存格可能已合併或不存在。\"\n' End If", "explanation": "嘗試合併活動文件中第一個表格的第一列第一格與第一列第二格。"}
    ],
    "keywords": ["word table merge cells", "combine table cells word", "合併表格儲存格Word"]
},
{
    "name": "InlineShapes(Index).ConvertToShape (Word)",
    "category": "Word 文件處理",
    "syntax": "Set shp = inlineShapeObject.ConvertToShape()",
    "description": "將指定的內嵌圖形轉換為浮動圖形 (Shape 物件)。",
    "parameters": [],
    "examples": [
        {"code": "Dim ils As Object ' Word.InlineShape\nDim convertedShape As Object ' Word.Shape\n' If ActiveDocument.InlineShapes.Count > 0 Then\n'   Set ils = ActiveDocument.InlineShapes(1)\n'   Set convertedShape = ils.ConvertToShape()\n'   convertedShape.WrapFormat.Type = wdWrapSquare ' Now can set wrap format\n'   MsgBox \"第一個內嵌圖形已轉換為浮動圖形並設定文繞圖。\"\n' End If", "explanation": "如果文件中有內嵌圖形，則將第一個內嵌圖形轉換為浮動圖形，然後設定其文繞圖格式。"}
    ],
    "keywords": ["word convert inlineshape to shape", "inline to floating picture", "轉換為浮動圖案"]
},
{
    "name": "Document.Revisions.AcceptAll (Word Track Changes)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Revisions.AcceptAll",
    "description": "接受指定文件中的所有追蹤修訂。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Revisions.Count > 0 Then\n'   If MsgBox(\"是否接受所有追蹤修訂?\", vbYesNo) = vbYes Then\n'     wdDoc.Revisions.AcceptAll\n'     MsgBox \"所有追蹤修訂已被接受。\"\n'   End If\n' Else\n'   MsgBox \"文件中沒有追蹤修訂。\"\n' End If", "explanation": "如果文件中有追蹤修訂，則提示用戶是否接受所有修訂。"}
    ],
    "keywords": ["word accept all revisions", "track changes accept", "接受所有修訂"]
},
{
    "name": "Document.Revisions.RejectAll (Word Track Changes)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Revisions.RejectAll",
    "description": "拒絕指定文件中的所有追蹤修訂。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Revisions.Count > 0 Then\n'   If MsgBox(\"是否拒絕所有追蹤修訂?\", vbYesNo) = vbYes Then\n'     wdDoc.Revisions.RejectAll\n'     MsgBox \"所有追蹤修訂已被拒絕。\"\n'   End If\n' End If", "explanation": "如果文件中有追蹤修訂，則提示用戶是否拒絕所有修訂。"}
    ],
    "keywords": ["word reject all revisions", "track changes reject", "拒絕所有修訂"]
},
{
    "name": "Range.LanguageID Property (Word Proofing)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.LanguageID = WdLanguageIDConstant\ncurrentLangID = rangeObject.LanguageID",
    "description": "設定或傳回指定範圍的校訂語言。",
    "parameters": [
        {"name": "WdLanguageIDConstant", "description": "WdLanguageID 常數，例如 wdEnglishUS, wdFrench, wdSimplifiedChinese。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' selRange.LanguageID = wdEnglishUK ' Set selected text language to UK English\n' MsgBox \"選取文字的校訂語言已設為英國英語。目前ID: \" & selRange.LanguageID", "explanation": "將目前選取文字的校訂語言設定為英國英語。"}
    ],
    "keywords": ["word proofing language", "set language word", "langugeid", "校訂語言"]
},
{
    "name": "Document.PrintPreview (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.PrintPreview",
    "description": "以預覽列印模式顯示指定的文件。",
    "parameters": [],
    "examples": [
        {"code": "' ActiveDocument.PrintPreview\n' MsgBox \"文件正在預覽列印模式下顯示。關閉預覽以繼續執行宏。\"", "explanation": "將活動文件切換到預覽列印模式。"}
    ],
    "keywords": ["word print preview", "preview document word", "預覽列印Word"]
},
{
    "name": "Dialogs(WdWordDialogConstant).Show (Word Built-in Dialogs)",
    "category": "Word 文件處理",
    "syntax": "returnValue = wdApplicationObject.Dialogs(WdWordDialogConstant).Show",
    "description": "顯示指定的 Word 內建對話框，並傳回一個 Long 值，指示哪個按鈕被按下。",
    "parameters": [
        {"name": "WdWordDialogConstant", "description": "WdWordDialog 常數，例如 wdDialogFileOpen, wdDialogFileSaveAs, wdDialogToolsOptions。"}
    ],
    "examples": [
        {"code": "Dim wdApp As Object ' Word.Application\nDim dlgResult As Long\n' Set wdApp = Application\n' ' Show the File Open dialog\n' dlgResult = wdApp.Dialogs(wdDialogFileOpen).Show\n' If dlgResult = -1 Then ' -1 means OK/Open was clicked\n'   MsgBox \"使用者在開啟對話框中點擊了確定/開啟。\" & vbCrLf & \"(注意：這只顯示對話框，實際開啟需另外編寫代碼，例如使用ActiveDocument)\"\n' Else ' 0 means Cancel was clicked\n'   MsgBox \"使用者取消了開啟對話框。\"\n' End If", "explanation": "顯示 Word 的標準「開啟舊檔」對話框。如果使用者點擊「開啟」，則 Show 方法傳回 -1。"}
    ],
    "keywords": ["word dialogs", "built-in dialogs word", "wdDialogFileOpen", "Word內建對話框"]
},
{
    "name": "ActiveWindow.View.Zoom.Percentage (Word)",
    "category": "Word 文件處理",
    "syntax": "activeWindowObject.View.Zoom.Percentage = ZoomPercentage",
    "description": "設定或傳回活動視窗的檢視縮放比例 (百分比)。",
    "parameters": [{"name": "ZoomPercentage", "description": "10 到 500 之間的數值。"}],
    "examples": [
        {"code": "Dim activeWin As Object ' Word.Window\n' Set activeWin = Application.ActiveWindow\n' activeWin.View.Zoom.Percentage = 150 ' Set zoom to 150%\n' MsgBox \"目前視窗的縮放比例已設為 150%。\"", "explanation": "將Word活動視窗的顯示縮放比例設定為150%。"}
    ],
    "keywords": ["word zoom percentage", "view zoom word", "設定Word縮放"]
},
// Excel 核心操作 (Adding a few more for balance)
{
    "name": "Range.ShowDetail (Property - Read)",
    "category": "Excel 核心操作",
    "syntax": "isExpanded = rangeObject.ShowDetail",
    "description": "讀取大綱中摘要列或摘要欄的詳細資料是否顯示。傳回 True 如果詳細資料已顯示 (已展開)，False 如果已摺疊。",
    "parameters": [],
    "examples": [
        {"code": "' Assume row 5 is a summary row in an outline\n' If Rows(5).ShowDetail Then\n'   MsgBox \"第5列的詳細資料目前是展開的。\"\n' Else\n'   MsgBox \"第5列的詳細資料目前是摺疊的。\"\n' End If", "explanation": "檢查大綱中第5列的詳細資料是否已展開。"}
    ],
    "keywords": ["check outline expanded", "is group expanded", "讀取大綱狀態"]
},
{
    "name": "Workbook.Connections.AddFromFile (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set newConn = workbookObject.Connections.AddFromFile(Filename As String, [CreatePivotTable As Boolean = False], [ExtractData As Boolean = False])",
    "description": "從外部連線檔案 (.odc, .atomsvc, .iqy, .oqy, .rqy, .cub) 建立一個新的活頁簿資料連線。",
    "parameters": [
        {"name": "Filename", "description": "必需。連線檔案的完整路徑。"},
        {"name": "CreatePivotTable", "description": "可選。True 表示基於此連線建立樞紐分析表。"},
        {"name": "ExtractData", "description": "可選。True 表示立即將資料提取到工作表。"}
    ],
    "examples": [
        {"code": "Dim connFile As String, newWbConn As WorkbookConnection\nconnFile = \"C:\\DataConnections\\MyQuery.iqy\" ' Example IQY file\n' If Dir(connFile) <> \"\" Then\n'   Set newWbConn = ThisWorkbook.Connections.AddFromFile(connFile)\n'   MsgBox \"已從檔案 '\" & connFile & \"' 新增資料連線: \" & newWbConn.Name\n'   ' newWbConn.Refresh ' Refresh the connection to get data\n' Else\n'   MsgBox \"連線檔案未找到: \" & connFile\n' End If", "explanation": "從一個 .iqy (網頁查詢) 連線檔案建立一個新的活頁簿資料連線。"}
    ],
    "keywords": ["add connection from file", "excel data connection odc", "iqy file connection", "從檔案新增連線"]
},
// Excel 資料分析與樞紐 (Adding a few more)
{
    "name": "PivotTable.ClearTable",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.ClearTable",
    "description": "清除樞紐分析表報表中的所有欄位、篩選和格式。這會將樞紐分析表重設為空白狀態，但保留其 PivotCache。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(\"SalesReport\")\n' If Not pt Is Nothing Then\n'   If MsgBox(\"是否要清除樞紐分析表 '\" & pt.Name & \"' 的所有欄位和格式?\", vbYesNo) = vbYes Then\n'     pt.ClearTable\n'     MsgBox \"樞紐分析表已清除。\"\n'   End If\n' End If", "explanation": "清除樞紐分析表 \"SalesReport\" 的所有欄位佈局和格式，使其變回空白樞紐分析表。"}
    ],
    "keywords": ["cleartable pivottable", "reset pivot table", "clear pivot layout", "清除樞紐分析表佈局"]
},
{
    "name": "PivotField.ClearManualFilter (Single Field)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.ClearManualFilter",
    "description": "清除套用於樞紐分析表欄位中特定 PivotField 的任何手動篩選 (例如，從下拉清單中勾選/取消勾選項目)。不會清除報表篩選或交叉分析篩選器篩選。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Country As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Country = pt.PivotFields(\"Country\")\n' If pf_Country.EnableMultiplePageItems = True Then ' Check if manual filter might be applied\n'    pf_Country.ClearManualFilter\n'    MsgBox \"'Country' 欄位的手動篩選 (項目勾選) 已清除。\"\n' End If", "explanation": "清除樞紐分析表中 \"Country\" 欄位上可能已套用的任何手動項目篩選。"}
    ],
    "keywords": ["pivotfield clearmanualfilter", "reset pivot item filter", "清除欄位手動篩選"]
},
{
    "name": "SlicerCache.SourceName Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "sourceNameString = slicerCacheObject.SourceName",
    "description": "傳回與 SlicerCache 關聯的 PivotTable 的來源欄位名稱 (例如，在 PivotTable 欄位清單中看到的欄位名稱)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim sc As SlicerCache\n' On Error Resume Next\n' Set sc = ThisWorkbook.SlicerCaches(1) ' Get the first slicer cache in the workbook\n' If Not sc Is Nothing Then\n'   MsgBox \"此交叉分析篩選器快取基於來源欄位: '\" & sc.SourceName & \"'\"\n' End If\n' On Error GoTo 0", "explanation": "獲取活頁簿中第一個 SlicerCache 的來源欄位名稱。"}
    ],
    "keywords": ["slicercache sourcename", "slicer field name", "交叉分析篩選器來源欄位"]
},
// Outlook 郵件與項目管理 (VBA Commands)
{
    "name": "MailItem.Reply",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set replyMailItem = mailItemObject.Reply()",
    "description": "為原始郵件項目建立一個回覆郵件。回覆郵件會預先填入收件者 (原始寄件者) 和主旨 (RE: 原始主旨)。",
    "parameters": [],
    "examples": [
        {"code": "Dim olOriginalMail As Object ' Outlook.MailItem, assume it's the selected email\nDim olReply As Object      ' Outlook.MailItem\n' Set olOriginalMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olOriginalMail) = \"MailItem\" Then\n'   Set olReply = olOriginalMail.Reply\n'   olReply.Body = \"這是對您郵件的回覆。\" & vbCrLf & olReply.Body ' Prepend new text\n'   olReply.Display ' Show the reply before sending\n' End If", "explanation": "獲取目前選取的郵件，為其建立一個回覆郵件，在原始郵件內容前加入新的回覆文字，然後顯示該回覆郵件。"}
    ],
    "keywords": ["outlook reply email", "create reply", "回覆郵件"]
},
{
    "name": "MailItem.ReplyAll",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set replyAllMailItem = mailItemObject.ReplyAll()",
    "description": "為原始郵件項目建立一個「全部回覆」郵件。新郵件會預先填入收件者 (原始寄件者和所有原始收件者/副本收件者) 和主旨。",
    "parameters": [],
    "examples": [
        {"code": "Dim olOriginalMail As Object, olReplyAll As Object\n' Set olOriginalMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olOriginalMail) = \"MailItem\" Then\n'   Set olReplyAll = olOriginalMail.ReplyAll\n'   olReplyAll.HTMLBody = \"<p>回覆給所有人：同意您的看法。</p>\" & olReplyAll.HTMLBody\n'   olReplyAll.Display\n' End If", "explanation": "為選取的郵件建立一個「全部回覆」郵件，並在郵件頂端加入HTML格式的回覆文字。"}
    ],
    "keywords": ["outlook reply all", "create reply all email", "全部回覆"]
},
{
    "name": "MailItem.Forward",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set forwardMailItem = mailItemObject.Forward()",
    "description": "為原始郵件項目建立一個轉寄郵件。轉寄郵件的主旨會預先填入 (FW: 原始主旨)，正文會包含原始郵件內容。",
    "parameters": [],
    "examples": [
        {"code": "Dim olOriginalMail As Object, olForward As Object\n' Set olOriginalMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olOriginalMail) = \"MailItem\" Then\n'   Set olForward = olOriginalMail.Forward\n'   olForward.To = \"colleague@example.com\"\n'   olForward.Body = \"FYI: \" & vbCrLf & olForward.Body ' Add a comment before forwarded content\n'   olForward.Display\n' End If", "explanation": "為選取的郵件建立一個轉寄郵件，設定新的收件者，並在轉寄內容前加入備註。"}
    ],
    "keywords": ["outlook forward email", "create forward", "轉寄郵件"]
},
{
    "name": "MailItem.Move",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set movedItem = mailItemObject.Move(DestinationFolder As MAPIFolder)",
    "description": "將 Outlook 項目移動到指定的資料夾。傳回代表已移動項目的物件。",
    "parameters": [{"name": "DestinationFolder", "description": "必需。MAPIFolder 物件，代表項目要移動到的目標資料夾。"}],
    "examples": [
        {"code": "Dim olMail As Object, olDestFolder As Object, olMovedMail As Object\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' ' Get the \"Archive\" subfolder of Inbox\n' On Error Resume Next\n' Set olDestFolder = Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox).Folders(\"Archive\")\n' If olDestFolder Is Nothing Then Set olDestFolder = Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox).Folders.Add(\"Archive\")\n' On Error GoTo 0\n' If Not olDestFolder Is Nothing And TypeName(olMail) = \"MailItem\" Then\n'   Set olMovedMail = olMail.Move(olDestFolder)\n'   MsgBox \"郵件 '\" & olMovedMail.Subject & \"' 已移動到 '\" & olDestFolder.Name & \"' 資料夾。\"\n' End If", "explanation": "將選取的郵件移動到收件匣下的 \"Archive\" 子資料夾 (如果該資料夾不存在則先建立它)。"}
    ],
    "keywords": ["outlook move email", "move item to folder", "移動郵件"]
},
{
    "name": "MailItem.Delete (Outlook Item)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.Delete",
    "description": "從包含該項目的資料夾中永久刪除該項目 (如果資料夾是「已刪除項目」資料夾)，或者將其移動到「已刪除項目」資料夾。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   If MsgBox(\"是否確實要刪除郵件 '\" & olMail.Subject & \"'？\", vbYesNo + vbExclamation) = vbYes Then\n'     olMail.Delete\n'     MsgBox \"郵件已移至 [已刪除項目]。\"\n'   End If\n' End If", "explanation": "在使用者確認後，將選取的郵件移動到「已刪除項目」資料夾。"}
    ],
    "keywords": ["outlook delete email", "remove email", "刪除郵件"]
},
{
    "name": "TaskItem.Assign (Outlook Task)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set assignedTask = taskItemObject.Assign()",
    "description": "指派一個任務並傳回代表該任務的 MailItem 物件 (任務要求)。",
    "parameters": [],
    "examples": [
        {"code": "Dim olTask As Object ' Outlook.TaskItem\nDim olTaskRequest As Object ' Outlook.MailItem (representing a task request)\n' Set olTask = Application.CreateItem(olTaskItem)\n' olTask.Subject = \"準備季度簡報\"\n' olTask.DueDate = Date + 14\n' olTask.Body = \"請收集所有相關數據並製作簡報初稿。\"\n' Set olTaskRequest = olTask.Assign()\n' olTaskRequest.Recipients.Add \"team.member@example.com\"\n' olTaskRequest.Recipients.ResolveAll\n' olTaskRequest.Send\n' MsgBox \"任務已指派給 team.member@example.com。\"", "explanation": "建立一個新任務，然後使用 Assign 方法將其轉換為一個任務要求，新增收件者並傳送該任務要求。"}
    ],
    "keywords": ["outlook assign task", "task request", "指派任務"]
},
{
    "name": "AppointmentItem.Recipients.Add (Outlook Meeting)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set newRecipient = appointmentItemObject.Recipients.Add(Name As String)",
    "description": "將收件者新增到約會 (會議邀請) 的 Recipients 集合中。",
    "parameters": [{"name": "Name", "description": "必需。收件者的名稱或電子郵件地址。"}],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem\nDim olRequiredAttendee As Object ' Outlook.Recipient\n' Set olAppt = Application.CreateItem(olAppointmentItem)\n' olAppt.MeetingStatus = olMeeting ' Set as a meeting\n' olAppt.Subject = \"專案啟動會議\"\n' olAppt.Start = Now + 1 + TimeValue(\"14:00:00\") ' Tomorrow 2 PM\n' olAppt.Duration = 60\n' Set olRequiredAttendee = olAppt.Recipients.Add(\"manager@example.com\")\n' olRequiredAttendee.Type = 1 ' olRequired\n' olAppt.Recipients.Add(\"optional.attendee@example.com\").Type = 2 ' olOptional\n' olAppt.Recipients.ResolveAll\n' olAppt.Display ' Or .Send to send meeting invitation", "explanation": "建立一個新的會議項目，新增必需和可選的與會者，然後顯示會議邀請。"}
    ],
    "keywords": ["outlook add meeting attendee", "meeting invitation recipients", "新增會議與會者"]
},
{
    "name": "Attachment.SaveAsFile (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "attachmentObject.SaveAsFile(Path As String)",
    "description": "將附件儲存到磁碟上的指定路徑。",
    "parameters": [{"name": "Path", "description": "必需。附件要儲存的完整檔案路徑。"}],
    "examples": [
        {"code": "Dim olMail As Object, olAtt As Object ' Outlook.MailItem, Outlook.Attachment\nDim saveFolderPath As String: saveFolderPath = \"C:\\Temp\\Attachments\\\"\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" And olMail.Attachments.Count > 0 Then\n'   If Dir(saveFolderPath, vbDirectory) = \"\" Then MkDir saveFolderPath ' Ensure folder exists\n'   For Each olAtt In olMail.Attachments\n'     olAtt.SaveAsFile saveFolderPath & olAtt.FileName\n'     Debug.Print \"附件 '\" & olAtt.FileName & \"' 已儲存到 \" & saveFolderPath\n'   Next olAtt\n'   MsgBox \"所有附件已儲存。\"\n' End If", "explanation": "遍歷選取郵件中的所有附件，並將它們儲存到 C:\\Temp\\Attachments\\ 資料夾中。"}
    ],
    "keywords": ["outlook save attachment", "download email attachment", "儲存附件"]
},
{
    "name": "ContactItem.Email1Address (Outlook Contact)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "contactItemObject.Email1Address [= String]",
    "description": "設定或傳回 Outlook 連絡人的第一個電子郵件地址。",
    "parameters": [{"name": "String", "description": "電子郵件地址。"}],
    "examples": [
        {"code": "Dim olContact As Object ' Outlook.ContactItem\n' Set olContact = Application.CreateItem(olContactItem)\n' olContact.FirstName = \"Jane\"\n' olContact.LastName = \"Doe\"\n' olContact.Email1Address = \"jane.doe@example.com\"\n' olContact.Email1DisplayName = \"Jane Doe (Work)\"\n' olContact.Email1AddressType = \"SMTP\"\n' olContact.Save\n' MsgBox \"連絡人 'Jane Doe' 已建立，電子郵件為: \" & olContact.Email1Address", "explanation": "建立一個新連絡人，並設定其第一個電子郵件地址、顯示名稱和地址類型。"}
    ],
    "keywords": ["outlook contact email", "set contact email address", "連絡人電子郵件"]
},
{
    "name": "Items.Find / .FindNext (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set foundItem = itemsCollection.Find(Filter As String)\nSet nextFoundItem = itemsCollection.FindNext()",
    "description": "Find 方法在 Items 集合中尋找符合指定篩選條件 (DASL 語法) 的第一個 Outlook 項目。FindNext 方法繼續先前的 Find 搜尋，尋找下一個符合相同條件的項目。",
    "parameters": [{"name": "Filter (Find method)", "description": "必需。DASL 篩選字串。"}],
    "examples": [
        {"code": "Dim olInbox As Object, olItems As Object, foundMail As Object\nDim strFilter As String\n' Set olInbox = Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox)\n' Set olItems = olInbox.Items\n' strFilter = \"@SQL=\" & Chr(34) & \"urn:schemas:httpmail:subject\" & Chr(34) & \" LIKE '%urgent%'\"\n' Set foundMail = olItems.Find(strFilter)\n' Do While Not foundMail Is Nothing\n'   Debug.Print \"找到緊急郵件: \" & foundMail.Subject & \" (Sender: \" & foundMail.SenderName & \")\"\n'   Set foundMail = olItems.FindNext()\n' Loop\n' MsgBox \"所有主旨含 'urgent' 的郵件已列印到立即視窗。\"", "explanation": "在收件匣中尋找所有主旨包含 \"urgent\" 的郵件，並將其主旨和寄件者列印到立即視窗。"}
    ],
    "keywords": ["outlook find items", "search emails outlook vba", "dasl query outlook", "findnext outlook", "尋找Outlook項目", "搜尋郵件"]
},
// 高階自動化應用 (Outlook)
{
    "name": "自動將特定發件人的郵件標記為已讀並移動到子文件夾 (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: VBA monitors the Inbox. When an email arrives from a specific sender (e.g., 'newsletter@example.com' or 'system.alerts@company.com'), it automatically marks the email as read and moves it to a predefined subfolder (e.g., 'Newsletters' or 'SystemAlerts').",
    "description": "此應用程式用於自動整理來自特定來源的郵件，保持收件匣清潔。1. **Outlook 事件處理 (ItemAdd)**：在 `ThisOutlookSession` 模組中，使用 `Application_NewMailEx` 或更針對特定資料夾的 `Items.ItemAdd` 事件來偵測新郵件的到達。2. **發件人檢查**：在事件處理程序中，檢查新到達郵件的 `SenderEmailAddress` 或 `SenderName` 是否符合預定義的列表或模式。3. **標記為已讀**：如果符合條件，將郵件的 `UnRead` 屬性設為 `False`。4. **移動到子文件夾**：  a. 獲取目標子文件夾的 `MAPIFolder` 物件。如果子文件夾不存在，可以自動建立它。  b. 使用郵件的 `.Move` 方法將其移動到目標子文件夾。5. **錯誤處理**：包含檢查資料夾是否存在、移動是否成功的錯誤處理。這個自動化對於不需立即關注但又希望歸檔的常規郵件（如新聞通訊、系統通知）非常有用。",
    "parameters": [
        {"name": "Target Sender Email Address(es)", "description": "要自動處理的郵件的發件人電子郵件地址列表。"},
        {"name": "Destination Subfolder Name", "description": "郵件將被移動到的收件匣下的子文件夾名稱。"},
        {"name": "Outlook Event Handler (ItemAdd or NewMailEx)", "description": "用於觸發處理邏輯的Outlook事件。"}
    ],
    "examples": [
        {"code": "' --- Code for ThisOutlookSession module --- \n' Private WithEvents inboxItems As Outlook.Items\n'\n' Private Sub Application_Startup()\n'   Dim olNS As Outlook.Namespace\n'   Set olNS = Application.GetNamespace(\"MAPI\")\n'   Set inboxItems = olNS.GetDefaultFolder(olFolderInbox).Items\n'   Set olNS = Nothing\n' End Sub\n'\n' Private Sub inboxItems_ItemAdd(ByVal Item As Object)\n'   Dim olMail As Outlook.MailItem\n'   Dim targetFolderName As String\n'   Dim destFolder As Outlook.MAPIFolder\n'\n'   If TypeOf Item Is MailItem Then\n'     Set olMail = Item\n'     Debug.Print \"New mail received: \" & olMail.Subject\n'\n'     ' --- Rule 1: Newsletters ---\n'     If LCase(olMail.SenderEmailAddress) = \"newsletter@example.com\" Or _\n'        LCase(olMail.SenderName) = \"Daily News Digest\" Then\n'       targetFolderName = \"Newsletters\"\n'       Set destFolder = GetOrCreateFolder(Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox), targetFolderName)\n'       If Not destFolder Is Nothing Then\n'         olMail.UnRead = False\n'         olMail.Move destFolder\n'         Debug.Print \"Moved '\" & olMail.Subject & \"' to \" & targetFolderName\n'       End If\n'     End If\n'\n'     ' --- Rule 2: System Alerts (Example with subject keyword) ---\n'     If InStr(1, olMail.Subject, \"[System Alert]\", vbTextCompare) > 0 Then\n'       targetFolderName = \"SystemAlerts\"\n'       Set destFolder = GetOrCreateFolder(Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox), targetFolderName)\n'       If Not destFolder Is Nothing Then\n'         olMail.UnRead = False\n'         olMail.Move destFolder\n'         Debug.Print \"Moved '\" & olMail.Subject & \"' to \" & targetFolderName\n'       End If\n'     End If\n'     ' Add more rules as needed\n'   End If\n'   Set olMail = Nothing: Set destFolder = Nothing\n' End Sub\n'\n' ' Helper function to get or create a subfolder\n' Function GetOrCreateFolder(parentFolder As Outlook.MAPIFolder, folderName As String) As Outlook.MAPIFolder\n'   Dim fldr As Outlook.MAPIFolder\n'   On Error Resume Next\n'   Set fldr = parentFolder.Folders(folderName)\n'   If fldr Is Nothing Then\n'     Set fldr = parentFolder.Folders.Add(folderName)\n'   End If\n'   On Error GoTo 0\n'   Set GetOrCreateFolder = fldr\n' End Function\n", "explanation": "此Outlook VBA代碼 (應放置在 `ThisOutlookSession` 模組中) 使用 `inboxItems_ItemAdd` 事件來監控收件匣中的新郵件。當新郵件到達時，它會檢查發件人或主旨是否符合預定義的條件。如果符合，它會將郵件標記為已讀，然後使用 `GetOrCreateFolder` 輔助函數找到或創建目標子文件夾，並將郵件移動到該子文件夾。"}
    ],
    "keywords": ["outlook auto-archive email", "vba move email by sender", "outlook rule automation", "organize inbox vba", "自動歸檔郵件", "按發件人移動郵件"]
},
{
    "name": "自動提取會議邀請的詳細信息到Excel日曆 (Outlook to Excel)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: VBA scans the Outlook Calendar folder (or Inbox for meeting requests) for appointments/meetings within a specified date range. It extracts details like subject, start time, end time, location, organizer, required attendees, and optional attendees, then logs this information into an Excel sheet formatted as a schedule or log.",
    "description": "此應用程式用於將Outlook日曆中的會議信息導出到Excel，以便進行報告、分析或與其他日程系統整合。1. **Excel日程記錄表 (“MeetingLog”)**：包含列：會議主旨、開始時間、結束時間、持續時間(分鐘)、地點、召集人、必需與會者、可選與會者、會議正文摘要。2. **VBA掃描與提取邏輯**：a. 連接到Outlook並訪問日曆資料夾 (`olFolderCalendar`) 或收件匣 (用於處理新的會議邀請 `MeetingItem`)。b. 設定要掃描的日期範圍。c. 遍歷在該日期範圍內的 `AppointmentItem` 物件。  i. 對於每個約會，提取其 `.Subject`, `.Start`, `.End`, `.Duration`, `.Location`, `.Organizer` 屬性。  ii. 遍歷 `.Recipients` 集合以獲取必需 (`olRequired`) 和可選 (`olOptional`) 與會者列表。  iii. (可選) 提取會議正文 (`.Body`) 的一部分作為摘要。d. 將提取到的信息作為新的一行寫入Excel的“MeetingLog”工作表。3. **篩選條件 (可選)**：可以添加篩選條件，例如只提取由特定人員召集的會議，或包含特定關鍵詞的會議。4. **執行方式**：此宏可以手動觸發，或設定為定期執行以更新Excel日程記錄。這個工具對於需要追蹤團隊成員會議安排、分析會議時長與頻率，或為項目管理整合會議數據的場景很有用。",
    "parameters": [
        {"name": "Outlook Calendar Folder (or Inbox for MeetingItems)", "description": "要掃描會議信息的Outlook資料夾。"},
        {"name": "Date Range for Scanning", "description": "指定要提取會議的日期範圍。"},
        {"name": "Excel Output Sheet for Meeting Log", "description": "用於存放提取的會議詳細信息的工作表。"},
        {"name": "Details to Extract", "description": "定義需要從每個會議項目中提取哪些信息。"}
    ],
    "examples": [
        {"code": "Sub ExtractCalendarMeetingsToExcel()\n    Dim olApp As Object, olNS As Object, olCalendar As Object ' Outlook.MAPIFolder\n    Dim olApptItems As Object ' Outlook.Items\n    Dim olAppt As Object    ' Outlook.AppointmentItem\n    Dim xlSheet As Object   ' Excel.Worksheet\n    Dim nextRow As Long, i As Long\n    Dim startDate As Date, endDate As Date\n\n    ' --- Configuration ---\n    Set xlSheet = ThisWorkbook.Sheets(\"MeetingLog\") ' Assumes this sheet exists\n    xlSheet.Cells.ClearContents\n    xlSheet.Range(\"A1:H1\").Value = Array(\"主旨\", \"開始時間\", \"結束時間\", \"時長(分)\", \"地點\", \"召集人\", \"必需與會者\", \"可選與會者\")\n    xlSheet.Rows(1).Font.Bold = True\n    nextRow = 2\n    startDate = DateSerial(Year(Now), Month(Now), 1) ' Start of current month\n    endDate = DateSerial(Year(Now), Month(Now) + 1, 0)   ' End of current month\n\n    On Error GoTo ErrorHandler\n    Set olApp = CreateObject(\"Outlook.Application\")\n    Set olNS = olApp.GetNamespace(\"MAPI\")\n    Set olCalendar = olNS.GetDefaultFolder(9) ' 9 = olFolderCalendar\n\n    ' Filter items by date range\n    Dim strFilter As String\n    strFilter = \"[Start] >= '\" & Format(startDate, \"ddddd h:nn AMPM\") & \"' AND [End] <= '\" & Format(endDate, \"ddddd h:nn AMPM\") & \"'\"\n    Set olApptItems = olCalendar.Items.Restrict(strFilter)\n    olApptItems.Sort \"[Start]\" ' Sort by start time\n\n    If olApptItems.Count = 0 Then\n        MsgBox \"在指定日期範圍內 (\" & Format(startDate, \"yyyy-mm-dd\") & \" 到 \" & Format(endDate, \"yyyy-mm-dd\") & \") 未找到會議。\", vbInformation\n        GoTo CleanUp\n    End If\n\n    Debug.Print \"找到 \" & olApptItems.Count & \" 個會議。正在提取...\"\n\n    For Each olAppt In olApptItems\n        If olAppt.Class = 26 Then ' olAppointment (26)\n            Dim requiredAttendees As String, optionalAttendees As String\n            requiredAttendees = \"\": optionalAttendees = \"\"\n            Dim recip As Object ' Outlook.Recipient\n            For Each recip In olAppt.Recipients\n                If recip.Type = 1 Then ' olRequired\n                    requiredAttendees = requiredAttendees & recip.Name & \"; \"\n                ElseIf recip.Type = 2 Then ' olOptional\n                    optionalAttendees = optionalAttendees & recip.Name & \"; \"\n                End If\n            Next recip\n            If Len(requiredAttendees) > 0 Then requiredAttendees = Left(requiredAttendees, Len(requiredAttendees) - 2)\n            If Len(optionalAttendees) > 0 Then optionalAttendees = Left(optionalAttendees, Len(optionalAttendees) - 2)\n\n            xlSheet.Cells(nextRow, \"A\").Value = olAppt.Subject\n            xlSheet.Cells(nextRow, \"B\").Value = olAppt.Start\n            xlSheet.Cells(nextRow, \"C\").Value = olAppt.End\n            xlSheet.Cells(nextRow, \"D\").Value = olAppt.Duration\n            xlSheet.Cells(nextRow, \"E\").Value = olAppt.Location\n            xlSheet.Cells(nextRow, \"F\").Value = olAppt.Organizer\n            xlSheet.Cells(nextRow, \"G\").Value = requiredAttendees\n            xlSheet.Cells(nextRow, \"H\").Value = optionalAttendees\n            nextRow = nextRow + 1\n        End If\n        If nextRow Mod 10 = 0 Then DoEvents\n    Next olAppt\n\n    xlSheet.Columns(\"A:H\").AutoFit\n    xlSheet.Columns(\"B:C\").NumberFormat = \"yyyy-mm-dd hh:mm\"\n    MsgBox \"日曆會議信息已成功提取到Excel。\", vbInformation\n\nCleanUp:\n    Set olAppt = Nothing: Set olApptItems = Nothing: Set olCalendar = Nothing\n    Set olNS = Nothing: Set olApp = Nothing: Set xlSheet = Nothing\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"提取會議時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub", "explanation": "此VBA子程序 `ExtractCalendarMeetingsToExcel` 會連接到Outlook，訪問預設的日曆資料夾。它會篩選出當前月份的會議項目，並按開始時間排序。然後，它遍歷這些會議，提取主旨、開始/結束時間、時長、地點、召集人以及必需和可選與會者列表，並將這些信息寫入到名為“MeetingLog”的Excel工作表中。"}
    ],
    "keywords": ["outlook calendar to excel vba", "extract meeting details", "vba export appointments", "outlook schedule automation", "Outlook日曆導出到Excel", "提取會議信息"]
},

{
    "name": "Document.Paragraphs.Last.Range.InsertBefore (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Paragraphs.Last.Range.InsertBefore(Text As String)",
    "description": "在文件的最後一個段落的開頭 (但在該段落的任何現有內容之前) 插入指定的文字。這對於在文件末尾但技術上仍在最後一個段落內添加內容很有用。",
    "parameters": [{"name": "Text", "description": "必需。要插入的文字。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.Paragraphs.Last.Range.InsertBefore \"--- 頁尾註解開始 ---\" & vbCrLf", "explanation": "在活動文件的最後一個段落的內容之前插入一行文字。"}
    ],
    "keywords": ["word insert before last paragraph", "add text end of document section", "文件末尾段落前插入"]
},
{
    "name": "Range.Font.AllCaps (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.AllCaps = True | False",
    "description": "設定或傳回指定範圍的文字是否格式化為全部大寫字母。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示所有字母均為大寫。"}],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' selRange.Font.AllCaps = True\n' MsgBox \"選取文字已設定為全部大寫。\"", "explanation": "將目前選取的文字格式化為全部大寫字母。"}
    ],
    "keywords": ["word font allcaps", "format text all caps", "全部大寫"]
},
{
    "name": "Range.Font.SmallCaps (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.SmallCaps = True | False",
    "description": "設定或傳回指定範圍的文字是否格式化為小型大寫字母。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示格式化為小型大寫字母。"}],
    "examples": [
        {"code": "Dim titleRange As Object ' Word.Range\n' Set titleRange = ActiveDocument.Paragraphs(1).Range ' Assume first paragraph is a title\n' titleRange.Font.SmallCaps = True\n' MsgBox \"第一個段落已設定為小型大寫字母。\"", "explanation": "將文件的第一個段落格式化為小型大寫字母。"}
    ],
    "keywords": ["word font smallcaps", "format text small caps", "小型大寫字母"]
},
{
    "name": "Range.Font.StrikeThrough (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.StrikeThrough = True | False",
    "description": "設定或傳回指定範圍的文字是否帶有刪除線。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示帶有刪除線。"}],
    "examples": [
        {"code": "Dim outdatedText As Object ' Word.Range\n' Set outdatedText = Selection.Range ' User selects some text\n' outdatedText.Font.StrikeThrough = True\n' MsgBox \"選取的文字已加上刪除線。\"", "explanation": "為目前選取的文字添加刪除線效果。"}
    ],
    "keywords": ["word font strikethrough", "text strikethrough", "刪除線"]
},
{
    "name": "Selection.Font.Spacing (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.Font.Spacing = PointValue",
    "description": "設定或傳回選取文字的字元間距 (以點為單位)。正值表示加寬，負值表示緊縮。",
    "parameters": [{"name": "PointValue", "description": "字元間距的點數值。"}],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionNormal Then\n'   Selection.Font.Spacing = 2 ' Expand character spacing by 2 points\n'   MsgBox \"選取文字的字元間距已加寬。\"\n' End If", "explanation": "將目前選取文字的字元間距增加2點。"}
    ],
    "keywords": ["word character spacing", "font spacing", "字元間距"]
},
{
    "name": "ParagraphFormat.LineSpacingRule (Word)",
    "category": "Word 文件處理",
    "syntax": "paragraphFormatObject.LineSpacingRule = WdLineSpacingConstant",
    "description": "設定或傳回段落的行距規則。",
    "parameters": [
        {"name": "WdLineSpacingConstant", "description": "例如 wdLineSpaceSingle (0), wdLineSpace1pt5 (1), wdLineSpaceDouble (2), wdLineSpaceAtLeast (3), wdLineSpaceExactly (4), wdLineSpaceMultiple (5)。"}
    ],
    "examples": [
        {"code": "Dim paraFmt As Object ' Word.ParagraphFormat\n' Set paraFmt = Selection.ParagraphFormat\n' paraFmt.LineSpacingRule = wdLineSpaceDouble ' Set to double spacing\n' If paraFmt.LineSpacingRule = wdLineSpaceMultiple Then\n'   paraFmt.LineSpacing = InchesToPoints(0.2) * 12 ' If multiple, LineSpacing is number of lines\n' ElseIf paraFmt.LineSpacingRule = wdLineSpaceAtLeast Or paraFmt.LineSpacingRule = wdLineSpaceExactly Then\n'   paraFmt.LineSpacing = 15 ' If AtLeast or Exactly, LineSpacing is points\n' End If\n' MsgBox \"選取段落的行距規則已設定。\"", "explanation": "將目前選取段落的行距規則設定為雙倍行高，並根據規則類型調整 LineSpacing 屬性。"}
    ],
    "keywords": ["word line spacing rule", "set line spacing", "行距規則"]
},
{
    "name": "ParagraphFormat.KeepWithNext (Word)",
    "category": "Word 文件處理",
    "syntax": "paragraphFormatObject.KeepWithNext = True | False",
    "description": "如果指定的段落與其後續段落保持在同一頁，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示與下段同頁。"}],
    "examples": [
        {"code": "Dim headingParaFmt As Object ' Word.ParagraphFormat\n' ' Assume the current selection is a heading that should stay with the next paragraph\n' Set headingParaFmt = Selection.ParagraphFormat\n' headingParaFmt.KeepWithNext = True\n' MsgBox \"選取的段落已設定為與下段同頁。\"", "explanation": "設定目前選取的段落（通常是標題）與其後續段落保持在同一頁上。"}
    ],
    "keywords": ["word keep with next", "paragraph pagination", "與下段同頁"]
},
{
    "name": "ParagraphFormat.KeepTogether (Word)",
    "category": "Word 文件處理",
    "syntax": "paragraphFormatObject.KeepTogether = True | False",
    "description": "如果指定段落中的所有行都保持在同一頁上 (不跨頁)，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示段落行同頁。"}],
    "examples": [
        {"code": "Dim importantParaFmt As Object ' Word.ParagraphFormat\n' Set importantParaFmt = ActiveDocument.Paragraphs(5).Format ' Example: 5th paragraph\n' importantParaFmt.KeepTogether = True\n' MsgBox \"第五個段落已設定為段落行同頁。\"", "explanation": "設定文件的第五個段落，使其所有行都保持在同一頁上，避免段落中間被分頁。"}
    ],
    "keywords": ["word keep lines together", "paragraph page break control", "段落行同頁"]
},
{
    "name": "Selection.InsertDateTime (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.InsertDateTime([DateTimeFormat As String], [InsertAsField As Boolean = False], [InsertAsFullWidth As Boolean = False], [DateLanguage As WdLanguageID = wdLanguageNone], [CalendarType As WdCalendarType = wdCalendarWestern])",
    "description": "在目前選取範圍或插入點處插入目前的日期或時間，或兩者。",
    "parameters": [
        {"name": "DateTimeFormat", "description": "可選。日期的顯示格式字串 (例如 \"yyyy-MM-dd HH:mm:ss\")。如果省略，則使用系統預設長日期格式。"},
        {"name": "InsertAsField", "description": "可選。True 表示插入為可更新的 DATE 或 TIME 功能變數。"}
    ],
    "examples": [
        {"code": "' Selection.InsertDateTime DateTimeFormat:=\"dddd, MMMM d, yyyy\", InsertAsField:=True\n' MsgBox \"已插入目前日期 (長格式，作為功能變數)。\"", "explanation": "在目前插入點插入完整的日期 (例如 \"星期一, 十月 30, 2023\")，並將其作為一個可更新的功能變數。"}
    ],
    "keywords": ["word insert datetime", "add current date word", "insert time field", "插入日期時間"]
},
{
    "name": "Document.Content.Select (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Content.Select",
    "description": "選取指定文件的全部內容 (主要內容區域)。",
    "parameters": [],
    "examples": [
        {"code": "' ActiveDocument.Content.Select\n' ' Now the entire document content is selected\n' ' Selection.Font.Name = \"Garamond\"\n' MsgBox \"整個文件的內容已被選取。\"", "explanation": "選取活動文件的所有主要內容。"}
    ],
    "keywords": ["word select all content", "select entire document", "選取全部內容"]
},
{
    "name": "Selection.Delete (Word)",
    "category": "Word 文件處理",
    "syntax": "deletedChars = selectionObject.Delete([Unit As WdUnits = wdCharacter], [Count As Long = 1])",
    "description": "從文件中刪除指定的選取範圍或指定數量的字元/單字。傳回刪除的單位數。",
    "parameters": [
        {"name": "Unit", "description": "可選。WdUnits 常數，指定要刪除的單位。"},
        {"name": "Count", "description": "可選。要刪除的單位數。"}
    ],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionNormal Then ' If text is selected\n'   Selection.Delete ' Delete the selected text\n'   MsgBox \"選取的文字已被刪除。\"\n' Else ' If it's an insertion point\n'   Selection.Delete Unit:=wdCharacter, Count:=5 ' Delete next 5 characters\n'   MsgBox \"插入點後的5個字元已被刪除。\"\n' End If", "explanation": "如果選取了文字，則刪除選取的文字。如果是一個插入點，則刪除插入點後的5個字元。"}
    ],
    "keywords": ["word delete selection", "delete text word", "刪除選取文字"]
},
{
    "name": "Range.ListFormat.ApplyListTemplate (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.ListFormat.ApplyListTemplate(ListTemplate As ListTemplate, [ContinuePreviousList As Boolean = False], [ApplyTo As WdListApplyTo = wdListApplyToWholeList], [DefaultListBehavior As WdDefaultListBehavior = wdWord10ListBehavior])",
    "description": "將指定的清單範本套用於範圍中的段落。",
    "parameters": [
        {"name": "ListTemplate", "description": "必需。ListTemplate 物件，代表要套用的清單範本。"},
        {"name": "ContinuePreviousList", "description": "可選。True 表示繼續前一個清單的編號。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\nDim lt As Object ' Word.ListTemplate\n' Set selRange = Selection.Range\n' ' Get the first bulleted list template from the list gallery\n' Set lt = Application.ListGalleries(wdBulletGallery).ListTemplates(1)\n' selRange.ListFormat.ApplyListTemplate ListTemplate:=lt, ContinuePreviousList:=False, ApplyTo:=wdListApplyToSelection\n' MsgBox \"已為選取範圍套用項目符號清單範本。\"", "explanation": "為目前選取的段落套用第一個預設的項目符號清單範本。"}
    ],
    "keywords": ["word apply list template", "format as list", "bulleted list word", "numbered list word", "套用清單範本"]
},
{
    "name": "Document.TrackRevisions Property (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.TrackRevisions = True | False",
    "description": "如果追蹤對指定文件所做的變更，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示啟用追蹤修訂。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.TrackRevisions = True\n' MsgBox \"文件 '\" & wdDoc.Name & \"' 的追蹤修訂功能已啟用。\"\n' ' wdDoc.TrackRevisions = False ' To turn off", "explanation": "啟用活動文件的追蹤修訂功能。"}
    ],
    "keywords": ["word track revisions", "enable track changes", "追蹤修訂"]
},
{
    "name": "Document.Comments.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newComment = documentObject.Comments.Add(Range As Range, [Text As String])",
    "description": "在文件中指定的範圍新增一個註解，並傳回代表該新註解的 Comment 物件。",
    "parameters": [
        {"name": "Range", "description": "必需。Range 物件，註解將標記此範圍。"},
        {"name": "Text", "description": "可選。註解的文字內容。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\nDim cmt As Object ' Word.Comment\n' Set selRange = Selection.Range\n' Set cmt = ActiveDocument.Comments.Add(Range:=selRange, Text:=\"請檢查此處的數據。\")\n' cmt.Author = \"自動審閱系統\"\n' MsgBox \"已在選取範圍新增註解。\"", "explanation": "在目前選取範圍新增一個註解，並設定其作者。"}
    ],
    "keywords": ["word add comment", "insert comment word", "document review", "新增註解Word"]
},
{
    "name": "Selection.Hyperlinks.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newHyperlink = selectionObject.Hyperlinks.Add(Anchor As Object, [Address As String], [SubAddress As String], [ScreenTip As String], [TextToDisplay As String], [Target As String])",
    "description": "將新的超連結新增到選取範圍。",
    "parameters": [
        {"name": "Anchor", "description": "必需。通常是 Selection.Range。"},
        {"name": "Address", "description": "可選。連結的位址 (URL、檔案路徑)。"},
        {"name": "TextToDisplay", "description": "可選。要在文件中顯示的超連結文字。如果 Anchor 已經是包含文字的範圍，則此參數可能會覆蓋它，或將連結套用於該文字。"}
    ],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionIP Then ' If it's an insertion point\n'   Selection.Hyperlinks.Add Anchor:=Selection.Range, Address:=\"http://www.microsoft.com\", TextToDisplay:=\"Microsoft 網站\"\n' ElseIf Selection.Type = wdSelectionNormal Then ' If text is selected\n'   Selection.Hyperlinks.Add Anchor:=Selection.Range, Address:=\"http://www.microsoft.com\"\n'   ' The selected text becomes the hyperlink text\n' End If\n' MsgBox \"已嘗試新增超連結。\"", "explanation": "如果在插入點，則插入一個顯示為 \"Microsoft 網站\" 的超連結。如果選取了文字，則將選取的文字轉換為超連結。"}
    ],
    "keywords": ["word add hyperlink selection", "create link word", "在選取範圍新增超連結"]
},
{
    "name": "Document.TablesOfContents.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set toc = documentObject.TablesOfContents.Add(Range As Range, [UseHeadingStyles As Boolean], [UpperHeadingLevel As Long], [LowerHeadingLevel As Long], ...)",
    "description": "在指定範圍建立一個目錄，並傳回代表該目錄的 TableOfContents 物件。",
    "parameters": [
        {"name": "Range", "description": "必需。Range 物件，目錄將在此處插入。"},
        {"name": "UseHeadingStyles", "description": "可選。True (預設) 表示使用內建標題樣式建立目錄。"},
        {"name": "UpperHeadingLevel", "description": "可選。目錄的起始標題級別 (預設1)。"},
        {"name": "LowerHeadingLevel", "description": "可選。目錄的結束標題級別 (預設9)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, tocRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' ' Insert TOC at the beginning of the document\n' Set tocRange = wdDoc.Range(Start:=0, End:=0)\n' wdDoc.TablesOfContents.Add Range:=tocRange, UseHeadingStyles:=True, UpperHeadingLevel:=1, LowerHeadingLevel:=3\n' MsgBox \"已在文件開頭插入基於標題1到標題3的目錄。\"", "explanation": "在活動文件的開頭插入一個目錄，該目錄基於標題1到標題3樣式。"}
    ],
    "keywords": ["word add table of contents", "insert toc word", "create document index", "新增目錄Word"]
},
{
    "name": "TableOfContents.Update (Word)",
    "category": "Word 文件處理",
    "syntax": "tocObject.Update",
    "description": "更新指定的 TableOfContents 物件中的頁碼和項目。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object\n' Set wdDoc = ActiveDocument\n' If wdDoc.TablesOfContents.Count > 0 Then\n'   wdDoc.TablesOfContents(1).Update\n'   MsgBox \"第一個目錄已更新。\"\n' Else\n'   MsgBox \"文件中沒有目錄可更新。\"\n' End If", "explanation": "如果活動文件中有目錄，則更新第一個目錄。"}
    ],
    "keywords": ["word update table of contents", "refresh toc", "更新目錄Word"]
},
{
    "name": "Document.Sections(Index).PageSetup (Word)",
    "category": "Word 文件處理",
    "syntax": "Set ps = documentObject.Sections(Index).PageSetup",
    "description": "傳回代表指定文件節 (Section) 的頁面設定屬性的 PageSetup 物件。",
    "parameters": [
        {"name": "Index", "description": "必需。節的索引號 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, pageSetupForSection1 As Object ' Word.PageSetup\n' Set wdDoc = ActiveDocument\n' If wdDoc.Sections.Count > 0 Then\n'   Set pageSetupForSection1 = wdDoc.Sections(1).PageSetup\n'   With pageSetupForSection1\n'     .Orientation = wdOrientLandscape ' 設定為橫向\n'     .TopMargin = InchesToPoints(0.8)\n'     .BottomMargin = InchesToPoints(0.8)\n'   End With\n'   MsgBox \"第一節的頁面設定已修改為橫向且調整了邊距。\"\n' End If", "explanation": "獲取活動文件第一節的 PageSetup 物件，並將其頁面方向設為橫向，同時調整上下邊距。"}
    ],
    "keywords": ["word section pagesetup", "set page orientation section", "section margins", "節頁面設定"]
},
{
    "name": "Selection.ClearFormatting (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.ClearFormatting",
    "description": "從選取的文字中移除文字和段落格式。",
    "parameters": [],
    "examples": [
        {"code": "' Assume some text is selected by the user\n' If Selection.Type = wdSelectionNormal Then\n'   Selection.ClearFormatting\n'   MsgBox \"選取範圍的文字和段落格式已被清除。\"\n' End If", "explanation": "如果使用者選取了文字，則清除選取文字的所有字元和段落格式，使其恢復為基礎樣式的預設格式。"}
    ],
    "keywords": ["word clear formatting selection", "remove text format word", "清除選取格式"]
},

{
    "name": "NameSpace.GetSharedDefaultFolder (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set sharedFolder = olNamespace.GetSharedDefaultFolder(Recipient As Outlook.Recipient, FolderType As OlDefaultFolders)",
    "description": "傳回一個 MAPIFolder 物件，代表指定使用者的共用預設資料夾。用於存取其他使用者已授予您權限的資料夾 (例如，共用行事曆、共用連絡人)。",
    "parameters": [
        {"name": "Recipient", "description": "必需。Recipient 物件，代表其共用資料夾要被存取的使用者。"},
        {"name": "FolderType", "description": "必需。OlDefaultFolders 常數，指定要存取的資料夾類型。"}
    ],
    "examples": [
        {"code": "Dim olNS As Object, olRecipient As Object, olSharedCalendar As Object\n' Set olNS = Application.GetNamespace(\"MAPI\")\n' ' Create a Recipient object for the user whose folder you want to open\n' Set olRecipient = olNS.CreateRecipient(\"user.name@example.com\")\n' olRecipient.Resolve\n' If olRecipient.Resolved Then\n'   On Error Resume Next ' Handle if folder not shared or permissions denied\n'   Set olSharedCalendar = olNS.GetSharedDefaultFolder(olRecipient, 9) ' 9 = olFolderCalendar\n'   If Not olSharedCalendar Is Nothing Then\n'     MsgBox \"已成功開啟 '\" & olRecipient.Name & \"' 的共用行事曆。\"\n'     olSharedCalendar.Display ' Display the shared calendar\n'   Else\n'     MsgBox \"無法開啟 '\" & olRecipient.Name & \"' 的共用行事曆。錯誤: \" & Err.Description\n'   End If\n'   On Error GoTo 0\n' Else\n'   MsgBox \"無法解析收件者: user.name@example.com\"\n' End If", "explanation": "嘗試開啟名為 \"user.name@example.com\" 的使用者的共用行事曆。首先建立並解析 Recipient 物件，然後使用 GetSharedDefaultFolder 獲取共用行事曆。"}
    ],
    "keywords": ["outlook getshareddefaultfolder", "access shared calendar", "open shared contacts", "共用資料夾", "開啟共用行事曆"]
},
{
    "name": "Explorer.CurrentView Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set currentViewObject = olExplorer.CurrentView",
    "description": "傳回或設定代表目前檢視的物件。物件類型取決於檢視類型 (例如，TableView, CardView, CalendarView)。",
    "parameters": [],
    "examples": [
        {"code": "Dim olExp As Object ' Outlook.Explorer\nDim currentView As Object\n' Set olExp = Application.ActiveExplorer\n' Set currentView = olExp.CurrentView\n' If Not currentView Is Nothing Then\n'   MsgBox \"目前檢視名稱: \" & currentView.Name & vbCrLf & \"檢視類型: \" & currentView.ViewType\n'   ' Example: If it's a TableView, you can change its settings\n'   If currentView.ViewType = olTableView Then ' olTableView = 0\n'     Dim tv As Object ' Outlook.TableView\n'     Set tv = currentView\n'     ' tv.Show pełne nagłówki ' Example: tv.ShowFullHeaders = True\n'     ' tv.Apply\n'   End If\n' End If", "explanation": "獲取 Outlook 活動瀏覽器中的目前檢視，並顯示其名稱和類型。如果檢視是 TableView，則可以進一步存取其特定屬性。"}
    ],
    "keywords": ["outlook currentview", "explorer view settings", "tableview outlook", "calendarview outlook", "目前檢視", "檢視設定"]
},
{
    "name": "TableView.GroupByFields Property (Outlook View)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set groupByFieldsCollection = tableViewObject.GroupByFields",
    "description": "傳回一個 OrderFields 集合，代表用於在 TableView 中分組項目的欄位集。可以新增或移除分組欄位。",
    "parameters": [],
    "examples": [
        {"code": "Dim olExp As Object, olView As Object ' Outlook.TableView\nDim olGroupBy As Object ' Outlook.OrderFields\n' Set olExp = Application.ActiveExplorer\n' If olExp.CurrentFolder.DefaultItemType = olMailItem Then\n'   Set olView = olExp.CurrentView\n'   If olView.ViewType = olTableView Then\n'     Set olGroupBy = olView.GroupByFields\n'     olGroupBy.Clear ' Clear existing grouping\n'     olGroupBy.Add \"urn:schemas:httpmail:from\" ' Group by From field\n'     olGroupBy.Add \"urn:schemas:httpmail:subject\" ' Then group by Subject\n'     olView.Apply ' Apply changes to the view\n'     MsgBox \"目前郵件檢視已設定為按寄件者然後按主旨分組。\"\n'   End If\n' End If", "explanation": "如果目前 Outlook 檢視是 TableView (例如，典型的郵件列表)，則此程式碼會清除現有的分組，然後設定為先按「寄件者」(From) 欄位分組，再按「主旨」(Subject) 欄位分組。"}
    ],
    "keywords": ["outlook tableview groupby", "group emails outlook vba", "custom view grouping", "依欄位分組郵件"]
},
{
    "name": "TableView.SortFields Property (Outlook View)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set sortFieldsCollection = tableViewObject.SortFields",
    "description": "傳回一個 OrderFields 集合，代表用於在 TableView 中排序項目的欄位集。",
    "parameters": [],
    "examples": [
        {"code": "Dim olView As Object ' Outlook.TableView\nDim olSort As Object ' Outlook.OrderFields\n' ' Assume olView is the current TableView for emails\n' Set olView = Application.ActiveExplorer.CurrentView\n' If olView.ViewType = olTableView Then\n'   Set olSort = olView.SortFields\n'   olSort.Clear\n'   olSort.Add \"urn:schemas:httpmail:datereceived\", True ' True for Descending (newest first)\n'   olSort.Add \"urn:schemas:httpmail:sendername\", False ' False for Ascending\n'   olView.Apply\n'   MsgBox \"郵件檢視已排序：先按接收日期 (新到舊)，再按寄件者名稱 (A-Z)。\"\n' End If", "explanation": "設定郵件列表檢視的排序順序：首先按接收日期降冪排列 (最新的在前面)，然後在相同日期內按寄件者名稱升冪排列。"}
    ],
    "keywords": ["outlook tableview sortfields", "sort emails vba", "custom view sorting", "排序郵件檢視"]
},
{
    "name": "MeetingItem.GetAssociatedAppointment (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set olAppt = meetingItemObject.GetAssociatedAppointment(AddToCalendar As Boolean)",
    "description": "從會議邀請或更新 (MeetingItem) 中獲取關聯的 AppointmentItem。如果 AddToCalendar 為 True，且約會尚不存在於日曆中，則會將其新增到日曆。",
    "parameters": [{"name": "AddToCalendar", "description": "必需。布林值。"}],
    "examples": [
        {"code": "Dim olMeetingRequest As Object ' Outlook.MeetingItem (assuming it's selected)\nDim olAppt As Object ' Outlook.AppointmentItem\n' Set olMeetingRequest = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMeetingRequest) = \"MeetingItem\" Then\n'   ' Get the appointment, add to calendar if not already there\n'   Set olAppt = olMeetingRequest.GetAssociatedAppointment(True)\n'   If Not olAppt Is Nothing Then\n'     MsgBox \"已處理會議邀請 '\" & olAppt.Subject & \"' 並更新/新增至日曆。\"\n'     olAppt.Display ' Show the appointment in the calendar\n'   Else\n'     MsgBox \"無法從會議邀請獲取關聯的約會。\"\n'   End If\n' End If", "explanation": "如果選取的項目是會議邀請 (MeetingItem)，則獲取其關聯的約會。如果 AddToCalendar 設為 True，則該約會會被新增到使用者的日曆中（如果尚未存在）。"}
    ],
    "keywords": ["outlook getassociatedappointment", "process meeting request", "add meeting to calendar", "處理會議邀請", "新增會議至日曆"]
},
{
    "name": "AppointmentItem.Respond (Outlook Meeting Response)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set olResponse = appointmentItemObject.Respond(Response As OlMeetingResponse, [fNoUI As Boolean = False], [fAdditionalTextDialog As Boolean = False])",
    "description": "對會議邀請做出回應 (接受、暫訂、拒絕)。傳回一個 MeetingItem 物件，代表要傳送的回應。",
    "parameters": [
        {"name": "Response", "description": "必需。OlMeetingResponse 常數 (olMeetingAccepted, olMeetingDeclined, olMeetingTentative)。"},
        {"name": "fNoUI", "description": "可選。True 表示不顯示回應視窗。"},
        {"name": "fAdditionalTextDialog", "description": "可選。True 表示提示使用者輸入額外文字。"}
    ],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem (received meeting that needs response)\nDim olMeetingResponse As Object ' Outlook.MeetingItem\n' ' Assume olAppt points to a meeting invitation in the calendar or inbox\n' If olAppt.MeetingStatus = olMeetingReceived Then ' Check if it's an invitation awaiting response\n'   ' Accept the meeting and send response immediately without UI\n'   Set olMeetingResponse = olAppt.Respond(olMeetingAccepted, True)\n'   ' olMeetingResponse.Body = \"很高興能參加！\" ' Optional: Add a message to the response\n'   olMeetingResponse.Send\n'   MsgBox \"會議 '\" & olAppt.Subject & \"' 已接受，並已傳送回應。\"\n' End If", "explanation": "如果一個約會項目是收到的會議邀請且尚未回應，則此程式碼會自動接受該會議，並立即傳送回應，而不向使用者顯示任何介面。"}
    ],
    "keywords": ["outlook respond meeting", "accept meeting vba", "decline meeting vba", "meeting response automation", "回覆會議邀請"]
},
{
    "name": "Store Object (Outlook NameSpace)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set olStore = olNamespace.Stores(IndexOrStoreID)\nSet rootFolder = olStore.GetRootFolder()",
    "description": "代表 Outlook 設定檔中定義的訊息儲存區 (例如，Exchange 郵箱、PST 檔案、共用郵箱)。可以通過 NameSpace.Stores 集合存取。",
    "parameters": [
        {"name": "Stores(IndexOrStoreID)", "description": "集合的 Item 方法，可以按索引 (1-based) 或儲存區的 StoreID (字串) 存取。"},
        {"name": ".DisplayName", "description": "屬性：儲存區的顯示名稱。"},
        {"name": ".FilePath", "description": "屬性：對於 PST 檔案，傳回其檔案路徑。"},
        {"name": ".GetRootFolder()", "description": "方法：傳回代表此儲存區根目錄的 MAPIFolder 物件。"}
    ],
    "examples": [
        {"code": "Dim olNS As Object, olStore As Object, olRootFldr As Object\nSet olNS = Application.GetNamespace(\"MAPI\")\nIf olNS.Stores.Count > 0 Then\n  Debug.Print \"可用的郵件儲存區:\"\n  For Each olStore In olNS.Stores\n    Debug.Print \"  - \" & olStore.DisplayName & \" (ID: \" & olStore.StoreID & \")\"\n    ' Get the root folder of this store\n    Set olRootFldr = olStore.GetRootFolder()\n    Debug.Print \"    根資料夾: \" & olRootFldr.Name\n    ' You can then access olRootFldr.Folders, etc.\n  Next olStore\nEnd If", "explanation": "遍歷目前 Outlook 設定檔中的所有郵件儲存區 (例如，您的主郵箱、任何已連結的 PST 檔案或共用郵箱)，並列印每個儲存區的顯示名稱、StoreID 及其根資料夾的名稱。"}
    ],
    "keywords": ["outlook store object", "access pst file vba", "shared mailbox vba", "getrootfolder", "郵件儲存區", "存取PST檔案"]
},

{
    "name": "自動處理Outlook外出/自動回覆郵件並更新Excel追蹤表 (Outlook to Excel)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: When sending bulk emails for campaigns or important announcements, it's useful to track Out-of-Office (OOF) or other auto-replies. VBA can monitor the Inbox for these types of replies (identified by keywords in subject/body or specific X-headers), extract the sender's email, and update a status column in an Excel tracking sheet for that recipient (e.g., changing status from 'Sent' to 'OOF Reply Received').",
    "description": "此應用程式用於識別並記錄對群發郵件的自動回覆（如外出通知）。1. **Excel郵件追蹤表 (“CampaignLog”)**：包含原始收件人郵箱、發送日期、發送狀態、以及新增的“自動回覆狀態”列。2. **Outlook事件處理或定期掃描**：a. 監控收件匣中的新郵件。b. 對於每封新郵件，檢查其是否為自動回覆。判斷方法可以包括：  i. 主旨行是否包含常見的自動回覆關鍵詞 (例如，“Out of Office”, “Automatic Reply”, “自動答覆”, “不在辦公室”)。  ii. 郵件正文中是否包含典型的自動回覆短語。  iii. (高級) 檢查郵件標頭中是否有特定的自動回覆相關 X-Header (例如，`X-Auto-Response-Suppress`)。3. **匹配與更新Excel**：a. 從自動回覆郵件中提取原始發件人（即自動回覆郵件的`SenderEmailAddress`，這對應於我們群發郵件的原始收件人）。b. 在Excel的“CampaignLog”表中查找該郵箱地址。c. 如果找到匹配記錄，則將其“自動回覆狀態”更新為“收到自動回覆”或更具體的類型 (例如，“外出通知”)，並可記錄收到自動回覆的日期。4. **郵件處理**：可以將已識別的自動回覆郵件移動到一個專門的“自動回覆”文件夾。這個工具幫助郵件發送者了解哪些收件人可能暫時無法查看郵件，對於調整後續溝通策略或統計有效送達率有一定幫助。",
    "parameters": [
        {"name": "Excel Campaign Log Sheet", "description": "記錄群發郵件的收件人列表和追蹤狀態的工作表。"},
        {"name": "Outlook Folder for Incoming Replies", "description": "監控回覆郵件的Outlook文件夾。"},
        {"name": "Keywords/Rules for Identifying Auto-Replies", "description": "用於判斷一封郵件是否為自動回覆的關鍵詞或規則。"},
        {"name": "VBA Logic for Matching and Updating Excel", "description": "將自動回覆與原始發送記錄匹配並更新狀態的代碼。"}
    ],
    "examples": [
        {"code": "' --- Code for ThisOutlookSession module (Conceptual) ---\n' Private WithEvents campaignReplyItems As Outlook.Items\n'\n' Private Sub Application_Startup()\n'   Dim olNS As Outlook.Namespace\n'   Set olNS = Application.GetNamespace(\"MAPI\")\n'   ' Monitor Inbox or a specific folder where replies are expected\n'   Set campaignReplyItems = olNS.GetDefaultFolder(olFolderInbox).Items\n' End Sub\n'\n' Private Sub campaignReplyItems_ItemAdd(ByVal Item As Object)\n'   Dim olMail As Outlook.MailItem\n'   Dim xlSheet As Object ' Excel.Worksheet\n'   Dim excelPath As String: excelPath = \"C:\\Path\\To\\CampaignLog.xlsx\" ' **實際路徑**\n'   Dim sheetName As String: sheetName = \"EmailTracking\"\n'   Dim originalRecipientEmail As String\n'   Dim r As Long, lastRow As Long\n'   Dim xlApp As Object, xlBook As Object\n'\n'   If TypeOf Item Is MailItem Then\n'     Set olMail = Item\n'     ' --- Identify Auto-Replies (Simplified keyword check) ---\n'     Dim autoReplyKeywords As Variant\n'     autoReplyKeywords = Array(\"out of office\", \"automatic reply\", \"不在辦公室\", \"自動答覆\")\n'     Dim keyword As Variant, isAutoReply As Boolean: isAutoReply = False\n'     For Each keyword In autoReplyKeywords\n'       If InStr(1, LCase(olMail.Subject), LCase(keyword)) > 0 Or _\n'          InStr(1, LCase(olMail.Body), LCase(keyword)) > 0 Then\n'         isAutoReply = True\n'         Exit For\n'       End If\n'     Next keyword\n'\n'     If isAutoReply Then\n'       originalRecipientEmail = olMail.SenderEmailAddress ' The sender of OOF is our original recipient\n'       Debug.Print \"自動回覆偵測到來自: \" & originalRecipientEmail & \" 主旨: \" & olMail.Subject\n'\n'       ' --- Update Excel Log (Simplified: Opens Excel each time, better to keep instance) ---\n'       On Error Resume Next\n'       Set xlApp = GetObject(, \"Excel.Application\")\n'       If xlApp Is Nothing Then Set xlApp = CreateObject(\"Excel.Application\")\n'       If xlApp Is Nothing Then Debug.Print \"無法啟動Excel以更新日誌。\": Exit Sub\n'       Set xlBook = xlApp.Workbooks.Open(excelPath)\n'       Set xlSheet = xlBook.Sheets(sheetName)\n'       If xlSheet Is Nothing Then Debug.Print \"Excel日誌表 '\" & sheetName & \"' 未找到。\": xlBook.Close False: Set xlApp=Nothing: Exit Sub\n'       On Error GoTo 0\n'\n'       lastRow = xlSheet.Cells(Rows.Count, \"A\").End(xlUp).Row ' Assume Email in Col A, Status in Col D\n'       For r = 2 To lastRow\n'         If LCase(Trim(CStr(xlSheet.Cells(r, \"A\").Value))) = LCase(originalRecipientEmail) And _\n'            LCase(Trim(CStr(xlSheet.Cells(r, \"D\").Value))) <> \"oof reply received\" Then \n'           xlSheet.Cells(r, \"D\").Value = \"OOF Reply Received\"\n'           xlSheet.Cells(r, \"E\").Value = Now ' Reply Received Date (Col E)\n'           Debug.Print \"Excel日誌已更新為 '\" & originalRecipientEmail & \"' 的自動回覆。\"\n'           Exit For\n'         End If\n'       Next r\n'       xlBook.Close True ' Save changes and close\n'       ' If xlApp.Workbooks.Count = 0 Then xlApp.Quit ' Quit if no other workbooks by this instance\n'       Set xlSheet = Nothing: Set xlBook = Nothing: Set xlApp = Nothing\n'       \n'       olMail.UnRead = False\n'       ' olMail.Move Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox).Folders(\"AutoReplies\")\n'     End If\n'   End If\n'   Set olMail = Nothing\n' End Sub\n", "explanation": "此概念性Outlook VBA代碼 (放置於 `ThisOutlookSession`) 監控收件匣的新郵件。如果郵件的主旨或正文包含常見的自動回覆關鍵詞，則認為它是一個自動回覆。然後，腳本會獲取該自動回覆的發件人郵箱（這就是我們原始群發郵件的收件人），並在指定的Excel追蹤工作表 (`CampaignLog.xlsx` 中的 `EmailTracking` 表) 中查找該郵箱。如果找到匹配且狀態尚未更新，則將其狀態更新為“OOF Reply Received”並記錄收到日期。**重要提示**：此範例中更新Excel的邏輯是每次都打開和關閉Excel文件，對於頻繁的更新效率較低，更好的做法是保持Excel實例打開或使用ADO與已開啟的Excel文件交互。自動回覆的識別邏輯也比較基礎，可能需要根據實際情況進行調整。"}
    ],
    "keywords": ["outlook vba track auto-replies", "excel log out-of-office responses", "automate email campaign tracking", "oof detection vba", "追蹤Outlook自動回覆", "Excel記錄外出通知"]
},
{
    "name": "基於發件人域名和附件類型自動將郵件及附件歸檔到客戶/項目文件夾 (Outlook to FileSystem)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: VBA monitors an Outlook Inbox or specific project-related subfolders. When an email arrives from a known client domain (e.g., '@clientcompany.com') and contains specific types of attachments (e.g., '.pdf', '.docx', '.zip' but not '.exe'), the email itself (as .msg or .txt) and its relevant attachments are saved to a predefined network folder structure, typically organized by client name and then by project or date.",
    "description": "此應用程式用於自動將來自重要客戶的包含特定類型附件的郵件及其附件歸檔到文件系統中，方便項目管理和記錄保存。1. **Excel配置表 (可選，或在VBA中硬編碼)**：a. “ClientDomainMapping”表：客戶域名 (例如，“clientcompany.com”)，對應的客戶文件夾名稱 (例如，“Client_A_Company”)。b. “AllowedAttachmentTypes”表：允許自動歸檔的附件擴展名列表 (例如，“pdf”, “docx”, “xlsx”, “zip”)。2. **Outlook事件處理 (`ItemAdd`)**：a. 監控收件匣或特定項目郵件夾的新郵件。b. **發件人域名驗證**：提取發件人郵箱的域名部分，並與“ClientDomainMapping”表中的列表進行匹配。3. **附件類型和名稱檢查**：a. 如果發件人域名匹配，則遍歷郵件的所有附件。b. 檢查每個附件的擴展名是否在“AllowedAttachmentTypes”列表中。c. (可選) 可以排除特定名稱模式的附件 (例如，圖片簽名檔 `image001.png`)。4. **創建歸檔路徑**：a. 根據匹配到的客戶域名，從“ClientDomainMapping”獲取客戶文件夾名稱。b. 構建完整的本地或網絡歸檔路徑，例如 `BaseArchivePath & ClientFolderName & \"\\\" & Format(olMail.ReceivedTime, \"yyyy-MM\") & \"\\\" & CleanSubjectForFolderName(olMail.Subject)`。可以按客戶、再按月份、再按郵件主旨（清理後）創建子文件夾。5. **保存郵件和附件**：a. 將郵件本身以 `.msg` 格式 (或 `.txt` 格式保存正文) 保存到目標歸檔路徑。b. 將所有符合條件的附件也保存到同一路徑，注意處理同名文件（例如，在文件名後附加時間戳或序號）。6. **郵件標記與移動**：已成功歸檔的郵件可以在Outlook中標記一個特定類別（例如，“已歸檔到文件系統”），並可選地移動到一個“已處理歸檔”的Outlook文件夾。7. **日誌記錄**：將歸檔操作（時間、郵件主旨、發件人、歸檔路徑、保存的文件列表）記錄到Excel日誌表中。這個流程確保了重要客戶的相關文件和通信記錄被系統地存儲在中央文件位置，而不是僅僅散落在郵箱中。",
    "parameters": [
        {"name": "Monitored Outlook Folder", "description": "接收客戶郵件的Outlook文件夾。"},
        {"name": "Client Domain to Folder Mapping (Excel/VBA)", "description": "客戶郵箱域名與其對應的文件系統歸檔文件夾名稱的映射關係。"},
        {"name": "Allowed/Excluded Attachment Types/Names", "description": "定義哪些附件應該被歸檔，哪些應該被忽略的規則。"},
        {"name": "Archive Folder Structure Logic", "description": "如何在文件系統中組織客戶/項目歸檔文件夾的規則。"},
        {"name": "Error Handling for File Operations", "description": "處理文件保存時可能發生的錯誤（例如，路徑無效、權限不足、文件名衝突）。"}
    ],
    "examples": [
        {"code": "' --- Code for ThisOutlookSession module (Conceptual) ---\n' Private WithEvents monitoredItems As Outlook.Items\n' Private Const BASE_ARCHIVE_PATH As String = \"C:\\ClientArchives\\\" ' **實際基礎歸檔路徑**\n' Private allowedExtensions As Object ' Scripting.Dictionary\n'\n' Private Sub Application_Startup()\n'   Dim olNS As Outlook.Namespace\n'   Set olNS = Application.GetNamespace(\"MAPI\")\n'   Set monitoredItems = olNS.GetDefaultFolder(olFolderInbox).Items\n'   ' Initialize allowed extensions dictionary\n'   Set allowedExtensions = CreateObject(\"Scripting.Dictionary\")\n'   allowedExtensions.CompareMode = vbTextCompare ' Case-insensitive\n'   allowedExtensions.Add \"pdf\", True\n'   allowedExtensions.Add \"docx\", True\n'   allowedExtensions.Add \"xlsx\", True\n'   allowedExtensions.Add \"zip\", True\n' End Sub\n'\n' Private Sub monitoredItems_ItemAdd(ByVal Item As Object)\n'   Dim olMail As Outlook.MailItem\n'   Dim fso As Object: Set fso = CreateObject(\"Scripting.FileSystemObject\")\n'   Dim clientDomain As String, clientFolderName As String, mailArchiveSubPath As String, fullArchivePath As String\n'   Dim att As Outlook.Attachment, safeFileName As String, fileExt As String\n'\n'   If TypeOf Item Is MailItem Then\n'     Set olMail = Item\n'     If InStr(olMail.SenderEmailAddress, \"@\") > 0 Then\n'       clientDomain = LCase(Split(olMail.SenderEmailAddress, \"@\")(1))\n'       clientFolderName = GetClientFolderFromDomain(clientDomain) ' Custom function to map domain to folder name\n'\n'       If clientFolderName <> \"\" And olMail.Attachments.Count > 0 Then\n'         ' Create archive path: BasePath\\ClientFolder\\YYYY-MM\\CleanedSubject\\\n'         mailArchiveSubPath = clientFolderName & \"\\\" & Format(olMail.ReceivedTime, \"yyyy-mm\") & \"\\\" & CleanStringForPath(olMail.Subject)\n'         fullArchivePath = fso.BuildPath(BASE_ARCHIVE_PATH, mailArchiveSubPath)\n'         If Not fso.FolderExists(fullArchivePath) Then fso.CreateFolder fullArchivePath\n'\n'         ' Save email itself\n'         olMail.SaveAs fso.BuildPath(fullArchivePath, CleanStringForPath(olMail.Subject) & \".msg\"), olMSG\n'\n'         ' Save allowed attachments\n'         For Each att In olMail.Attachments\n'           fileExt = LCase(fso.GetExtensionName(att.FileName))\n'           If allowedExtensions.Exists(fileExt) Then\n'             safeFileName = CleanStringForPath(att.FileName)\n'             att.SaveAsFile fso.BuildPath(fullArchivePath, safeFileName)\n'             Debug.Print \"歸檔附件: \" & safeFileName & \" 到 \" & fullArchivePath\n'           End If\n'         Next att\n'\n'         olMail.Categories = \"已歸檔到文件系統\"\n'         olMail.Save\n'         ' olMail.Move GetOrCreateFolder(Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox), \"已處理歸檔\")\n'         Debug.Print \"郵件 '\" & olMail.Subject & \"' 已歸檔到 \" & fullArchivePath\n'       End If\n'     End If\n'   End If\n'   Set olMail = Nothing: Set fso = Nothing\n' End Sub\n'\n' Function GetClientFolderFromDomain(domain As String) As String\n'   ' Placeholder: Lookup in Excel sheet or hardcode\n'   Select Case domain\n'     Case \"clientA.com\": GetClientFolderFromDomain = \"ClientA_Company\"\n'     Case \"partnercorp.net\": GetClientFolderFromDomain = \"Partner_Corporation\"\n'     Case Else: GetClientFolderFromDomain = \"_OtherClients\"\n'   End Select\n' End Function\n'\n' Function CleanStringForPath(inputStr As String) As String\n'   Dim invalidChars As String: invalidChars = \"\\/:*?\"\"<>|\" & vbCrLf\n'   Dim i As Long, char As String\n'   CleanStringForPath = inputStr\n'   For i = 1 To Len(invalidChars)\n'     char = Mid(invalidChars, i, 1)\n'     CleanStringForPath = Replace(CleanStringForPath, char, \"_\")\n'   Next i\n'   If Len(CleanStringForPath) > 100 Then CleanStringForPath = Left(CleanStringForPath, 100)\n'   CleanStringForPath = Trim(CleanStringForPath)\n' End Function\n", "explanation": "此概念性Outlook VBA代碼 (放置於 `ThisOutlookSession`) 監控收件匣的新郵件。它使用一個輔助函數 `GetClientFolderFromDomain` (此處為簡化版，實際中可能查詢Excel表) 來根據發件人郵箱域名確定客戶特定的歸檔文件夾名稱。如果郵件包含附件，並且附件類型在允許的列表中（通過 `allowedExtensions` 字典檢查），則郵件本身（以.msg格式）和符合條件的附件會被保存到一個按客戶/年月/郵件主旨組織的文件夾結構中。`CleanStringForPath` 用於清理文件名和文件夾名中的非法字符。已處理的郵件會被加上類別並可選擇移動。"}
    ],
    "keywords": ["outlook vba archive email attachments to filesystem", "automate email filing", "save outlook attachments by sender domain", "organize client emails to folders", "郵件附件自動歸檔到文件夾", "按發件人域名整理郵件"]
},
{
    "name": "基於郵件內容的情緒分析初判並標記高風險客戶溝通 (Outlook, Excel, Text Analytics API - 概念)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: VBA monitors incoming client emails. For emails that are not standard auto-replies, it extracts the body text and sends it to a Text Analytics service (e.g., Azure Cognitive Services Text Analytics API - requires internet & API key) to get a sentiment score (positive, neutral, negative). If the sentiment is strongly negative, or contains specific怒氣詞彙 (defined in Excel), the email is flagged in Outlook (e.g., with a category 'High-Risk Sentiment'), and a log is made in an Excel 'ClientSentimentLog' sheet, prompting RM follow-up.",
    "description": "此高階應用旨在自動識別客戶郵件中的負面情緒，以便及時介入。1. **Outlook郵件監控**：使用 `ItemAdd` 事件監控新郵件。2. **初步過濾**：排除已知的自動回覆或不相關的郵件。3. **文本提取**：提取郵件正文的純文本內容。4. **情緒分析API調用 (核心)**：  a. VBA構建一個HTTP請求（使用 `MSXML2.XMLHTTP` 或 `WinHttp.WinHttpRequest`）。  b. 將提取的郵件文本作為請求體發送到外部的情緒分析API服務端點（例如，Azure Text Analytics API的 `/sentiment` 端點）。請求中需要包含API密鑰和正確的內容格式（通常是JSON）。  c. 接收API返回的JSON響應，其中包含情緒評分（例如，一個介於0到1之間的分數，越接近0越負面）和/或主要情緒標籤（Positive, Neutral, Negative）。5. **JSON解析與本地關鍵詞檢查**：  a. 解析API返回的JSON以獲取情緒評分/標籤。  b. (可選補充) 在Excel的“NegativeKeywords”表中定義一個本地的負面/抱怨詞彙列表。檢查郵件正文是否包含這些詞彙，作為輔助判斷。6. **標記與記錄**：  a. 如果API返回的情緒為“Negative”且置信度較高，或本地關鍵詞匹配達到一定數量，則：    i. 在Outlook中將該郵件標記一個特定類別，例如“客戶情緒預警”。    ii. 在Excel的“ClientSentimentLog”表中記錄郵件信息（發件人、日期、主旨摘要）、檢測到的情緒、以及觸發的關鍵詞（如果有）。7. **通知RM (可選)**：可以創建一個Outlook任務或發送一封內部郵件給相關的客戶經理，提醒他們關注此高風險情緒郵件。**重要考量**：此方案依賴外部API服務，需要有效的API訂閱和密鑰，並且VBA執行環境需要能夠訪問互聯網。API調用涉及異步處理或等待，以及JSON的解析（需要輔助庫或函數）。本地關鍵詞庫的維護也很重要。保護API密鑰的安全是首要任務。",
    "parameters": [
        {"name": "Outlook Monitored Folder", "description": "監控客戶郵件的資料夾。"},
        {"name": "Text Analytics API Endpoint and Key", "description": "外部情緒分析服務的URL和API訪問密鑰。"},
        {"name": "JSON Parsing Logic/Library", "description": "用於解析API返回的JSON響應。"},
        {"name": "Local Negative Keyword List (Excel/VBA)", "description": "輔助識別負面情緒的本地詞彙表。"},
        {"name": "Excel Client Sentiment Log Sheet", "description": "記錄檢測到的高風險情緒郵件的日誌表。"},
        {"name": "Outlook Flagging/Notification Rules", "description": "如何在Outlook中標記預警郵件以及如何通知RM。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet (Assumes an external API call function exists) ---\n' --- This requires a JSON parser and a function to call the Sentiment API. ---\n'\n' Private Const SENTIMENT_API_ENDPOINT As String = \"YOUR_AZURE_TEXT_ANALYTICS_ENDPOINT/text/analytics/v3.1/sentiment\"\n' Private Const SENTIMENT_API_KEY As String = \"YOUR_AZURE_TEXT_ANALYTICS_KEY\" ' **NEVER HARDCODE KEYS IN PRODUCTION!** Use secure storage.\n'\n' ' In ThisOutlookSession\n' Private Sub MonitoredItems_ItemAdd(ByVal Item As Object)\n'   Dim olMail As Outlook.MailItem\n'   Dim mailText As String, sentimentResultJson As String, sentimentLabel As String, sentimentScore As Double\n'   Dim isHighRisk As Boolean: isHighRisk = False\n'\n'   If TypeOf Item Is MailItem Then\n'     Set olMail = Item\n'     If Not IsAutoReply(olMail) And olMail.Importance <> olImportanceLow Then ' Basic filter\n'       mailText = olMail.Body ' Get plain text for analysis\n'       If Len(mailText) > 10 Then ' Min length for analysis\n'         ' --- Call Sentiment API (Conceptual function) ---\n'         sentimentResultJson = GetSentimentFromApi(mailText, SENTIMENT_API_ENDPOINT, SENTIMENT_API_KEY)\n'         If sentimentResultJson <> \"\" Then\n'           ' --- Parse JSON (Conceptual function - e.g., using VBA-JSON library) ---\n'           ' Dim parsedJson As Object: Set parsedJson = JsonConverter.ParseJson(sentimentResultJson)\n'           ' sentimentLabel = parsedJson(\"documents\")(1)(\"sentiment\") ' Example path in Azure response\n'           ' sentimentScore = parsedJson(\"documents\")(1)(\"confidenceScores\")(sentimentLabel) ' Example path\n'\n'           ' --- Dummy values for demonstration without real API call & parser ---\n'           If InStr(1, LCase(mailText), \"complaint\") > 0 Or InStr(1, LCase(mailText), \"very unhappy\") > 0 Then\n'               sentimentLabel = \"negative\": sentimentScore = 0.95\n'           ElseIf InStr(1, LCase(mailText), \"excellent service\") > 0 Then\n'               sentimentLabel = \"positive\": sentimentScore = 0.98\n'           Else\n'               sentimentLabel = \"neutral\": sentimentScore = 0.7\n'           End If\n'           ' --- End Dummy values ---\n'\n'           Debug.Print \"Mail: '\" & olMail.Subject & \"', Sentiment: \" & sentimentLabel & \" (Score: \" & sentimentScore & \")\"\n'           If LCase(sentimentLabel) = \"negative\" And sentimentScore > 0.75 Then ' Threshold for high risk\n'             isHighRisk = True\n'           End If\n'         End If\n'\n'         ' --- (Optional) Check local negative keywords from Excel ---\n'         ' If Not isHighRisk And ContainsLocalNegativeKeywords(mailText, ThisWorkbook.Sheets(\"NegativeKeywords\")) Then\n'         '   isHighRisk = True: sentimentLabel = sentimentLabel & \" (Local Keywords Triggered)\"\n'         ' End If\n'\n'         If isHighRisk Then\n'           olMail.Categories = \"客戶情緒預警, 待跟進\"\n'           olMail.FlagRequest = \"需立即跟進客戶情緒\"\n'           olMail.FlagDueBy = Now + 1\n'           olMail.Importance = olImportanceHigh\n'           olMail.Save\n'           LogSentimentAlertToExcel olMail, sentimentLabel, sentimentScore\n'           ' Optional: NotifyRMForHighRiskSentiment olMail\n'           Debug.Print \"高風險情緒郵件已標記並記錄: \" & olMail.Subject\n'         End If\n'       End If\n'     End If\n'   End If\n'   Set olMail = Nothing\n' End Sub\n'\n' Function GetSentimentFromApi(textToAnalyze As String, apiEndpoint As String, apiKey As String) As String\n'   ' Placeholder: This function would use MSXML2.XMLHTTP or WinHttp.WinHttpRequest\n'   ' to make a POST request to the sentiment API with 'textToAnalyze' in JSON format\n'   ' and return the JSON response string. Headers would include Ocp-Apim-Subscription-Key.\n'   GetSentimentFromApi = \"\" ' Simulate no response or error for now\n'   ' Example structure of request body for Azure Text Analytics:\n'   ' { \"documents\": [ { \"id\": \"1\", \"language\": \"en\", \"text\": \"Some text to analyze\" } ] }\n'   Debug.Print \"Simulating API call for: \" & Left(textToAnalyze, 50) & \"...\"\n'   ' Return a dummy negative response for testing:\n'   ' GetSentimentFromApi = \"{ \"\"documents\"\": [ { \"\"id\"\": \"\"1\"\", \"\"sentiment\"\": \"\"negative\"\", \"\"confidenceScores\"\": { \"\"positive\"\": 0.01, \"\"neutral\"\": 0.05, \"\"negative\"\": 0.94 } } ], \"\"errors\"\": [] }\"\n' End Function\n'\n' Sub LogSentimentAlertToExcel(mailItem As Outlook.MailItem, sentiment As String, score As Double)\n'   ' Placeholder: Code to write details to 'ClientSentimentLog' Excel sheet\n'   Debug.Print \"記錄到Excel - 發件人: \" & mailItem.SenderEmailAddress & \", 主旨: \" & mailItem.Subject & \", 情緒: \" & sentiment\n' End Sub\n' ' Other helper functions like IsAutoReply, ContainsLocalNegativeKeywords, NotifyRM would be needed.\n", "explanation": "此概念性Outlook VBA代碼 (放置於 `ThisOutlookSession`) 監控新郵件。它首先對郵件進行初步過濾（例如，排除自動回覆和低重要性郵件）。然後，它將郵件正文發送到一個假設的外部情緒分析API（通過 `GetSentimentFromApi` 函數，此處為佔位符，實際實現需要進行HTTP請求和JSON處理）。根據API返回的情緒標籤（例如，\"negative\"）和置信度評分，以及可選的本地負面關鍵詞庫檢查，如果郵件被判定為高風險負面情緒，則會在Outlook中為該郵件加上特定分類、標記跟進請求和高重要性，並調用 `LogSentimentAlertToExcel` 將其記錄到Excel日誌表中。**重要：** 此範例的核心部分——API調用和JSON解析——是概念性的，需要您實現或集成相應的庫。API金鑰管理也至關重要。"}
    ],
    "keywords": ["outlook vba sentiment analysis", "excel client email mood tracking", "text analytics api vba", "automate customer complaint flagging", "客戶郵件情緒分析", "Excel記錄負面反饋", "文本分析API"]
},
// Excel 核心操作
{
    "name": "Range.Font.FontStyle",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Font.FontStyle = \"Bold Italic\" ' Or \"Regular\", \"Italic\", \"Bold\"",
    "description": "設定或傳回儲存格文字的字型樣式 (例如，\"粗體 斜體\")。",
    "parameters": [{"name": "StyleString", "description": "字串，如 \"Bold\", \"Italic\", \"Bold Italic\", \"Regular\"。"}],
    "examples": [
        {"code": "Range(\"A1\").Font.FontStyle = \"Bold Italic\"\nMsgBox \"A1的字型樣式為: \" & Range(\"A1\").Font.FontStyle", "explanation": "將A1儲存格的字型樣式設為粗體斜體。"}
    ],
    "keywords": ["fontstyle", "字型樣式", "excel text format"]
},
{
    "name": "Range.Interior.PatternColorIndex",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Interior.PatternColorIndex = XlColorIndexConstant Or Index",
    "description": "設定或傳回儲存格內部背景圖樣的顏色索引。如果 Pattern 為 xlSolid，則這也類似於設定背景色。",
    "parameters": [{"name": "XlColorIndexConstant Or Index", "description": "顏色索引號或 XlColorIndex 常數 (例如 xlColorIndexAutomatic, xlColorIndexNone, 或1-56)。"}],
    "examples": [
        {"code": "With Range(\"A1\").Interior\n  .Pattern = xlGray16 ' 設定一個非實心圖樣\n  .PatternColorIndex = 5 ' 設定圖樣顏色為藍色 (索引5)\nEnd With\nMsgBox \"A1的背景圖樣顏色已設定。\"", "explanation": "為A1儲存格設定16%灰色背景圖樣，並將圖樣本身的顏色設為藍色。"}
    ],
    "keywords": ["patterncolorindex", "背景圖樣顏色", "excel cell shading"]
},
{
    "name": "Range.Borders(xlDiagonalDown).Weight",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Borders(xlDiagonalDown).Weight = XlBorderWeightConstant",
    "description": "設定從左上到右下對角線框線的粗細。",
    "parameters": [{"name": "XlBorderWeightConstant", "description": "例如 xlHairline, xlThin, xlMedium, xlThick。"}],
    "examples": [
        {"code": "With Range(\"A1\").Borders(xlDiagonalDown)\n  .LineStyle = xlContinuous\n  .Weight = xlThick\n  .Color = vbRed\nEnd With\nMsgBox \"A1已設定粗紅色左上到右下對角線。\"", "explanation": "為A1儲存格設定一條從左上到右下的粗紅色對角線。"}
    ],
    "keywords": ["diagonal border weight", "對角線粗細", "excel cell border"]
},
{
    "name": "Range.Hyperlinks.Item(Index).Address",
    "category": "Excel 核心操作",
    "syntax": "addressString = rangeObject.Hyperlinks.Item(Index).Address",
    "description": "傳回範圍中特定超連結的目標位址 (URL 或檔案路徑)。",
    "parameters": [{"name": "Index", "description": "必需。超連結在儲存格 Hyperlinks 集合中的索引 (1-based)。"}],
    "examples": [
        {"code": "ActiveSheet.Hyperlinks.Add Anchor:=Range(\"A1\"), Address:=\"http://www.example.com\"\nIf Range(\"A1\").Hyperlinks.Count > 0 Then\n  MsgBox \"A1中第一個超連結的位址: \" & Range(\"A1\").Hyperlinks.Item(1).Address\nEnd If", "explanation": "如果在A1儲存格中存在超連結，則顯示其第一個超連結的位址。"}
    ],
    "keywords": ["hyperlink address", "get link url", "超連結位址"]
},
{
    "name": "Range.Comment.Shape (Legacy Comment)",
    "category": "Excel 核心操作",
    "syntax": "Set commentShape = rangeObject.Comment.Shape",
    "description": "傳回代表舊版註解方塊的 Shape 物件。允許修改註解方塊的外觀，如大小、顏色等。",
    "parameters": [],
    "examples": [
        {"code": "Dim cmt As Comment, shpCmt As Shape\n' Range(\"A1\").ClearComments\n' Range(\"A1\").AddComment \"This is a legacy comment.\"\n' Set cmt = Range(\"A1\").Comment\n' If Not cmt Is Nothing Then\n'   Set shpCmt = cmt.Shape\n'   shpCmt.Fill.ForeColor.RGB = RGB(255, 255, 200) ' Light yellow background\n'   shpCmt.TextFrame.Characters.Font.Bold = True\n'   MsgBox \"A1儲存格的舊版註解外觀已修改。\"\n' End If", "explanation": "如果A1儲存格有舊版註解，則獲取其Shape物件並修改其背景色和文字字型。"}
    ],
    "keywords": ["comment shape", "format legacy comment", "註解圖案", "舊版註解格式"]
},
{
    "name": "Range.Validation.Type Property",
    "category": "Excel 核心操作",
    "syntax": "validationTypeConstant = rangeObject.Validation.Type",
    "description": "傳回一個 XlDVType 常數，表示應用於範圍的資料驗證類型。如果範圍中存在多種類型或無驗證，則可能傳回特定值或錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Validation.Add Type:=xlValidateList, Formula1:=\"Yes,No\"\nDim dvType As Long\nOn Error Resume Next ' In case no validation or mixed types\ndvType = Range(\"A1\").Validation.Type\nOn Error GoTo 0\nIf dvType > 0 Then\n  MsgBox \"A1的資料驗證類型是: \" & dvType & \" (例如，xlValidateList = \" & xlValidateList & \")\"\nElse\n  MsgBox \"A1沒有單一的資料驗證類型，或沒有驗證。\"\nEnd If", "explanation": "獲取A1儲存格的資料驗證類型並顯示其常數值。"}
    ],
    "keywords": ["validation type", "get data validation type", "資料驗證類型"]
},
{
    "name": "Worksheet.Phonetics.Count Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "count = worksheetObject.Phonetics.Count",
    "description": "傳回工作表上 Phonetic 物件的數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim ws As Worksheet\nSet ws = ActiveSheet\n' Add some phonetic text for testing\n' ws.Range(\"A1\").Value = \"日本\"\n' ws.Range(\"A1\").Phonetics.Add Start:=1, Length:=2, Text:=\"にほん\"\nMsgBox \"活動工作表上共有 \" & ws.Phonetics.Count & \" 個注音假名物件。\"", "explanation": "顯示活動工作表上注音假名物件的總數。"}
    ],
    "keywords": ["phonetics count", "count furigana", "注音假名計數"]
},
{
    "name": "Range.Cut (Destination)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Cut([Destination As Range])",
    "description": "將指定範圍的內容剪下並貼到剪貼簿或指定的目標位置。",
    "parameters": [{"name": "Destination", "description": "可選。Range 物件，指定剪下內容要貼上的新位置。如果省略，則剪下到剪貼簿。"}],
    "examples": [
        {"code": "Range(\"A1:A5\").Cut Destination:=Range(\"C1\")\nMsgBox \"A1:A5的內容已剪下並貼到C1開始的區域。\"", "explanation": "將範圍A1:A5的內容剪下並貼到以C1為左上角的儲存格。"}
    ],
    "keywords": ["剪下貼上", "移動儲存格", "excel cut paste", "move cells"]
},
{
    "name": "Range.AutoFill",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AutoFill(Destination As Range, [Type As XlAutoFillType = xlFillDefault])",
    "description": "對指定範圍內的儲存格執行自動填充。rangeObject 必須是 Destination 範圍的第一列或第一列。",
    "parameters": [
        {"name": "Destination", "description": "必需。要填充的 Range 物件。必須包含來源範圍。"},
        {"name": "Type", "description": "可選。XlAutoFillType 常數，指定填充類型。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 1\nRange(\"A2\").Value = 2\nRange(\"A1:A2\").AutoFill Destination:=Range(\"A1:A10\"), Type:=xlFillSeries\nMsgBox \"A1:A10已使用A1:A2的序列自動填充。\"", "explanation": "使用A1和A2中的值 (1, 2) 作為序列，自動填充A3到A10 (結果為3, 4, ..., 10)。"}
    ],
    "keywords": ["自動填充", "excel autofill", "fill series"]
},
{
    "name": "Range.Ungroup (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Ungroup",
    "description": "取消指定範圍中列或欄的分組 (大綱)。",
    "parameters": [],
    "examples": [
        {"code": "' Rows(\"3:6\").Group ' First group some rows\n' Rows(\"3:6\").Ungroup ' Then ungroup them\n' MsgBox \"先前分組的第3到6列已取消分組。\"", "explanation": "如果第3到6列之前被分組，則此程式碼將取消該分組。"}
    ],
    "keywords": ["ungroup rows", "ungroup columns", "remove outline excel", "取消分組"]
},
{
    "name": "Range.GoalSeek",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.GoalSeek(Goal, ChangingCell As Range) As Boolean",
    "description": "調整一個儲存格的值，直到包含特定公式的儲存格 (rangeObject) 達到指定的目標值 (Goal)。傳回 True 如果找到解。",
    "parameters": [
        {"name": "Goal", "description": "必需。希望 rangeObject 達到的值。"},
        {"name": "ChangingCell", "description": "必需。Range 物件，指定要更改以達到目標的儲存格。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 10 ' Input value\nRange(\"A2\").Value = 5  ' Input value\nRange(\"A3\").Formula = \"=A1*A2\" ' Formula cell (want this to be 100)\n' We want A3 to be 100 by changing A1\nIf Range(\"A3\").GoalSeek(Goal:=100, ChangingCell:=Range(\"A1\")) Then\n  MsgBox \"找到解: A1應為 \" & Range(\"A1\").Value & \" 以使A3等於100。\"\nElse\n  MsgBox \"目標搜尋未找到解。\"\nEnd If", "explanation": "在A3包含公式=A1*A2的情況下，通過調整A1的值，使A3的結果達到100。"}
    ],
    "keywords": ["目標搜尋", "what-if analysis", "excel goalseek", "單變數求解"]
},
{
    "name": "Worksheet.Select (ReplaceSelection Parameter)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Select([Replace As Boolean = True])",
    "description": "選取指定的工作表。Replace 引數決定此選取是否取代先前的選取。",
    "parameters": [
        {"name": "Replace", "description": "可選。True (預設) 表示新選取取代先前選取。False 表示將此工作表添加到現有選取的工作表集合中 (用於多選工作表)。"}
    ],
    "examples": [
        {"code": "Sheets(\"Sheet1\").Select ' Selects Sheet1 only\n' Select Sheet1 and Sheet3 together (if Sheet1 is already active and you want to add Sheet3)\n' Application.ScreenUpdating = False ' Recommended when selecting multiple sheets programmatically\n' Sheets(\"Sheet3\").Select Replace:=False\n' MsgBox ActiveWindow.SelectedSheets.Count & \" 個工作表已被選取。\"\n' Application.ScreenUpdating = True\n' Sheets(1).Select ' Reselect a single sheet to clear multi-select mode for user", "explanation": "演示如何選取單個工作表，以及如何使用 Replace:=False (概念性，通常結合Ctrl鍵在UI中操作) 來選取多個工作表。"}
    ],
    "keywords": ["選取多個工作表", "excel select multiple sheets", "worksheet select replace"]
},
{
    "name": "Worksheet.Protection.AllowFormattingCells Property",
    "category": "Excel 核心操作",
    "syntax": "isAllowed = worksheetObject.Protection.AllowFormattingCells",
    "description": "如果受保護的工作表允許格式化儲存格，則傳回 True。此屬性在呼叫 Worksheet.Protect 方法時設定。唯讀 (在工作表受保護後)。",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Protect AllowFormattingCells:=True ' Protect sheet but allow cell formatting\nIf ActiveSheet.Protection.AllowFormattingCells Then\n  MsgBox \"此受保護的工作表允許使用者格式化儲存格。\"\nElse\n  MsgBox \"此受保護的工作表不允許格式化儲存格。\"\nEnd If\nActiveSheet.Unprotect", "explanation": "保護工作表同時允許使用者格式化儲存格，然後檢查此保護屬性。"}
    ],
    "keywords": ["worksheet protection allow formatting", "protected sheet format cells", "保護工作表允許格式化"]
},
{
    "name": "Worksheet.ScrollArea Property",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.ScrollArea [= rangeAddressString]",
    "description": "設定或傳回允許捲動的範圍 (A1樣式參照)。超出此範圍的區域將無法被選取。設為空字串 \"\" 以移除捲動區域限制。",
    "parameters": [{"name": "rangeAddressString", "description": "字串，例如 \"A1:G20\"。"}],
    "examples": [
        {"code": "ActiveSheet.ScrollArea = \"A1:H30\"\nMsgBox \"活動工作表的捲動區域已限制為 A1:H30。\"\n' To remove restriction: ActiveSheet.ScrollArea = \"\"", "explanation": "將活動工作表的捲動區域限制在 A1:H30 範圍內。"}
    ],
    "keywords": ["捲動區域限制", "excel scrollarea", "limit scrolling range"]
},
{
    "name": "Worksheet.CustomProperties.Add",
    "category": "Excel 核心操作",
    "syntax": "Set cp = worksheetObject.CustomProperties.Add(Name As String, Value As Variant)",
    "description": "將自訂屬性新增到工作表的 CustomProperties 集合中。",
    "parameters": [
        {"name": "Name", "description": "必需。自訂屬性的名稱。"},
        {"name": "Value", "description": "必需。自訂屬性的值。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet, newProp As CustomProperty\nSet ws = ActiveSheet\nOn Error Resume Next ' In case property already exists\nSet newProp = ws.CustomProperties.Add(Name:=\"Version\", Value:=\"1.2.3\")\nIf Err.Number <> 0 Then ' Property might exist, try accessing\n    Err.Clear\n    ws.CustomProperties(\"Version\").Value = \"1.2.4\" ' Update if exists\nEnd If\nOn Error GoTo 0\nMsgBox \"工作表自訂屬性 'Version' 的值是: \" & ws.CustomProperties(\"Version\").Value", "explanation": "為活動工作表新增一個名為 \"Version\" 的自訂屬性並設定其值。如果已存在則更新它。"}
    ],
    "keywords": ["worksheet custom properties", "add custom property sheet", "工作表自訂屬性"]
},
{
    "name": "Workbook.HasPassword Property",
    "category": "Excel 核心操作",
    "syntax": "isPasswordProtected = workbookObject.HasPassword",
    "description": "如果活頁簿設定了開啟密碼，則傳回 True。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "If ThisWorkbook.HasPassword Then\n  MsgBox \"此活頁簿受開啟密碼保護。\"\nElse\n  MsgBox \"此活頁簿沒有設定開啟密碼。\"\nEnd If", "explanation": "檢查目前活頁簿是否設定了開啟密碼。"}
    ],
    "keywords": ["workbook haspassword", "check password protection", "活頁簿是否有密碼"]
},
{
    "name": "Workbook.Password Property (Set/Get)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.Password = passwordString ' Set password for opening\npasswordString = workbookObject.Password ' Get password (only works if you know it)",
    "description": "設定或傳回開啟活頁簿所需的密碼。設定密碼會在下次儲存時生效。獲取密碼通常不直接使用，因為您需要先能開啟檔案。",
    "parameters": [{"name": "passwordString", "description": "密碼字串。"}],
    "examples": [
        {"code": "' CAUTION: Setting password programmatically\n' ThisWorkbook.Password = \"MySecret123\" ' Sets password for next save\n' ThisWorkbook.Save ' Now it's password protected\n' MsgBox \"活頁簿已設定開啟密碼。下次開啟需要輸入。\"\n' ThisWorkbook.Password = \"\" ' Remove password (for next save)\n' ThisWorkbook.Save ' Save again to remove password protection", "explanation": "演示如何為活頁簿設定和移除開啟密碼。設定或移除密碼後需要儲存活頁簿才會生效。"}
    ],
    "keywords": ["workbook password", "set open password", "remove workbook password", "活頁簿密碼"]
},
{
    "name": "Workbook.WritePassword Property",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.WritePassword = passwordString",
    "description": "設定或傳回儲存活頁簿變更所需的寫入權限密碼 (寫入預留密碼)。",
    "parameters": [{"name": "passwordString", "description": "寫入權限密碼字串。設為空字串 \"\" 可移除。"}],
    "examples": [
        {"code": "ThisWorkbook.WritePassword = \"WritePass456\"\nThisWorkbook.Save\nMsgBox \"活頁簿已設定寫入預留密碼。修改並儲存時需要此密碼，否則只能唯讀開啟。\"\n' ThisWorkbook.WritePassword = \"\" ' To remove\n' ThisWorkbook.Save", "explanation": "為目前活頁簿設定寫入預留密碼。"}
    ],
    "keywords": ["workbook writepassword", "write reservation password", "寫入預留密碼"]
},
{
    "name": "Workbook.CreateForecastSheet (Excel 2016+)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.CreateForecastSheet(Timeline As Range, Values As Range, [ForecastStart], [ForecastEnd], [ConfInt As Double = 0.95], [Seasonality As Variant = 1], ...)",
    "description": "基於現有的時間序列資料建立一個新的預測工作表。",
    "parameters": [
        {"name": "Timeline", "description": "必需。包含日期或時間戳的 Range。"},
        {"name": "Values", "description": "必需。包含對應數值的 Range。"},
        {"name": "ForecastEnd", "description": "可選。預測結束的日期。"}
    ],
    "examples": [
        {"code": "' Assume Sheet1 A1:A10 contains dates (Timeline) and B1:B10 contains values\n' On Error Resume Next ' Requires Excel 2016 or later\n' ThisWorkbook.CreateForecastSheet Timeline:=Sheets(\"Sheet1\").Range(\"A1:A10\"), _\n'                                  Values:=Sheets(\"Sheet1\").Range(\"B1:B10\"), _\n'                                  ForecastEnd:=DateSerial(Year(Now) + 1, Month(Now), Day(Now))\n' If Err.Number = 0 Then\n'   MsgBox \"已基於 Sheet1!A1:B10 的資料建立預測工作表。\"\n' Else\n'   MsgBox \"無法建立預測工作表。錯誤: \" & Err.Description & \" (可能需要Excel 2016+)\"\n' End If\n' On Error GoTo 0", "explanation": "根據 Sheet1 中 A1:A10 的時間軸資料和 B1:B10 的數值資料，建立一個預測到明年今天的預測工作表。"}
    ],
    "keywords": ["create forecast sheet", "excel forecasting", "time series forecast", "建立預測工作表"]
},
{
    "name": "Application.Undo",
    "category": "Excel 核心操作",
    "syntax": "Application.Undo",
    "description": "撤銷使用者介面中執行的上一個動作。如果上一個動作無法撤銷，或者撤銷堆疊為空，則此方法無效。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Original Text\"\nRange(\"A1\").Value = \"New Text\" ' User action or VBA action\n' If the last action was undoable from UI:\nOn Error Resume Next ' Undo might fail if stack is empty or action not undoable\nApplication.Undo\nIf Err.Number = 0 Then\n  MsgBox \"上一個動作 (將A1設為 'New Text') 已被撤銷。A1現在是: '\" & Range(\"A1\").Value & \"'\"\nElse\n  MsgBox \"無法執行撤銷。\"\nEnd If\nOn Error GoTo 0", "explanation": "將A1設為 \"New Text\" 後，嘗試使用 Application.Undo 撤銷此操作。"}
    ],
    "keywords": ["撤銷", "excel undo", "undo last action"]
},
{
    "name": "Application.Build Property",
    "category": "Excel 核心操作",
    "syntax": "buildNumberString = Application.Build",
    "description": "傳回 Microsoft Excel 的組建編號 (字串)。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"Excel 組建編號: \" & Application.Build", "explanation": "顯示目前執行的 Excel 實例的組建編號。"}
    ],
    "keywords": ["excel build number", "application build", "Excel版本組建"]
},
{
    "name": "Application.CalculationInterruptKey Property",
    "category": "Excel 核心操作",
    "syntax": "Application.CalculationInterruptKey = XlCalculationInterruptKeyConstant",
    "description": "設定用於在計算期間中斷 Microsoft Excel 的按鍵。預設為 xlNoKey (沒有中斷鍵)。可以設為 xlEscKey 以允許 Esc 鍵中斷。",
    "parameters": [{"name": "XlCalculationInterruptKeyConstant", "description": "xlNoKey 或 xlEscKey。"}],
    "examples": [
        {"code": "Application.CalculationInterruptKey = xlEscKey\nMsgBox \"已設定 Esc 鍵可以中斷 Excel 計算。\"\n' Application.CalculationInterruptKey = xlNoKey ' Restore default", "explanation": "設定 Esc 鍵作為計算的中斷鍵。"}
    ],
    "keywords": ["calculation interrupt key", "stop calculation excel", "計算中斷鍵"]
},
{
    "name": "Application.CalculationState Property",
    "category": "Excel 核心操作",
    "syntax": "stateConstant = Application.CalculationState",
    "description": "傳回一個 XlCalculationState 常數，指出應用程式的計算狀態 (xlDone, xlCalculating, xlPending)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim calcState As Long\ncalcState = Application.CalculationState\nSelect Case calcState\n  Case 0: Debug.Print \"計算狀態: xlDone\"\n  Case 1: Debug.Print \"計算狀態: xlCalculating\"\n  Case 2: Debug.Print \"計算狀態: xlPending\"\nEnd Select\n' If calcState = xlCalculating Then MsgBox \"Excel目前正在計算中...\"", "explanation": "獲取並顯示 Excel 目前的計算狀態。"}
    ],
    "keywords": ["calculation state", "excel calculating status", "計算狀態"]
},
{
    "name": "Application.CentimetersToPoints",
    "category": "Excel 核心操作",
    "syntax": "pointValue = Application.CentimetersToPoints(Centimeters As Double)",
    "description": "將度量單位從公分轉換為點 (1 英吋 = 72 點；1 英吋 = 2.54 公分)。",
    "parameters": [{"name": "Centimeters", "description": "必需。要轉換的公分數值。"}],
    "examples": [
        {"code": "Dim widthInPoints As Double\nwidthInPoints = Application.CentimetersToPoints(5) ' Convert 5 cm to points\nMsgBox \"5 公分約等於 \" & Format(widthInPoints, \"0.00\") & \" 點。\"\n' ActiveSheet.PageSetup.LeftMargin = Application.CentimetersToPoints(2.5)", "explanation": "將5公分轉換為點數，並示範如何用於設定頁面邊距。"}
    ],
    "keywords": ["centimeters to points", "unit conversion cm", "公分轉點"]
},
{
    "name": "Application.ConvertFormula",
    "category": "Excel 核心操作",
    "syntax": "convertedFormulaString = Application.ConvertFormula(Formula As String, FromReferenceStyle As XlReferenceStyle, [ToReferenceStyle], [ToAbsolute As XlReferenceType], [RelativeTo As Range])",
    "description": "轉換儲存格參照在公式中的樣式 (例如，從 A1 到 R1C1) 和類型 (絕對/相對)。",
    "parameters": [
        {"name": "Formula", "description": "必需。要轉換的公式字串。"},
        {"name": "FromReferenceStyle", "description": "必需。XlReferenceStyle 常數，指定公式的原始參照樣式。"},
        {"name": "ToReferenceStyle", "description": "可選。XlReferenceStyle 常數，指定目標參照樣式。"},
        {"name": "ToAbsolute", "description": "可選。XlReferenceType 常數，指定轉換後的參照類型。"}
    ],
    "examples": [
        {"code": "Dim formulaA1 As String, formulaR1C1 As String\nformulaA1 = \"=SUM(B1:B10)\"\nformulaR1C1 = Application.ConvertFormula(Formula:=formulaA1, FromReferenceStyle:=xlA1, ToReferenceStyle:=xlR1C1)\nMsgBox \"A1樣式 '\" & formulaA1 & \"' 轉換為R1C1樣式是: '\" & formulaR1C1 & \"'\"", "explanation": "將 A1 樣式的公式 \"=SUM(B1:B10)\" 轉換為 R1C1 樣式。"}
    ],
    "keywords": ["convertformula", "formula reference style", "a1 to r1c1", "公式參照轉換"]
},
{
    "name": "Application.DefaultSheetDirection Property",
    "category": "Excel 核心操作",
    "syntax": "Application.DefaultSheetDirection = xlContext | xlLTR | xlRTL",
    "description": "設定或傳回新工作表的預設顯示方向 (從左到右 xlLTR，或從右到左 xlRTL)。xlContext 表示基於語言設定。",
    "parameters": [{"name": "DirectionConstant", "description": "xlContext, xlLTR, xlRTL。"}],
    "examples": [
        {"code": "MsgBox \"目前新工作表的預設方向常數是: \" & Application.DefaultSheetDirection\n' Application.DefaultSheetDirection = xlRTL ' Set new sheets to be Right-to-Left\n' Dim newWs As Worksheet: Set newWs = Worksheets.Add\n' MsgBox \"新建立的工作表方向是否為從右到左: \" & (newWs.DisplayRightToLeft = True)", "explanation": "顯示目前Excel應用程式為新工作表設定的預設方向。"}
    ],
    "keywords": ["default sheet direction", "rtl sheet excel", "新工作表方向"]
},
{
    "name": "Application.EnableAutoComplete Property",
    "category": "Excel 核心操作",
    "syntax": "Application.EnableAutoComplete [= Boolean]",
    "description": "如果啟用儲存格值的自動完成功能，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "Boolean", "description": "True 啟用，False 禁用。"}],
    "examples": [
        {"code": "If Application.EnableAutoComplete Then\n  MsgBox \"儲存格自動完成功能已啟用。\"\n  ' Application.EnableAutoComplete = False ' To disable\nEnd If", "explanation": "檢查並可切換Excel的儲存格自動完成功能。"}
    ],
    "keywords": ["enableautocomplete", "excel autocomplete cell", "儲存格自動完成"]
},
{
    "name": "Application.Iteration Property (Circular References)",
    "category": "Excel 核心操作",
    "syntax": "Application.Iteration = True | False",
    "description": "如果 Excel 將使用迭代來解析循環參照，則為 True。讀取/寫入布林值。",
    "parameters": [
        {"name": ".MaxChange", "description": "屬性：設定或傳回兩次迭代結果之間允許的最大變更量。"},
        {"name": ".MaxIterations", "description": "屬性：設定或傳回 Excel 在解析循環參照時可以進行的最大迭代次數。"}
    ],
    "examples": [
        {"code": "Application.Iteration = True\nApplication.MaxIterations = 1000\nApplication.MaxChange = 0.0001\nMsgBox \"已啟用迭代計算，最大迭代次數: \" & Application.MaxIterations & \", 最大變更: \" & Application.MaxChange\n' Range(\"A1\").Formula = \"=A1+1\" ' This would now iterate if Iteration is True", "explanation": "啟用迭代計算以處理循環參照，並設定最大迭代次數和最大變更量。"}
    ],
    "keywords": ["iteration calculation", "circular reference excel", "maxiterations", "maxchange", "迭代計算", "循環參照處理"]
},
{
    "name": "Application.MoveAfterReturn Property / .MoveAfterReturnDirection",
    "category": "Excel 核心操作",
    "syntax": "Application.MoveAfterReturn = True | False\nApplication.MoveAfterReturnDirection = XlDirectionConstant",
    "description": "MoveAfterReturn 控制按下 Enter 鍵後活動儲存格是否移動。MoveAfterReturnDirection 設定移動的方向。",
    "parameters": [
        {"name": "MoveAfterReturn (Boolean)", "description": "True (預設) 表示移動。"},
        {"name": "MoveAfterReturnDirection (XlDirectionConstant)", "description": "xlDown (預設), xlToRight, xlToLeft, xlUp。"}
    ],
    "examples": [
        {"code": "Application.MoveAfterReturn = True\nApplication.MoveAfterReturnDirection = xlToRight\nMsgBox \"按下Enter鍵後，活動儲存格將向右移動。\"\n' Restore defaults:\n' Application.MoveAfterReturnDirection = xlDown", "explanation": "設定Excel在用戶按下Enter鍵後將活動儲存格游標向右移動。"}
    ],
    "keywords": ["move after enter", "excel enter key behavior", "Enter鍵後移動"]
},
{
    "name": "Application.Path Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "appPathString = Application.Path",
    "description": "傳回包含 Excel.exe 執行檔的完整路徑 (字串)，不包括最後的反斜線。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"Excel應用程式的路徑是: \" & Application.Path", "explanation": "顯示Excel應用程式的安裝路徑。"}
    ],
    "keywords": ["application path excel", "excel installation path", "Excel程式路徑"]
},
{
    "name": "Application.SheetsInNewWorkbook Property",
    "category": "Excel 核心操作",
    "syntax": "Application.SheetsInNewWorkbook [= Long]",
    "description": "設定或傳回 Microsoft Excel 在建立新活頁簿時自動插入的工作表數量。",
    "parameters": [{"name": "Long", "description": "1 到 255 之間的整數。"}],
    "examples": [
        {"code": "Dim originalSheetCount As Long\noriginalSheetCount = Application.SheetsInNewWorkbook\nApplication.SheetsInNewWorkbook = 1 ' Set new workbooks to have only 1 sheet by default\nMsgBox \"新活頁簿的預設工作表數量已設為 1。\"\n' Workbooks.Add ' New workbook will have 1 sheet\nApplication.SheetsInNewWorkbook = originalSheetCount ' Restore original setting", "explanation": "設定當建立新活頁簿時，預設只包含一個工作表。"}
    ],
    "keywords": ["sheets in new workbook", "default number of sheets", "新活頁簿工作表數量"]
},
{
    "name": "Application.StandardFont / .StandardFontSize Properties",
    "category": "Excel 核心操作",
    "syntax": "Application.StandardFont = fontNameString\nApplication.StandardFontSize = pointSizeLong",
    "description": "設定或傳回 Excel 的標準 (預設) 字型名稱和大小。這些設定會影響新工作表和新活頁簿的預設字型。",
    "parameters": [
        {"name": "fontNameString", "description": "字型名稱。"},
        {"name": "pointSizeLong", "description": "字型大小 (點)。"}
    ],
    "examples": [
        {"code": "MsgBox \"目前標準字型: \" & Application.StandardFont & \", 大小: \" & Application.StandardFontSize\n' Application.StandardFont = \"Verdana\"\n' Application.StandardFontSize = 10\n' MsgBox \"標準字型已更改 (下次啟動Excel或新建工作簿時生效)。\"", "explanation": "顯示Excel的目前標準字型和大小。修改這些屬性通常需要重新啟動Excel或創建新工作簿才能看到對新內容的影響。"}
    ],
    "keywords": ["standard font excel", "default font size", "標準字型", "預設字型大小"]
},
{
    "name": "Application.StartupPath Property",
    "category": "Excel 核心操作",
    "syntax": "startupFolderPathString = Application.StartupPath",
    "description": "傳回 Excel 啟動資料夾的完整路徑。Excel 啟動時會自動開啟此資料夾中的任何檔案。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"Excel的啟動資料夾路徑是: \" & Application.StartupPath", "explanation": "顯示 Excel 的主啟動資料夾路徑。"}
    ],
    "keywords": ["excel startuppath", "startup folder", "Excel啟動路徑"]
},
{
    "name": "Application.AltStartupPath Property",
    "category": "Excel 核心操作",
    "syntax": "altStartupFolderPathString = Application.AltStartupPath",
    "description": "傳回或設定備用啟動資料夾的名稱。如果設定了此路徑，Excel 啟動時也會自動開啟此資料夾中的檔案。",
    "parameters": [],
    "examples": [
        {"code": "If Application.AltStartupPath <> \"\" Then\n  MsgBox \"Excel的備用啟動資料夾是: \" & Application.AltStartupPath\nElse\n  MsgBox \"未設定備用啟動資料夾。\"\nEnd If\n' Application.AltStartupPath = \"C:\\MyExcelAddins\\Startup\" ' Example to set it", "explanation": "檢查並顯示Excel的備用啟動資料夾路徑。"}
    ],
    "keywords": ["excel altstartuppath", "alternate startup folder", "備用啟動路徑"]
},
{
    "name": "Application.Version Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "versionString = Application.Version",
    "description": "傳回 Microsoft Excel 的版本號 (字串，例如 \"16.0\" 對應 Excel 2016/2019/365)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"您正在使用的 Excel 版本是: \" & Application.Version", "explanation": "顯示目前執行的 Excel 應用程式的版本號。"}
    ],
    "keywords": ["excel version", "application version", "Excel版本號"]
},
{
    "name": "Window.Caption Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowCaptionString = windowObject.Caption\nwindowObject.Caption = newCaptionString",
    "description": "設定或傳回顯示在視窗標題列中的文字。對於活頁簿視窗，預設是活頁簿的檔案名稱。",
    "parameters": [{"name": "newCaptionString", "description": "視窗的新標題。"}],
    "examples": [
        {"code": "Dim mainExcelWindow As Window\nSet mainExcelWindow = Application.Windows(1) ' Get the first main Excel window (usually the app window)\nMsgBox \"目前視窗的標題是: \" & mainExcelWindow.Caption\nDim originalCaption As String: originalCaption = mainExcelWindow.Caption\n' mainExcelWindow.Caption = \"My Custom Excel Title\"\n' Application.Wait Now + TimeValue(\"00:00:02\")\n' mainExcelWindow.Caption = originalCaption ' Restore", "explanation": "獲取目前Excel主視窗的標題，並示範如何修改它 (修改應用程式視窗標題通常作用不大，更多用於活頁簿視窗)。"}
    ],
    "keywords": ["window caption excel", "set window title", "視窗標題"]
},
{
    "name": "Window.DisplayFormulas Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.DisplayFormulas = True | False",
    "description": "如果視窗顯示公式，則為 True；如果顯示值，則為 False。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示公式。"}],
    "examples": [
        {"code": "ActiveWindow.DisplayFormulas = True\nMsgBox \"目前視窗現在顯示公式 (等同於按 Ctrl+`)。\"\nActiveWindow.DisplayFormulas = False ' Restore to show values", "explanation": "將活動視窗設定為顯示公式而不是儲存格的值。"}
    ],
    "keywords": ["display formulas excel", "show formulas", "toggle formula view", "顯示公式"]
},
{
    "name": "Window.DisplayZeros Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.DisplayZeros = True | False",
    "description": "如果視窗顯示值為零的儲存格，則為 True。讀取/寫入布林值。這是視窗級別的設定，影響該視窗中所有工作表。",
    "parameters": [{"name": "True | False", "description": "True (預設) 表示顯示零值。"}],
    "examples": [
        {"code": "ActiveWindow.DisplayZeros = False\nMsgBox \"目前視窗現在將不顯示值為零的儲存格 (除非它們是公式結果)。\"\n' ActiveWindow.DisplayZeros = True ' Restore to show zeros", "explanation": "設定活動視窗不顯示值為零的儲存格。"}
    ],
    "keywords": ["display zeros excel", "hide zero values", "顯示零值"]
},
{
    "name": "Window.FreezePanes Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.FreezePanes = True | False",
    "description": "如果分割窗格被凍結，則為 True。讀取/寫入布林值。要凍結窗格，需先選取要凍結位置右下方的一個儲存格，然後將此屬性設為 True。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"C3\").Select ' Select cell below and to the right of desired freeze point\nActiveWindow.FreezePanes = True\nMsgBox \"已在C3左上方凍結窗格。\"\n' ActiveWindow.FreezePanes = False ' To unfreeze", "explanation": "選取C3儲存格，然後凍結其上方和左側的窗格。"}
    ],
    "keywords": ["freeze panes", "excel freeze rows columns", "凍結窗格"]
},
{
    "name": "Window.GridlineColor Property / .GridlineColorIndex (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.GridlineColor = RGBColor\nwindowObject.GridlineColorIndex = XlColorIndexConstantOrInteger",
    "description": "設定或傳回格線的顏色。GridlineColor 使用 RGB 值，GridlineColorIndex 使用顏色索引。",
    "parameters": [
        {"name": "RGBColor", "description": "RGB 長整數值。"},
        {"name": "XlColorIndexConstantOrInteger", "description": "顏色索引號 (1-56) 或 xlColorIndexAutomatic。"}
    ],
    "examples": [
        {"code": "ActiveWindow.GridlineColor = RGB(0, 128, 0) ' Dark Green gridlines\nMsgBox \"活動視窗的格線顏色已變更為深綠色。\"\n' ActiveWindow.GridlineColorIndex = xlColorIndexAutomatic ' Restore default", "explanation": "將活動視窗的格線顏色設定為深綠色。"}
    ],
    "keywords": ["gridline color", "excel grid color", "格線顏色"]
},
{
    "name": "Window.NewWindow Method (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set newWin = windowObject.NewWindow()",
    "description": "為指定的視窗 (通常是活頁簿視窗) 建立一個新的視窗。傳回代表新視窗的 Window 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim originalWindow As Window, newCopyWindow As Window\nSet originalWindow = ActiveWindow\nSet newCopyWindow = originalWindow.NewWindow\nMsgBox \"已為 '\" & originalWindow.Caption & \"' 建立一個新視窗: '\" & newCopyWindow.Caption & \"'\"", "explanation": "為目前活動的活頁簿視窗建立一個新的檢視視窗。"}
    ],
    "keywords": ["new window excel", "duplicate window view", "建立新視窗"]
},
{
    "name": "Window.Panes(Index).ScrollRow / .ScrollColumn (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.Panes(Index).ScrollRow = rowNumber\nwindowObject.Panes(Index).ScrollColumn = columnNumber",
    "description": "在分割窗格中，設定或傳回指定窗格左上角可見的列號或欄號。",
    "parameters": [
        {"name": "Index", "description": "窗格的索引號 (1-4)。"},
        {"name": "rowNumber / columnNumber", "description": "要捲動到的列號或欄號。"}
    ],
    "examples": [
        {"code": "' ActiveWindow.SplitColumn = 200 ' Split window for example\n' If ActiveWindow.Panes.Count > 1 Then\n'   ActiveWindow.Panes(2).ScrollColumn = 5 ' Scroll the second pane (right or bottom) to show column E at its left\n'   MsgBox \"第二個窗格已捲動以顯示第5欄為起始。\"\n' Else\n'   MsgBox \"視窗未分割或只有一個窗格。\"\n' End If\n' ' ActiveWindow.Split = False ' Remove split", "explanation": "如果視窗已分割 (例如，在約200點位置分割欄)，則將第二個窗格捲動使其最左側顯示第5欄。"}
    ],
    "keywords": ["scroll pane excel", "window pane scroll", "分割窗格捲動"]
},
{
    "name": "Window.Split Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.Split = True | False",
    "description": "如果視窗被分割，則為 True。讀取/寫入布林值。設定為 False 以移除所有分割。",
    "parameters": [],
    "examples": [
        {"code": "' ActiveWindow.SplitColumn = 200 ' Create a vertical split\n' If ActiveWindow.Split Then\n'   MsgBox \"視窗目前是分割的。現在移除分割。\"\n'   ActiveWindow.Split = False\n' Else\n'   MsgBox \"視窗未分割。\"\n' End If", "explanation": "如果視窗已分割，則移除分割。"}
    ],
    "keywords": ["split window excel", "remove split panes", "分割視窗", "移除分割"]
},
{
    "name": "Window.View Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.View = XlWindowViewConstant",
    "description": "設定或傳回視窗的檢視模式。",
    "parameters": [
        {"name": "XlWindowViewConstant", "description": "xlNormalView, xlPageBreakPreview, xlPageLayoutView。"}
    ],
    "examples": [
        {"code": "ActiveWindow.View = xlPageBreakPreview\nMsgBox \"活動視窗已切換到分頁預覽模式。\"\nApplication.Wait Now + TimeValue(\"00:00:02\")\nActiveWindow.View = xlNormalView\nMsgBox \"活動視窗已還原到標準模式。\"", "explanation": "將活動視窗切換到分頁預覽模式，等待2秒，然後再切換回標準檢視模式。"}
    ],
    "keywords": ["excel window view", "page break preview", "page layout view", "視窗檢視模式"]
},

{
    "name": "Range.Show (Outline)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Show",
    "description": "如果範圍是可展開或摺疊大綱的一部分，則展開該大綱以顯示詳細資料。",
    "parameters": [],
    "examples": [
        {"code": "' Assuming Rows 2-5 are grouped and collapsed under Row 1\n' Rows(1).Show ' Expands the group under row 1\n' Columns(\"A\").Show ' If column A is part of a collapsed group, expands it", "explanation": "展開包含在指定範圍內已摺疊的任何大綱級別。"}
    ],
    "keywords": ["展開大綱顯示", "show outline excel", "expand group"]
},
{
    "name": "Range.ColumnDifferences",
    "category": "Excel 核心操作",
    "syntax": "Set diffCells = rangeObject.ColumnDifferences(Comparison As Range)",
    "description": "傳回一個 Range 物件，代表指定範圍中所有其內容與比較儲存格 (Comparison) 不同的儲存格。比較是逐欄進行的。",
    "parameters": [
        {"name": "Comparison", "description": "必需。Range 物件，指定每欄中要與之比較的儲存格。通常是該欄的第一個儲存格。"}
    ],
    "examples": [
        {"code": "Dim myRange As Range, diffs As Range\nSet myRange = Range(\"A1:A10\") ' Column to check\n' Compare each cell in A2:A10 with A1\nOn Error Resume Next ' If all cells are same, diffs will be Nothing\nSet diffs = myRange.ColumnDifferences(Comparison:=myRange.Cells(1, 1))\nOn Error GoTo 0\nIf Not diffs Is Nothing Then\n  MsgBox \"A欄中與A1不同的儲存格有: \" & diffs.Address\n  diffs.Font.Color = vbRed\nElse\n  MsgBox \"A欄中所有儲存格 (A2:A10) 都與A1相同，或範圍只有一行。\"\nEnd If", "explanation": "找出A欄 (A2:A10) 中與A1儲存格內容不同的所有儲存格，並將其字型設為紅色。"}
    ],
    "keywords": ["欄差異", "比較儲存格", "不同儲存格", "excel", "column differences", "compare cells"]
},
{
    "name": "Range.RowDifferences",
    "category": "Excel 核心操作",
    "syntax": "Set diffCells = rangeObject.RowDifferences(Comparison As Range)",
    "description": "傳回一個 Range 物件，代表指定範圍中所有其內容與比較儲存格 (Comparison) 不同的儲存格。比較是逐列進行的。",
    "parameters": [
        {"name": "Comparison", "description": "必需。Range 物件，指定每列中要與之比較的儲存格。通常是該列的第一個儲存格。"}
    ],
    "examples": [
        {"code": "Dim myRange As Range, diffs As Range\nSet myRange = Range(\"A1:E1\") ' Row to check\n' Compare each cell in B1:E1 with A1\nOn Error Resume Next\nSet diffs = myRange.RowDifferences(Comparison:=myRange.Cells(1, 1))\nOn Error GoTo 0\nIf Not diffs Is Nothing Then\n  MsgBox \"第1列中與A1不同的儲存格有: \" & diffs.Address\n  diffs.Interior.Color = vbYellow\nElse\n  MsgBox \"第1列中所有儲存格 (B1:E1) 都與A1相同，或範圍只有一欄。\"\nEnd If", "explanation": "找出第1列 (B1:E1) 中與A1儲存格內容不同的所有儲存格，並將其背景設為黃色。"}
    ],
    "keywords": ["列差異", "比較儲存格", "excel", "row differences", "compare cells"]
},
{
    "name": "Range.Replace (Detailed)",
    "category": "Excel 核心操作",
    "syntax": "booleanResult = rangeObject.Replace(What, Replacement, [LookAt As XlLookAt = xlPart], [SearchOrder As XlSearchOrder = xlByRows], [MatchCase As Boolean = False], [MatchByte], [SearchFormat As Boolean = False], [ReplaceFormat As Boolean = False])",
    "description": "在指定的儲存格範圍內尋找並取代字元。如果找到並取代了任何資訊，則傳回 True。",
    "parameters": [
        {"name": "What", "description": "必需。要搜尋的字串。"},
        {"name": "Replacement", "description": "必需。取代字串。"},
        {"name": "LookAt", "description": "可選。xlPart (預設，部分符合) 或 xlWhole (完全符合)。"},
        {"name": "SearchOrder", "description": "可選。xlByRows (預設) 或 xlByColumns。"},
        {"name": "MatchCase", "description": "可選。False (預設，不區分大小寫) 或 True (區分大小寫)。"},
        {"name": "SearchFormat/ReplaceFormat", "description": "可選。用於基於格式進行搜尋/取代。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A10\").Replace What:=\"OldText\", Replacement:=\"NewText\", LookAt:=xlWhole, MatchCase:=True\nMsgBox \"A1:A10中所有'OldText'(區分大小寫，完全符合)已取代為'NewText'。\"", "explanation": "在A1:A10範圍內，將所有完全符合且區分大小寫的 \"OldText\" 取代為 \"NewText\"。"}
    ],
    "keywords": ["取代文字", "尋找並取代", "excel range replace", "find and replace"]
},
{
    "name": "Range.PrintOut (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.PrintOut([From], [To], [Copies], [Preview], [ActivePrinter], [PrintToFile], [Collate], [PrToFileName])",
    "description": "列印指定的物件 (可以是儲存格範圍、整個工作表、整個活頁簿)。",
    "parameters": [
        {"name": "From", "description": "可選。要開始列印的頁碼。"},
        {"name": "To", "description": "可選。要結束列印的頁碼。"},
        {"name": "Copies", "description": "可選。要列印的份數。"},
        {"name": "Preview", "description": "可選。True 表示在列印前預覽。"}
    ],
    "examples": [
        {"code": "Range(\"A1:D20\").PrintOut Copies:=2, Preview:=True", "explanation": "預覽列印範圍 A1:D20，並設定列印兩份。"},
        {"code": "ActiveSheet.PrintOut From:=1, To:=1 ' Print only the first page of the active sheet", "explanation": "僅列印活動工作表的第一頁。"}
    ],
    "keywords": ["列印範圍", "列印工作表", "excel print", "print range", "print sheet"]
},
// Word
{
    "name": "Document.Words(Index).Text (Word)",
    "category": "Word 文件處理",
    "syntax": "wordText = documentObject.Words(Index).Text",
    "description": "傳回文件中指定索引位置的單字的文字內容 (String)。Words 集合中的單字包含其後的空格。",
    "parameters": [
        {"name": "Index", "description": "必需。Words 集合中的單字索引 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Words.Count >= 3 Then\n'   MsgBox \"文件的第三個單字 (含空格) 是: '\" & wdDoc.Words(3).Text & \"'\"\n'   Debug.Print \"(去除前後空格後: '\" & Trim(wdDoc.Words(3).Text) & \"')\"\n' End If", "explanation": "如果文件至少有三個單字，則顯示第三個單字的文字 (它會包含單字後的空格)。"}
    ],
    "keywords": ["word get word text", "access specific word", "讀取特定單字"]
},
{
    "name": "Range.Collapse (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Collapse(Direction As WdCollapseDirection)",
    "description": "將指定的範圍摺疊到其起始或結束位置，使其成為一個插入點。",
    "parameters": [
        {"name": "Direction", "description": "必需。WdCollapseDirection 常數 (wdCollapseStart 或 wdCollapseEnd)。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' If selRange.Type <> wdSelectionIP Then ' If something is selected\n'   selRange.Collapse Direction:=1 ' 1 = wdCollapseEnd (collapse to end of selection)\n'   selRange.InsertAfter \" (已摺疊到選取範圍末尾並插入文字)\"\n' End If", "explanation": "如果使用者選取了文字，則將選取範圍摺疊到其結束位置 (變成一個插入點)，然後在該位置後插入文字。"}
    ],
    "keywords": ["word collapse range", "make range insertion point", "摺疊範圍", "變成插入點"]
},
{
    "name": "Font.Superscript / .Subscript (Word/Excel/PPT Text)",
    "category": "Word 文件處理",
    "syntax": "fontObject.Superscript = True | False\nfontObject.Subscript = True | False",
    "description": "設定或傳回文字是否格式化為上標或下標。這些屬性是互斥的。",
    "parameters": [{"name": "True | False", "description": "讀取/寫入布林值。"}],
    "examples": [
        {"code": "' In Word, for selected text:\n' With Selection.Font\n'   .Superscript = True ' Make text superscript\n'   ' .Subscript = True ' This would turn off superscript and turn on subscript\n' End With\n' MsgBox \"選取文字已設為上標。\"", "explanation": "將目前選取的文字格式化為上標。注意在 Word、Excel (儲存格文字) 和 PowerPoint (文字框文字) 的 Font 物件中均可使用。"}
    ],
    "keywords": ["superscript", "subscript", "text formatting", "上標", "下標", "文字格式", "通用"]
},
// Outlook
{
    "name": "MailItem.DeferredDeliveryTime",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.DeferredDeliveryTime = DateTimeValue",
    "description": "設定或傳回一個 Date，表示郵件的延遲傳送日期和時間。",
    "parameters": [{"name": "DateTimeValue", "description": "郵件應傳送的未來日期和時間。"}],
    "examples": [
        {"code": "Dim olMail As Object\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.To = \"recipient@example.com\"\nolMail.Subject = \"Scheduled Email\"\nolMail.Body = \"This email is scheduled to be sent later.\"\nolMail.DeferredDeliveryTime = Now + TimeValue(\"02:00:00\") ' Send in 2 hours\n' olMail.Send ' This will place it in Outbox until delivery time\nMsgBox \"郵件已設定為2小時後傳送。\"", "explanation": "建立一封新郵件，並將其設定為從現在起2小時後延遲傳送。調用 .Send 後，郵件會進入寄件匣等待。"}
    ],
    "keywords": ["outlook deferred delivery", "schedule email", "delay sending", "延遲傳送", "排程郵件"]
},
{
    "name": "MailItem.ExpiryTime",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.ExpiryTime = DateTimeValue",
    "description": "設定或傳回一個 Date，表示 Outlook 項目的到期日期和時間，之後該項目可能被視為過期或自動刪除 (取決於用戶端和伺服器設定)。",
    "parameters": [{"name": "DateTimeValue", "description": "項目的到期日期和時間。"}],
    "examples": [
        {"code": "Dim olMail As Object\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.Subject = \"Limited Time Offer - Expires Soon!\"\nolMail.To = \"customer@example.com\"\nolMail.Body = \"This offer expires in 3 days.\"\nolMail.ExpiryTime = Now + 3 ' Expires in 3 days from now\nolMail.Display", "explanation": "建立一封新郵件，並將其設定為3天後到期。"}
    ],
    "keywords": ["outlook email expiry", "message expiration", "郵件到期時間"]
},
// PowerPoint
{
    "name": "Shapes.AddChart (PowerPoint - Legacy)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set shpChart = slideObject.Shapes.AddChart([Type As XlChartType = xlColumnClustered], [Left], [Top], [Width], [Height])",
    "description": "在投影片上新增一個圖表。這是較舊的新增圖表方法，AddChart2 提供了更多選項。此方法通常會開啟一個 Excel 視窗供編輯資料。",
    "parameters": [
        {"name": "Type", "description": "可選。XlChartType 常數。"},
        {"name": "Left, Top, Width, Height", "description": "可選。圖表的位置和大小。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, chartShape As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, 12) ' ppLayoutBlank\n' Set chartShape = pptSlide.Shapes.AddChart(Type:=xlLine, Left:=50, Top:=50, Width:=400, Height:=250)\n' ' To access chart data (opens an Excel instance):\n' Dim chartData As Object ' Excel.ChartData\n' Dim wbChart As Object   ' Excel.Workbook\n' Dim wsChart As Object   ' Excel.Worksheet\n' Set chartData = chartShape.Chart.ChartData\n' chartData.Activate ' This makes the Excel data grid visible\n' Set wbChart = chartData.Workbook\n' Set wsChart = wbChart.Worksheets(1)\n' wsChart.Range(\"A1:B5\").Value = Application.Transpose(Array(Array(\"Category\", \"Value\"), Array(\"A\", 10), Array(\"B\", 20), Array(\"C\", 15), Array(\"D\", 25)))\n' wbChart.Close SaveChanges:=False ' Close the Excel data window\n' chartShape.Chart.HasTitle = True\n' chartShape.Chart.ChartTitle.Text = \"舊版圖表範例\"", "explanation": "在新投影片上使用舊版 AddChart 方法新增一個折線圖，並示範如何存取和修改其關聯的 Excel 資料工作表。"}
    ],
    "keywords": ["powerpoint addchart legacy", "insert chart old method", "ppt excel chart data", "新增圖表 (舊版)"]
},
{
    "name": "Shapes.AddSmartArt (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set saShape = slideObject.Shapes.AddSmartArt(Layout As SmartArtLayout, [Left], [Top], [Width], [Height])",
    "description": "將 SmartArt 圖形新增至投影片。",
    "parameters": [
        {"name": "Layout", "description": "必需。SmartArtLayout 物件，指定要新增的 SmartArt 圖形版面配置。"},
        {"name": "Left, Top, Width, Height", "description": "可選。SmartArt 圖形的位置和大小。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, smArt As Object ' PowerPoint.Shape\nDim saLayout As Object ' SmartArtLayout\n' Set pptSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, ppLayoutBlank)\n' ' Get a specific SmartArt layout (e.g., Organization Chart)\n' ' Need to ensure PowerPoint application object is available for Application.SmartArtLayouts\n' Dim pptApp As Object: Set pptApp = CreateObject(\"PowerPoint.Application\")\n' Set saLayout = pptApp.SmartArtLayouts(109) ' 109 is an example ID for an org chart type\n' If Not saLayout Is Nothing Then\n'   Set smArt = pptSlide.Shapes.AddSmartArt(Layout:=saLayout, Left:=50, Top:=50, Width:=500, Height:=300)\n'   ' Populate SmartArt nodes (this is complex and depends on the layout)\n'   ' smArt.SmartArt.Nodes(1).TextFrame2.TextRange.Text = \"CEO\"\n'   ' smArt.SmartArt.Nodes(1).Nodes.Add.TextFrame2.TextRange.Text = \"VP1\"\n'   MsgBox \"SmartArt 圖形 ('\" & saLayout.Name & \"') 已新增。\"\n' Else\n'   MsgBox \"未找到指定的SmartArt版面配置。\"\n' End If", "explanation": "在新投影片上新增一個 SmartArt 圖形 (此處以組織圖為例的概念性 ID)。填充 SmartArt 節點需要額外的代碼。"}
    ],
    "keywords": ["powerpoint add smartart", "insert smartart graphic", "ppt smartart", "新增SmartArt圖形"]
},
// FSO
{
    "name": "Folder.DateCreated Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "dateValue = folderObject.DateCreated",
    "description": "傳回指定資料夾的建立日期和時間。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fldr As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldr = fso.GetFolder(\"C:\\Windows\")\nMsgBox \"資料夾 '\" & fldr.Name & \"' 建立於: \" & fldr.DateCreated", "explanation": "顯示 C:\\Windows 資料夾的建立日期和時間。"}
    ],
    "keywords": ["fso folder datecreated", "directory creation time", "資料夾建立日期"]
},
{
    "name": "Folder.DateLastAccessed Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "dateValue = folderObject.DateLastAccessed",
    "description": "傳回指定資料夾的上次存取日期和時間。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fldr As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldr = fso.GetFolder(\"C:\\Users\")\nMsgBox \"資料夾 '\" & fldr.Name & \"' 上次存取於: \" & fldr.DateLastAccessed", "explanation": "顯示 C:\\Users 資料夾的上次存取日期和時間。"}
    ],
    "keywords": ["fso folder datelastaccessed", "directory access time", "資料夾上次存取日期"]
},
{
    "name": "Folder.DateLastModified Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "dateValue = folderObject.DateLastModified",
    "description": "傳回指定資料夾的上次修改日期和時間。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fldr As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet fldr = fso.GetFolder(\"C:\\Program Files\")\nMsgBox \"資料夾 '\" & fldr.Name & \"' 上次修改於: \" & fldr.DateLastModified", "explanation": "顯示 C:\\Program Files 資料夾的上次修改日期和時間。"}
    ],
    "keywords": ["fso folder datelastmodified", "directory modification time", "資料夾上次修改日期"]
},
// String
{
    "name": "ChrW / AscW (Unicode)",
    "category": "字串與文本操作",
    "syntax": "charString = ChrW(CharCode As Long)\ncharCodeLong = AscW(String As String)",
    "description": "ChrW 返回與指定 Unicode (寬字元) 字元碼相關聯的字元。AscW 返回字串第一個字元的 Unicode 字元碼。這些函數用於處理超出標準 ANSI (0-255) 範圍的 Unicode 字元。",
    "parameters": [
        {"name": "CharCode (ChrW)", "description": "必需。Unicode 字元碼。"},
        {"name": "String (AscW)", "description": "必需。任何有效的字串表達式。"}
    ],
    "examples": [
        {"code": "Dim unicodeChar As String, unicodeCode As Long\n' Example: Euro symbol € (Unicode U+20AC, Decimal 8364)\nunicodeChar = ChrW(8364)\nMsgBox \"ChrW(8364) = \" & unicodeChar\n\nunicodeCode = AscW(unicodeChar)\nMsgBox \"AscW(\" & unicodeChar & \") = \" & unicodeCode", "explanation": "演示如何使用 ChrW 從 Unicode 碼點創建歐元符號 (€)，以及如何使用 AscW 獲取其 Unicode 碼點。"}
    ],
    "keywords": ["chrw", "ascw", "unicode characters", "wide characters", "Unicode字元", "寬字元"]
},
// Math
{
    "name": "WorksheetFunction.SumIf (Excel)",
    "category": "數學、日期與時間",
    "syntax": "sumResult = Application.WorksheetFunction.SumIf(Range, Criteria, [Sum_Range])",
    "description": "使用 Excel 的 SUMIF 工作表函數，對符合指定條件的儲存格進行加總。",
    "parameters": [
        {"name": "Range", "description": "必需。要評估條件的儲存格範圍。"},
        {"name": "Criteria", "description": "必需。決定哪些儲存格將被加總的條件 (數字、表達式或文字)。"},
        {"name": "Sum_Range", "description": "可選。要加總的實際儲存格。如果省略，則對 Range 中的儲存格進行加總。"}
    ],
    "examples": [
        {"code": "' Assume A1:A5 contains product names, B1:B5 contains sales amounts\n' Range(\"A1:B5\").Value = Application.Transpose(Array(Array(\"Apple\", 100), Array(\"Banana\", 150), Array(\"Apple\", 200), Array(\"Orange\", 50), Array(\"Apple\", 120)))\nDim totalAppleSales As Double\ntotalAppleSales = Application.WorksheetFunction.SumIf(Range(\"A1:A5\"), \"Apple\", Range(\"B1:B5\"))\nMsgBox \"Apple產品的總銷售額是: \" & totalAppleSales ' Should be 100+200+120 = 420", "explanation": "計算A欄中產品名稱為 \"Apple\" 的所有對應B欄銷售額的總和。"}
    ],
    "keywords": ["sumif", "conditional sum", "excel sumif vba", "條件加總"]
},
{
    "name": "WorksheetFunction.CountIf (Excel)",
    "category": "數學、日期與時間",
    "syntax": "countResult = Application.WorksheetFunction.CountIf(Range, Criteria)",
    "description": "使用 Excel 的 COUNTIF 工作表函數，計算範圍中符合指定條件的非空儲存格數量。",
    "parameters": [
        {"name": "Range", "description": "必需。要計數的儲存格範圍。"},
        {"name": "Criteria", "description": "必需。決定哪些儲存格將被計數的條件。"}
    ],
    "examples": [
        {"code": "' Range(\"A1:A10\").Value = Application.Transpose(Array(10,20,5,25,10,15,30,10,8,22))\nDim countOver15 As Long\ncountOver15 = Application.WorksheetFunction.CountIf(Range(\"A1:A10\"), \">15\")\nMsgBox \"A1:A10 中大於15的數字有 \" & countOver15 & \" 個。\"", "explanation": "計算A1:A10範圍內值大於15的儲存格數量。"}
    ],
    "keywords": ["countif", "conditional count", "excel countif vba", "條件計數"]
},
// Data Types
{
    "name": "Empty Keyword (Variant)",
    "category": "資料類型、轉換與驗證",
    "syntax": "variantVariable = Empty",
    "description": "Empty 是一個關鍵字，用於指示一個 Variant 變數尚未被初始化 (即未賦予任何值)。它是 Variant 變數的預設初始狀態。可以使用 IsEmpty 函數檢查變數是否為 Empty。",
    "parameters": [],
    "examples": [
        {"code": "Dim myVar As Variant ' myVar is Empty at this point\nDim anotherVar As Variant\nIf IsEmpty(myVar) Then Debug.Print \"myVar is Empty.\"\nmyVar = 100\nIf Not IsEmpty(myVar) Then Debug.Print \"myVar is now \" & myVar\nanotherVar = Empty ' Explicitly set to Empty\nIf IsEmpty(anotherVar) Then Debug.Print \"anotherVar has been set to Empty.\"", "explanation": "演示 Variant 變數的預設 Empty 狀態，以及如何明確地將 Variant 變數設為 Empty。"}
    ],
    "keywords": ["empty keyword", "uninitialized variant", "variant state", "isempty", "未初始化Variant"]
},
// Program Flow
{
    "name": "On...GoTo Statement (Legacy)",
    "category": "程式流程與結構控制",
    "syntax": "On expression GoTo destinationlist",
    "description": "根據運算式的值，分支到指定的幾個行標籤或行號之一。如果 expression 的值是 1，則跳轉到 destinationlist 中的第一個標籤/行號；如果是 2，則跳轉到第二個，依此類推。這是較舊的 BASIC 結構，通常被 Select Case 取代。",
    "parameters": [
        {"name": "expression", "description": "必需。任何評估為小範圍正整數的數值運算式。"},
        {"name": "destinationlist", "description": "必需。以逗號分隔的行號或行標籤列表。"}
    ],
    "examples": [
        {"code": "Sub TestOnGoTo()\n  Dim choice As Integer\n  choice = CInt(InputBox(\"輸入 1 (顯示訊息), 2 (顯示時間), 或 3 (結束):\"))\n  If choice < 1 Or choice > 3 Then GoTo InvalidChoice\n  On choice GoTo ShowMessage, ShowTime, EndProgram\nShowMessage:\n  MsgBox \"您選擇了顯示訊息。\"\n  GoTo EndProcessing\nShowTime:\n  MsgBox \"目前時間是: \" & Time\n  GoTo EndProcessing\nInvalidChoice:\n  MsgBox \"無效的選擇。\"\nEndProgram:\n  Debug.Print \"程式即將結束或已處理。\"\nEndProcessing:\n  Debug.Print \"處理完成。\"\nEnd Sub", "explanation": "根據使用者輸入的數字 (1, 2, 或 3)，程式會跳轉到相應的標籤。此範例顯示了 GoTo 如何使流程控制變得複雜。"}
    ],
    "keywords": ["on goto", "computed goto", "legacy control flow", "分支", "多路跳轉"]
},
// External API
{
    "name": "CreateShortcut (WScript.Shell)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "Set shortcutObj = wshShell.CreateShortcut(PathLink As String)",
    "description": "使用 Windows Script Host Shell 物件的 CreateShortcut 方法來建立捷徑 (.lnk) 檔案。",
    "parameters": [
        {"name": "PathLink", "description": "必需。字串，指定要建立的捷徑檔案的完整路徑和名稱。"},
        {"name": "Shortcut Object Properties", "description": ".TargetPath (要指向的檔案/程式)、.Arguments (參數)、.WorkingDirectory、.IconLocation、.WindowStyle、.Description、.Hotkey。"},
        {"name": "Shortcut Object .Save() Method", "description": "儲存捷徑檔案。"}
    ],
    "examples": [
        {"code": "Sub CreateDesktopShortcutToNotepad()\n    Dim wshShell As Object, oShellLink As Object\n    Dim desktopPath As String\n\n    Set wshShell = CreateObject(\"WScript.Shell\")\n    desktopPath = wshShell.SpecialFolders(\"Desktop\") ' Get path to desktop\n    \n    If desktopPath = \"\" Then\n        MsgBox \"無法獲取桌面路徑。\", vbCritical\n        Exit Sub\n    End If\n\n    Set oShellLink = wshShell.CreateShortcut(desktopPath & \"\\記事本捷徑.lnk\")\n    With oShellLink\n        .TargetPath = Environ(\"SystemRoot\") & \"\\System32\\notepad.exe\"\n        .Arguments = \"C:\\Temp\\MyFile.txt\" ' Optional: file to open with notepad\n        .WorkingDirectory = Environ(\"SystemRoot\") & \"\\System32\"\n        .WindowStyle = 1 ' 1 = Normal, 3 = Maximized, 7 = Minimized\n        .IconLocation = Environ(\"SystemRoot\") & \"\\System32\\notepad.exe, 0\"\n        .Description = \"開啟記事本並載入MyFile.txt\"\n        ' .Hotkey = \"CTRL+SHIFT+N\" ' Example Hotkey (use with caution)\n        .Save\n    End With\n    MsgBox \"記事本的捷徑已創建在您的桌面上！\"\n    Set oShellLink = Nothing\n    Set wshShell = Nothing\nEnd Sub", "explanation": "此子程序在用戶桌面上創建一個名為“記事本捷徑.lnk”的捷徑。該捷徑指向 Windows 的記事本程式 (notepad.exe)，並設定了它打開時可以加載的可選文件、工作目錄、圖標、描述等屬性。"}
    ],
    "keywords": ["wscript.shell createshortcut", "vba create lnk file", "desktop shortcut vba", "windows scripting host", "創建捷徑", "桌面快捷方式"]
},
{
    "name": "SpecialFolders Property (WScript.Shell)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "folderPath = wshShell.SpecialFolders(SpecialFolderName As String)",
    "description": "傳回 Windows 特殊資料夾的路徑 (例如 Desktop, MyDocuments, StartMenu, Favorites)。",
    "parameters": [
        {"name": "SpecialFolderName", "description": "必需。字串，指定特殊資料夾的名稱 (例如 \"Desktop\", \"MyDocuments\", \"AppData\", \"StartMenu\", \"Favorites\", \"Startup\", \"Recent\", \"SendTo\", \"Templates\", \"Fonts\", \"ProgramFiles\", \"System\")。"}
    ],
    "examples": [
        {"code": "Dim wshShell As Object\nSet wshShell = CreateObject(\"WScript.Shell\")\nDebug.Print \"Desktop: \" & wshShell.SpecialFolders(\"Desktop\")\nDebug.Print \"My Documents: \" & wshShell.SpecialFolders(\"MyDocuments\")\nDebug.Print \"Application Data: \" & wshShell.SpecialFolders(\"AppData\")\nDebug.Print \"Program Files: \" & wshShell.SpecialFolders(\"ProgramFiles\")\nSet wshShell = Nothing", "explanation": "使用 WScript.Shell 物件的 SpecialFolders 屬性獲取常用 Windows 特殊資料夾的路徑並列印到立即視窗。"}
    ],
    "keywords": ["wscript.shell specialfolders", "windows special folders vba", "get desktop path", "get mydocuments path", "特殊資料夾路徑", "系統文件夾"]
},
// Excel 核心操作
{
    "name": "Range.EntireRow.Delete",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.EntireRow.Delete([Shift As XlDeleteShiftDirection])",
    "description": "刪除包含指定範圍的整個列。下方儲存格會向上移動以填補空間。",
    "parameters": [
        {"name": "Shift", "description": "可選。通常省略，因為刪除整列時下方列會自動上移。"}
    ],
    "examples": [
        {"code": "Range(\"A5\").EntireRow.Delete ' 刪除第5列", "explanation": "刪除包含儲存格A5的整列 (即第5列)。"},
        {"code": "Selection.EntireRow.Delete ' 刪除目前選取儲存格所在的整列", "explanation": "刪除使用者目前選取範圍所在的整列或多列。"}
    ],
    "keywords": ["刪除整列", "移除列", "excel", "delete entire row", "remove row"]
},
{
    "name": "Range.EntireColumn.Delete",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.EntireColumn.Delete([Shift As XlDeleteShiftDirection])",
    "description": "刪除包含指定範圍的整個欄。右方儲存格會向左移動以填補空間。",
    "parameters": [
        {"name": "Shift", "description": "可選。通常省略，因為刪除整欄時右方欄會自動左移。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").EntireColumn.Delete ' 刪除C欄", "explanation": "刪除包含儲存格C1的整欄 (即C欄)。"},
        {"code": "Range(\"B2:D5\").EntireColumn.Delete ' 刪除B、C、D三欄", "explanation": "刪除包含範圍B2:D5的所有欄 (即B、C和D欄)。"}
    ],
    "keywords": ["刪除整欄", "移除欄", "excel", "delete entire column", "remove column"]
},
{
    "name": "Range.EntireRow.Insert",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.EntireRow.Insert([Shift As XlInsertShiftDirection = xlShiftDown], [CopyOrigin As XlInsertFormatOrigin = xlFormatFromLeftOrAbove])",
    "description": "在指定範圍的上方插入一個新的空白列 (或多列)。原來的列會向下移動。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A3\").EntireRow.Insert ' 在第3列上方插入一個新列", "explanation": "在第3列上方插入一個新的空白列，原第3列及以下各列下移。"},
        {"code": "Range(\"A5:A7\").EntireRow.Insert ' 在第5列上方插入3個新列", "explanation": "基於選取了3列的範圍，在其上方插入3個新的空白列。"}
    ],
    "keywords": ["插入整列", "新增列", "excel", "insert entire row", "add row"]
},
{
    "name": "Range.EntireColumn.Insert",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.EntireColumn.Insert([Shift As XlInsertShiftDirection = xlShiftToRight], [CopyOrigin As XlInsertFormatOrigin = xlFormatFromLeftOrAbove])",
    "description": "在指定範圍的左側插入一個新的空白欄 (或多欄)。原來的欄會向右移動。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"C1\").EntireColumn.Insert ' 在C欄左側插入一個新欄", "explanation": "在C欄左側插入一個新的空白欄，原C欄及右側各欄右移。"},
        {"code": "Range(\"D2:E5\").EntireColumn.Insert ' 在D欄左側插入2個新欄", "explanation": "基於選取了2欄的範圍，在其左側插入2個新的空白欄。"}
    ],
    "keywords": ["插入整欄", "新增欄", "excel", "insert entire column", "add column"]
},
{
    "name": "Worksheet.Move (Before/After Another Sheet)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Move([Before], [After])",
    "description": "將工作表移動到活頁簿中的另一個位置，可以指定在其前或其後的工作表。",
    "parameters": [
        {"name": "Before", "description": "可選。工作表物件，移動的工作表將置於其前。"},
        {"name": "After", "description": "可選。工作表物件，移動的工作表將置於其後。"}
    ],
    "examples": [
        {"code": "ThisWorkbook.Sheets(\"Sheet3\").Move Before:=ThisWorkbook.Sheets(1)", "explanation": "將名為 \"Sheet3\" 的工作表移動到活頁簿中第一個工作表之前。"},
        {"code": "Dim wsToMove As Worksheet, wsTarget As Worksheet\nSet wsToMove = ThisWorkbook.Sheets(\"DataInput\")\nSet wsTarget = ThisWorkbook.Sheets(\"Summary\")\nwsToMove.Move After:=wsTarget", "explanation": "將 \"DataInput\" 工作表移動到 \"Summary\" 工作表之後。"}
    ],
    "keywords": ["移動工作表位置", "重排工作表", "excel", "move sheet order", "reorder sheets"]
},
{
    "name": "Range.CurrentRegion.Select",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.CurrentRegion.Select",
    "description": "選取由空白列和空白欄包圍的目前區域。通常用於選取一個完整的資料區塊。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").CurrentRegion.Select ' 如果A1是資料區塊的左上角，則選取整個區塊", "explanation": "選取以A1儲存格為起點的連續資料區域。"},
        {"code": "Dim targetCell As Range\nSet targetCell = ActiveSheet.Cells(5, 3) ' C5\n' Select the data block that C5 belongs to\ntargetCell.CurrentRegion.Select", "explanation": "選取包含儲存格C5的連續資料區塊。"}
    ],
    "keywords": ["選取目前區域", "選取資料區塊", "excel", "select current region", "select data block"]
},
{
    "name": "Range.SpecialCells(xlCellTypeLastCell)",
    "category": "Excel 核心操作",
    "syntax": "Set lastCell = worksheetObject.Cells.SpecialCells(xlCellTypeLastCell)",
    "description": "傳回工作表上已使用範圍中的最後一個儲存格。這個儲存格可能不一定是包含資料的最後一個儲存格，而是Excel內部記錄的“已使用”區域的右下角。",
    "parameters": [],
    "examples": [
        {"code": "Dim lc As Range\nSet lc = ActiveSheet.Cells.SpecialCells(xlCellTypeLastCell)\nMsgBox \"工作表上的最後一個儲存格 (Excel內部記錄) 是: \" & lc.Address", "explanation": "獲取活動工作表上被Excel視為“最後使用”的儲存格。"},
        {"code": "' To get the true last cell with data, often better to use:\n' Dim trueLastRow As Long, trueLastCol As Long\n' If WorksheetFunction.CountA(ActiveSheet.Cells) > 0 Then\n'    trueLastRow = ActiveSheet.Cells.Find(What:=\"*\", SearchOrder:=xlByRows, SearchDirection:=xlPrevious).Row\n'    trueLastCol = ActiveSheet.Cells.Find(What:=\"*\", SearchOrder:=xlByColumns, SearchDirection:=xlPrevious).Column\n'    MsgBox \"真正包含資料的最後一個儲存格可能是: \" & ActiveSheet.Cells(trueLastRow, trueLastCol).Address\n' End If", "explanation": "演示xlCellTypeLastCell與實際包含資料的最後一個儲存格的區別，並提供後者的查找方法。"}
    ],
    "keywords": ["最後儲存格", "工作表邊界", "excel", "last cell", "worksheet bounds", "xlCellTypeLastCell"]
},
{
    "name": "Range.SpecialCells(xlCellTypeVisible)",
    "category": "Excel 核心操作",
    "syntax": "Set visibleCellsRange = rangeObject.SpecialCells(xlCellTypeVisible)",
    "description": "傳回一個 Range 物件，代表指定範圍內所有可見的儲存格。在篩選清單後，這對於僅操作可見儲存格非常有用。",
    "parameters": [],
    "examples": [
        {"code": "' Assume A1:A10 has some data and some rows are hidden by a filter\n' Range(\"A1:A10\").AutoFilter Field:=1, Criteria1:=\"<>\" ' Example filter applied\nDim visCells As Range\nOn Error Resume Next ' If all cells are hidden or no cells in range\nSet visCells = Range(\"A1:A10\").SpecialCells(xlCellTypeVisible)\nOn Error GoTo 0\nIf Not visCells Is Nothing Then\n  MsgBox \"可見儲存格的總數: \" & visCells.Cells.Count\n  visCells.Interior.Color = vbGreen ' Highlight visible cells\nElse\n  MsgBox \"範圍內沒有可見儲存格。\"\nEnd If", "explanation": "在篩選後的範圍A1:A10中，選取所有可見的儲存格並將其背景設為綠色。"}
    ],
    "keywords": ["可見儲存格", "篩選後儲存格", "excel", "visible cells", "filtered range", "xlCellTypeVisible"]
},
{
    "name": "Workbook.ActiveChart",
    "category": "Excel 核心操作",
    "syntax": "Set ch = workbookObject.ActiveChart",
    "description": "傳回一個 Chart 物件，代表活動活頁簿中活動的圖表 (可以是嵌入式圖表或圖表工作表)。如果沒有圖表處於活動狀態，則傳回 Nothing。",
    "parameters": [],
    "examples": [
        {"code": "Dim myActiveChart As Chart\nOn Error Resume Next ' In case no chart is active\nSet myActiveChart = ActiveWorkbook.ActiveChart\nOn Error GoTo 0\nIf Not myActiveChart Is Nothing Then\n  MsgBox \"活動圖表的名稱是: \" & myActiveChart.Name\n  myActiveChart.ChartTitle.Font.Bold = True\nElse\n  MsgBox \"目前沒有活動的圖表。\"\nEnd If", "explanation": "獲取目前活動活頁簿中的活動圖表，並將其標題字型設為粗體。"}
    ],
    "keywords": ["活動圖表", "目前圖表", "excel", "active chart", "current chart"]
},
{
    "name": "Chart.ChartArea",
    "category": "Excel 核心操作",
    "syntax": "Set ca = chartObject.ChartArea",
    "description": "傳回代表完整圖表區域的 ChartArea 物件。ChartArea 物件包含圖表的所有元素，如繪圖區、圖例、標題等。",
    "parameters": [],
    "examples": [
        {"code": "Dim ch As Chart\n' Set ch = ActiveChart ' Assume a chart is active\n' If Not ch Is Nothing Then\n'   With ch.ChartArea\n'     .Format.Fill.ForeColor.RGB = RGB(240, 240, 240) ' Light grey background for entire chart area\n'     .Border.Color = RGB(0, 0, 128) ' Dark blue border for chart area\n'   End With\n'   MsgBox \"活動圖表的圖表區域格式已修改。\"\n' End If", "explanation": "設定活動圖表的整個圖表區域的背景色和框線顏色。"}
    ],
    "keywords": ["圖表區域", "chart area format", "excel chart background", "excel"]
},
{
    "name": "Chart.PlotArea",
    "category": "Excel 核心操作",
    "syntax": "Set pa = chartObject.PlotArea",
    "description": "傳回代表圖表繪圖區的 PlotArea 物件。繪圖區是包含實際資料序列、座標軸和格線的區域。",
    "parameters": [],
    "examples": [
        {"code": "Dim ch As Chart\n' Set ch = ActiveChart\n' If Not ch Is Nothing Then\n'   With ch.PlotArea\n'     .Interior.Color = RGB(255, 255, 200) ' Light yellow background for plot area\n'     .Format.Line.Visible = msoTrue\n'     .Format.Line.ForeColor.RGB = RGB(100, 100, 100) ' Grey border for plot area\n'   End With\n'   MsgBox \"活動圖表的繪圖區域格式已修改。\"\n' End If", "explanation": "設定活動圖表的繪圖區域的背景色和框線。"}
    ],
    "keywords": ["繪圖區", "chart plot area", "excel chart formatting", "excel"]
},
{
    "name": "SeriesCollection.Add (Chart)",
    "category": "Excel 核心操作",
    "syntax": "Set newSeries = chartObject.SeriesCollection.Add(Source, [Rowcol As XlRowCol = xlColumns], [SeriesLabels As Boolean], [CategoryLabels As Boolean], [Replace])",
    "description": "將一個或多個新數列新增到圖表的 SeriesCollection 集合中。",
    "parameters": [
        {"name": "Source", "description": "必需。Range 物件，包含新數列的來源資料。"},
        {"name": "Rowcol", "description": "可選。XlRowCol 常數，指定資料是按列還是按欄排列。"},
        {"name": "SeriesLabels", "description": "可選。True 表示 Source 中的第一列/列包含數列名稱。"},
        {"name": "CategoryLabels", "description": "可選。True 表示 Source 中的第一列/列包含類別 (X) 軸標籤。"}
    ],
    "examples": [
        {"code": "Dim ch As Chart, newSeries As Series\n' Set ch = ActiveSheet.ChartObjects(1).Chart ' Assume an existing chart\n' Set newSeries = ch.SeriesCollection.Add(Source:=Range(\"Sheet2!A1:B5\"), Rowcol:=xlColumns, SeriesLabels:=True, CategoryLabels:=True)\n' newSeries.Name = \"New Data Series\"\n' MsgBox \"新數列已新增到圖表。\"", "explanation": "將 Sheet2!A1:B5 範圍的資料作為一個新數列新增到現有圖表中，並假設資料按欄排列，且第一列為類別標籤，第一列為數列標籤 (數列名稱)。"}
    ],
    "keywords": ["新增圖表數列", "add chart series", "excel chart data", "seriescollection add"]
},
{
    "name": "Series.XValues / .Values (Chart)",
    "category": "Excel 核心操作",
    "syntax": "seriesObject.XValues = rangeOrArray\nseriesObject.Values = rangeOrArray",
    "description": "設定或傳回圖表數列的 X 值 (類別軸標籤) 和 Y 值 (數值)。",
    "parameters": [
        {"name": "rangeOrArray", "description": "包含 X 或 Y 值的儲存格範圍或陣列。"}
    ],
    "examples": [
        {"code": "Dim ch As Chart, srs As Series\n' Set ch = ActiveChart\n' If ch.SeriesCollection.Count > 0 Then\n'   Set srs = ch.SeriesCollection(1)\n'   ' Set X values from Sheet1 C1:C5\n'   srs.XValues = ThisWorkbook.Sheets(\"Sheet1\").Range(\"C1:C5\")\n'   ' Set Y values from Sheet1 D1:D5\n'   srs.Values = ThisWorkbook.Sheets(\"Sheet1\").Range(\"D1:D5\")\n'   MsgBox \"第一個數列的 X 和 Y 值已更新。\"\n' End If", "explanation": "修改活動圖表中第一個數列的 X 值和 Y 值來源。"}
    ],
    "keywords": ["圖表數列值", "chart series xvalues", "chart series values", "update chart data"]
},
{
    "name": "Range.Borders(xlDiagonalDown / xlDiagonalUp)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Borders(xlDiagonalDown).LineStyle = XlLineStyleConstant\nrangeObject.Borders(xlDiagonalUp).LineStyle = XlLineStyleConstant",
    "description": "設定儲存格的對角線框線。",
    "parameters": [
        {"name": "xlDiagonalDown", "description": "常數，表示從左上到右下的對角線。"},
        {"name": "xlDiagonalUp", "description": "常數，表示從左下到右上的對角線。"}
    ],
    "examples": [
        {"code": "With Range(\"A1\")\n  .Value = \"X\"\n  .Borders(xlDiagonalDown).LineStyle = xlContinuous\n  .Borders(xlDiagonalUp).LineStyle = xlContinuous\n  .Borders(xlDiagonalDown).Weight = xlThin\n  .Borders(xlDiagonalUp).Weight = xlThin\nEnd With\nMsgBox \"A1儲存格已設定交叉對角線框線。\"", "explanation": "在A1儲存格中畫一個交叉 (X) 的對角線框線。"}
    ],
    "keywords": ["對角線框線", "儲存格斜線", "excel diagonal border", "cell strikethrough diagonal"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.DataBodyRange",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set dataRange = pivotTableObject.DataBodyRange",
    "description": "傳回一個 Range 物件，代表樞紐分析表報表中的值區域 (不包括列總計和欄總計)。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, dataValuesRange As Range\n' Set pt = ActiveSheet.PivotTables(1) ' Assume a PivotTable exists\n' If Not pt Is Nothing Then\n'   Set dataValuesRange = pt.DataBodyRange\n'   If Not dataValuesRange Is Nothing Then\n'     dataValuesRange.Font.Color = vbBlue\n'     MsgBox \"樞紐分析表的數據值區域 ('\" & dataValuesRange.Address & \"') 字型已設為藍色。\"\n'   Else\n'      MsgBox \"樞紐分析表沒有數據值。\"\n'   End If\n' End If", "explanation": "獲取活動工作表上第一個樞紐分析表的數據值區域，並將其字型顏色設為藍色。"}
    ],
    "keywords": ["pivottable databodyrange", "pivot values range", "樞紐分析表數據區域", "值範圍"]
},
{
    "name": "PivotTable.RowRange / .ColumnRange",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set rowHeaderRange = pivotTableObject.RowRange\nSet colHeaderRange = pivotTableObject.ColumnRange",
    "description": "RowRange 傳回包含樞紐分析表報表中列標題的 Range 物件。ColumnRange 傳回包含欄標題的 Range 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(\"SalesSummary\")\n' If Not pt Is Nothing Then\n'   If Not pt.RowRange Is Nothing Then pt.RowRange.Interior.Color = RGB(220, 220, 220) ' Light grey for row headers\n'   If Not pt.ColumnRange Is Nothing Then pt.ColumnRange.Font.Italic = True ' Italicize column headers\n'   MsgBox \"樞紐分析表的列標題和欄標題已格式化。\"\n' End If", "explanation": "格式化樞紐分析表的列標題背景和欄標題字型。"}
    ],
    "keywords": ["pivottable rowrange", "pivottable columnrange", "pivot row headers", "pivot column headers", "樞紐分析表列標題", "樞紐分析表欄標題"]
},
{
    "name": "PivotField.CurrentPage",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.CurrentPage = pageNameString\ncurrentPageName = pivotFieldObject.CurrentPageName",
    "description": "設定或傳回頁面欄位 (篩選欄位) 的目前顯示頁面。CurrentPageName 傳回目前頁面的名稱。",
    "parameters": [
        {"name": "pageNameString", "description": "要顯示的頁面項目的名稱。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Year As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Year = pt.PageFields(\"Year\") ' Assume \"Year\" is a page field\n' On Error Resume Next ' If \"2023\" is not a valid page item\n' pf_Year.CurrentPage = \"2023\"\n' If Err.Number = 0 Then\n'   MsgBox \"樞紐分析表已篩選顯示年份: \" & pf_Year.CurrentPageName\n' Else\n'   MsgBox \"無法設定頁面欄位 'Year' 到 '2023': \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "將樞紐分析表中名為 \"Year\" 的頁面欄位篩選為顯示 \"2023\" 年的數據。"}
    ],
    "keywords": ["pivotfield currentpage", "filter page field", "pivottable filter", "頁面欄位篩選", "目前頁面"]
},
{
    "name": "PivotTable.PivotSelect",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.PivotSelect(Name As String, Mode As XlPTSelectionMode, [UseStandardName As Boolean])",
    "description": "選取樞紐分析表報表的一部分。",
    "parameters": [
        {"name": "Name", "description": "必需。要選取的樞紐分析表結構部分的名稱或路徑 (字串)。"},
        {"name": "Mode", "description": "必需。XlPTSelectionMode 常數，指定如何選取 (例如，xlDataAndLabel, xlLabelOnly, xlButton, xlBlanks)。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' ' Select the data and label for 'Grand Total' row\n' On Error Resume Next\n' pt.PivotSelect \"'Grand Total'\", xlDataAndLabel, True ' UseStandardName might be needed for localized versions\n' If Err.Number <> 0 Then\n'   ' Try localized name if English standard name fails\n'   pt.PivotSelect \"'總計'\", xlDataAndLabel\n' End If\n' On Error GoTo 0\n' If Not Selection Is Nothing And TypeName(Selection) = \"Range\" Then\n'   Selection.Font.Bold = True\n'   MsgBox \"樞紐分析表的總計列已選取並設為粗體。\"\n' End If", "explanation": "嘗試選取樞紐分析表中的「總計」列 (包括其標籤和數據)，並將其字型設為粗體。"}
    ],
    "keywords": ["pivotselect", "select pivot part", "pivottable selection", "選取樞紐分析表部分"]
},
{
    "name": "PivotTable.GetPivotData",
    "category": "Excel 資料分析與樞紐",
    "syntax": "value = pivotTableObject.GetPivotData(DataField As String, [Field1, Item1], [Field2, Item2], ...)",
    "description": "從樞紐分析表報表中擷取資料。類似於工作表中的 GETPIVOTDATA 函數。",
    "parameters": [
        {"name": "DataField", "description": "必需。要擷取資料的資料欄位名稱 (字串)。"},
        {"name": "FieldN, ItemN", "description": "可選。成對的欄位名稱和項目名稱，用於指定要擷取資料的交叉點。最多14對。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, salesForApples As Variant\n' Set pt = ActiveSheet.PivotTables(\"ProductSales\")\n' ' Get total sales for 'Apples' in the 'East' region from 'Sum of SalesAmount' data field\n' On Error Resume Next ' In case items/fields don't exist or data is not available\n' salesForApples = pt.GetPivotData(\"Sum of SalesAmount\", \"Product\", \"Apples\", \"Region\", \"East\")\n' If Err.Number = 0 And Not IsEmpty(salesForApples) Then\n'   MsgBox \"東區蘋果的銷售總額是: \" & salesForApples\n' ElseIf IsEmpty(salesForApples) Then\n'   MsgBox \"未找到東區蘋果的銷售數據 (GetPivotData傳回Empty)。\"\n' Else\n'   MsgBox \"使用 GetPivotData 時發生錯誤: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "從名為 \"ProductSales\" 的樞紐分析表中擷取 \"Product\" 為 \"Apples\" 且 \"Region\" 為 \"East\" 的 \"Sum of SalesAmount\" 資料欄位的值。"}
    ],
    "keywords": ["getpivotdata", "retrieve pivot data", "pivottable value lookup", "擷取樞紐分析表資料"]
},
{
    "name": "PivotTable.CalculatedItems.Add (OLAP only)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set ci = pivotFieldObject.CalculatedItems.Add(Name As String, Formula As String, [UseStandardFormula As Boolean])",
    "description": "在 OLAP 樞紐分析表的欄位中建立一個新的計算項目。對於非 OLAP 來源，計算項目是透過在來源資料中新增欄位或使用樞紐分析表中的計算欄位來實現的。",
    "parameters": [
        {"name": "Name", "description": "必需。新計算項目的名稱。"},
        {"name": "Formula", "description": "必需。計算項目的 MDX (多維運算式) 公式。"}
    ],
    "examples": [
        {"code": "' This is primarily for OLAP PivotTables.\n' Dim pt As PivotTable, pf_Product As PivotField, calcItem As CalculatedItem\n' ' Set pt = ActiveSheet.PivotTables(\"OLAPSalesCube\")\n' ' If pt.PivotCache.OLAP Then\n' '   Set pf_Product = pt.PivotFields(\"[Product].[Category]\") ' Example OLAP field\n' '   On Error Resume Next\n' '   Set calcItem = pf_Product.CalculatedItems.Add(\"ElectronicsPlusAppliances\", _\n' '                     \"[Product].[Category].[Electronics] + [Product].[Category].[Appliances]\")\n' '   If Err.Number = 0 Then\n' '     MsgBox \"計算項目 'ElectronicsPlusAppliances' 已新增。\"\n' '   Else\n' '     MsgBox \"新增計算項目失敗: \" & Err.Description\n' '   End If\n' '   On Error GoTo 0\n' ' Else\n' '   MsgBox \"此樞紐分析表不是基於OLAP資料來源。\"\n' ' End If", "explanation": "如果樞紐分析表是基於 OLAP 資料來源，則在產品類別欄位中新增一個名為 \"ElectronicsPlusAppliances\" 的計算項目，其值為 \"Electronics\" 和 \"Appliances\" 類別的總和。"}
    ],
    "keywords": ["pivottable calculated item", "olap calculated member", "mdx formula", "計算項目OLAP"]
},
{
    "name": "SlicerCache.Slicers.Add",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set sl = slicerCacheObject.Slicers.Add(SlicerDestination, [Level], [Name], [Caption], [Top], [Left], [Width], [Height])",
    "description": "根據指定的 SlicerCache 物件建立一個新的交叉分析篩選器 (Slicer)。",
    "parameters": [
        {"name": "SlicerDestination", "description": "必需。Worksheet 物件或字串，指定交叉分析篩選器放置的工作表。"},
        {"name": "Name", "description": "可選。交叉分析篩選器的名稱。"},
        {"name": "Caption", "description": "可選。交叉分析篩選器頂部顯示的標題。"}
    ],
    "examples": [
        {"code": "Dim sc As SlicerCache, newSlicer As Slicer\n' Assume a PivotTable 'SalesPivot' exists and has a SlicerCache for 'Region' field\n' You first need to create a SlicerCache if one doesn't exist for the field\n' Set sc = ThisWorkbook.SlicerCaches.Add(ActiveSheet.PivotTables(\"SalesPivot\"), \"Region\")\n'\n' Or get an existing SlicerCache\n' Set sc = ThisWorkbook.SlicerCaches(\"Slicer_Region\") ' Name might be Slicer_Region, Slicer_Region1 etc.\n'\n' If Not sc Is Nothing Then\n'   Set newSlicer = sc.Slicers.Add(SlicerDestination:=ActiveSheet, Name:=\"RegionSlicer\", Caption:=\"按區域篩選\", _\n'                                   Top:=10, Left:=500, Width:=150, Height:=200)\n'   MsgBox \"名為 '\" & newSlicer.Name & \"' 的交叉分析篩選器已新增。\"\n' End If", "explanation": "為樞紐分析表的 \"Region\" 欄位建立一個新的 SlicerCache (如果不存在)，然後根據該快取新增一個交叉分析篩選器到活動工作表上。"}
    ],
    "keywords": ["add slicer", "pivottable slicer", "excel slicer vba", "新增交叉分析篩選器"]
},
{
    "name": "Slicer.SlicerCacheLevel.SlicerItems",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set siColl = slicerObject.SlicerCache.SlicerCacheLevels(1).SlicerItems ' For non-OLAP, usually one level",
    "description": "傳回一個 SlicerItems 集合，代表交叉分析篩選器中的項目。可以設定 SlicerItem 的 .Selected 屬性來篩選資料。",
    "parameters": [],
    "examples": [
        {"code": "Dim sl As Slicer, si As SlicerItem\n' Set sl = ActiveSheet.Slicers(\"RegionSlicer\") ' Assume slicer exists\n' If Not sl Is Nothing Then\n'   ' Clear previous selections\n'   sl.SlicerCache.ClearAllFilters\n'   ' Select specific items\n'   On Error Resume Next ' Item may not exist\n'   sl.SlicerCache.SlicerCacheLevels(1).SlicerItems(\"East\").Selected = True\n'   sl.SlicerCache.SlicerCacheLevels(1).SlicerItems(\"West\").Selected = True\n'   ' To deselect all others, one common way is to select the first one, then others, then deselect the first if it's not wanted.\n'   ' Or iterate and set Selected = False for items not in your desired list.\n'   On Error GoTo 0\n'   MsgBox \"交叉分析篩選器已設定為選取 'East' 和 'West'。\"\n' End If", "explanation": "獲取名為 \"RegionSlicer\" 的交叉分析篩選器，清除其目前篩選，然後設定為僅選取 \"East\" 和 \"West\" 項目。"}
    ],
    "keywords": ["slicer items", "filter with slicer vba", "sliceritem selected", "交叉分析篩選器項目"]
},
{
    "name": "PivotField.ClearAllFilters (PivotTable Filter)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.ClearAllFilters",
    "description": "清除套用於指定 PivotField 的任何篩選 (包括手動篩選、標籤篩選、值篩選或頁面欄位篩選)。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Category As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Category = pt.PivotFields(\"Product Category\")\n' ' Apply some filter first for demonstration (e.g., through UI or code)\n' ' ...\n' pf_Category.ClearAllFilters\n' pt.RefreshTable ' Refresh table to see effect if data source changed or for some filter types\n' MsgBox \"'Product Category' 欄位的所有篩選已被清除。\"", "explanation": "清除樞紐分析表中 \"Product Category\" 欄位上的所有篩選。"}
    ],
    "keywords": ["clear pivotfield filter", "reset field filter", "清除欄位篩選"]
},
{
    "name": "PivotTable.ManualUpdate Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.ManualUpdate = True | False",
    "description": "如果樞紐分析表報表僅在使用者要求時才重新計算 (設為 True)，則為 True。預設為 False (自動更新)。將其設為 True 可以在進行多項更改時提高效能，然後再呼叫 RefreshTable。",
    "parameters": [{"name": "True | False", "description": "True 表示手動更新，False 表示自動更新。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(\"MyPivot\")\n' pt.ManualUpdate = True ' Defer updates\n' ' ... Make multiple changes to pivot table layout or fields ...\n' pt.PivotFields(\"Region\").Orientation = xlRowField\n' pt.PivotFields(\"Sales\").Orientation = xlDataField\n' pt.ManualUpdate = False ' Re-enable auto-update AND triggers a refresh\n' ' Or: pt.RefreshTable ' explicitly refresh if needed before setting ManualUpdate to False\n' MsgBox \"樞紐分析表已在手動更新模式下修改，然後重新啟用自動更新。\"", "explanation": "在對樞紐分析表進行多項結構性更改前，將其設定為手動更新模式以避免每次更改都觸發重算，完成更改後再恢復自動更新 (通常會觸發一次刷新)。"}
    ],
    "keywords": ["pivottable manual update", "defer pivot refresh", "pivottable performance", "樞紐分析表手動更新"]
},
// FSO
{
    "name": "FileSystemObject.GetFileVersion (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "versionString = fso.GetFileVersion(FilePath)",
    "description": "傳回指定檔案的版本號 (字串)。如果檔案沒有版本資訊，則傳回空字串。",
    "parameters": [{"name": "FilePath", "description": "必需。檔案的完整路徑。"}],
    "examples": [
        {"code": "Dim fso As Object, ver As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nver = fso.GetFileVersion(Environ(\"SystemRoot\") & \"\\System32\\notepad.exe\")\nIf ver <> \"\" Then\n  MsgBox \"Notepad.exe 的檔案版本是: \" & ver\nElse\n  MsgBox \"無法獲取 Notepad.exe 的檔案版本資訊。\"\nEnd If\nSet fso = Nothing", "explanation": "獲取 Windows 記事本程式 (notepad.exe) 的檔案版本號。"}
    ],
    "keywords": ["fso getfileversion", "file version info", "獲取檔案版本"]
},
// Math
{
    "name": "WorksheetFunction.AverageIf (Excel)",
    "category": "數學、日期與時間",
    "syntax": "avgResult = Application.WorksheetFunction.AverageIf(Range, Criteria, [Average_Range])",
    "description": "使用 Excel 的 AVERAGEIF 工作表函數，計算範圍中符合指定條件的所有儲存格的平均值。",
    "parameters": [
        {"name": "Range", "description": "必需。要評估條件的一個或多個儲存格。"},
        {"name": "Criteria", "description": "必需。定義哪些儲存格將被平均的條件。"},
        {"name": "Average_Range", "description": "可選。要計算平均值的實際儲存格集。如果省略，則使用 Range。"}
    ],
    "examples": [
        {"code": "' Assume A1:A5 has categories, B1:B5 has values\n' Range(\"A1:B5\").Value = Application.Transpose(Array(Array(\"Fruit\",10),Array(\"Veg\",20),Array(\"Fruit\",15),Array(\"Dairy\",25),Array(\"Fruit\",12)))\nDim avgFruit As Double\nOn Error Resume Next ' Handle if no matching criteria\navgFruit = Application.WorksheetFunction.AverageIf(Range(\"A1:A5\"), \"Fruit\", Range(\"B1:B5\"))\nIf Err.Number = 0 Then\n  MsgBox \"水果類別的平均值是: \" & Format(avgFruit, \"0.00\") ' (10+15+12)/3 = 12.33\nElse\n  MsgBox \"無法計算平均值 (例如，沒有符合條件的水果)。\"\nEnd If\nOn Error GoTo 0", "explanation": "計算A欄中類別為 \"Fruit\" 的所有對應B欄值的平均值。"}
    ],
    "keywords": ["averageif", "conditional average", "excel averageif vba", "條件平均"]
},
{
    "name": "WorksheetFunction.SumIfs (Excel)",
    "category": "數學、日期與時間",
    "syntax": "sumResult = Application.WorksheetFunction.SumIfs(Sum_Range, Criteria_Range1, Criteria1, [Criteria_Range2, Criteria2], ...)",
    "description": "使用 Excel 的 SUMIFS 工作表函數，對一組儲存格中符合多個條件的儲存格進行加總。",
    "parameters": [
        {"name": "Sum_Range", "description": "必需。要加總的實際儲存格範圍。"},
        {"name": "Criteria_Range1", "description": "必需。第一個要評估條件的範圍。"},
        {"name": "Criteria1", "description": "必需。應用於 Criteria_Range1 的第一個條件。"},
        {"name": "Criteria_RangeN, CriteriaN", "description": "可選。額外的條件範圍和條件。"}
    ],
    "examples": [
        {"code": "' A=Region, B=Product, C=Sales\n' Range(\"A1:C5\").Value = Application.Transpose(Array(Array(\"East\",\"Apple\",100),Array(\"West\",\"Apple\",150),Array(\"East\",\"Banana\",200),Array(\"East\",\"Apple\",50),Array(\"West\",\"Banana\",120)))\nDim totalEastApples As Double\ntotalEastApples = Application.WorksheetFunction.SumIfs(Range(\"C1:C5\"), Range(\"A1:A5\"), \"East\", Range(\"B1:B5\"), \"Apple\")\nMsgBox \"東區Apple的總銷售額是: \" & totalEastApples ' Should be 100+50=150", "explanation": "計算A欄為 \"East\" 且B欄為 \"Apple\" 的所有對應C欄銷售額的總和。"}
    ],
    "keywords": ["sumifs", "multiple criteria sum", "excel sumifs vba", "多條件加總"]
},
{
    "name": "WorksheetFunction.AverageIfs (Excel)",
    "category": "數學、日期與時間",
    "syntax": "avgResult = Application.WorksheetFunction.AverageIfs(Average_Range, Criteria_Range1, Criteria1, [Criteria_Range2, Criteria2], ...)",
    "description": "使用 Excel 的 AVERAGEIFS 工作表函數，計算一組儲存格中符合多個條件的所有儲存格的平均值。",
    "parameters": [
        {"name": "Average_Range", "description": "必需。要計算平均值的實際儲存格範圍。"},
        {"name": "Criteria_Range1", "description": "必需。第一個條件範圍。"},
        {"name": "Criteria1", "description": "必需。第一個條件。"}
    ],
    "examples": [
        {"code": "' Assume previous SumIfs example data\nDim avgEastApples As Double\nOn Error Resume Next\navgEastApples = Application.WorksheetFunction.AverageIfs(Range(\"C1:C5\"), Range(\"A1:A5\"), \"East\", Range(\"B1:B5\"), \"Apple\")\nIf Err.Number = 0 Then\n  MsgBox \"東區Apple的平均銷售額是: \" & Format(avgEastApples, \"0.00\") ' (100+50)/2 = 75\nElse\n  MsgBox \"無法計算平均值。\"\nEnd If\nOn Error GoTo 0", "explanation": "計算A欄為 \"East\" 且B欄為 \"Apple\" 的所有對應C欄銷售額的平均值。"}
    ],
    "keywords": ["averageifs", "multiple criteria average", "excel averageifs vba", "多條件平均"]
},
// Data Types
{
    "name": "Type Mismatch Error (Runtime Error 13)",
    "category": "資料類型、轉換與驗證",
    "description": "當嘗試在不相容的資料類型之間執行操作或賦值時，會發生執行階段錯誤 13「類型不符」。例如，試圖將文字字串與數字相加，或將非日期格式的字串直接賦給 Date 類型變數。",
    "parameters": [],
    "examples": [
        {"code": "Sub TypeMismatchExample()\n  Dim num As Integer\n  Dim strVal As String: strVal = \"abc\"\n  On Error Resume Next ' To catch the error for demonstration\n  num = 10 + strVal ' This will cause Error 13\n  If Err.Number = 13 Then\n    MsgBox \"發生類型不符錯誤! 無法將數字與字串相加。\"\n    Err.Clear\n  End If\n  On Error GoTo 0\nEnd Sub", "explanation": "演示一個典型的類型不符錯誤：試圖將一個整數和一個字串相加。使用 On Error Resume Next 來捕獲並處理此錯誤。"}
    ],
    "keywords": ["type mismatch error", "runtime error 13", "data type compatibility", "vba error 13", "類型不符錯誤", "執行階段錯誤13"]
},
// Program Flow
{
    "name": "WithEvents (Usage in UserForm)",
    "category": "程式流程與結構控制",
    "syntax": "Private WithEvents MyButton As MSForms.CommandButton",
    "description": "在 UserForm 的程式碼模組中，使用 WithEvents 宣告窗體上的控制項 (例如按鈕、文字方塊)，以便為這些控制項撰寫事件處理程序 (例如 Click, Change)。",
    "parameters": [
        {"name": "MyButton", "description": "在程式碼中代表窗體上某個控制項的變數名稱。"},
        {"name": "MSForms.CommandButton", "description": "控制項的實際類型 (例如，CommandButton, TextBox, ComboBox)。"}
    ],
    "examples": [
        {"code": "' --- In a UserForm's code module (e.g., UserForm1) ---\n' ' Assume there is a CommandButton named 'CommandButton1' on the UserForm.\n' Private WithEvents MySpecialButton As MSForms.CommandButton\n'\n' Private Sub UserForm_Initialize()\n'   Set MySpecialButton = Me.CommandButton1 ' Link the WithEvents variable to the actual control\n' End Sub\n'\n' Private Sub MySpecialButton_Click()\n'   MsgBox \"MySpecialButton (CommandButton1) was clicked!\"\n' End Sub\n'\n' ' To show the form:\n' ' Sub ShowMyForm()\n' '   UserForm1.Show\n' ' End Sub", "explanation": "演示如何在 UserForm 的程式碼模組中使用 WithEvents 關鍵字來宣告一個 CommandButton，然後為其 Click 事件撰寫一個事件處理程序。在 UserForm_Initialize 事件中，將 WithEvents 變數與窗體上實際的控制項連結起來。"}
    ],
    "keywords": ["withevents userform", "form control events", "handle button click vba", "userform event procedure", "UserForm事件處理"]
},
// Excel 核心操作
{
    "name": "Range.Offset(0,0) Behavior",
    "category": "Excel 核心操作",
    "syntax": "Set sameRange = rangeObject.Offset(0, 0)",
    "description": "當 Offset 方法的 RowOffset 和 ColumnOffset 引數都為 0 時，它會傳回原始的 Range 物件本身。",
    "parameters": [
        {"name": "RowOffset", "description": "設為 0。"},
        {"name": "ColumnOffset", "description": "設為 0。"}
    ],
    "examples": [
        {"code": "Dim rng1 As Range, rng2 As Range\nSet rng1 = Range(\"A1\")\nSet rng2 = rng1.Offset(0, 0)\nMsgBox \"rng1 address: \" & rng1.Address & vbCrLf & \"rng2 address: \" & rng2.Address & vbCrLf & \"Are they the same object? \" & (rng1 Is rng2)", "explanation": "演示 Offset(0,0) 傳回與原始範圍相同的物件參考 (通常為 True，但嚴格的物件比較可能因 Excel 內部實現而異，傳回的 Range 物件具有相同的位址和內容)。最重要的結果是位址相同。"}
    ],
    "keywords": ["offset zero", "identity range", "excel", "no offset"]
},
{
    "name": "Workbook.ActiveSheet Property (Workbook Level)",
    "category": "Excel 核心操作",
    "syntax": "Set actSheet = workbookObject.ActiveSheet",
    "description": "傳回一個物件，代表指定活頁簿中的活動工作表。如果沒有工作表處於活動狀態 (例如，活頁簿剛開啟且沒有任何工作表被選取)，則可能傳回 Nothing 或第一個工作表，取決於情境。",
    "parameters": [],
    "examples": [
        {"code": "Dim wb As Workbook, currentSheet As Worksheet\nSet wb = ThisWorkbook\n' Ensure a sheet is active by selecting one if needed\n' wb.Sheets(1).Activate ' Uncomment if needed\nOn Error Resume Next ' In case no sheet is truly active\nSet currentSheet = wb.ActiveSheet\nOn Error GoTo 0\nIf Not currentSheet Is Nothing Then\n  MsgBox \"活頁簿 '\" & wb.Name & \"' 的活動工作表是: \" & currentSheet.Name\nElse\n  MsgBox \"活頁簿 '\" & wb.Name & \"' 當前沒有活動的工作表。\"\nEnd If", "explanation": "獲取特定活頁簿物件 (此處為 ThisWorkbook) 中的活動工作表。"}
    ],
    "keywords": ["workbook activesheet", "current sheet in workbook", "excel", "active sheet specific workbook"]
},
{
    "name": "Range.Address (RelativeTo in R1C1)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Address(ReferenceStyle:=xlR1C1, RelativeTo:=RangeObject)",
    "description": "以 R1C1 樣式傳回相對於指定儲存格的儲存格範圍參照。",
    "parameters": [
        {"name": "ReferenceStyle:=xlR1C1", "description": "指定 R1C1 樣式。"},
        {"name": "RelativeTo", "description": "必需。指定傳回相對位址的基準儲存格。"}
    ],
    "examples": [
        {"code": "MsgBox Range(\"C5\").Address(ReferenceStyle:=xlR1C1, RelativeTo:=Range(\"A1\")) ' C5相對於A1是RC", "explanation": "獲取儲存格C5相對於儲存格A1的R1C1樣式相對位址。C是A右邊2欄 (C)，5是1下面4列 (R)。"},
        {"code": "MsgBox Range(\"A1\").Address(ReferenceStyle:=xlR1C1, RelativeTo:=Range(\"C5\")) ' A1相對於C5是R[-4]C[-2]", "explanation": "獲取儲存格A1相對於儲存格C5的R1C1樣式相對位址。A是C左邊2欄 (C[-2])，1是5上面4列 (R[-4])。"}
    ],
    "keywords": ["r1c1 relative address", "relative r1c1", "excel", "address r1c1 relative"]
},
{
    "name": "Range.Borders.LineStyle (Various Styles)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Borders(BorderIndex).LineStyle = XlLineStyleConstant",
    "description": "設定框線的線條樣式。XlLineStyleConstant 可以是 xlContinuous, xlDot, xlDash, xlDashDot, xlDashDotDot, xlDouble, xlSlantDashDot, xlLineStyleNone 等。",
    "parameters": [
        {"name": "BorderIndex", "description": "XlBordersIndex 常數 (例如 xlEdgeBottom, xlInsideVertical)。"},
        {"name": "XlLineStyleConstant", "description": "線條樣式常數。"}
    ],
    "examples": [
        {"code": "With Range(\"A1\")\n  .Borders(xlEdgeBottom).LineStyle = xlDouble ' 底部雙線\n  .Borders(xlEdgeBottom).Color = vbRed\n  .Borders(xlEdgeLeft).LineStyle = xlDashDot ' 左側點破折線\n  .Borders(xlEdgeLeft).Weight = xlThick\nEnd With\nMsgBox \"A1儲存格已設定不同樣式的框線。\"", "explanation": "為A1儲存格的底部設定紅色雙實線框線，為左側設定粗點破折線框線。"}
    ],
    "keywords": ["border linestyle", "excel line styles", "dashed border", "dotted border", "框線樣式", "虛線框線"]
},
{
    "name": "Range.CommentThreaded Property (Excel - Modern Comments)",
    "category": "Excel 核心操作",
    "syntax": "Set cmtThread = rangeObject.CommentThreaded\ncmtThread.AddReply \"This is a reply.\"",
    "description": "傳回代表附加到儲存格的執行緒式註解 (新式註解) 的 CommentThreaded 物件。如果儲存格沒有執行緒式註解，則傳回 Nothing。",
    "parameters": [],
    "examples": [
        {"code": "Dim cmtTh As CommentThreaded\n' Ensure A1 has a modern threaded comment first (add manually or via VBA)\n' Range(\"A1\").AddCommentThreaded \"Initial threaded comment.\"\nOn Error Resume Next ' If no threaded comment\nSet cmtTh = Range(\"A1\").CommentThreaded\nOn Error GoTo 0\nIf Not cmtTh Is Nothing Then\n  MsgBox \"A1的第一條執行緒式註解: \" & cmtTh.Replies(1).Text\n  cmtTh.AddReply \"VBA 自動回覆!\"\n  MsgBox \"已向A1的執行緒式註解新增回覆。\"\nElse\n  MsgBox \"A1儲存格沒有執行緒式註解。\"\nEnd If", "explanation": "如果A1儲存格有新式執行緒註解，則獲取其第一個回覆的內容，並新增一個新的自動回覆。"}
    ],
    "keywords": ["threaded comment", "modern comments excel", "comment replies", "執行緒式註解", "新式註解"]
},
{
    "name": "Application.CheckSpelling (Excel)",
    "category": "Excel 核心操作",
    "syntax": "isCorrect = Application.CheckSpelling(Word As String, [CustomDictionary], [IgnoreUppercase As Boolean = False])",
    "description": "檢查單字的拼字。傳回 True 如果單字拼字正確或在字典中找到，否則傳回 False。",
    "parameters": [
        {"name": "Word", "description": "必需。要檢查的單字。"},
        {"name": "CustomDictionary", "description": "可選。要使用的自訂字典檔案名稱。"},
        {"name": "IgnoreUppercase", "description": "可選。True 表示忽略全大寫單字。"}
    ],
    "examples": [
        {"code": "If Application.CheckSpelling(\"Aplle\") = False Then\n  MsgBox \"'Aplle' 拼字錯誤。\"\nElse\n  MsgBox \"'Aplle' 拼字正確 (或不在檢查範圍)。\"\nEnd If\nIf Application.CheckSpelling(\"Excel\", IgnoreUppercase:=True) Then\n  MsgBox \"'Excel' 拼字正確 (大寫被忽略)。\"", "explanation": "檢查 \"Aplle\" (錯誤) 和 \"Excel\" (正確，但可忽略大寫) 的拼字。"}
    ],
    "keywords": ["check spelling", "spell check excel", "validate word", "拼字檢查"]
},
{
    "name": "Workbook.ChangeFileAccess (Excel)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.ChangeFileAccess(Mode As XlFileAccess, [WritePassword], [Notify])",
    "description": "變更活頁簿的存取模式。例如，可以將唯讀活頁簿變更為讀寫模式 (如果可能)。",
    "parameters": [
        {"name": "Mode", "description": "必需。XlFileAccess 常數 (例如 xlReadOnly, xlReadWrite)。"},
        {"name": "WritePassword", "description": "可選。如果活頁簿有寫入保護密碼，則為該密碼。"},
        {"name": "Notify", "description": "可選。如果檔案無法立即存取，True 表示通知使用者。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook\n' Set wb = Workbooks.Open(\"C:\\Path\\ReadOnlyFile.xlsx\", ReadOnly:=True)\n' If wb.ReadOnly Then\n'   On Error Resume Next ' May fail if file is locked by another process\n'   wb.ChangeFileAccess Mode:=xlReadWrite, WritePassword:=\"password_if_any\"\n'   If Err.Number = 0 And Not wb.ReadOnly Then\n'     MsgBox wb.Name & \" 現在是讀寫模式。\"\n'     ' wb.Save ' Now you can save changes\n'   Else\n'     MsgBox \"無法變更檔案存取模式為讀寫。錯誤: \" & Err.Description\n'   End If\n'   On Error GoTo 0\n' End If", "explanation": "如果一個活頁簿是以唯讀模式開啟的，此範例嘗試將其變更為讀寫模式。"}
    ],
    "keywords": ["change file access", "readonly to readwrite", "excel file mode", "變更檔案存取"]
},
{
    "name": "Worksheet.CircularReference Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set circRefCell = worksheetObject.CircularReference",
    "description": "傳回一個 Range 物件，代表工作表上第一個包含循環參照的儲存格。如果工作表上沒有循環參照，則傳回 Nothing。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim circRef As Range\nOn Error Resume Next ' If no circular reference, this causes an error without this line\nSet circRef = ActiveSheet.CircularReference\nOn Error GoTo 0\nIf Not circRef Is Nothing Then\n  MsgBox \"在 \" & ActiveSheet.Name & \" 中找到循環參照，第一個位於: \" & circRef.Address\n  circRef.Select\nElse\n  MsgBox \"在 \" & ActiveSheet.Name & \" 中沒有找到循環參照。\"\nEnd If", "explanation": "檢查活動工作表是否有循環參照，如果有，則顯示第一個包含循環參照的儲存格位址並選取它。"}
    ],
    "keywords": ["circular reference", "find circular reference", "excel formula error", "循環參照"]
},
{
    "name": "Range.DirectDependents / .DirectPrecedents (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set directDeps = rangeObject.DirectDependents\nSet directPrecs = rangeObject.DirectPrecedents",
    "description": "DirectDependents 傳回一個 Range 物件，代表該儲存格的所有直接引用儲存格。DirectPrecedents 傳回一個 Range 物件，代表該儲存格的所有直接前導儲存格。僅追蹤活動工作表上的儲存格。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = 1\nRange(\"A2\").Value = 2\nRange(\"B1\").Formula = \"=A1*10\"\nRange(\"B2\").Formula = \"=A2*10\"\nRange(\"C1\").Formula = \"=B1+B2\"\nDim dDeps As Range, dPrecs As Range\n' Direct Dependents of A1\nSet dDeps = Range(\"A1\").DirectDependents: If Not dDeps Is Nothing Then Debug.Print \"A1 Direct Deps: \" & dDeps.Address ' B1\n' Direct Precedents of C1\nSet dPrecs = Range(\"C1\").DirectPrecedents: If Not dPrecs Is Nothing Then Debug.Print \"C1 Direct Precs: \" & dPrecs.Address ' B1:B2", "explanation": "演示如何獲取A1的直接引用儲存格 (B1) 和C1的直接前導儲存格 (B1和B2)。"}
    ],
    "keywords": ["direct dependents", "direct precedents", "formula trace", "直接引用", "直接前導"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.RowGrand / .ColumnGrand Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.RowGrand = BooleanValue\npivotTableObject.ColumnGrand = BooleanValue",
    "description": "設定或傳回樞紐分析表報表是否顯示列總計 (RowGrand) 或欄總計 (ColumnGrand)。讀取/寫入布林值。",
    "parameters": [{"name": "BooleanValue", "description": "True 表示顯示總計，False 表示隱藏。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' If Not pt Is Nothing Then\n'   pt.RowGrand = True    ' Show grand totals for rows\n'   pt.ColumnGrand = False ' Hide grand totals for columns\n'   MsgBox \"樞紐分析表已設定顯示列總計並隱藏欄總計。\"\n' End If", "explanation": "設定樞紐分析表以顯示列的總計，但隱藏欄的總計。"}
    ],
    "keywords": ["pivottable grand total", "rowgrand", "columngrand", "show totals pivot", "樞紐分析表總計"]
},
{
    "name": "PivotField.Subtotals Property (Array)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.Subtotals = Array(Boolean, Boolean, ..., Boolean) ' Array of 12 booleans\npivotFieldObject.Subtotals(Index As XlSubtotalLocationType) = Boolean",
    "description": "設定或傳回樞紐分析表欄位的小計類型。可以設定一個包含12個布林值的陣列，對應11種小計函數 (Sum, Count, Average, Max, Min, Product, CountNums, StDev, StDevP, Var, VarP) 外加自動小計。或者，可以透過索引 (1到11) 單獨設定特定小計函數的顯示與否。",
    "parameters": [
        {"name": "Array(Boolean...)", "description": "12個布林值的陣列。第一個元素對應自動小計，後續11個對應各種函數。"},
        {"name": "Subtotals(Index)", "description": "索引1=Sum, 2=Count, ..., 11=VarP。設為True以顯示該小計。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\") ' Assume Region is a row or column field\n' ' Show only Sum and Count subtotals for Region field\n' Dim subtotalFlags(1 To 12) As Boolean\n' ' Index 1 for Sum, Index 2 for Count. All others false.\n' subtotalFlags(1) = True ' Sum\n' subtotalFlags(2) = True ' Count\n' ' (all others default to False if array is freshly Dim'd)\n' pf_Region.Subtotals = subtotalFlags\n' ' Alternatively, to turn off all except Sum:\n' ' pf_Region.Subtotals(1) = True ' Sum\n' ' For i = 2 To 11: pf_Region.Subtotals(i) = False: Next i\n' MsgBox \"'Region' 欄位的小計已設定為僅顯示Sum和Count。\"", "explanation": "為樞紐分析表中的 \"Region\" 欄位設定小計，使其僅顯示 Sum 和 Count 兩種小計。"}
    ],
    "keywords": ["pivotfield subtotals", "custom subtotals", "sum subtotal", "count subtotal", "欄位小計設定"]
},
{
    "name": "PivotField.DragTo Method",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.DragTo(Destination As XlPivotFieldOrientation)",
    "description": "將欄位拖曳 (移動) 到樞紐分析表報表的另一個位置 (列、欄、頁面、資料區域或隱藏)。這與設定 Orientation 屬性類似，但更直觀地模擬拖放操作。",
    "parameters": [
        {"name": "Destination", "description": "必需。XlPivotFieldOrientation 常數，指定欄位要移動到的新位置。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Salesperson As PivotField\n' Set pt = ActiveSheet.PivotTables(\"SalesPivot\")\n' Set pf_Salesperson = pt.PivotFields(\"Salesperson\")\n' ' If Salesperson field is currently, e.g., a Row field, move it to be a Page field\n' If pf_Salesperson.Orientation = xlRowField Then\n'   pf_Salesperson.DragTo xlPageField\n'   MsgBox \"'Salesperson' 欄位已從列區域拖曳到頁面/篩選區域。\"\n' End If", "explanation": "如果 \"Salesperson\" 欄位目前位於列區域，則將其拖曳 (移動) 到頁面/篩選區域。"}
    ],
    "keywords": ["pivotfield dragto", "move pivot field", "rearrange pivottable", "拖曳欄位", "重排樞紐分析表"]
},
{
    "name": "SlicerCache.ClearManualFilter",
    "category": "Excel 資料分析與樞紐",
    "syntax": "slicerCacheObject.ClearManualFilter",
    "description": "清除套用於指定 SlicerCache 的任何手動篩選。這會重設交叉分析篩選器以顯示所有項目 (除非有其他篩選，例如來自其他交叉分析篩選器或報表篩選的交叉篩選)。",
    "parameters": [],
    "examples": [
        {"code": "Dim sc_Product As SlicerCache\n' On Error Resume Next ' In case SlicerCache doesn't exist\n' Set sc_Product = ThisWorkbook.SlicerCaches(\"Slicer_Product_Name\") ' Name depends on field\n' If Not sc_Product Is Nothing Then\n'   sc_Product.ClearManualFilter\n'   MsgBox \"產品交叉分析篩選器的手動篩選已清除。\"\n' Else\n'   MsgBox \"未找到名為 'Slicer_Product_Name' 的 SlicerCache。\"\n' End If\n' On Error GoTo 0", "explanation": "清除名為 \"Slicer_Product_Name\" 的 SlicerCache 上的所有手動篩選，使關聯的交叉分析篩選器顯示所有可用項目。"}
    ],
    "keywords": ["slicercache clear filter", "reset slicer", "clear manual filter", "清除交叉分析篩選器"]
},
{
    "name": "SlicerItem.HasData Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "booleanResult = slicerItemObject.HasData",
    "description": "如果交叉分析篩選器項目在套用所有目前交叉分析篩選器後仍包含資料，則傳回 True。如果項目因其他交叉分析篩選器的篩選而變暗 (沒有可用資料)，則傳回 False。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim sl As Slicer, si As SlicerItem\n' Set sl = ActiveSheet.Slicers(\"ProductCategorySlicer\")\n' If Not sl Is Nothing Then\n'   For Each si In sl.SlicerCache.SlicerCacheLevels(1).SlicerItems\n'     If Not si.HasData Then\n'       Debug.Print \"交叉分析篩選器項目 '\" & si.Name & \"' 當前沒有可用資料 (可能因其他篩選器而變暗)。\"\n'       ' si.Selected = False ' Optionally deselect items with no data\n'     End If\n'   Next si\n' End If", "explanation": "遍歷 \"ProductCategorySlicer\" 交叉分析篩選器中的所有項目，並檢查哪些項目因為其他篩選器的作用而沒有可用數據 (在UI中顯示為灰色)。"}
    ],
    "keywords": ["sliceritem hasdata", "slicer item disabled", "check slicer data", "交叉分析篩選器項目是否有資料"]
},
// FSO
{
    "name": "Folder.Files.Count Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "numberOfFiles = folderObject.Files.Count",
    "description": "傳回指定資料夾中檔案的數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myFolder As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFolder = fso.GetFolder(\"C:\\Windows\")\nMsgBox \"C:\\Windows 資料夾包含 \" & myFolder.Files.Count & \" 個檔案 (不含子資料夾中的檔案)。\"", "explanation": "顯示 C:\\Windows 資料夾中直接包含的檔案數量。"}
    ],
    "keywords": ["fso folder files count", "number of files in folder", "資料夾檔案數量"]
},
{
    "name": "Folder.SubFolders.Count Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "numberOfSubFolders = folderObject.SubFolders.Count",
    "description": "傳回指定資料夾中子資料夾的數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myFolder As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFolder = fso.GetFolder(\"C:\\Program Files\")\nMsgBox \"C:\\Program Files 資料夾包含 \" & myFolder.SubFolders.Count & \" 個子資料夾。\"", "explanation": "顯示 C:\\Program Files 資料夾中直接包含的子資料夾數量。"}
    ],
    "keywords": ["fso folder subfolders count", "number of subfolders", "資料夾子資料夾數量"]
},
// String
{
    "name": "Like Operator (# Wildcard)",
    "category": "字串與文本操作",
    "syntax": "stringResult Like \"pattern#pattern\"",
    "description": "Like 運算子中的井號 (#) 萬用字元匹配任何單個數字 (0–9)。",
    "parameters": [{"name": "#", "description": "匹配0到9之間的任何單個數字。"}],
    "examples": [
        {"code": "Debug.Print \"ID-007\" Like \"ID-###\"   ' True\nDebug.Print \"ProductA5\" Like \"ProductA#\" ' True\nDebug.Print \"CodeX\" Like \"Code#\"       ' False (X is not a digit)", "explanation": "演示如何使用 # 萬用字元來匹配字串中的特定數字位置。"}
    ],
    "keywords": ["like operator digit", "pattern matching number", "# wildcard", "數字萬用字元"]
},
// Data Types
{
    "name": "Object Variable Assignment (Is vs =)",
    "category": "資料類型、轉換與驗證",
    "description": "比較兩個物件變數時，應使用 Is 運算子來判斷它們是否參考同一個物件實例。使用等號 (=) 比較物件變數通常會比較它們的預設屬性 (如果有的話)，或者產生類型不符錯誤，而不是比較物件參考本身。",
    "parameters": [
        {"name": "Is Operator", "description": "比較兩個物件變數是否指向記憶體中的同一個物件。"},
        {"name": "= Operator", "description": "用於比較值類型變數或物件的預設屬性 (不建議用於比較物件參考)。"}
    ],
    "examples": [
        {"code": "Dim ws1 As Worksheet, ws2 As Worksheet, ws3 As Worksheet\nSet ws1 = ThisWorkbook.Sheets(1)\nSet ws2 = ThisWorkbook.Sheets(1)\nSet ws3 = ThisWorkbook.Sheets(2)\n\nIf ws1 Is ws2 Then Debug.Print \"ws1 和 ws2 參考同一個工作表物件。\"\nIf ws1 Is ws3 Then Debug.Print \"ws1 和 ws3 參考同一個工作表物件。\" Else Debug.Print \"ws1 和 ws3 參考不同的工作表物件。\"\n\n' Avoid using '=' for object comparison of reference:\n' On Error Resume Next ' This would likely error or give misleading result\n' If ws1 = ws2 Then Debug.Print \"(Using =) ws1 equals ws2 (default property comparison)\"\n' On Error GoTo 0", "explanation": "演示 Is 運算子如何正確比較物件參考。ws1 和 ws2 都指向第一個工作表，所以 `ws1 Is ws2` 為 True。ws3 指向第二個工作表，所以 `ws1 Is ws3` 為 False。不建議使用等號比較物件參考。"}
    ],
    "keywords": ["object comparison", "is operator", "object reference equality", "comparing objects", "物件比較", "Is運算子"]
},
// Program Flow
{
    "name": "Stop Statement (Conditional)",
    "category": "程式流程與結構控制",
    "syntax": "If condition Then Stop",
    "description": "在滿足特定條件時暫停程式執行，進入中斷模式。這對於在複雜邏輯中特定點進行調試非常有用。",
    "parameters": [{"name": "condition", "description": "一個布林表達式。"}],
    "examples": [
        {"code": "Sub ProcessItems(itemsCount As Long)\n  Dim i As Long\n  For i = 1 To itemsCount\n    ' Some processing for each item\n    If i = 500 And itemsCount > 1000 Then\n      Debug.Print \"達到第500個項目，且總數大於1000，暫停檢查。\"\n      Stop ' Execution pauses here if condition met\n    End If\n    ' Continue processing\n  Next i\nEnd Sub\n' ProcessItems 1200 ' This call will trigger the Stop statement", "explanation": "如果迴圈變數 i 達到500且總項目數大於1000，則 Stop 語句會使程式在中斷模式下暫停，允許開發者檢查當時的變數狀態。"}
    ],
    "keywords": ["conditional stop", "debug break condition", "pause on condition", "條件暫停", "調試中斷"]
},
// Excel 核心操作
{
    "name": "Range.Validation.Modify",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.Modify([Type As XlDVType], [AlertStyle As XlDVAlertStyle], [Operator As XlFormatConditionOperator], [Formula1], [Formula2])",
    "description": "修改現有的資料驗證規則。如果範圍中有多種驗證規則，則會修改第一個驗證規則。",
    "parameters": [
        {"name": "Type", "description": "可選。XlDVType 常數，指定新的驗證類型。"},
        {"name": "Formula1", "description": "可選。新的 Formula1。"}
    ],
    "examples": [
        {"code": "' Assume A1 has existing validation (e.g., whole number between 1 and 10)\n' On Error Resume Next ' If no validation exists, this will error\n' Range(\"A1\").Validation.Modify Type:=xlValidateWholeNumber, Formula1:=\"5\", Formula2:=\"20\"\n' If Err.Number = 0 Then MsgBox \"A1的資料驗證已修改為介於5和20之間的整數。\" Else MsgBox \"A1沒有資料驗證或修改失敗。\"\n' On Error GoTo 0", "explanation": "修改A1儲存格的現有資料驗證，將其條件更改為允許介於5和20之間的整數。"}
    ],
    "keywords": ["修改資料驗證", "更新驗證規則", "excel", "modify data validation", "update validation"]
},
{
    "name": "Range.Phonetic Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set phoneticObject = rangeObject.Phonetic",
    "description": "傳回代表儲存格中特定注音假名文字字串的 Phonetic 物件。主要用於日文版 Excel。",
    "parameters": [],
    "examples": [
        {"code": "Dim phText As Phonetic\n' Range(\"A1\").Value = \"日本語\" ' Add Japanese text\n' Range(\"A1\").Phonetics.Add Start:=1, Length:=3, Text:=\"ニホンゴ\" ' Add phonetic info\n' Set phText = Range(\"A1\").Phonetic\n' If Not phText Is Nothing Then\n'   MsgBox \"A1的注音文字: \" & phText.Text & \" (可見性: \" & phText.Visible & \")\"\n'   phText.Visible = True ' Make phonetic text visible above the characters\n' End If", "explanation": "獲取A1儲存格的 Phonetic 物件，並顯示其注音文字及其可見性狀態。"}
    ],
    "keywords": ["phonetic object", "furigana excel", "japanese phonetic", "注音假名物件"]
},
{
    "name": "ActiveWindow.DisplayGridlines Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "ActiveWindow.DisplayGridlines [= Boolean]",
    "description": "如果顯示格線，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "Boolean", "description": "True 表示顯示格線，False 表示隱藏。"}],
    "examples": [
        {"code": "If ActiveWindow.DisplayGridlines Then\n  MsgBox \"格線目前是可見的。現在隱藏它們。\"\n  ActiveWindow.DisplayGridlines = False\nElse\n  MsgBox \"格線目前是隱藏的。現在顯示它們。\"\n  ActiveWindow.DisplayGridlines = True\nEnd If", "explanation": "切換活動視窗中格線的顯示狀態。"}
    ],
    "keywords": ["顯示格線", "隱藏格線", "excel gridlines", "toggle gridlines"]
},
{
    "name": "ActiveWindow.DisplayHeadings Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "ActiveWindow.DisplayHeadings [= Boolean]",
    "description": "如果顯示列和欄標題，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "Boolean", "description": "True 表示顯示標題，False 表示隱藏。"}],
    "examples": [
        {"code": "ActiveWindow.DisplayHeadings = False\nMsgBox \"列和欄標題已隱藏。\"\nActiveWindow.DisplayHeadings = True\nMsgBox \"列和欄標題已重新顯示。\"", "explanation": "隱藏然後再顯示活動視窗的列和欄標題。"}
    ],
    "keywords": ["顯示標題", "隱藏標題", "excel headings", "row column headers"]
},
{
    "name": "Workbook.Names.Item().Delete (Excel Named Range)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.Names.Item(IndexOrName).Delete",
    "description": "從活頁簿的 Names 集合中刪除指定的已定義名稱。",
    "parameters": [{"name": "IndexOrName", "description": "必需。名稱的索引號或名稱本身 (字串)。"}],
    "examples": [
        {"code": "On Error Resume Next ' In case the name doesn't exist\nThisWorkbook.Names(\"ObsoleteNamedRange\").Delete\nIf Err.Number = 0 Then\n  MsgBox \"名稱 'ObsoleteNamedRange' 已被刪除。\"\nElse\n  MsgBox \"名稱 'ObsoleteNamedRange' 未找到或無法刪除。\"\nEnd If\nOn Error GoTo 0", "explanation": "嘗試刪除活頁簿中名為 \"ObsoleteNamedRange\" 的已定義名稱。"}
    ],
    "keywords": ["刪除名稱", "移除已命名範圍", "excel delete named range", "names collection delete"]
},
{
    "name": "Range.MergeArea Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set mergedAreaRange = rangeObject.MergeArea",
    "description": "如果指定的儲存格位於一個合併區域中，則傳回代表該整個合併區域的 Range 物件。如果儲存格未合併，則傳回該儲存格本身。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1:C1\").Merge\nDim ma As Range\nSet ma = Range(\"B1\").MergeArea\nMsgBox \"B1所在的合併區域是: \" & ma.Address ' 傳回 \"$A$1:$C$1\"", "explanation": "合併A1:C1，然後獲取B1儲存格所在的合併區域 (即A1:C1)。"},
        {"code": "If Not Range(\"D5\").MergeCells Then\n  MsgBox \"D5不是合併儲存格，MergeArea將只傳回D5本身: \" & Range(\"D5\").MergeArea.Address\nEnd If", "explanation": "如果D5未合併，則其MergeArea屬性將只傳回D5本身。"}
    ],
    "keywords": ["合併區域", "獲取合併範圍", "excel mergearea", "merged cell range"]
},
{
    "name": "Range.Cells(RowIndex, ColumnIndex) (Specific Access)",
    "category": "Excel 核心操作",
    "syntax": "Set specificCell = rangeObject.Cells(RowIndex, ColumnIndex)",
    "description": "在一個現有的 Range 物件內，按相對的列和欄索引存取特定的單個儲存格。",
    "parameters": [
        {"name": "RowIndex", "description": "必需。相對於 rangeObject 左上角的列索引 (1-based)。"},
        {"name": "ColumnIndex", "description": "必需。相對於 rangeObject 左上角的欄索引 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim myBlock As Range, cell_2_3 As Range\nSet myBlock = Range(\"B5:D10\")\n' Get the cell at 2nd row, 3rd column *within* myBlock (i.e., D6)\nSet cell_2_3 = myBlock.Cells(2, 3)\nMsgBox \"myBlock中第2列第3欄的儲存格是: \" & cell_2_3.Address ' 傳回 $D$6\ncell_2_3.Value = \"Relative Access\"", "explanation": "定義一個範圍B5:D10，然後使用 .Cells(2,3) 存取該範圍內的第二列第三欄 (即儲存格D6)。"}
    ],
    "keywords": ["range relative cell", "cells within range", "excel specific cell in range", "相對儲存格存取"]
},
{
    "name": "Range.Hyperlinks(Index).Follow (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Hyperlinks(Index).Follow([NewWindow], [AddHistory], [ExtraInfo], [Method], [HeaderInfo])",
    "description": "開啟 (追蹤) 指定儲存格中特定索引的超連結。",
    "parameters": [{"name": "Index", "description": "必需。儲存格中超連結的索引號 (如果一個儲存格有多個超連結，通常是1)。"}],
    "examples": [
        {"code": "' Assume A1 has a hyperlink\n' If Range(\"A1\").Hyperlinks.Count > 0 Then\n'   On Error Resume Next ' In case hyperlink is invalid\n'   Range(\"A1\").Hyperlinks(1).Follow NewWindow:=True\n'   If Err.Number <> 0 Then MsgBox \"無法開啟超連結: \" & Err.Description\n'   On Error GoTo 0\n' End If", "explanation": "如果A1儲存格包含超連結，則嘗試在新視窗中開啟第一個超連結。"}
    ],
    "keywords": ["follow hyperlink vba", "open link from cell", "excel hyperlink follow", "追蹤超連結"]
},
{
    "name": "Worksheet.Shapes.SelectAll (Excel)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Shapes.SelectAll",
    "description": "選取工作表上的所有圖案。選取後，可以使用 Selection 物件對所有選取的圖案進行操作。",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Shapes.SelectAll\nIf TypeName(Selection) = \"DrawingObjects\" Then\n  MsgBox Selection.Count & \" 個圖案已被選取。\"\n  ' Selection.Delete ' Example: delete all selected shapes\n  Range(\"A1\").Select ' Deselect shapes\nElse\n  MsgBox \"沒有圖案被選取或選取失敗。\"\nEnd If", "explanation": "選取活動工作表上的所有圖案，然後顯示選取的圖案數量。"}
    ],
    "keywords": ["select all shapes", "excel shapes selection", "選取所有圖案"]
},
{
    "name": "Range.InsertIndent (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.InsertIndent(InsertAmount As Long)",
    "description": "將指定範圍的內容縮排指定的層級數。每層縮排對應於標準字型大小的一個字元寬度。",
    "parameters": [
        {"name": "InsertAmount", "description": "必需。要增加的縮排層級數。可以是正數 (增加縮排) 或負數 (減少縮排)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"層級1\"\nRange(\"A2\").Value = \"層級2\"\nRange(\"A3\").Value = \"層級3\"\nRange(\"A2\").InsertIndent 1 ' Indent A2 by 1 level\nRange(\"A3\").InsertIndent 2 ' Indent A3 by 2 levels\nMsgBox \"A2和A3儲存格已設定縮排。\"", "explanation": "為A2儲存格增加1級縮排，為A3儲存格增加2級縮排。"}
    ],
    "keywords": ["縮排", "儲存格縮排", "excel indent", "text indentation"]
},
{
    "name": "Range.FormatConditions.Add (Excel Conditional Formatting)",
    "category": "Excel 核心操作",
    "syntax": "Set fc = rangeObject.FormatConditions.Add(Type As XlFormatConditionType, [Operator], [Formula1], [Formula2], [String], [TextOperator], [DateOperator], [ScopeType])",
    "description": "將新的條件格式新增到指定的範圍。傳回一個代表新條件格式的 FormatCondition 物件。",
    "parameters": [
        {"name": "Type", "description": "必需。XlFormatConditionType 常數 (例如，xlCellValue, xlExpression, xlTop10, xlUniqueValues, xlTextString)。"},
        {"name": "Operator", "description": "可選 (但通常與 Type 一起使用)。XlFormatConditionOperator 常數 (例如，xlBetween, xlGreater, xlEqual)。"},
        {"name": "Formula1", "description": "可選。條件的第一個值或公式。"},
        {"name": "Formula2", "description": "可選。條件的第二個值或公式 (如果 Operator 需要)。"}
    ],
    "examples": [
        {"code": "Dim dataRange As Range, fc As FormatCondition\nSet dataRange = Range(\"A1:A10\")\ndataRange.FormatConditions.Delete ' Clear existing conditions\n' Highlight cells with values greater than 50\nSet fc = dataRange.FormatConditions.Add(Type:=xlCellValue, Operator:=xlGreater, Formula1:=\"50\")\nWith fc.Interior\n  .Color = RGB(255, 100, 100) ' Light red fill\nEnd With\nMsgBox \"A1:A10中大於50的儲存格已設定條件格式。\"", "explanation": "為範圍A1:A10新增一個條件格式，將值大於50的儲存格背景設為淺紅色。"}
    ],
    "keywords": ["條件格式", "新增條件格式", "excel conditional formatting", "formatcondition add"]
},
{
    "name": "FormatCondition.Modify (Excel Conditional Formatting)",
    "category": "Excel 核心操作",
    "syntax": "formatConditionObject.Modify(Type As XlFormatConditionType, [Operator], [Formula1], [Formula2], [String], [TextOperator], [DateOperator])",
    "description": "修改現有的條件格式規則。",
    "parameters": [
        {"name": "Type", "description": "必需。XlFormatConditionType 常數。"},
        {"name": "Formula1", "description": "可選。新的 Formula1。"}
    ],
    "examples": [
        {"code": "Dim fcToModify As FormatCondition\n' Assume Range(\"A1\") has one conditional format already applied\nIf Range(\"A1\").FormatConditions.Count > 0 Then\n  Set fcToModify = Range(\"A1\").FormatConditions(1)\n  ' Modify it to highlight if value is less than 20\n  fcToModify.Modify Type:=xlCellValue, Operator:=xlLess, Formula1:=\"20\"\n  fcToModify.Font.Bold = True\n  fcToModify.Interior.Color = vbYellow\n  MsgBox \"A1的條件格式已修改。\"\nElse\n  MsgBox \"A1沒有條件格式可修改。\"\nEnd If", "explanation": "如果A1儲存格有條件格式，則修改第一個條件格式規則，使其在值小於20時將字型設為粗體且背景為黃色。"}
    ],
    "keywords": ["修改條件格式", "更新條件格式", "excel formatcondition modify"]
},
{
    "name": "Range.FormatConditions.Delete (Excel Conditional Formatting)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormatConditions.Delete",
    "description": "刪除指定範圍上的所有條件格式規則。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"B1:B10\").FormatConditions.Delete\nMsgBox \"範圍B1:B10上的所有條件格式已被刪除。\"", "explanation": "刪除B1:B10範圍內所有儲存格的條件格式設定。"}
    ],
    "keywords": ["刪除條件格式", "清除條件格式", "excel formatconditions delete"]
},
{
    "name": "Workbook.Connections Property (Excel Data Connections)",
    "category": "Excel 核心操作",
    "syntax": "Set conns = workbookObject.Connections",
    "description": "傳回代表活頁簿中所有資料連線的 Connections 集合。每個連線都是一個 WorkbookConnection 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As WorkbookConnection\nIf ThisWorkbook.Connections.Count > 0 Then\n  MsgBox \"此活頁簿共有 \" & ThisWorkbook.Connections.Count & \" 個資料連線。\"\n  For Each conn In ThisWorkbook.Connections\n    Debug.Print \"連線名稱: \" & conn.Name & \", 類型: \" & conn.Type & \", 描述: \" & conn.Description\n    ' conn.Refresh ' To refresh the connection\n  Next conn\nElse\n  MsgBox \"此活頁簿沒有資料連線。\"\nEnd If", "explanation": "遍歷目前活頁簿中的所有資料連線，並列印其名稱、類型和描述。"}
    ],
    "keywords": ["資料連線", "excel data connections", "workbook connections", "connection object"]
},
{
    "name": "Range.FillDown / .FillRight / .FillUp / .FillLeft (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FillDown\nrangeObject.FillRight\nrangeObject.FillUp\nrangeObject.FillLeft",
    "description": "從指定範圍的頂部儲存格向下填充 (FillDown)，從左側儲存格向右填充 (FillRight)，依此類推。填充內容包括值和格式。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Sample\"\nRange(\"A1:A5\").FillDown ' Fills A2:A5 with the value and format of A1\nRange(\"B1\").Formula = \"=A1*2\"\nRange(\"B1:E1\").FillRight ' Fills C1:E1 with formulas relative to B1\nMsgBox \"A1:A5已向下填充，B1:E1已向右填充。\"", "explanation": "演示FillDown和FillRight的用法。FillDown將A1的值和格式複製到A2:A5。FillRight將B1的公式（相對調整）複製到C1:E1。"}
    ],
    "keywords": ["向下填充", "向右填充", "excel filldown", "excel fillright", "autofill range"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.PivotFields.Count",
    "category": "Excel 資料分析與樞紐",
    "syntax": "longCount = pivotTableObject.PivotFields.Count",
    "description": "傳回 PivotTable 物件中 PivotField 物件的數量 (包括隱藏的欄位)。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' If Not pt Is Nothing Then\n'   MsgBox \"樞紐分析表 '\" & pt.Name & \"' 共有 \" & pt.PivotFields.Count & \" 個欄位。\"\n' End If", "explanation": "顯示活動工作表上第一個樞紐分析表包含的欄位總數。"}
    ],
    "keywords": ["pivotfields count", "number of pivot fields", "樞紐分析表欄位數"]
},
{
    "name": "PivotField.DataRange Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set dataValueRange = pivotFieldObject.DataRange",
    "description": "傳回一個 Range 物件，代表包含樞紐分析表欄位數據值的範圍。對於列或欄欄位，這通常是其項目標籤的範圍；對於資料欄位，則是其值的範圍。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Sales As PivotField, salesValues As Range\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Sales = pt.DataFields(\"Sum of Sales\") ' Assuming 'Sum of Sales' is a data field\n' If Not pf_Sales Is Nothing Then\n'   Set salesValues = pf_Sales.DataRange\n'   If Not salesValues Is Nothing Then\n'     salesValues.NumberFormat = \"_(\"\"*\"\" #,##0.00_);_(\"\"*\"\" (#,##0.00);_(\"\"*\"\" \"\"-\"\"??_);_(@_)\" ' Accounting format\n'     MsgBox \"'Sum of Sales' 數據範圍 ('\" & salesValues.Address & \"') 已設定會計格式。\"\n'   End If\n' End If", "explanation": "獲取樞紐分析表中 \"Sum of Sales\" 資料欄位的數據範圍，並將其設定為會計數字格式。"}
    ],
    "keywords": ["pivotfield datarange", "pivot data values", "欄位數據範圍"]
},
{
    "name": "PivotField.LabelRange Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set labelCellRange = pivotFieldObject.LabelRange",
    "description": "傳回一個 Range 物件，代表包含樞紐分析表欄位標籤的儲存格。對於列、欄或頁面欄位，這是包含欄位名稱的儲存格。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField, regionLabel As Range\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\")\n' If Not pf_Region Is Nothing Then\n'   Set regionLabel = pf_Region.LabelRange\n'   If Not regionLabel Is Nothing Then\n'     regionLabel.Font.Bold = True\n'     MsgBox \"欄位 '\" & pf_Region.Name & \"' 的標籤 ('\" & regionLabel.Address & \"') 已設為粗體。\"\n'   End If\n' End If", "explanation": "獲取樞紐分析表中 \"Region\" 欄位的標籤儲存格，並將其字型設為粗體。"}
    ],
    "keywords": ["pivotfield labelrange", "pivot field header", "欄位標籤範圍"]
},
{
    "name": "Slicer.ActiveItem Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set activeSlicerItem = slicerObject.ActiveItem",
    "description": "傳回一個 SlicerItem 物件，代表交叉分析篩選器中目前具有焦點的按鈕。如果交叉分析篩選器沒有焦點或焦點不在任何按鈕上，則傳回 Nothing。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim sl As Slicer, activeSI As SlicerItem\n' On Error Resume Next ' Slicer may not exist or have focus\n' Set sl = ActiveSheet.Slicers(\"MyRegionSlicer\")\n' If Not sl Is Nothing Then\n'   sl.Activate ' Ensure slicer itself has focus for ActiveItem to be meaningful for user interaction context\n'   Set activeSI = sl.ActiveItem\n'   If Not activeSI Is Nothing Then\n'     MsgBox \"交叉分析篩選器 '\" & sl.Name & \"' 中的活動項目是: \" & activeSI.Name\n'   Else\n'     MsgBox \"交叉分析篩選器 '\" & sl.Name & \"' 中沒有活動項目，或篩選器本身沒有焦點。\"\n'   End If\n' End If\n' On Error GoTo 0", "explanation": "如果存在名為 \"MyRegionSlicer\" 的交叉分析篩選器，則嘗試獲取其活動項目並顯示其名稱。"}
    ],
    "keywords": ["slicer activeitem", "focused slicer item", "交叉分析篩選器活動項目"]
},
{
    "name": "SlicerCache.SourceType Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "slicerCacheType = slicerCacheObject.SourceType",
    "description": "傳回 SlicerCache 的資料來源類型。可以是 xlDatabase (來自工作表範圍或表格的非 OLAP 樞紐分析表)、xlExternal (來自 OLAP Cube 或 Power Pivot 的樞紐分析表)。唯讀 XlPivotTableSourceType。",
    "parameters": [],
    "examples": [
        {"code": "Dim sc As SlicerCache\n' On Error Resume Next\n' Set sc = ThisWorkbook.SlicerCaches(\"Slicer_ProductCategory\")\n' If Not sc Is Nothing Then\n'   Select Case sc.SourceType\n'     Case 1: MsgBox \"交叉分析篩選器來源類型: xlDatabase (工作表/表格)\"\n'     Case 2: MsgBox \"交叉分析篩選器來源類型: xlExternal (OLAP/Power Pivot)\"\n'     Case Else: MsgBox \"交叉分析篩選器來源類型: 其他 (\" & sc.SourceType & \")\"\n'   End Select\n' Else\n'   MsgBox \"未找到 SlicerCache。\"\n' End If", "explanation": "獲取名為 \"Slicer_ProductCategory\" 的 SlicerCache 的來源類型，並顯示其描述。"}
    ],
    "keywords": ["slicercache sourcetype", "slicer data source", "交叉分析篩選器來源類型"]
},
{
    "name": "PivotTable.DisplayNullString Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.DisplayNullString = BooleanValue\npivotTableObject.NullString = StringValue",
    "description": "DisplayNullString 決定是否在包含 Null 值的儲存格中顯示 NullString。NullString 屬性設定要顯示的字串。",
    "parameters": [
        {"name": "DisplayNullString (Boolean)", "description": "True 表示顯示 NullString，False 表示顯示空白。"},
        {"name": "NullString (String)", "description": "當 DisplayNullString 為 True 時，用於取代 Null 值的字串。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' If Not pt Is Nothing Then\n'   pt.DisplayNullString = True\n'   pt.NullString = \"(無資料)\"\n'   MsgBox \"樞紐分析表將為空值顯示 '(無資料)'。\"\n' End If", "explanation": "設定樞紐分析表，使其在包含空 (Null) 值的資料儲存格中顯示 \"(無資料)\" 字串。"}
    ],
    "keywords": ["pivottable nullstring", "display empty as pivot", "處理樞紐分析表空值"]
},
{
    "name": "PivotField.DrillTo (OLAP PivotTable)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.DrillTo(FieldName As String)",
    "description": "對於 OLAP 樞紐分析表，此方法允許從目前欄位向下鑽研到另一個相關的欄位層級。",
    "parameters": [
        {"name": "FieldName", "description": "必需。要鑽研到的欄位名稱 (在 OLAP Cube 中的層次結構名稱)。"}
    ],
    "examples": [
        {"code": "' Dim pt As PivotTable, pf_DateHierarchy As PivotField\n' ' Set pt = ActiveSheet.PivotTables(\"SalesOLAPCube\")\n' ' If pt.PivotCache.OLAP Then\n' '   Set pf_DateHierarchy = pt.PivotFields(\"[Date].[Calendar Hierarchy]\") ' Example OLAP date hierarchy\n' '   On Error Resume Next\n' '   ' Drill from Year level (assuming it's current) to Quarter level\n' '   pf_DateHierarchy.DrillTo \"[Date].[Calendar Hierarchy].[Calendar Quarter]\"\n' '   If Err.Number = 0 Then\n' '     MsgBox \"已從日期層次向下鑽研到季度層級。\"\n' '   Else\n' '     MsgBox \"向下鑽研失敗: \" & Err.Description\n' '   End If\n' '   On Error GoTo 0\n' ' Else\n' '   MsgBox \"此功能主要適用於OLAP樞紐分析表。\"\n' ' End If", "explanation": "如果樞紐分析表基於 OLAP 資料來源，並且有一個名為 \"[Date].[Calendar Hierarchy]\" 的日期層次欄位，此範例嘗試從目前層級向下鑽研到 \"[Date].[Calendar Hierarchy].[Calendar Quarter]\" 層級。"}
    ],
    "keywords": ["pivotfield drillto", "olap drill down", "pivottable olap navigation", "OLAP向下鑽研"]
},
{
    "name": "PivotTable.Allocation Property (OLAP - What-If Analysis)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.Allocation = XlAllocationValueConstant\npivotTableObject.AllocateChanges\npivotTableObject.DiscardChanges",
    "description": "設定或傳回當執行假設分析 (What-If Analysis) 時如何在 OLAP 樞紐分析表中分配值。AllocateChanges 方法執行分配。DiscardChanges 放棄變更。",
    "parameters": [
        {"name": "Allocation (XlAllocationValueConstant)", "description": "例如 xlAllocateValue, xlAllocateIncrement。"},
        {"name": "AllocateChanges()", "description": "方法：將變更寫回 OLAP 資料來源 (如果提供者支援)。"},
        {"name": "DiscardChanges()", "description": "方法：放棄在樞紐分析表中所做的所有假設分析變更。"}
    ],
    "examples": [
        {"code": "' Dim pt As PivotTable\n' ' Set pt = ActiveSheet.PivotTables(\"SalesForecastCube\")\n' ' If pt.PivotCache.OLAP And pt.EnableWriteback Then ' Requires writeback enabled OLAP cube\n' '   pt.Allocation = xlAllocateValue ' How to allocate changes\n' '   ' User makes changes to values in the PivotTable data area for what-if\n' '   ' For example, change a total and see how it might be allocated to children\n' '   On Error Resume Next\n' '   pt.PivotFields(\"Sales Amount\").DataRange.Cells(1).Value = pt.PivotFields(\"Sales Amount\").DataRange.Cells(1).Value * 1.1 ' Increase first data point by 10%\n' '   pt.AllocateChanges ' Attempt to write these changes back to the OLAP source\n' '   If Err.Number = 0 Then\n' '     MsgBox \"假設分析變更已嘗試分配。\"\n' '   Else\n' '     MsgBox \"分配變更失敗: \" & Err.Description\n' '     pt.DiscardChanges ' Rollback if allocation failed\n' '   End If\n' '   On Error GoTo 0\n' ' Else\n' '   MsgBox \"此功能需要可寫回的OLAP樞紐分析表。\"\n' ' End If", "explanation": "如果樞紐分析表基於一個支援寫回的 OLAP Cube，此範例演示如何設定值分配方法，在使用者對樞紐分析表中的資料進行假設性變更後，嘗試使用 AllocateChanges 將這些變更寫回資料來源。如果失敗，則使用 DiscardChanges 放棄變更。"}
    ],
    "keywords": ["pivottable allocation", "what-if analysis pivot", "olap writeback", "假設分析", "OLAP值分配"]
},
// Excel 核心操作
{
    "name": "Range.Copy (Destination Range)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Copy Destination:=destinationRangeObject",
    "description": "將指定的儲存格範圍複製並貼到指定的目標儲存格範圍。這是一個單一步驟的複製貼上操作。",
    "parameters": [
        {"name": "Destination", "description": "必需。Range 物件，指定複製內容要貼上的左上角儲存格或整個目標範圍。"}
    ],
    "examples": [
        {"code": "Range(\"A1:B5\").Copy Destination:=Range(\"D1\")", "explanation": "將範圍 A1:B5 的內容和格式複製並貼到以 D1 為左上角的區域 (即 D1:E5)。"},
        {"code": "Sheets(\"Sheet1\").Range(\"C1:C10\").Copy Destination:=Sheets(\"Sheet2\").Range(\"A1\")", "explanation": "將 Sheet1 上的 C1:C10 範圍複製到 Sheet2 上的 A1 開始的區域。"}
    ],
    "keywords": ["複製貼上範圍", "直接複製到", "excel", "copy paste range", "direct copy"]
},
{
    "name": "Worksheet.Calculate (Specific Sheet)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Calculate",
    "description": "計算指定工作表上的所有公式。如果 Application.Calculation 設為 xlCalculationManual，這很有用。",
    "parameters": [],
    "examples": [
        {"code": "Application.Calculation = xlCalculationManual\nSheets(\"Sheet1\").Range(\"A1\").Value = Now ' Change a value\n' Formulas on Sheet1 dependent on A1 will not update yet\nSheets(\"Sheet1\").Calculate ' Now formulas on Sheet1 are recalculated\nMsgBox \"Sheet1 上的公式已重新計算。\"\nApplication.Calculation = xlCalculationAutomatic", "explanation": "將計算模式設為手動，修改 Sheet1 上的數據，然後僅重新計算 Sheet1。"}
    ],
    "keywords": ["計算特定工作表", "recalculate sheet", "excel sheet calculate", "手動計算後刷新"]
},
{
    "name": "Workbook.SaveCopyAs (Excel)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.SaveCopyAs(Filename As String)",
    "description": "將活頁簿的副本儲存到檔案，但不修改記憶體中開啟的活頁簿。原始活頁簿的 Saved 屬性不受影響。",
    "parameters": [
        {"name": "Filename", "description": "必需。儲存副本的檔案名稱 (字串，可包含完整路徑)。"}
    ],
    "examples": [
        {"code": "Dim backupPath As String\nbackupPath = \"C:\\ExcelBackups\\\" & Left(ThisWorkbook.Name, InStrRev(ThisWorkbook.Name, \".\") - 1) & \"_Backup_\" & Format(Now, \"yyyymmddhhmmss\") & \".xlsx\"\nOn Error Resume Next\nThisWorkbook.SaveCopyAs backupPath\nIf Err.Number = 0 Then\n  MsgBox \"活頁簿副本已儲存到: \" & backupPath\nElse\n  MsgBox \"儲存副本失敗: \" & Err.Description\nEnd If\nOn Error GoTo 0\n' ThisWorkbook.Saved remains unchanged by SaveCopyAs", "explanation": "將目前活頁簿的副本以包含時間戳的新名稱儲存到備份資料夾，而不會影響目前開啟活頁簿的儲存狀態。"}
    ],
    "keywords": ["儲存副本", "另存備份", "excel savecopyas", "backup workbook"]
},
{
    "name": "Range.TextToColumns (FixedWidth Example)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.TextToColumns(Destination, DataType:=xlFixedWidth, FieldInfo, [DecimalSeparator], [ThousandsSeparator])",
    "description": "使用固定寬度將包含文字的儲存格範圍解析成多個欄。",
    "parameters": [
        {"name": "Destination", "description": "必需。Range 物件，指定解析後資料放置的左上角儲存格。"},
        {"name": "DataType:=xlFixedWidth", "description": "指定固定寬度解析。"},
        {"name": "FieldInfo", "description": "必需。一個陣列，包含解析資訊。每個二元素子陣列指定一個欄的起始位置 (0-based) 和資料類型 (例如，Array(Array(0, 1), Array(5, 1), Array(10, 2)) 表示第一欄從位置0開始，第二欄從位置5開始，都為一般格式(1)；第三欄從位置10開始，為文字格式(2))。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Part1ValuePart2\"\nRange(\"A2\").Value = \"ItemXMoreData\"\n' FieldInfo: Col1 starts at 0, Col2 at 5, Col3 at 10\nDim fieldInfoArray As Variant\nfieldInfoArray = Array(Array(0, 1), Array(5, 1), Array(10, 1)) ' All general format\nRange(\"A1:A2\").TextToColumns Destination:=Range(\"B1\"), DataType:=xlFixedWidth, FieldInfo:=fieldInfoArray\nMsgBox \"A1:A2的內容已按固定寬度分欄到B欄開始的區域。\"", "explanation": "將A1和A2儲存格的內容按固定寬度分割，第一部分從字元0開始，第二部分從字元5開始，第三部分從字元10開始，結果輸出到B1開始的區域。"}
    ],
    "keywords": ["texttocolumns fixedwidth", "固定寬度分欄", "parse fixed width", "資料剖析固定寬度"]
},
{
    "name": "Range.Consolidate (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Consolidate(Sources, [Function As XlConsolidationFunction = xlSum], [TopRow As Boolean], [LeftColumn As Boolean], [CreateLinks As Boolean])",
    "description": "從多個來源範圍合併資料到指定的目的範圍 (rangeObject)。",
    "parameters": [
        {"name": "Sources", "description": "必需。一個字串陣列，指定來源範圍的位址 (例如 `Array(\"Sheet2!A1:B5\", \"Sheet3!A1:B5\")`) 或已命名範圍的名稱。"},
        {"name": "Function", "description": "可選。XlConsolidationFunction 常數，指定合併函數 (例如 xlSum, xlAverage, xlCount)。"},
        {"name": "TopRow / LeftColumn", "description": "可選。True 表示使用來源範圍的頂端列/左側欄作為標籤。"},
        {"name": "CreateLinks", "description": "可選。True 表示建立與來源資料的連結，以便目的範圍隨來源更新。"}
    ],
    "examples": [
        {"code": "' Assume Sheet2!A1:B5 and Sheet3!A1:B5 contain numbers, and Sheet1 is active\n' Clear previous consolidation if any\n' Range(\"A1:B5\").ClearContents \n' Range(\"A1\").Consolidate Sources:=Array(\"Sheet2!R1C1:R5C2\", \"Sheet3!R1C1:R5C2\"), Function:=xlSum, TopRow:=False, LeftColumn:=False, CreateLinks:=False\n' MsgBox \"Sheet2和Sheet3的數據已匯總到Sheet1的A1開始的區域。\" ' Uses R1C1 style in Sources array for robustness", "explanation": "將 Sheet2 和 Sheet3 上 A1:B5 範圍的數據使用 SUM 函數合併到目前活動工作表的 A1 儲存格開始的區域。注意 Sources 陣列中使用 R1C1 樣式參照以避免工作表名稱可能包含空格或特殊字元的問題。"}
    ],
    "keywords": ["合併計算", "數據匯總", "excel consolidate", "data consolidation", "summarize data from multiple sheets"]
},
{
    "name": "Range.FormulaHidden and Range.Locked (Interaction)",
    "category": "Excel 核心操作",
    "description": "當工作表受保護時，`Range.FormulaHidden = True` 會隱藏資料編輯列中的公式。`Range.Locked = True` (預設) 會阻止編輯儲存格。要同時隱藏公式並允許編輯儲存格 (罕見需求)，需要 `FormulaHidden = True` 且 `Locked = False`，然後保護工作表。通常，隱藏公式的儲存格也會被鎖定以防修改。",
    "parameters": [],
    "examples": [
        {"code": "With Range(\"A1\")\n  .Formula = \"=SUM(B1:B5)\"\n  .FormulaHidden = True ' Hide formula when sheet is protected\n  .Locked = True        ' Prevent editing when sheet is protected (default)\nEnd With\nWith Range(\"A2\")\n  .Value = \"Can edit this, but formula (if any) also hidden if set\"\n  .FormulaHidden = True ' Even if no formula, this can be set\n  .Locked = False       ' Allow editing when sheet is protected\nEnd With\nActiveSheet.Protect Password:=\"secret\"\nMsgBox \"A1公式已隱藏且鎖定，A2內容可編輯但其公式(如果有)也會被隱藏。\"", "explanation": "演示 `FormulaHidden` 和 `Locked` 屬性在工作表保護下的交互作用。"}
    ],
    "keywords": ["formula hidden locked", "protect sheet formula", "excel cell protection interaction"]
},
{
    "name": "Range.Validation.InputMessage / .ErrorMessage",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.InputMessage = stringMessage\nrangeObject.Validation.ErrorMessage = stringMessage",
    "description": "設定或傳回資料驗證的輸入訊息和錯誤訊息。InputMessage 在選取儲存格時顯示。ErrorMessage 在輸入無效資料時顯示。",
    "parameters": [
        {"name": "InputMessage", "description": "選取儲存格時顯示的提示文字。"},
        {"name": "ErrorMessage", "description": "輸入無效資料時顯示的錯誤訊息文字。"}
    ],
    "examples": [
        {"code": "With Range(\"A1\").Validation\n  .Delete\n  .Add Type:=xlValidateWholeNumber, Operator:=xlBetween, Formula1:=\"1\", Formula2:=\"10\"\n  .InputTitle = \"輸入提示\"\n  .InputMessage = \"請輸入1到10之間的整數。\"\n  .ErrorTitle = \"輸入錯誤\"\n  .ErrorMessage = \"您輸入的值無效！必須是1到10之間的整數。\"\n  .ShowInput = True\n  .ShowError = True\nEnd With\nMsgBox \"A1儲存格已設定資料驗證的輸入和錯誤訊息。\"", "explanation": "為A1儲存格設定資料驗證，並自訂選取時的輸入提示訊息和輸入錯誤時的錯誤警告訊息。"}
    ],
    "keywords": ["validation input message", "validation error message", "data validation prompt", "資料驗證提示", "資料驗證錯誤"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.DataFields Property / Method",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set dataFieldsCollection = pivotTableObject.DataFields\nSet specificDataField = pivotTableObject.DataFields(IndexOrName)",
    "description": "DataFields 屬性 (不帶參數) 傳回代表樞紐分析表中所有資料欄位 (值欄位) 的 PivotFields 集合。DataFields 方法 (帶參數) 傳回集合中單個資料欄位 (PivotField 物件)。",
    "parameters": [{"name": "IndexOrName", "description": "可選。資料欄位的索引號或其目前標題。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, df As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' If pt.DataFields.Count > 0 Then\n'   MsgBox \"第一個資料欄位的名稱是: \" & pt.DataFields(1).Name\n'   For Each df In pt.DataFields\n'     Debug.Print \"資料欄位: \" & df.SourceName & \" (顯示為: \" & df.Caption & \", 函數: \" & df.Function & \")\"\n'     df.NumberFormat = \"#,##0\" ' Example: Format all data fields\n'   Next df\n' Else\n'   MsgBox \"此樞紐分析表沒有資料欄位。\"\n' End If", "explanation": "遍歷樞紐分析表中的所有資料欄位，列印其來源名稱、目前顯示標題和摘要函數，並將它們的數字格式設定為整數。"}
    ],
    "keywords": ["pivottable datafields", "pivot value fields", "access data fields", "樞紐分析表資料欄位", "值欄位"]
},
{
    "name": "PivotTable.RowFields / .ColumnFields / .PageFields Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set rowFieldsColl = pivotTableObject.RowFields\nSet colFieldsColl = pivotTableObject.ColumnFields\nSet pageFieldsColl = pivotTableObject.PageFields",
    "description": "這些屬性分別傳回代表樞紐分析表中所有列欄位、欄欄位或頁面/篩選欄位的 PivotFields 集合。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf As PivotField\n' Set pt = ActiveSheet.PivotTables(\"SalesSummary\")\n' Debug.Print \"--- 列欄位 ---\"\n' For Each pf In pt.RowFields\n'   Debug.Print pf.Name\n' Next pf\n' Debug.Print \"--- 欄欄位 ---\"\n' For Each pf In pt.ColumnFields\n'   Debug.Print pf.Name\n' Next pf\n' Debug.Print \"--- 頁面/篩選欄位 ---\"\n' For Each pf In pt.PageFields\n'   Debug.Print pf.Name\n' Next pf", "explanation": "遍歷樞紐分析表 \"SalesSummary\" 中的所有列欄位、欄欄位和頁面欄位，並將其名稱列印到立即視窗。"}
    ],
    "keywords": ["pivottable rowfields", "pivottable columnfields", "pivottable pagefields", "pivot layout fields", "樞紐分析表佈局欄位"]
},
{
    "name": "PivotField.NumberFormat Property (PivotTable Data Field)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "dataPivotFieldObject.NumberFormat = formatString",
    "description": "設定或傳回樞紐分析表資料欄位中顯示數值的格式代碼。",
    "parameters": [{"name": "formatString", "description": "表示數字格式的字串代碼 (例如 \"$#,##0.00\", \"0.0%\", \"yyyy-mm-dd\")。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, df_Revenue As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' On Error Resume Next ' In case data field doesn't exist\n' Set df_Revenue = pt.DataFields(\"Sum of Revenue\")\n' If Not df_Revenue Is Nothing Then\n'   df_Revenue.NumberFormat = \"€#,##0.00;[Red]-€#,##0.00\" ' Euro format with negative in red\n'   MsgBox \"'Sum of Revenue' 資料欄位的數字格式已更新。\"\n' Else\n'   MsgBox \"未找到名為 'Sum of Revenue' 的資料欄位。\"\n' End If\n' On Error GoTo 0", "explanation": "設定樞紐分析表中名為 \"Sum of Revenue\" 的資料欄位的數字格式為歐元，負數顯示為紅色。"}
    ],
    "keywords": ["pivotfield numberformat", "format pivot data field", "樞紐分析表數字格式"]
},
{
    "name": "PivotTable.RefreshDataSourceValues (Memory Optimization)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.PivotCache.RefreshDataSourceValues = True | False",
    "description": "RefreshDataSourceValues 是一個不直接存在於 PivotTable 或 PivotCache 物件上的屬性。然而，管理 PivotCache 的 `MissingItemsLimit` 和 `UpgradeOnRefresh` 屬性，以及正確地刷新 (`PivotCache.Refresh` / `PivotTable.RefreshTable`)，可以影響記憶體使用和效能。`MissingItemsLimit` (例如 `xlMissingItemsNone` 或 `xlMissingItemsDefault`) 控制是否保留已從資料來源中移除的舊項目。設定為 `xlMissingItemsNone` 可以在刷新時清除不再存在的項目，有助於減少快取大小和潛在的記憶體佔用。",
    "parameters": [
        {"name": "PivotCache.MissingItemsLimit", "description": "XlMissingItemsLimit 常數。`xlMissingItemsNone` 不保留已刪除項目。"},
        {"name": "PivotCache.UpgradeOnRefresh", "description": "如果可能，在刷新時將 PivotCache 升級到最新版本。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, pc As PivotCache\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pc = pt.PivotCache\n' ' To potentially reduce memory by not retaining items removed from source:\npc.MissingItemsLimit = xlMissingItemsNone ' 0 = xlMissingItemsNone\n' pc.UpgradeOnRefresh = True ' Ensure cache is up-to-date format on refresh\n' pc.Refresh ' Refresh the cache from the source\n' pt.RefreshTable ' Refresh the PivotTable report itself\n' MsgBox \"PivotCache設定已調整以優化，並已刷新。\"", "explanation": "設定 PivotCache 在刷新時不保留已從資料來源中移除的項目，並在可能的情況下升級快取格式，然後刷新快取和樞紐分析表。這有助於管理快取大小和效能。"}
    ],
    "keywords": ["pivotcache missingitemslimit", "optimize pivotcache memory", "refresh pivot data source values", "樞紐分析表快取優化"]
},
{
    "name": "PivotTable.ColumnGrand / .RowGrand (Toggle Visibility)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.ColumnGrand = True | False\npivotTableObject.RowGrand = True | False",
    "description": "設定樞紐分析表是否顯示欄總計或列總計。",
    "parameters": [{"name": "True | False", "description": "True表示顯示，False表示隱藏。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' pt.ColumnGrand = False ' Hide column grand totals\n' pt.RowGrand = True    ' Ensure row grand totals are visible\n' MsgBox \"欄總計已隱藏，列總計已顯示。\"", "explanation": "隱藏樞紐分析表的欄總計，同時確保列總計是可見的。"}
    ],
    "keywords": ["pivottable grand totals", "show hide grand totals", "總計顯示切換"]
},
{
    "name": "PivotField.LayoutBlankLine Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.LayoutBlankLine = True | False",
    "description": "如果在指定樞紐分析表欄位的每個項目之後插入一個空白列，則為 True。僅適用於以列表形式顯示的欄位。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True表示在每個項目後插入空白列。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\") ' Assume Region is a row field\n' ' Ensure the field is in Tabular or Outline form for this to have a visible effect\n' pt.RowAxisLayout xlTabularRow ' Or xlOutlineRow\n' pf_Region.LayoutBlankLine = True\n' MsgBox \"'Region' 欄位的每個項目後已插入空白列。\"", "explanation": "設定樞紐分析表的 \"Region\" 列欄位，在其每個項目後插入一個空白列，前提是樞紐分析表的報表版面配置是列表或大綱形式。"}
    ],
    "keywords": ["pivotfield layoutblankline", "insert blank row pivot", "樞紐分析表項目間隔"]
},
{
    "name": "PivotTable.RepeatAllItemLabels",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.RepeatAllItemLabels(Repeat As XlPivotFieldRepeatLabels)",
    "description": "設定樞紐分析表中的所有 PivotField 是否重複項目標籤。",
    "parameters": [
        {"name": "Repeat", "description": "必需。XlPivotFieldRepeatLabels 常數 (例如，xlRepeatLabels, xlDoNotRepeatLabels)。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' ' To repeat all item labels in the PivotTable:\n' pt.RepeatAllItemLabels xlRepeatLabels\n' MsgBox \"樞紐分析表中的所有項目標籤已設定為重複顯示。\"\n' ' To turn off repetition for all fields:\n' ' pt.RepeatAllItemLabels xlDoNotRepeatLabels", "explanation": "將樞紐分析表中所有欄位的項目標籤設定為重複顯示。"}
    ],
    "keywords": ["pivottable repeatallitemlabels", "repeat item labels", "樞紐分析表重複項目標籤"]
},
{
    "name": "PivotField.RepeatLabels Property (Individual Field)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.RepeatLabels = True | False",
    "description": "如果為指定 PivotField 重複項目標籤，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示重複標籤。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Category As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Category = pt.PivotFields(\"Category\") ' Assume Category is a row field\n' pf_Category.RepeatLabels = True\n' MsgBox \"'Category' 欄位的項目標籤已設定為重複。\"", "explanation": "單獨設定 \"Category\" 欄位的項目標籤為重複顯示。"}
    ],
    "keywords": ["pivotfield repeatlabels", "repeat specific field labels", "重複特定欄位標籤"]
},
// Word 文件處理
{
    "name": "Document.SaveAs (Word - Legacy)",
    "category": "Word 文件處理",
    "syntax": "wdDoc.SaveAs(FileName, [FileFormat], [LockComments], [Password], ...)",
    "description": "將 Word 文件以不同的名稱或格式儲存。這是較舊的 SaveAs 方法，對於新版 Word (2007+)，建議使用 SaveAs2 以獲得更完整的格式支援。",
    "parameters": [
        {"name": "FileName", "description": "必需。新檔案的名稱 (字串，可包含路徑)。"},
        {"name": "FileFormat", "description": "可選。WdSaveFormat 常數，指定檔案格式 (例如，wdFormatDocument, wdFormatText, wdFormatRTF)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument ' Assuming in Word VBA context\n' On Error Resume Next\n' wdDoc.SaveAs FileName:=\"C:\\LegacyDocs\\Report_OldFormat.doc\", FileFormat:=0 ' 0 = wdFormatDocument (for .doc)\n' If Err.Number = 0 Then MsgBox \"文件已另存為舊版 .doc 格式。\"\n' On Error GoTo 0", "explanation": "將目前文件另存為舊版 Word 97-2003 文件格式 (.doc)。"}
    ],
    "keywords": ["word saveas legacy", "save as .doc word", "wdformatdocument", "儲存為舊版Word"]
},
{
    "name": "Selection.Characters.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "charCount = selectionObject.Characters.Count",
    "description": "傳回指定選取範圍中字元的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\n' Set sel = Application.Selection\n' If sel.Type = wdSelectionNormal Then ' If text is selected\n'   MsgBox \"選取的文字包含 \" & sel.Characters.Count & \" 個字元。\"\n' Else\n'   MsgBox \"沒有文字被選取。\"\n' End If", "explanation": "如果使用者在 Word 中選取了文字，則計算並顯示選取文字的字元數。"}
    ],
    "keywords": ["word selection character count", "count selected characters", "選取字元計數"]
},
{
    "name": "Selection.Words.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "wordCount = selectionObject.Words.Count",
    "description": "傳回指定選取範圍中單字的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\n' Set sel = Application.Selection\n' If sel.Type = wdSelectionNormal Then\n'   MsgBox \"選取的文字包含 \" & sel.Words.Count & \" 個單字。\"\n' End If", "explanation": "如果使用者在 Word 中選取了文字，則計算並顯示選取文字的單字數。"}
    ],
    "keywords": ["word selection word count", "count selected words", "選取單字計數"]
},
{
    "name": "Selection.Paragraphs.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "paraCount = selectionObject.Paragraphs.Count",
    "description": "傳回指定選取範圍中段落的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\n' Set sel = Application.Selection\n' If sel.Type = wdSelectionNormal Then\n'   MsgBox \"選取的文字跨越 \" & sel.Paragraphs.Count & \" 個段落。\"\n' End If", "explanation": "如果使用者在 Word 中選取了文字，則計算並顯示選取文字所跨越的段落數。"}
    ],
    "keywords": ["word selection paragraph count", "count selected paragraphs", "選取段落計數"]
},
{
    "name": "Range.Information (Word)",
    "category": "Word 文件處理",
    "syntax": "infoValue = rangeObject.Information(Type As WdInformation)",
    "description": "傳回有關指定範圍的資訊。WdInformation 常數指定要傳回的資訊類型。",
    "parameters": [
        {"name": "Type", "description": "必需。WdInformation 常數，例如 wdActiveEndPageNumber (目前頁碼), wdFirstCharacterLineNumber (範圍內第一個字元的行號), wdHeaderFooterType (頁首/頁尾類型), wdNumberOfPagesInDocument (文件總頁數)。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' MsgBox \"選取範圍開始於第 \" & selRange.Information(wdFirstCharacterLineNumber) & \" 行。\"\n' MsgBox \"文件目前總頁數: \" & ActiveDocument.Content.Information(wdNumberOfPagesInDocument)", "explanation": "顯示目前選取範圍第一個字元所在的行號，以及文件的總頁數。"}
    ],
    "keywords": ["word range information", "get page number word", "get line number word", "wdinformation", "範圍資訊"]
},
{
    "name": "Find.HitHighlight (Word)",
    "category": "Word 文件處理",
    "syntax": "booleanResult = findObject.HitHighlight(FindText, [HighlightColor As WdColorIndex = wdYellow], [MatchCase], [MatchWholeWord], ...)",
    "description": "尋找並高亮顯示指定文字的所有實例。傳回 True 如果至少找到一個符合項。",
    "parameters": [
        {"name": "FindText", "description": "必需。要尋找並高亮的文字。"},
        {"name": "HighlightColor", "description": "可選。WdColorIndex 常數，指定高亮顏色。"},
        {"name": "MatchCase", "description": "可選。True 表示區分大小寫。"}
    ],
    "examples": [
        {"code": "Dim searchRange As Object ' Word.Range\n' Set searchRange = ActiveDocument.Content\n' If searchRange.Find.HitHighlight(FindText:=\"重要\", HighlightColor:=wdTurquoise, MatchCase:=False, MatchWholeWord:=True) Then\n'   MsgBox \"文件中所有 '重要' (不分大小寫，全字匹配) 已被高亮顯示為綠松石色。\"\n' Else\n'   MsgBox \"文件中未找到 '重要'。\"\n' End If", "explanation": "在整個文件中尋找所有出現的 \"重要\" (不區分大小寫，全字匹配)，並將其高亮顯示為綠松石色。"}
    ],
    "keywords": ["word find highlight", "hithighlight", "highlight text word", "尋找並高亮"]
},
{
    "name": "Find.ClearHitHighlight (Word)",
    "category": "Word 文件處理",
    "syntax": "findObject.ClearHitHighlight",
    "description": "移除使用 HitHighlight 方法套用的所有高亮顯示。",
    "parameters": [],
    "examples": [
        {"code": "' First, apply some highlights (see HitHighlight example)\n' ActiveDocument.Content.Find.HitHighlight FindText:=\"分析\"\n' ' Then, clear all such highlights\n' ActiveDocument.Content.Find.ClearHitHighlight\n' MsgBox \"所有透過 HitHighlight 套用的高亮已清除。\"", "explanation": "清除文件中所有由 HitHighlight 方法套用的高亮效果。"}
    ],
    "keywords": ["word clear highlight", "remove hithighlight", "清除高亮"]
},
{
    "name": "Selection.Previous / .Next (Word - Unit Based)",
    "category": "Word 文件處理",
    "syntax": "Set prevUnitRange = selectionObject.Previous(Unit As WdUnits, [Count As Long = 1])\nSet nextUnitRange = selectionObject.Next(Unit As WdUnits, [Count As Long = 1])",
    "description": "傳回一個 Range 物件，代表相對於目前選取範圍的上一個或下一個指定的單位 (例如，單字、句子、段落)。",
    "parameters": [
        {"name": "Unit", "description": "必需。WdUnits 常數 (例如 wdWord, wdSentence, wdParagraph, wdLine, wdCharacter)。"},
        {"name": "Count", "description": "可選。要移動的單位數。"}
    ],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\nDim prevPara As Object ' Word.Range\n' Set sel = Application.Selection\n' Set prevPara = sel.Previous(Unit:=wdParagraph, Count:=1)\n' If Not prevPara Is Nothing Then\n'   prevPara.Select\n'   MsgBox \"已選取上一個段落。\"\n' Else\n'   MsgBox \"沒有上一個段落。\"\n' End If", "explanation": "選取目前選取範圍之前的上一個段落。"}
    ],
    "keywords": ["word selection previous unit", "selection next unit", "navigate by word", "navigate by paragraph", "依單位導航Word"]
},
// Excel 核心操作
{
    "name": "Range.Validation.InCellDropdown Property",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.InCellDropdown = True | False",
    "description": "如果資料驗證在儲存格中顯示下拉清單，則為 True。僅當驗證類型為 xlValidateList 時適用。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示下拉箭頭，False 表示不顯示。"}],
    "examples": [
        {"code": "With Range(\"A1\").Validation\n  .Delete\n  .Add Type:=xlValidateList, Formula1:=\"Option1,Option2,Option3\"\n  .InCellDropdown = True ' Ensure dropdown arrow is visible\nEnd With\nMsgBox \"A1儲存格的清單驗證已設定並顯示下拉箭頭。\"", "explanation": "為A1儲存格設定一個清單型資料驗證，並確保儲存格內顯示下拉箭頭。"}
    ],
    "keywords": ["in-cell dropdown", "validation list arrow", "儲存格內下拉", "資料驗證清單箭頭"]
},
{
    "name": "Worksheet.OLEObjects Property / Method (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set oleObjectsCollection = worksheetObject.OLEObjects\nSet specificOleObject = worksheetObject.OLEObjects(IndexOrName)",
    "description": "OLEObjects 屬性 (不帶參數) 傳回代表工作表上所有 OLE 物件 (嵌入的物件，如Word文件、PDF，或ActiveX控制項) 的 OLEObjects 集合。OLEObjects 方法 (帶參數) 傳回單個 OLEObject。",
    "parameters": [{"name": "IndexOrName", "description": "OLE 物件的索引號或名稱。"}],
    "examples": [
        {"code": "Dim oleObj As OLEObject\n' Assume an OLE object (e.g., an embedded Word document named \"EmbedWordDoc\") exists on Sheet1\n' On Error Resume Next\n' Set oleObj = ActiveSheet.OLEObjects(\"EmbedWordDoc\")\n' If Not oleObj Is Nothing Then\n'   oleObj.Verb xlVerbPrimary ' Activate the primary verb (usually Open or Edit)\n'   MsgBox \"OLE物件 '\" & oleObj.Name & \"' 已嘗試啟動其主要動作。\"\n' Else\n'   MsgBox \"未找到名為 'EmbedWordDoc' 的OLE物件。\"\n' End If\n' On Error GoTo 0", "explanation": "嘗試獲取名為 \"EmbedWordDoc\" 的 OLE 物件，並執行其主要動作 (例如，如果是嵌入的Word文件，則可能會打開它進行編輯)。"}
    ],
    "keywords": ["ole objects", "embedded object excel", "activex control excel", "OLE物件", "嵌入物件"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.PageRange Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set pageFieldAreaRange = pivotTableObject.PageRange",
    "description": "傳回一個 Range 物件，代表包含樞紐分析表報表中頁面/篩選欄位區域的範圍。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pageArea As Range\n' Set pt = ActiveSheet.PivotTables(1)\n' If Not pt Is Nothing And pt.PageFields.Count > 0 Then\n'   Set pageArea = pt.PageRange\n'   If Not pageArea Is Nothing Then\n'     pageArea.Interior.Color = RGB(200, 255, 200) ' Light green for page field area\n'     MsgBox \"樞紐分析表的頁面/篩選欄位區域 ('\" & pageArea.Address & \"') 已設定背景色。\"\n'   End If\n' Else\n'   MsgBox \"此樞紐分析表沒有頁面/篩選欄位。\"\n' End If", "explanation": "如果樞紐分析表有頁面/篩選欄位，則獲取該區域的範圍並將其背景設為淺綠色。"}
    ],
    "keywords": ["pivottable pagerange", "pivot filter area", "樞紐分析表頁面欄位區域"]
},
{
    "name": "PivotField.PivotItems.Count",
    "category": "Excel 資料分析與樞紐",
    "syntax": "numberOfItems = pivotFieldObject.PivotItems.Count",
    "description": "傳回指定 PivotField 中 PivotItem 物件的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\")\n' MsgBox \"'Region' 欄位共有 \" & pf_Region.PivotItems.Count & \" 個不重複的項目。\"", "explanation": "顯示 \"Region\" 欄位中包含的不重複項目的數量。"}
    ],
    "keywords": ["pivotitems count", "number of unique items pivot", "樞紐分析項目數量"]
},
{
    "name": "PivotItem.RecordCount Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "count = pivotItemObject.RecordCount",
    "description": "傳回指定 PivotItem 在 PivotCache 中的記錄數。如果 PivotItem 是計算項目，則此屬性會產生錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pi_East As PivotItem\n' Set pt = ActiveSheet.PivotTables(1)\n' On Error Resume Next ' Handle if item doesn't exist\n' Set pi_East = pt.PivotFields(\"Region\").PivotItems(\"East\")\n' If Not pi_East Is Nothing Then\n'   MsgBox \"資料來源中 'East' 區域的記錄數為: \" & pi_East.RecordCount\n' Else\n'   MsgBox \"未找到項目 'East'。\"\n' End If\n' On Error GoTo 0", "explanation": "顯示 \"Region\" 欄位中 \"East\" 項目的原始資料來源中的記錄數量。"}
    ],
    "keywords": ["pivotitem recordcount", "count records for pivot item", "樞紐分析項目記錄數"]
},
{
    "name": "SlicerCache.VisibleSlicerItems Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set visibleSICollection = slicerCacheObject.VisibleSlicerItems",
    "description": "傳回一個 SlicerItems 集合，其中包含目前在 SlicerCache 中可見 (即未被篩選掉) 的所有項目。",
    "parameters": [],
    "examples": [
        {"code": "Dim sc As SlicerCache, si As SlicerItem\n' Set sc = ThisWorkbook.SlicerCaches(\"Slicer_Category\")\n' If Not sc Is Nothing Then\n'   Debug.Print \"'\" & sc.Name & \"' 中目前可見的項目:\"\n'   If sc.VisibleSlicerItems.Count > 0 Then\n'       For Each si In sc.VisibleSlicerItems\n'           Debug.Print \"  - \" & si.Name & \" (Selected: \" & si.Selected & \")\"\n'       Next si\n'   Else\n'       Debug.Print \"  (沒有可見的項目)\"\n'   End If\n' End If", "explanation": "遍歷名為 \"Slicer_Category\" 的 SlicerCache 中所有目前可見的項目，並列印其名稱和選取狀態。"}
    ],
    "keywords": ["slicercache visiblesliceritems", "visible slicer items", "可見交叉分析篩選器項目"]
},
// Excel 核心操作
{
    "name": "Range.FormulaLocal",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaLocal [= formulaStringLocal]",
    "description": "設定或傳回物件的公式，使用使用者語言的 A1 樣式參照。例如，在中文 Excel 中，SUM 函數可能是 `SUM`，但在德文 Excel 中可能是 `SUMME`。",
    "parameters": [{"name": "formulaStringLocal", "description": "本地化語言的公式字串。"}],
    "examples": [
        {"code": "Range(\"C1\").FormulaLocal = \"=SUMME(A1:B1)\" ' 如果Excel是德文版，這會設定求和公式", "explanation": "使用本地化函數名稱設定公式。效果取決於Excel的語言設定。"},
        {"code": "MsgBox Range(\"C1\").FormulaLocal", "explanation": "以本地化語言顯示C1儲存格的公式。"}
    ],
    "keywords": ["本地化公式", "語言特定公式", "excel", "formulalocal", "localized formula"]
},
{
    "name": "Range.FormulaR1C1Local",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaR1C1Local [= formulaStringLocalR1C1]",
    "description": "設定或傳回物件的公式，使用使用者語言的 R1C1 樣式參照。",
    "parameters": [{"name": "formulaStringLocalR1C1", "description": "本地化語言的 R1C1 樣式公式字串。"}],
    "examples": [
        {"code": "Range(\"C1\").FormulaR1C1Local = \"=SUMME(ZEILE()SPALTE(-2):ZEILE()SPALTE(-1))\" ' 德文R1C1的=SUM(RC[-2]:RC[-1])", "explanation": "使用本地化語言和R1C1樣式設定公式。"},
        {"code": "MsgBox Range(\"C1\").FormulaR1C1Local", "explanation": "以本地化語言和R1C1樣式顯示C1儲存格的公式。"}
    ],
    "keywords": ["本地化R1C1公式", "excel", "formular1c1local", "localized r1c1 formula"]
},
{
    "name": "Range.ShowErrors (Error Checking)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ShowErrors",
    "description": "如果範圍包含錯誤，則顯示「錯誤檢查選項」按鈕。此方法本身不傳回值，而是觸發UI行為。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = 1 / 0 ' Create a #DIV/0! error\nOn Error Resume Next ' ShowErrors might error if cell doesn't have a traceable error UI element\nRange(\"A1\").ShowErrors\nIf Err.Number <> 0 Then MsgBox \"無法顯示儲存格A1的錯誤檢查選項按鈕，或A1沒有可追蹤的錯誤。\"\nOn Error GoTo 0", "explanation": "在A1儲存格中產生一個錯誤，然後嘗試顯示該儲存格的錯誤檢查選項按鈕。"}
    ],
    "keywords": ["顯示錯誤檢查", "錯誤選項按鈕", "excel error checking options", "trace error button"]
},
{
    "name": "Range.Dirty (Usage in UDFs)",
    "category": "Excel 核心操作",
    "description": "在使用者定義函數 (UDF) 中，如果函數的結果依賴於非直接作為參數傳入的儲存格，且該儲存格的值發生變化時，Excel 的標準重新計算引擎可能不會自動重新計算此UDF。在這種情況下，可以在UDF內部或外部使用 `Application.Volatile` 使UDF易失，或更精確地，在相關儲存格變化時，使用 `Worksheet_Change` 事件來呼叫包含該UDF的儲存格的 `.Dirty` 方法，然後觸發計算，以強制其更新。",
    "parameters": [],
    "examples": [
        {"code": "' Function MyUDF_Reads_C1() As Double\n'   ' This UDF implicitly depends on cell C1\n'   MyUDF_Reads_C1 = Range(\"C1\").Value * 2\n' End Function\n'\n' ' In the Worksheet module where cells with MyUDF_Reads_C1() are located:\n' Private Sub Worksheet_Change(ByVal Target As Range)\n'   If Not Intersect(Target, Me.Range(\"C1\")) Is Nothing Then\n'     Dim cellWithUDF As Range\n'     ' Assume D1 contains =MyUDF_Reads_C1()\n'     Set cellWithUDF = Me.Range(\"D1\")\n'     cellWithUDF.Dirty ' Mark D1 as needing recalculation\n'     ' Application.Calculate ' Or specific calculation for D1\n'     ' Or if many such UDFs exist, could make the UDF Application.Volatile True\n'   End If\n' End Sub", "explanation": "如果一個UDF間接依賴C1，當C1改變時，可以通過Worksheet_Change事件將使用該UDF的儲存格(例如D1)標記為Dirty，從而確保它在下次計算時更新。"}
    ],
    "keywords": ["udf dirty", "force udf recalculation", "non-volatile udf update", "UDF強制重算"]
},
{
    "name": "Worksheet.EnableCalculation Property",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.EnableCalculation = True | False",
    "description": "如果 Microsoft Excel 在需要時自動重新計算工作表，則為 True。設為 False 可以阻止特定工作表的自動計算，即使應用程式的計算模式是自動的。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True (預設) 啟用工作表計算，False 禁用。"}],
    "examples": [
        {"code": "Sheets(\"Sheet1\").EnableCalculation = False\nMsgBox \"Sheet1 的自動計算已禁用。除非手動計算，否則其公式不會更新。\"\n' Sheets(\"Sheet1\").EnableCalculation = True ' To re-enable", "explanation": "禁用 Sheet1 的自動計算。即使 Application.Calculation 是自動的，Sheet1 上的公式也不會自動更新。"}
    ],
    "keywords": ["禁用工作表計算", "enable calculation sheet", "stop sheet recalculation", "工作表計算控制"]
},
{
    "name": "Workbook.PrecisionAsDisplayed Property",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.PrecisionAsDisplayed = True | False",
    "description": "如果此活頁簿中的計算是使用顯示的精確度完成的，則為 True。設為 True 可能會永久更改活頁簿中儲存格的值以符合顯示的格式，並可能導致數據丟失。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示以顯示精確度計算，False (預設) 表示以完整精確度計算。"}],
    "examples": [
        {"code": "MsgBox \"目前活頁簿的 '以顯示精確度為準' 設定是: \" & ThisWorkbook.PrecisionAsDisplayed\n' ThisWorkbook.PrecisionAsDisplayed = True ' CAUTION: This can lead to data loss.\n' If ThisWorkbook.PrecisionAsDisplayed Then\n'   MsgBox \"警告：活頁簿已設定為以顯示精確度計算，儲存格的基礎值可能已更改。\"\n' End If", "explanation": "顯示活頁簿是否設定為「以顯示精確度為準」進行計算。開啟此選項應非常謹慎。"}
    ],
    "keywords": ["precision as displayed", "calculation precision", "excel rounding data loss", "顯示精確度計算"]
},
{
    "name": "Range.ShowPrecedents / .ShowDependents (Trace Arrows)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ShowPrecedents([Remove As Boolean])\nrangeObject.ShowDependents([Remove As Boolean])",
    "description": "在工作表上繪製追蹤箭頭，指向指定範圍的直接前導儲存格 (ShowPrecedents) 或直接引用儲存格 (ShowDependents)。",
    "parameters": [{"name": "Remove", "description": "可選。True 表示移除指定級別的追蹤箭頭。"}],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=A1+B1\"\nRange(\"C1\").ShowPrecedents ' Draws arrows from A1 and B1 to C1\nMsgBox \"已顯示C1的前導追蹤箭頭。\"\nApplication.Wait Now + TimeValue(\"00:00:03\")\nRange(\"C1\").ShowPrecedents Remove:=True ' Removes the arrows", "explanation": "為C1儲存格顯示其直接前導儲存格的追蹤箭頭，等待3秒，然後移除這些箭頭。"}
    ],
    "keywords": ["追蹤箭頭", "顯示前導", "顯示引用", "excel trace precedents", "excel trace dependents", "formula arrows"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.ShowValuesRow Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.ShowValuesRow = True | False",
    "description": "如果樞紐分析表報表在有多個資料欄位時，將資料欄位按列顯示 (即所謂的「值」列)，則為 True。如果資料欄位按欄顯示，則為 False。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示值顯示為列，False 表示值顯示為欄。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' If pt.DataFields.Count > 1 Then\n'   pt.ShowValuesRow = True\n'   MsgBox \"樞紐分析表的多個資料欄位現在按列顯示。\"\n' Else\n'   MsgBox \"此樞紐分析表沒有多個資料欄位可供切換顯示方式。\"\n' End If", "explanation": "如果樞紐分析表有多個資料欄位，則將它們設定為按列顯示 (在UI中稱為「值」的列標籤)。"}
    ],
    "keywords": ["pivottable showvaluesrow", "pivot values as rows", "multiple data fields layout", "樞紐分析表值列顯示"]
},
{
    "name": "PivotTable.RepeatAllItemLabels (Specific Field)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.RepeatItemLabels = True | False",
    "description": "為樞紐分析表中的特定欄位設定是否重複項目標籤。這與 PivotTable.RepeatAllItemLabels 不同，後者會影響所有欄位。",
    "parameters": [{"name": "True | False", "description": "True 表示重複該欄位的項目標籤，False 表示不重複。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Region As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Region = pt.PivotFields(\"Region\") ' Assume Region is an outer row field\n' If Not pf_Region Is Nothing Then\n'   pf_Region.RepeatItemLabels = True\n'   MsgBox \"'Region' 欄位的項目標籤已設定為重複。\"\n' End If", "explanation": "設定樞紐分析表中名為 \"Region\" 的特定欄位重複其項目標籤。"}
    ],
    "keywords": ["pivotfield repeatitemlabels", "repeat labels for field", "特定欄位重複標籤"]
},

{
"name": "PivotTable.VisualTotals Property (OLAP)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.VisualTotals = True | False",
    "description": "如果樞紐分析表報表在篩選 OLAP 資料來源時包含篩選後項目的總計，則為 True。預設為 True。設為 False 可以僅顯示篩選後可見項目的總計，而不包括隱藏項目的貢獻。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示視覺總計。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(\"OLAP_Sales\")\n' If pt.PivotCache.OLAP Then\n'   pt.VisualTotals = False ' Show totals only for visible items after filtering\n'   MsgBox \"OLAP樞紐分析表的視覺總計已禁用 (僅匯總可見項目)。\"\n' Else\n'   MsgBox \"此樞紐分析表不是基於OLAP資料來源，VisualTotals屬性可能不適用。\"\n' End If", "explanation": "對於基於 OLAP 資料來源的樞紐分析表，將 VisualTotals 設為 False，可以使總計僅反映目前篩選後可見的項目，而不是所有基礎項目。"}
    ],
    "keywords": ["pivottable visualtotals", "olap pivot totals", "filter totals olap", "視覺總計OLAP"]
},
{
    "name": "PivotTable.CalculatedMembers Property (OLAP)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set calcMembers = pivotTableObject.CalculatedMembers",
    "description": "傳回一個 CalculatedMembers 集合，代表 OLAP 樞紐分析表中的所有計算成員。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, cm As CalculatedMember\n' Set pt = ActiveSheet.PivotTables(\"SalesCube\")\n' If pt.PivotCache.OLAP Then\n'   If pt.CalculatedMembers.Count > 0 Then\n'     MsgBox \"此OLAP樞紐分析表有 \" & pt.CalculatedMembers.Count & \" 個計算成員。\"\n'     For Each cm In pt.CalculatedMembers\n'       Debug.Print \"計算成員: \" & cm.Name & \", 公式: \" & cm.Formula\n'     Next cm\n'   Else\n'     MsgBox \"此OLAP樞紐分析表沒有計算成員。\"\n'   End If\n' End If", "explanation": "如果樞紐分析表是基於 OLAP，則遍歷其所有計算成員並列印其名稱和 MDX 公式。"}
    ],
    "keywords": ["pivottable calculatedmembers", "olap calculated members", "list calculated members", "OLAP計算成員"]
},
{
    "name": "CalculatedMember.Delete (OLAP PivotTable)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "calculatedMemberObject.Delete",
    "description": "從 OLAP 樞紐分析表中刪除指定的計算成員。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, cmToDelete As CalculatedMember\n' Set pt = ActiveSheet.PivotTables(\"SalesCube\")\n' If pt.PivotCache.OLAP Then\n'   On Error Resume Next ' In case member doesn't exist\n'   Set cmToDelete = pt.CalculatedMembers(\"MyCustomCalcMember\")\n'   If Not cmToDelete Is Nothing Then\n'     cmToDelete.Delete\n'     MsgBox \"計算成員 'MyCustomCalcMember' 已刪除。\"\n'   Else\n'     MsgBox \"未找到名為 'MyCustomCalcMember' 的計算成員。\"\n'   End If\n'   On Error GoTo 0\n' End If", "explanation": "嘗試從 OLAP 樞紐分析表中刪除一個名為 \"MyCustomCalcMember\" 的計算成員。"}
    ],
    "keywords": ["calculatedmember delete", "remove olap calculated member", "刪除計算成員"]
},
{
    "name": "PivotTable.AllocationMethod Property (OLAP What-If)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.AllocationMethod = XlAllocationMethodConstant",
    "description": "設定或傳回當執行假設分析並將值寫回 OLAP 資料來源時使用的分配方法。僅當 Allocation 屬性設為 xlWeightedAllocation 時才使用。",
    "parameters": [
        {"name": "XlAllocationMethodConstant", "description": "例如 xlEqualAllocation (平均分配), xlWeightedAllocation (按權重分配)。"}
    ],
    "examples": [
        {"code": "' Dim pt As PivotTable\n' ' Set pt = ActiveSheet.PivotTables(\"ForecastOLAP\")\n' ' If pt.PivotCache.OLAP And pt.EnableWriteback And pt.EnableAllocation Then\n' '   pt.Allocation = xlWeightedAllocation ' Set to use weights\n' '   pt.AllocationMethod = xlWeightedAllocation ' This property seems redundant with .Allocation for this specific value or contextually used.\n' '   ' For weighted allocation, you also need to set .AllocationWeightExpression\n' '   pt.AllocationWeightExpression = \"[Measures].[Previous Sales]\" ' Example: Allocate based on previous sales measure\n' '   MsgBox \"樞紐分析表已設定為按先前銷售額權重進行值分配。\"\n' ' End If", "explanation": "如果樞紐分析表設定為使用加權分配進行假設分析，此範例概念性地展示如何設定分配方法，並指出需要同時設定 AllocationWeightExpression。"}
    ],
    "keywords": ["pivottable allocationmethod", "olap what-if weighted allocation", "OLAP假設分析分配方法"]
},
// Word 文件處理
{
    "name": "Selection.Font.Name (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.Font.Name = \"FontName\"",
    "description": "設定目前選取範圍文字的字型名稱。",
    "parameters": [{"name": "FontName", "description": "字型名稱的字串，例如 \"Arial\", \"Times New Roman\"。"}],
    "examples": [
        {"code": "' Assume text is selected in Word\n' If Selection.Type = wdSelectionNormal Then\n'   Selection.Font.Name = \"Calibri Light\"\n'   MsgBox \"選取文字的字型已變更為 Calibri Light。\"\n' End If", "explanation": "將Word中目前選取文字的字型設定為 \"Calibri Light\"。"}
    ],
    "keywords": ["word font name", "change selected font", "設定選取字型"]
},
{
    "name": "Selection.Font.Size (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.Font.Size = PointValue",
    "description": "設定目前選取範圍文字的字型大小 (以點為單位)。",
    "parameters": [{"name": "PointValue", "description": "字型大小的數值。"}],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionNormal Then\n'   Selection.Font.Size = 14\n'   MsgBox \"選取文字的字型大小已設為 14 點。\"\n' End If", "explanation": "將Word中目前選取文字的字型大小設定為 14 點。"}
    ],
    "keywords": ["word font size", "change selected text size", "設定選取字型大小"]
},
{
    "name": "Selection.Font.Color (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.Font.Color = WdColorConstant Or RGB(R,G,B)",
    "description": "設定目前選取範圍文字的顏色。",
    "parameters": [
        {"name": "WdColorConstant", "description": "WdColor 常數，例如 wdColorRed, wdColorBlue。"},
        {"name": "RGB(R,G,B)", "description": "使用 RGB 函數指定的顏色值。"}
    ],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionNormal Then\n'   Selection.Font.Color = wdColorDarkBlue ' Using WdColor constant\n'   ' Or Selection.Font.Color = RGB(0, 0, 139) ' Using RGB for dark blue\n'   MsgBox \"選取文字的顏色已變更。\"\n' End If", "explanation": "將Word中目前選取文字的顏色設定為深藍色。"}
    ],
    "keywords": ["word font color", "change selected text color", "設定選取文字顏色"]
},
{
    "name": "Selection.ParagraphFormat.Alignment (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.ParagraphFormat.Alignment = WdParagraphAlignmentConstant",
    "description": "設定目前選取範圍中段落的對齊方式。",
    "parameters": [
        {"name": "WdParagraphAlignmentConstant", "description": "WdParagraphAlignment 常數，例如 wdAlignParagraphLeft, wdAlignParagraphCenter, wdAlignParagraphRight, wdAlignParagraphJustify。"}
    ],
    "examples": [
        {"code": "' Selection.ParagraphFormat.Alignment = wdAlignParagraphJustify ' Set to Justify\n' MsgBox \"選取段落已設定為左右對齊。\"", "explanation": "將Word中目前選取段落的對齊方式設定為左右對齊。"}
    ],
    "keywords": ["word paragraph alignment selected", "justify text word", "設定選取段落對齊"]
},
{
    "name": "Selection.ParagraphFormat.LeftIndent (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.ParagraphFormat.LeftIndent = PointValue",
    "description": "設定目前選取範圍中段落的左縮排 (以點為單位)。",
    "parameters": [{"name": "PointValue", "description": "縮排的點數值。可以使用 InchesToPoints() 轉換。"}],
    "examples": [
        {"code": "' Selection.ParagraphFormat.LeftIndent = Application.InchesToPoints(0.5)\n' MsgBox \"選取段落的左縮排已設定為 0.5 英吋。\"", "explanation": "將Word中目前選取段落的左縮排設定為 0.5 英吋。"}
    ],
    "keywords": ["word paragraph leftindent", "set indentation word", "設定段落左縮排"]
},
{
    "name": "Selection.ParagraphFormat.SpaceAfter (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.ParagraphFormat.SpaceAfter = PointValue",
    "description": "設定目前選取範圍中段落的段後間距 (以點為單位)。",
    "parameters": [{"name": "PointValue", "description": "間距的點數值。"}],
    "examples": [
        {"code": "' Selection.ParagraphFormat.SpaceAfter = 12 ' Set to 12 points\n' MsgBox \"選取段落的段後間距已設定為 12 點。\"", "explanation": "將Word中目前選取段落的段後間距設定為 12 點。"}
    ],
    "keywords": ["word paragraph spaceafter", "set paragraph spacing word", "設定段落後間距"]
},
{
    "name": "Document.Paragraphs(Index).Range (Word)",
    "category": "Word 文件處理",
    "syntax": "Set paraRange = documentObject.Paragraphs(Index).Range",
    "description": "傳回一個 Range 物件，代表文件中指定索引的段落的內容 (包括段落標記)。",
    "parameters": [{"name": "Index", "description": "必需。Paragraphs 集合中的段落索引 (1-based)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object, pRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' If wdDoc.Paragraphs.Count >= 2 Then\n'   Set pRange = wdDoc.Paragraphs(2).Range\n'   pRange.Font.Bold = True\n'   MsgBox \"第二個段落 ('\" & Left(pRange.Text, Len(pRange.Text)-1) & \"') 已設為粗體。\"\n' End If", "explanation": "如果文件至少有兩個段落，則獲取第二個段落的範圍並將其設為粗體。"}
    ],
    "keywords": ["word specific paragraph range", "get paragraph by index", "獲取特定段落範圍"]
},
{
    "name": "Document.Characters(Index) (Word)",
    "category": "Word 文件處理",
    "syntax": "Set charRange = documentObject.Characters(Index)",
    "description": "傳回一個 Range 物件，代表文件中指定索引的單個字元。",
    "parameters": [{"name": "Index", "description": "必需。Characters 集合中的字元索引 (1-based)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object, firstChar As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' If wdDoc.Characters.Count > 0 Then\n'   Set firstChar = wdDoc.Characters(1)\n'   MsgBox \"文件的第一個字元是: '\" & firstChar.Text & \"'\"\n'   firstChar.Font.Size = 20\n' End If", "explanation": "獲取文件的第一個字元，顯示它，並將其字型大小更改為20。"}
    ],
    "keywords": ["word specific character", "get character by index", "獲取特定字元"]
},
{
    "name": "Table.Rows.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newRow = tableObject.Rows.Add([BeforeRow As Row])",
    "description": "在表格中新增一列。如果指定 BeforeRow，則新列會插入到該列之前；否則，新列會新增到表格末尾。",
    "parameters": [{"name": "BeforeRow", "description": "可選。Row 物件，新列將插入其前。"}],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\nDim newAddedRow As Object ' Word.Row\n' Set tbl = ActiveDocument.Tables(1) ' Assume a table exists\n' Set newAddedRow = tbl.Rows.Add ' Add row at the end\n' newAddedRow.Cells(1).Range.Text = \"新列數據\"\n' MsgBox \"新列已新增到表格末尾。\"", "explanation": "在活動文件的第一個表格末尾新增一列，並在新列的第一個儲存格填入文字。"}
    ],
    "keywords": ["word table add row", "insert row in table word", "表格新增列Word"]
},
{
    "name": "Table.Columns.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newCol = tableObject.Columns.Add([BeforeColumn As Column])",
    "description": "在表格中新增一欄。如果指定 BeforeColumn，則新欄會插入到該欄之前；否則，新欄會新增到表格右側。",
    "parameters": [{"name": "BeforeColumn", "description": "可選。Column 物件，新欄將插入其前。"}],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\nDim newAddedCol As Object ' Word.Column\n' Set tbl = ActiveDocument.Tables(1)\n' Set newAddedCol = tbl.Columns.Add ' Add column at the end (right)\n' tbl.Cell(1, newAddedCol.Index).Range.Text = \"新欄標題\"\n' MsgBox \"新欄已新增到表格右側。\"", "explanation": "在活動文件的第一個表格右側新增一欄，並在新欄的第一個儲存格填入文字。"}
    ],
    "keywords": ["word table add column", "insert column in table word", "表格新增欄Word"]
},
{
    "name": "Cell.Merge (Word Table)",
    "category": "Word 文件處理",
    "syntax": "cellObject.Merge(MergeTo As Cell)",
    "description": "將指定的表格儲存格與另一個儲存格合併。",
    "parameters": [{"name": "MergeTo", "description": "必需。Cell 物件，代表要與 cellObject 合併的儲存格。"}],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\n' Set tbl = ActiveDocument.Tables(1)\n' If tbl.Cell(1,1).Range.Text <> \"\" And tbl.Cell(1,2).Range.Text <> \"\" Then ' Ensure cells are not already part of a merge\n'   tbl.Cell(1, 1).Merge MergeTo:=tbl.Cell(1, 2) ' Merge cell(1,1) with cell(1,2)\n'   MsgBox \"表格中 (1,1) 和 (1,2) 儲存格已合併。\"\n' Else\n'   MsgBox \"無法合併，儲存格可能已合併或不存在。\"\n' End If", "explanation": "嘗試合併活動文件中第一個表格的第一列第一格與第一列第二格。"}
    ],
    "keywords": ["word table merge cells", "combine table cells word", "合併表格儲存格Word"]
},
{
    "name": "InlineShapes(Index).ConvertToShape (Word)",
    "category": "Word 文件處理",
    "syntax": "Set shp = inlineShapeObject.ConvertToShape()",
    "description": "將指定的內嵌圖形轉換為浮動圖形 (Shape 物件)。",
    "parameters": [],
    "examples": [
        {"code": "Dim ils As Object ' Word.InlineShape\nDim convertedShape As Object ' Word.Shape\n' If ActiveDocument.InlineShapes.Count > 0 Then\n'   Set ils = ActiveDocument.InlineShapes(1)\n'   Set convertedShape = ils.ConvertToShape()\n'   convertedShape.WrapFormat.Type = wdWrapSquare ' Now can set wrap format\n'   MsgBox \"第一個內嵌圖形已轉換為浮動圖形並設定文繞圖。\"\n' End If", "explanation": "如果文件中有內嵌圖形，則將第一個內嵌圖形轉換為浮動圖形，然後設定其文繞圖格式。"}
    ],
    "keywords": ["word convert inlineshape to shape", "inline to floating picture", "轉換為浮動圖案"]
},
{
    "name": "Document.Revisions.AcceptAll (Word Track Changes)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Revisions.AcceptAll",
    "description": "接受指定文件中的所有追蹤修訂。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Revisions.Count > 0 Then\n'   If MsgBox(\"是否接受所有追蹤修訂?\", vbYesNo) = vbYes Then\n'     wdDoc.Revisions.AcceptAll\n'     MsgBox \"所有追蹤修訂已被接受。\"\n'   End If\n' Else\n'   MsgBox \"文件中沒有追蹤修訂。\"\n' End If", "explanation": "如果文件中有追蹤修訂，則提示用戶是否接受所有修訂。"}
    ],
    "keywords": ["word accept all revisions", "track changes accept", "接受所有修訂"]
},
{
    "name": "Document.Revisions.RejectAll (Word Track Changes)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Revisions.RejectAll",
    "description": "拒絕指定文件中的所有追蹤修訂。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Revisions.Count > 0 Then\n'   If MsgBox(\"是否拒絕所有追蹤修訂?\", vbYesNo) = vbYes Then\n'     wdDoc.Revisions.RejectAll\n'     MsgBox \"所有追蹤修訂已被拒絕。\"\n'   End If\n' End If", "explanation": "如果文件中有追蹤修訂，則提示用戶是否拒絕所有修訂。"}
    ],
    "keywords": ["word reject all revisions", "track changes reject", "拒絕所有修訂"]
},
{
    "name": "Range.LanguageID Property (Word Proofing)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.LanguageID = WdLanguageIDConstant\ncurrentLangID = rangeObject.LanguageID",
    "description": "設定或傳回指定範圍的校訂語言。",
    "parameters": [
        {"name": "WdLanguageIDConstant", "description": "WdLanguageID 常數，例如 wdEnglishUS, wdFrench, wdSimplifiedChinese。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' selRange.LanguageID = wdEnglishUK ' Set selected text language to UK English\n' MsgBox \"選取文字的校訂語言已設為英國英語。目前ID: \" & selRange.LanguageID", "explanation": "將目前選取文字的校訂語言設定為英國英語。"}
    ],
    "keywords": ["word proofing language", "set language word", "langugeid", "校訂語言"]
},
{
    "name": "Document.PrintPreview (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.PrintPreview",
    "description": "以預覽列印模式顯示指定的文件。",
    "parameters": [],
    "examples": [
        {"code": "' ActiveDocument.PrintPreview\n' MsgBox \"文件正在預覽列印模式下顯示。關閉預覽以繼續執行宏。\"", "explanation": "將活動文件切換到預覽列印模式。"}
    ],
    "keywords": ["word print preview", "preview document word", "預覽列印Word"]
},
{
    "name": "Dialogs(WdWordDialogConstant).Show (Word Built-in Dialogs)",
    "category": "Word 文件處理",
    "syntax": "returnValue = wdApplicationObject.Dialogs(WdWordDialogConstant).Show",
    "description": "顯示指定的 Word 內建對話框，並傳回一個 Long 值，指示哪個按鈕被按下。",
    "parameters": [
        {"name": "WdWordDialogConstant", "description": "WdWordDialog 常數，例如 wdDialogFileOpen, wdDialogFileSaveAs, wdDialogToolsOptions。"}
    ],
    "examples": [
        {"code": "Dim wdApp As Object ' Word.Application\nDim dlgResult As Long\n' Set wdApp = Application\n' ' Show the File Open dialog\n' dlgResult = wdApp.Dialogs(wdDialogFileOpen).Show\n' If dlgResult = -1 Then ' -1 means OK/Open was clicked\n'   MsgBox \"使用者在開啟對話框中點擊了確定/開啟。\" & vbCrLf & \"(注意：這只顯示對話框，實際開啟需另外編寫代碼，例如使用ActiveDocument)\"\n' Else ' 0 means Cancel was clicked\n'   MsgBox \"使用者取消了開啟對話框。\"\n' End If", "explanation": "顯示 Word 的標準「開啟舊檔」對話框。如果使用者點擊「開啟」，則 Show 方法傳回 -1。"}
    ],
    "keywords": ["word dialogs", "built-in dialogs word", "wdDialogFileOpen", "Word內建對話框"]
},
{
    "name": "ActiveWindow.View.Zoom.Percentage (Word)",
    "category": "Word 文件處理",
    "syntax": "activeWindowObject.View.Zoom.Percentage = ZoomPercentage",
    "description": "設定或傳回活動視窗的檢視縮放比例 (百分比)。",
    "parameters": [{"name": "ZoomPercentage", "description": "10 到 500 之間的數值。"}],
    "examples": [
        {"code": "Dim activeWin As Object ' Word.Window\n' Set activeWin = Application.ActiveWindow\n' activeWin.View.Zoom.Percentage = 150 ' Set zoom to 150%\n' MsgBox \"目前視窗的縮放比例已設為 150%。\"", "explanation": "將Word活動視窗的顯示縮放比例設定為150%。"}
    ],
    "keywords": ["word zoom percentage", "view zoom word", "設定Word縮放"]
},
// Excel 核心操作 (Adding a few more for balance)
{
    "name": "Range.ShowDetail (Property - Read)",
    "category": "Excel 核心操作",
    "syntax": "isExpanded = rangeObject.ShowDetail",
    "description": "讀取大綱中摘要列或摘要欄的詳細資料是否顯示。傳回 True 如果詳細資料已顯示 (已展開)，False 如果已摺疊。",
    "parameters": [],
    "examples": [
        {"code": "' Assume row 5 is a summary row in an outline\n' If Rows(5).ShowDetail Then\n'   MsgBox \"第5列的詳細資料目前是展開的。\"\n' Else\n'   MsgBox \"第5列的詳細資料目前是摺疊的。\"\n' End If", "explanation": "檢查大綱中第5列的詳細資料是否已展開。"}
    ],
    "keywords": ["check outline expanded", "is group expanded", "讀取大綱狀態"]
},
{
    "name": "Workbook.Connections.AddFromFile (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set newConn = workbookObject.Connections.AddFromFile(Filename As String, [CreatePivotTable As Boolean = False], [ExtractData As Boolean = False])",
    "description": "從外部連線檔案 (.odc, .atomsvc, .iqy, .oqy, .rqy, .cub) 建立一個新的活頁簿資料連線。",
    "parameters": [
        {"name": "Filename", "description": "必需。連線檔案的完整路徑。"},
        {"name": "CreatePivotTable", "description": "可選。True 表示基於此連線建立樞紐分析表。"},
        {"name": "ExtractData", "description": "可選。True 表示立即將資料提取到工作表。"}
    ],
    "examples": [
        {"code": "Dim connFile As String, newWbConn As WorkbookConnection\nconnFile = \"C:\\DataConnections\\MyQuery.iqy\" ' Example IQY file\n' If Dir(connFile) <> \"\" Then\n'   Set newWbConn = ThisWorkbook.Connections.AddFromFile(connFile)\n'   MsgBox \"已從檔案 '\" & connFile & \"' 新增資料連線: \" & newWbConn.Name\n'   ' newWbConn.Refresh ' Refresh the connection to get data\n' Else\n'   MsgBox \"連線檔案未找到: \" & connFile\n' End If", "explanation": "從一個 .iqy (網頁查詢) 連線檔案建立一個新的活頁簿資料連線。"}
    ],
    "keywords": ["add connection from file", "excel data connection odc", "iqy file connection", "從檔案新增連線"]
},
// Excel 資料分析與樞紐 (Adding a few more)
{
    "name": "PivotTable.ClearTable",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.ClearTable",
    "description": "清除樞紐分析表報表中的所有欄位、篩選和格式。這會將樞紐分析表重設為空白狀態，但保留其 PivotCache。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(\"SalesReport\")\n' If Not pt Is Nothing Then\n'   If MsgBox(\"是否要清除樞紐分析表 '\" & pt.Name & \"' 的所有欄位和格式?\", vbYesNo) = vbYes Then\n'     pt.ClearTable\n'     MsgBox \"樞紐分析表已清除。\"\n'   End If\n' End If", "explanation": "清除樞紐分析表 \"SalesReport\" 的所有欄位佈局和格式，使其變回空白樞紐分析表。"}
    ],
    "keywords": ["cleartable pivottable", "reset pivot table", "clear pivot layout", "清除樞紐分析表佈局"]
},
{
    "name": "PivotField.ClearManualFilter (Single Field)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotFieldObject.ClearManualFilter",
    "description": "清除套用於樞紐分析表欄位中特定 PivotField 的任何手動篩選 (例如，從下拉清單中勾選/取消勾選項目)。不會清除報表篩選或交叉分析篩選器篩選。",
    "parameters": [],
    "examples": [
        {"code": "Dim pt As PivotTable, pf_Country As PivotField\n' Set pt = ActiveSheet.PivotTables(1)\n' Set pf_Country = pt.PivotFields(\"Country\")\n' If pf_Country.EnableMultiplePageItems = True Then ' Check if manual filter might be applied\n'    pf_Country.ClearManualFilter\n'    MsgBox \"'Country' 欄位的手動篩選 (項目勾選) 已清除。\"\n' End If", "explanation": "清除樞紐分析表中 \"Country\" 欄位上可能已套用的任何手動項目篩選。"}
    ],
    "keywords": ["pivotfield clearmanualfilter", "reset pivot item filter", "清除欄位手動篩選"]
},
{
    "name": "SlicerCache.SourceName Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "sourceNameString = slicerCacheObject.SourceName",
    "description": "傳回與 SlicerCache 關聯的 PivotTable 的來源欄位名稱 (例如，在 PivotTable 欄位清單中看到的欄位名稱)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim sc As SlicerCache\n' On Error Resume Next\n' Set sc = ThisWorkbook.SlicerCaches(1) ' Get the first slicer cache in the workbook\n' If Not sc Is Nothing Then\n'   MsgBox \"此交叉分析篩選器快取基於來源欄位: '\" & sc.SourceName & \"'\"\n' End If\n' On Error GoTo 0", "explanation": "獲取活頁簿中第一個 SlicerCache 的來源欄位名稱。"}
    ],
    "keywords": ["slicercache sourcename", "slicer field name", "交叉分析篩選器來源欄位"]
},
// Outlook 郵件與項目管理 (VBA Commands)
{
    "name": "MailItem.Reply",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set replyMailItem = mailItemObject.Reply()",
    "description": "為原始郵件項目建立一個回覆郵件。回覆郵件會預先填入收件者 (原始寄件者) 和主旨 (RE: 原始主旨)。",
    "parameters": [],
    "examples": [
        {"code": "Dim olOriginalMail As Object ' Outlook.MailItem, assume it's the selected email\nDim olReply As Object      ' Outlook.MailItem\n' Set olOriginalMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olOriginalMail) = \"MailItem\" Then\n'   Set olReply = olOriginalMail.Reply\n'   olReply.Body = \"這是對您郵件的回覆。\" & vbCrLf & olReply.Body ' Prepend new text\n'   olReply.Display ' Show the reply before sending\n' End If", "explanation": "獲取目前選取的郵件，為其建立一個回覆郵件，在原始郵件內容前加入新的回覆文字，然後顯示該回覆郵件。"}
    ],
    "keywords": ["outlook reply email", "create reply", "回覆郵件"]
},
{
    "name": "MailItem.ReplyAll",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set replyAllMailItem = mailItemObject.ReplyAll()",
    "description": "為原始郵件項目建立一個「全部回覆」郵件。新郵件會預先填入收件者 (原始寄件者和所有原始收件者/副本收件者) 和主旨。",
    "parameters": [],
    "examples": [
        {"code": "Dim olOriginalMail As Object, olReplyAll As Object\n' Set olOriginalMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olOriginalMail) = \"MailItem\" Then\n'   Set olReplyAll = olOriginalMail.ReplyAll\n'   olReplyAll.HTMLBody = \"<p>回覆給所有人：同意您的看法。</p>\" & olReplyAll.HTMLBody\n'   olReplyAll.Display\n' End If", "explanation": "為選取的郵件建立一個「全部回覆」郵件，並在郵件頂端加入HTML格式的回覆文字。"}
    ],
    "keywords": ["outlook reply all", "create reply all email", "全部回覆"]
},
{
    "name": "MailItem.Forward",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set forwardMailItem = mailItemObject.Forward()",
    "description": "為原始郵件項目建立一個轉寄郵件。轉寄郵件的主旨會預先填入 (FW: 原始主旨)，正文會包含原始郵件內容。",
    "parameters": [],
    "examples": [
        {"code": "Dim olOriginalMail As Object, olForward As Object\n' Set olOriginalMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olOriginalMail) = \"MailItem\" Then\n'   Set olForward = olOriginalMail.Forward\n'   olForward.To = \"colleague@example.com\"\n'   olForward.Body = \"FYI: \" & vbCrLf & olForward.Body ' Add a comment before forwarded content\n'   olForward.Display\n' End If", "explanation": "為選取的郵件建立一個轉寄郵件，設定新的收件者，並在轉寄內容前加入備註。"}
    ],
    "keywords": ["outlook forward email", "create forward", "轉寄郵件"]
},
{
    "name": "MailItem.Move",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set movedItem = mailItemObject.Move(DestinationFolder As MAPIFolder)",
    "description": "將 Outlook 項目移動到指定的資料夾。傳回代表已移動項目的物件。",
    "parameters": [{"name": "DestinationFolder", "description": "必需。MAPIFolder 物件，代表項目要移動到的目標資料夾。"}],
    "examples": [
        {"code": "Dim olMail As Object, olDestFolder As Object, olMovedMail As Object\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' ' Get the \"Archive\" subfolder of Inbox\n' On Error Resume Next\n' Set olDestFolder = Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox).Folders(\"Archive\")\n' If olDestFolder Is Nothing Then Set olDestFolder = Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox).Folders.Add(\"Archive\")\n' On Error GoTo 0\n' If Not olDestFolder Is Nothing And TypeName(olMail) = \"MailItem\" Then\n'   Set olMovedMail = olMail.Move(olDestFolder)\n'   MsgBox \"郵件 '\" & olMovedMail.Subject & \"' 已移動到 '\" & olDestFolder.Name & \"' 資料夾。\"\n' End If", "explanation": "將選取的郵件移動到收件匣下的 \"Archive\" 子資料夾 (如果該資料夾不存在則先建立它)。"}
    ],
    "keywords": ["outlook move email", "move item to folder", "移動郵件"]
},
{
    "name": "MailItem.Delete (Outlook Item)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.Delete",
    "description": "從包含該項目的資料夾中永久刪除該項目 (如果資料夾是「已刪除項目」資料夾)，或者將其移動到「已刪除項目」資料夾。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   If MsgBox(\"是否確實要刪除郵件 '\" & olMail.Subject & \"'？\", vbYesNo + vbExclamation) = vbYes Then\n'     olMail.Delete\n'     MsgBox \"郵件已移至 [已刪除項目]。\"\n'   End If\n' End If", "explanation": "在使用者確認後，將選取的郵件移動到「已刪除項目」資料夾。"}
    ],
    "keywords": ["outlook delete email", "remove email", "刪除郵件"]
},
{
    "name": "TaskItem.Assign (Outlook Task)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set assignedTask = taskItemObject.Assign()",
    "description": "指派一個任務並傳回代表該任務的 MailItem 物件 (任務要求)。",
    "parameters": [],
    "examples": [
        {"code": "Dim olTask As Object ' Outlook.TaskItem\nDim olTaskRequest As Object ' Outlook.MailItem (representing a task request)\n' Set olTask = Application.CreateItem(olTaskItem)\n' olTask.Subject = \"準備季度簡報\"\n' olTask.DueDate = Date + 14\n' olTask.Body = \"請收集所有相關數據並製作簡報初稿。\"\n' Set olTaskRequest = olTask.Assign()\n' olTaskRequest.Recipients.Add \"team.member@example.com\"\n' olTaskRequest.Recipients.ResolveAll\n' olTaskRequest.Send\n' MsgBox \"任務已指派給 team.member@example.com。\"", "explanation": "建立一個新任務，然後使用 Assign 方法將其轉換為一個任務要求，新增收件者並傳送該任務要求。"}
    ],
    "keywords": ["outlook assign task", "task request", "指派任務"]
},
{
    "name": "AppointmentItem.Recipients.Add (Outlook Meeting)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set newRecipient = appointmentItemObject.Recipients.Add(Name As String)",
    "description": "將收件者新增到約會 (會議邀請) 的 Recipients 集合中。",
    "parameters": [{"name": "Name", "description": "必需。收件者的名稱或電子郵件地址。"}],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem\nDim olRequiredAttendee As Object ' Outlook.Recipient\n' Set olAppt = Application.CreateItem(olAppointmentItem)\n' olAppt.MeetingStatus = olMeeting ' Set as a meeting\n' olAppt.Subject = \"專案啟動會議\"\n' olAppt.Start = Now + 1 + TimeValue(\"14:00:00\") ' Tomorrow 2 PM\n' olAppt.Duration = 60\n' Set olRequiredAttendee = olAppt.Recipients.Add(\"manager@example.com\")\n' olRequiredAttendee.Type = 1 ' olRequired\n' olAppt.Recipients.Add(\"optional.attendee@example.com\").Type = 2 ' olOptional\n' olAppt.Recipients.ResolveAll\n' olAppt.Display ' Or .Send to send meeting invitation", "explanation": "建立一個新的會議項目，新增必需和可選的與會者，然後顯示會議邀請。"}
    ],
    "keywords": ["outlook add meeting attendee", "meeting invitation recipients", "新增會議與會者"]
},
{
    "name": "Attachment.SaveAsFile (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "attachmentObject.SaveAsFile(Path As String)",
    "description": "將附件儲存到磁碟上的指定路徑。",
    "parameters": [{"name": "Path", "description": "必需。附件要儲存的完整檔案路徑。"}],
    "examples": [
        {"code": "Dim olMail As Object, olAtt As Object ' Outlook.MailItem, Outlook.Attachment\nDim saveFolderPath As String: saveFolderPath = \"C:\\Temp\\Attachments\\\"\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" And olMail.Attachments.Count > 0 Then\n'   If Dir(saveFolderPath, vbDirectory) = \"\" Then MkDir saveFolderPath ' Ensure folder exists\n'   For Each olAtt In olMail.Attachments\n'     olAtt.SaveAsFile saveFolderPath & olAtt.FileName\n'     Debug.Print \"附件 '\" & olAtt.FileName & \"' 已儲存到 \" & saveFolderPath\n'   Next olAtt\n'   MsgBox \"所有附件已儲存。\"\n' End If", "explanation": "遍歷選取郵件中的所有附件，並將它們儲存到 C:\\Temp\\Attachments\\ 資料夾中。"}
    ],
    "keywords": ["outlook save attachment", "download email attachment", "儲存附件"]
},
{
    "name": "ContactItem.Email1Address (Outlook Contact)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "contactItemObject.Email1Address [= String]",
    "description": "設定或傳回 Outlook 連絡人的第一個電子郵件地址。",
    "parameters": [{"name": "String", "description": "電子郵件地址。"}],
    "examples": [
        {"code": "Dim olContact As Object ' Outlook.ContactItem\n' Set olContact = Application.CreateItem(olContactItem)\n' olContact.FirstName = \"Jane\"\n' olContact.LastName = \"Doe\"\n' olContact.Email1Address = \"jane.doe@example.com\"\n' olContact.Email1DisplayName = \"Jane Doe (Work)\"\n' olContact.Email1AddressType = \"SMTP\"\n' olContact.Save\n' MsgBox \"連絡人 'Jane Doe' 已建立，電子郵件為: \" & olContact.Email1Address", "explanation": "建立一個新連絡人，並設定其第一個電子郵件地址、顯示名稱和地址類型。"}
    ],
    "keywords": ["outlook contact email", "set contact email address", "連絡人電子郵件"]
},
{
    "name": "Items.Find / .FindNext (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set foundItem = itemsCollection.Find(Filter As String)\nSet nextFoundItem = itemsCollection.FindNext()",
    "description": "Find 方法在 Items 集合中尋找符合指定篩選條件 (DASL 語法) 的第一個 Outlook 項目。FindNext 方法繼續先前的 Find 搜尋，尋找下一個符合相同條件的項目。",
    "parameters": [{"name": "Filter (Find method)", "description": "必需。DASL 篩選字串。"}],
    "examples": [
        {"code": "Dim olInbox As Object, olItems As Object, foundMail As Object\nDim strFilter As String\n' Set olInbox = Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox)\n' Set olItems = olInbox.Items\n' strFilter = \"@SQL=\" & Chr(34) & \"urn:schemas:httpmail:subject\" & Chr(34) & \" LIKE '%urgent%'\"\n' Set foundMail = olItems.Find(strFilter)\n' Do While Not foundMail Is Nothing\n'   Debug.Print \"找到緊急郵件: \" & foundMail.Subject & \" (Sender: \" & foundMail.SenderName & \")\"\n'   Set foundMail = olItems.FindNext()\n' Loop\n' MsgBox \"所有主旨含 'urgent' 的郵件已列印到立即視窗。\"", "explanation": "在收件匣中尋找所有主旨包含 \"urgent\" 的郵件，並將其主旨和寄件者列印到立即視窗。"}
    ],
    "keywords": ["outlook find items", "search emails outlook vba", "dasl query outlook", "findnext outlook", "尋找Outlook項目", "搜尋郵件"]
},
// 高階自動化應用 (Outlook)
{
    "name": "自動將特定發件人的郵件標記為已讀並移動到子文件夾 (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: VBA monitors the Inbox. When an email arrives from a specific sender (e.g., 'newsletter@example.com' or 'system.alerts@company.com'), it automatically marks the email as read and moves it to a predefined subfolder (e.g., 'Newsletters' or 'SystemAlerts').",
    "description": "此應用程式用於自動整理來自特定來源的郵件，保持收件匣清潔。1. Outlook 事件處理 (ItemAdd)：在 `ThisOutlookSession` 模組中，使用 `Application_NewMailEx` 或更針對特定資料夾的 `Items.ItemAdd` 事件來偵測新郵件的到達。2. 發件人檢查：在事件處理程序中，檢查新到達郵件的 `SenderEmailAddress` 或 `SenderName` 是否符合預定義的列表或模式。3. 標記為已讀：如果符合條件，將郵件的 `UnRead` 屬性設為 `False`。4. 移動到子文件夾：  a. 獲取目標子文件夾的 `MAPIFolder` 物件。如果子文件夾不存在，可以自動建立它。  b. 使用郵件的 `.Move` 方法將其移動到目標子文件夾。5. 錯誤處理：包含檢查資料夾是否存在、移動是否成功的錯誤處理。這個自動化對於不需立即關注但又希望歸檔的常規郵件（如新聞通訊、系統通知）非常有用。",
    "parameters": [
        {"name": "Target Sender Email Address(es)", "description": "要自動處理的郵件的發件人電子郵件地址列表。"},
        {"name": "Destination Subfolder Name", "description": "郵件將被移動到的收件匣下的子文件夾名稱。"},
        {"name": "Outlook Event Handler (ItemAdd or NewMailEx)", "description": "用於觸發處理邏輯的Outlook事件。"}
    ],
    "examples": [
        {"code": "' --- Code for ThisOutlookSession module --- \n' Private WithEvents inboxItems As Outlook.Items\n'\n' Private Sub Application_Startup()\n'   Dim olNS As Outlook.Namespace\n'   Set olNS = Application.GetNamespace(\"MAPI\")\n'   Set inboxItems = olNS.GetDefaultFolder(olFolderInbox).Items\n'   Set olNS = Nothing\n' End Sub\n'\n' Private Sub inboxItems_ItemAdd(ByVal Item As Object)\n'   Dim olMail As Outlook.MailItem\n'   Dim targetFolderName As String\n'   Dim destFolder As Outlook.MAPIFolder\n'\n'   If TypeOf Item Is MailItem Then\n'     Set olMail = Item\n'     Debug.Print \"New mail received: \" & olMail.Subject\n'\n'     ' --- Rule 1: Newsletters ---\n'     If LCase(olMail.SenderEmailAddress) = \"newsletter@example.com\" Or _\n'        LCase(olMail.SenderName) = \"Daily News Digest\" Then\n'       targetFolderName = \"Newsletters\"\n'       Set destFolder = GetOrCreateFolder(Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox), targetFolderName)\n'       If Not destFolder Is Nothing Then\n'         olMail.UnRead = False\n'         olMail.Move destFolder\n'         Debug.Print \"Moved '\" & olMail.Subject & \"' to \" & targetFolderName\n'       End If\n'     End If\n'\n'     ' --- Rule 2: System Alerts (Example with subject keyword) ---\n'     If InStr(1, olMail.Subject, \"[System Alert]\", vbTextCompare) > 0 Then\n'       targetFolderName = \"SystemAlerts\"\n'       Set destFolder = GetOrCreateFolder(Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox), targetFolderName)\n'       If Not destFolder Is Nothing Then\n'         olMail.UnRead = False\n'         olMail.Move destFolder\n'         Debug.Print \"Moved '\" & olMail.Subject & \"' to \" & targetFolderName\n'       End If\n'     End If\n'     ' Add more rules as needed\n'   End If\n'   Set olMail = Nothing: Set destFolder = Nothing\n' End Sub\n'\n' ' Helper function to get or create a subfolder\n' Function GetOrCreateFolder(parentFolder As Outlook.MAPIFolder, folderName As String) As Outlook.MAPIFolder\n'   Dim fldr As Outlook.MAPIFolder\n'   On Error Resume Next\n'   Set fldr = parentFolder.Folders(folderName)\n'   If fldr Is Nothing Then\n'     Set fldr = parentFolder.Folders.Add(folderName)\n'   End If\n'   On Error GoTo 0\n'   Set GetOrCreateFolder = fldr\n' End Function\n", "explanation": "此Outlook VBA代碼 (應放置在 `ThisOutlookSession` 模組中) 使用 `inboxItems_ItemAdd` 事件來監控收件匣中的新郵件。當新郵件到達時，它會檢查發件人或主旨是否符合預定義的條件。如果符合，它會將郵件標記為已讀，然後使用 `GetOrCreateFolder` 輔助函數找到或創建目標子文件夾，並將郵件移動到該子文件夾。"}
    ],
    "keywords": ["outlook auto-archive email", "vba move email by sender", "outlook rule automation", "organize inbox vba", "自動歸檔郵件", "按發件人移動郵件"]
},
{
    "name": "自動提取會議邀請的詳細信息到Excel日曆 (Outlook to Excel)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: VBA scans the Outlook Calendar folder (or Inbox for meeting requests) for appointments/meetings within a specified date range. It extracts details like subject, start time, end time, location, organizer, required attendees, and optional attendees, then logs this information into an Excel sheet formatted as a schedule or log.",
    "description": "此應用程式用於將Outlook日曆中的會議信息導出到Excel，以便進行報告、分析或與其他日程系統整合。1. Excel日程記錄表 (“MeetingLog”)：包含列：會議主旨、開始時間、結束時間、持續時間(分鐘)、地點、召集人、必需與會者、可選與會者、會議正文摘要。2. VBA掃描與提取邏輯：a. 連接到Outlook並訪問日曆資料夾 (`olFolderCalendar`) 或收件匣 (用於處理新的會議邀請 `MeetingItem`)。b. 設定要掃描的日期範圍。c. 遍歷在該日期範圍內的 `AppointmentItem` 物件。  i. 對於每個約會，提取其 `.Subject`, `.Start`, `.End`, `.Duration`, `.Location`, `.Organizer` 屬性。  ii. 遍歷 `.Recipients` 集合以獲取必需 (`olRequired`) 和可選 (`olOptional`) 與會者列表。  iii. (可選) 提取會議正文 (`.Body`) 的一部分作為摘要。d. 將提取到的信息作為新的一行寫入Excel的“MeetingLog”工作表。3. 篩選條件 (可選)：可以添加篩選條件，例如只提取由特定人員召集的會議，或包含特定關鍵詞的會議。4. 執行方式：此宏可以手動觸發，或設定為定期執行以更新Excel日程記錄。這個工具對於需要追蹤團隊成員會議安排、分析會議時長與頻率，或為項目管理整合會議數據的場景很有用。",
    "parameters": [
        {"name": "Outlook Calendar Folder (or Inbox for MeetingItems)", "description": "要掃描會議信息的Outlook資料夾。"},
        {"name": "Date Range for Scanning", "description": "指定要提取會議的日期範圍。"},
        {"name": "Excel Output Sheet for Meeting Log", "description": "用於存放提取的會議詳細信息的工作表。"},
        {"name": "Details to Extract", "description": "定義需要從每個會議項目中提取哪些信息。"}
    ],
    "examples": [
        {"code": "Sub ExtractCalendarMeetingsToExcel()\n    Dim olApp As Object, olNS As Object, olCalendar As Object ' Outlook.MAPIFolder\n    Dim olApptItems As Object ' Outlook.Items\n    Dim olAppt As Object    ' Outlook.AppointmentItem\n    Dim xlSheet As Object   ' Excel.Worksheet\n    Dim nextRow As Long, i As Long\n    Dim startDate As Date, endDate As Date\n\n    ' --- Configuration ---\n    Set xlSheet = ThisWorkbook.Sheets(\"MeetingLog\") ' Assumes this sheet exists\n    xlSheet.Cells.ClearContents\n    xlSheet.Range(\"A1:H1\").Value = Array(\"主旨\", \"開始時間\", \"結束時間\", \"時長(分)\", \"地點\", \"召集人\", \"必需與會者\", \"可選與會者\")\n    xlSheet.Rows(1).Font.Bold = True\n    nextRow = 2\n    startDate = DateSerial(Year(Now), Month(Now), 1) ' Start of current month\n    endDate = DateSerial(Year(Now), Month(Now) + 1, 0)   ' End of current month\n\n    On Error GoTo ErrorHandler\n    Set olApp = CreateObject(\"Outlook.Application\")\n    Set olNS = olApp.GetNamespace(\"MAPI\")\n    Set olCalendar = olNS.GetDefaultFolder(9) ' 9 = olFolderCalendar\n\n    ' Filter items by date range\n    Dim strFilter As String\n    strFilter = \"[Start] >= '\" & Format(startDate, \"ddddd h:nn AMPM\") & \"' AND [End] <= '\" & Format(endDate, \"ddddd h:nn AMPM\") & \"'\"\n    Set olApptItems = olCalendar.Items.Restrict(strFilter)\n    olApptItems.Sort \"[Start]\" ' Sort by start time\n\n    If olApptItems.Count = 0 Then\n        MsgBox \"在指定日期範圍內 (\" & Format(startDate, \"yyyy-mm-dd\") & \" 到 \" & Format(endDate, \"yyyy-mm-dd\") & \") 未找到會議。\", vbInformation\n        GoTo CleanUp\n    End If\n\n    Debug.Print \"找到 \" & olApptItems.Count & \" 個會議。正在提取...\"\n\n    For Each olAppt In olApptItems\n        If olAppt.Class = 26 Then ' olAppointment (26)\n            Dim requiredAttendees As String, optionalAttendees As String\n            requiredAttendees = \"\": optionalAttendees = \"\"\n            Dim recip As Object ' Outlook.Recipient\n            For Each recip In olAppt.Recipients\n                If recip.Type = 1 Then ' olRequired\n                    requiredAttendees = requiredAttendees & recip.Name & \"; \"\n                ElseIf recip.Type = 2 Then ' olOptional\n                    optionalAttendees = optionalAttendees & recip.Name & \"; \"\n                End If\n            Next recip\n            If Len(requiredAttendees) > 0 Then requiredAttendees = Left(requiredAttendees, Len(requiredAttendees) - 2)\n            If Len(optionalAttendees) > 0 Then optionalAttendees = Left(optionalAttendees, Len(optionalAttendees) - 2)\n\n            xlSheet.Cells(nextRow, \"A\").Value = olAppt.Subject\n            xlSheet.Cells(nextRow, \"B\").Value = olAppt.Start\n            xlSheet.Cells(nextRow, \"C\").Value = olAppt.End\n            xlSheet.Cells(nextRow, \"D\").Value = olAppt.Duration\n            xlSheet.Cells(nextRow, \"E\").Value = olAppt.Location\n            xlSheet.Cells(nextRow, \"F\").Value = olAppt.Organizer\n            xlSheet.Cells(nextRow, \"G\").Value = requiredAttendees\n            xlSheet.Cells(nextRow, \"H\").Value = optionalAttendees\n            nextRow = nextRow + 1\n        End If\n        If nextRow Mod 10 = 0 Then DoEvents\n    Next olAppt\n\n    xlSheet.Columns(\"A:H\").AutoFit\n    xlSheet.Columns(\"B:C\").NumberFormat = \"yyyy-mm-dd hh:mm\"\n    MsgBox \"日曆會議信息已成功提取到Excel。\", vbInformation\n\nCleanUp:\n    Set olAppt = Nothing: Set olApptItems = Nothing: Set olCalendar = Nothing\n    Set olNS = Nothing: Set olApp = Nothing: Set xlSheet = Nothing\n    Exit Sub\n\nErrorHandler:\n    MsgBox \"提取會議時發生錯誤: \" & vbCrLf & _\n           \"錯誤號碼: \" & Err.Number & vbCrLf & \"錯誤描述: \" & Err.Description, vbCritical\n    Resume CleanUp\nEnd Sub", "explanation": "此VBA子程序 `ExtractCalendarMeetingsToExcel` 會連接到Outlook，訪問預設的日曆資料夾。它會篩選出當前月份的會議項目，並按開始時間排序。然後，它遍歷這些會議，提取主旨、開始/結束時間、時長、地點、召集人以及必需和可選與會者列表，並將這些信息寫入到名為“MeetingLog”的Excel工作表中。"}
    ],
    "keywords": ["outlook calendar to excel vba", "extract meeting details", "vba export appointments", "outlook schedule automation", "Outlook日曆導出到Excel", "提取會議信息"]
},

{
    "name": "Document.Paragraphs.Last.Range.InsertBefore (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Paragraphs.Last.Range.InsertBefore(Text As String)",
    "description": "在文件的最後一個段落的開頭 (但在該段落的任何現有內容之前) 插入指定的文字。這對於在文件末尾但技術上仍在最後一個段落內添加內容很有用。",
    "parameters": [{"name": "Text", "description": "必需。要插入的文字。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.Paragraphs.Last.Range.InsertBefore \"--- 頁尾註解開始 ---\" & vbCrLf", "explanation": "在活動文件的最後一個段落的內容之前插入一行文字。"}
    ],
    "keywords": ["word insert before last paragraph", "add text end of document section", "文件末尾段落前插入"]
},
{
    "name": "Range.Font.AllCaps (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.AllCaps = True | False",
    "description": "設定或傳回指定範圍的文字是否格式化為全部大寫字母。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示所有字母均為大寫。"}],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' selRange.Font.AllCaps = True\n' MsgBox \"選取文字已設定為全部大寫。\"", "explanation": "將目前選取的文字格式化為全部大寫字母。"}
    ],
    "keywords": ["word font allcaps", "format text all caps", "全部大寫"]
},
{
    "name": "Range.Font.SmallCaps (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.SmallCaps = True | False",
    "description": "設定或傳回指定範圍的文字是否格式化為小型大寫字母。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示格式化為小型大寫字母。"}],
    "examples": [
        {"code": "Dim titleRange As Object ' Word.Range\n' Set titleRange = ActiveDocument.Paragraphs(1).Range ' Assume first paragraph is a title\n' titleRange.Font.SmallCaps = True\n' MsgBox \"第一個段落已設定為小型大寫字母。\"", "explanation": "將文件的第一個段落格式化為小型大寫字母。"}
    ],
    "keywords": ["word font smallcaps", "format text small caps", "小型大寫字母"]
},
{
    "name": "Range.Font.StrikeThrough (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.StrikeThrough = True | False",
    "description": "設定或傳回指定範圍的文字是否帶有刪除線。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示帶有刪除線。"}],
    "examples": [
        {"code": "Dim outdatedText As Object ' Word.Range\n' Set outdatedText = Selection.Range ' User selects some text\n' outdatedText.Font.StrikeThrough = True\n' MsgBox \"選取的文字已加上刪除線。\"", "explanation": "為目前選取的文字添加刪除線效果。"}
    ],
    "keywords": ["word font strikethrough", "text strikethrough", "刪除線"]
},
{
    "name": "Selection.Font.Spacing (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.Font.Spacing = PointValue",
    "description": "設定或傳回選取文字的字元間距 (以點為單位)。正值表示加寬，負值表示緊縮。",
    "parameters": [{"name": "PointValue", "description": "字元間距的點數值。"}],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionNormal Then\n'   Selection.Font.Spacing = 2 ' Expand character spacing by 2 points\n'   MsgBox \"選取文字的字元間距已加寬。\"\n' End If", "explanation": "將目前選取文字的字元間距增加2點。"}
    ],
    "keywords": ["word character spacing", "font spacing", "字元間距"]
},
{
    "name": "ParagraphFormat.LineSpacingRule (Word)",
    "category": "Word 文件處理",
    "syntax": "paragraphFormatObject.LineSpacingRule = WdLineSpacingConstant",
    "description": "設定或傳回段落的行距規則。",
    "parameters": [
        {"name": "WdLineSpacingConstant", "description": "例如 wdLineSpaceSingle (0), wdLineSpace1pt5 (1), wdLineSpaceDouble (2), wdLineSpaceAtLeast (3), wdLineSpaceExactly (4), wdLineSpaceMultiple (5)。"}
    ],
    "examples": [
        {"code": "Dim paraFmt As Object ' Word.ParagraphFormat\n' Set paraFmt = Selection.ParagraphFormat\n' paraFmt.LineSpacingRule = wdLineSpaceDouble ' Set to double spacing\n' If paraFmt.LineSpacingRule = wdLineSpaceMultiple Then\n'   paraFmt.LineSpacing = InchesToPoints(0.2) * 12 ' If multiple, LineSpacing is number of lines\n' ElseIf paraFmt.LineSpacingRule = wdLineSpaceAtLeast Or paraFmt.LineSpacingRule = wdLineSpaceExactly Then\n'   paraFmt.LineSpacing = 15 ' If AtLeast or Exactly, LineSpacing is points\n' End If\n' MsgBox \"選取段落的行距規則已設定。\"", "explanation": "將目前選取段落的行距規則設定為雙倍行高，並根據規則類型調整 LineSpacing 屬性。"}
    ],
    "keywords": ["word line spacing rule", "set line spacing", "行距規則"]
},
{
    "name": "ParagraphFormat.KeepWithNext (Word)",
    "category": "Word 文件處理",
    "syntax": "paragraphFormatObject.KeepWithNext = True | False",
    "description": "如果指定的段落與其後續段落保持在同一頁，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示與下段同頁。"}],
    "examples": [
        {"code": "Dim headingParaFmt As Object ' Word.ParagraphFormat\n' ' Assume the current selection is a heading that should stay with the next paragraph\n' Set headingParaFmt = Selection.ParagraphFormat\n' headingParaFmt.KeepWithNext = True\n' MsgBox \"選取的段落已設定為與下段同頁。\"", "explanation": "設定目前選取的段落（通常是標題）與其後續段落保持在同一頁上。"}
    ],
    "keywords": ["word keep with next", "paragraph pagination", "與下段同頁"]
},
{
    "name": "ParagraphFormat.KeepTogether (Word)",
    "category": "Word 文件處理",
    "syntax": "paragraphFormatObject.KeepTogether = True | False",
    "description": "如果指定段落中的所有行都保持在同一頁上 (不跨頁)，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示段落行同頁。"}],
    "examples": [
        {"code": "Dim importantParaFmt As Object ' Word.ParagraphFormat\n' Set importantParaFmt = ActiveDocument.Paragraphs(5).Format ' Example: 5th paragraph\n' importantParaFmt.KeepTogether = True\n' MsgBox \"第五個段落已設定為段落行同頁。\"", "explanation": "設定文件的第五個段落，使其所有行都保持在同一頁上，避免段落中間被分頁。"}
    ],
    "keywords": ["word keep lines together", "paragraph page break control", "段落行同頁"]
},
{
    "name": "Selection.InsertDateTime (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.InsertDateTime([DateTimeFormat As String], [InsertAsField As Boolean = False], [InsertAsFullWidth As Boolean = False], [DateLanguage As WdLanguageID = wdLanguageNone], [CalendarType As WdCalendarType = wdCalendarWestern])",
    "description": "在目前選取範圍或插入點處插入目前的日期或時間，或兩者。",
    "parameters": [
        {"name": "DateTimeFormat", "description": "可選。日期的顯示格式字串 (例如 \"yyyy-MM-dd HH:mm:ss\")。如果省略，則使用系統預設長日期格式。"},
        {"name": "InsertAsField", "description": "可選。True 表示插入為可更新的 DATE 或 TIME 功能變數。"}
    ],
    "examples": [
        {"code": "' Selection.InsertDateTime DateTimeFormat:=\"dddd, MMMM d, yyyy\", InsertAsField:=True\n' MsgBox \"已插入目前日期 (長格式，作為功能變數)。\"", "explanation": "在目前插入點插入完整的日期 (例如 \"星期一, 十月 30, 2023\")，並將其作為一個可更新的功能變數。"}
    ],
    "keywords": ["word insert datetime", "add current date word", "insert time field", "插入日期時間"]
},
{
    "name": "Document.Content.Select (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Content.Select",
    "description": "選取指定文件的全部內容 (主要內容區域)。",
    "parameters": [],
    "examples": [
        {"code": "' ActiveDocument.Content.Select\n' ' Now the entire document content is selected\n' ' Selection.Font.Name = \"Garamond\"\n' MsgBox \"整個文件的內容已被選取。\"", "explanation": "選取活動文件的所有主要內容。"}
    ],
    "keywords": ["word select all content", "select entire document", "選取全部內容"]
},
{
    "name": "Selection.Delete (Word)",
    "category": "Word 文件處理",
    "syntax": "deletedChars = selectionObject.Delete([Unit As WdUnits = wdCharacter], [Count As Long = 1])",
    "description": "從文件中刪除指定的選取範圍或指定數量的字元/單字。傳回刪除的單位數。",
    "parameters": [
        {"name": "Unit", "description": "可選。WdUnits 常數，指定要刪除的單位。"},
        {"name": "Count", "description": "可選。要刪除的單位數。"}
    ],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionNormal Then ' If text is selected\n'   Selection.Delete ' Delete the selected text\n'   MsgBox \"選取的文字已被刪除。\"\n' Else ' If it's an insertion point\n'   Selection.Delete Unit:=wdCharacter, Count:=5 ' Delete next 5 characters\n'   MsgBox \"插入點後的5個字元已被刪除。\"\n' End If", "explanation": "如果選取了文字，則刪除選取的文字。如果是一個插入點，則刪除插入點後的5個字元。"}
    ],
    "keywords": ["word delete selection", "delete text word", "刪除選取文字"]
},
{
    "name": "Range.ListFormat.ApplyListTemplate (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.ListFormat.ApplyListTemplate(ListTemplate As ListTemplate, [ContinuePreviousList As Boolean = False], [ApplyTo As WdListApplyTo = wdListApplyToWholeList], [DefaultListBehavior As WdDefaultListBehavior = wdWord10ListBehavior])",
    "description": "將指定的清單範本套用於範圍中的段落。",
    "parameters": [
        {"name": "ListTemplate", "description": "必需。ListTemplate 物件，代表要套用的清單範本。"},
        {"name": "ContinuePreviousList", "description": "可選。True 表示繼續前一個清單的編號。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\nDim lt As Object ' Word.ListTemplate\n' Set selRange = Selection.Range\n' ' Get the first bulleted list template from the list gallery\n' Set lt = Application.ListGalleries(wdBulletGallery).ListTemplates(1)\n' selRange.ListFormat.ApplyListTemplate ListTemplate:=lt, ContinuePreviousList:=False, ApplyTo:=wdListApplyToSelection\n' MsgBox \"已為選取範圍套用項目符號清單範本。\"", "explanation": "為目前選取的段落套用第一個預設的項目符號清單範本。"}
    ],
    "keywords": ["word apply list template", "format as list", "bulleted list word", "numbered list word", "套用清單範本"]
},
{
    "name": "Document.TrackRevisions Property (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.TrackRevisions = True | False",
    "description": "如果追蹤對指定文件所做的變更，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示啟用追蹤修訂。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.TrackRevisions = True\n' MsgBox \"文件 '\" & wdDoc.Name & \"' 的追蹤修訂功能已啟用。\"\n' ' wdDoc.TrackRevisions = False ' To turn off", "explanation": "啟用活動文件的追蹤修訂功能。"}
    ],
    "keywords": ["word track revisions", "enable track changes", "追蹤修訂"]
},
{
    "name": "Document.Comments.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newComment = documentObject.Comments.Add(Range As Range, [Text As String])",
    "description": "在文件中指定的範圍新增一個註解，並傳回代表該新註解的 Comment 物件。",
    "parameters": [
        {"name": "Range", "description": "必需。Range 物件，註解將標記此範圍。"},
        {"name": "Text", "description": "可選。註解的文字內容。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\nDim cmt As Object ' Word.Comment\n' Set selRange = Selection.Range\n' Set cmt = ActiveDocument.Comments.Add(Range:=selRange, Text:=\"請檢查此處的數據。\")\n' cmt.Author = \"自動審閱系統\"\n' MsgBox \"已在選取範圍新增註解。\"", "explanation": "在目前選取範圍新增一個註解，並設定其作者。"}
    ],
    "keywords": ["word add comment", "insert comment word", "document review", "新增註解Word"]
},
{
    "name": "Selection.Hyperlinks.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newHyperlink = selectionObject.Hyperlinks.Add(Anchor As Object, [Address As String], [SubAddress As String], [ScreenTip As String], [TextToDisplay As String], [Target As String])",
    "description": "將新的超連結新增到選取範圍。",
    "parameters": [
        {"name": "Anchor", "description": "必需。通常是 Selection.Range。"},
        {"name": "Address", "description": "可選。連結的位址 (URL、檔案路徑)。"},
        {"name": "TextToDisplay", "description": "可選。要在文件中顯示的超連結文字。如果 Anchor 已經是包含文字的範圍，則此參數可能會覆蓋它，或將連結套用於該文字。"}
    ],
    "examples": [
        {"code": "' If Selection.Type = wdSelectionIP Then ' If it's an insertion point\n'   Selection.Hyperlinks.Add Anchor:=Selection.Range, Address:=\"http://www.microsoft.com\", TextToDisplay:=\"Microsoft 網站\"\n' ElseIf Selection.Type = wdSelectionNormal Then ' If text is selected\n'   Selection.Hyperlinks.Add Anchor:=Selection.Range, Address:=\"http://www.microsoft.com\"\n'   ' The selected text becomes the hyperlink text\n' End If\n' MsgBox \"已嘗試新增超連結。\"", "explanation": "如果在插入點，則插入一個顯示為 \"Microsoft 網站\" 的超連結。如果選取了文字，則將選取的文字轉換為超連結。"}
    ],
    "keywords": ["word add hyperlink selection", "create link word", "在選取範圍新增超連結"]
},
{
    "name": "Document.TablesOfContents.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set toc = documentObject.TablesOfContents.Add(Range As Range, [UseHeadingStyles As Boolean], [UpperHeadingLevel As Long], [LowerHeadingLevel As Long], ...)",
    "description": "在指定範圍建立一個目錄，並傳回代表該目錄的 TableOfContents 物件。",
    "parameters": [
        {"name": "Range", "description": "必需。Range 物件，目錄將在此處插入。"},
        {"name": "UseHeadingStyles", "description": "可選。True (預設) 表示使用內建標題樣式建立目錄。"},
        {"name": "UpperHeadingLevel", "description": "可選。目錄的起始標題級別 (預設1)。"},
        {"name": "LowerHeadingLevel", "description": "可選。目錄的結束標題級別 (預設9)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, tocRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' ' Insert TOC at the beginning of the document\n' Set tocRange = wdDoc.Range(Start:=0, End:=0)\n' wdDoc.TablesOfContents.Add Range:=tocRange, UseHeadingStyles:=True, UpperHeadingLevel:=1, LowerHeadingLevel:=3\n' MsgBox \"已在文件開頭插入基於標題1到標題3的目錄。\"", "explanation": "在活動文件的開頭插入一個目錄，該目錄基於標題1到標題3樣式。"}
    ],
    "keywords": ["word add table of contents", "insert toc word", "create document index", "新增目錄Word"]
},
{
    "name": "TableOfContents.Update (Word)",
    "category": "Word 文件處理",
    "syntax": "tocObject.Update",
    "description": "更新指定的 TableOfContents 物件中的頁碼和項目。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object\n' Set wdDoc = ActiveDocument\n' If wdDoc.TablesOfContents.Count > 0 Then\n'   wdDoc.TablesOfContents(1).Update\n'   MsgBox \"第一個目錄已更新。\"\n' Else\n'   MsgBox \"文件中沒有目錄可更新。\"\n' End If", "explanation": "如果活動文件中有目錄，則更新第一個目錄。"}
    ],
    "keywords": ["word update table of contents", "refresh toc", "更新目錄Word"]
},
{
    "name": "Document.Sections(Index).PageSetup (Word)",
    "category": "Word 文件處理",
    "syntax": "Set ps = documentObject.Sections(Index).PageSetup",
    "description": "傳回代表指定文件節 (Section) 的頁面設定屬性的 PageSetup 物件。",
    "parameters": [
        {"name": "Index", "description": "必需。節的索引號 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, pageSetupForSection1 As Object ' Word.PageSetup\n' Set wdDoc = ActiveDocument\n' If wdDoc.Sections.Count > 0 Then\n'   Set pageSetupForSection1 = wdDoc.Sections(1).PageSetup\n'   With pageSetupForSection1\n'     .Orientation = wdOrientLandscape ' 設定為橫向\n'     .TopMargin = InchesToPoints(0.8)\n'     .BottomMargin = InchesToPoints(0.8)\n'   End With\n'   MsgBox \"第一節的頁面設定已修改為橫向且調整了邊距。\"\n' End If", "explanation": "獲取活動文件第一節的 PageSetup 物件，並將其頁面方向設為橫向，同時調整上下邊距。"}
    ],
    "keywords": ["word section pagesetup", "set page orientation section", "section margins", "節頁面設定"]
},
{
    "name": "Selection.ClearFormatting (Word)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.ClearFormatting",
    "description": "從選取的文字中移除文字和段落格式。",
    "parameters": [],
    "examples": [
        {"code": "' Assume some text is selected by the user\n' If Selection.Type = wdSelectionNormal Then\n'   Selection.ClearFormatting\n'   MsgBox \"選取範圍的文字和段落格式已被清除。\"\n' End If", "explanation": "如果使用者選取了文字，則清除選取文字的所有字元和段落格式，使其恢復為基礎樣式的預設格式。"}
    ],
    "keywords": ["word clear formatting selection", "remove text format word", "清除選取格式"]
},

{
    "name": "NameSpace.GetSharedDefaultFolder (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set sharedFolder = olNamespace.GetSharedDefaultFolder(Recipient As Outlook.Recipient, FolderType As OlDefaultFolders)",
    "description": "傳回一個 MAPIFolder 物件，代表指定使用者的共用預設資料夾。用於存取其他使用者已授予您權限的資料夾 (例如，共用行事曆、共用連絡人)。",
    "parameters": [
        {"name": "Recipient", "description": "必需。Recipient 物件，代表其共用資料夾要被存取的使用者。"},
        {"name": "FolderType", "description": "必需。OlDefaultFolders 常數，指定要存取的資料夾類型。"}
    ],
    "examples": [
        {"code": "Dim olNS As Object, olRecipient As Object, olSharedCalendar As Object\n' Set olNS = Application.GetNamespace(\"MAPI\")\n' ' Create a Recipient object for the user whose folder you want to open\n' Set olRecipient = olNS.CreateRecipient(\"user.name@example.com\")\n' olRecipient.Resolve\n' If olRecipient.Resolved Then\n'   On Error Resume Next ' Handle if folder not shared or permissions denied\n'   Set olSharedCalendar = olNS.GetSharedDefaultFolder(olRecipient, 9) ' 9 = olFolderCalendar\n'   If Not olSharedCalendar Is Nothing Then\n'     MsgBox \"已成功開啟 '\" & olRecipient.Name & \"' 的共用行事曆。\"\n'     olSharedCalendar.Display ' Display the shared calendar\n'   Else\n'     MsgBox \"無法開啟 '\" & olRecipient.Name & \"' 的共用行事曆。錯誤: \" & Err.Description\n'   End If\n'   On Error GoTo 0\n' Else\n'   MsgBox \"無法解析收件者: user.name@example.com\"\n' End If", "explanation": "嘗試開啟名為 \"user.name@example.com\" 的使用者的共用行事曆。首先建立並解析 Recipient 物件，然後使用 GetSharedDefaultFolder 獲取共用行事曆。"}
    ],
    "keywords": ["outlook getshareddefaultfolder", "access shared calendar", "open shared contacts", "共用資料夾", "開啟共用行事曆"]
},
{
    "name": "Explorer.CurrentView Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set currentViewObject = olExplorer.CurrentView",
    "description": "傳回或設定代表目前檢視的物件。物件類型取決於檢視類型 (例如，TableView, CardView, CalendarView)。",
    "parameters": [],
    "examples": [
        {"code": "Dim olExp As Object ' Outlook.Explorer\nDim currentView As Object\n' Set olExp = Application.ActiveExplorer\n' Set currentView = olExp.CurrentView\n' If Not currentView Is Nothing Then\n'   MsgBox \"目前檢視名稱: \" & currentView.Name & vbCrLf & \"檢視類型: \" & currentView.ViewType\n'   ' Example: If it's a TableView, you can change its settings\n'   If currentView.ViewType = olTableView Then ' olTableView = 0\n'     Dim tv As Object ' Outlook.TableView\n'     Set tv = currentView\n'     ' tv.Show pełne nagłówki ' Example: tv.ShowFullHeaders = True\n'     ' tv.Apply\n'   End If\n' End If", "explanation": "獲取 Outlook 活動瀏覽器中的目前檢視，並顯示其名稱和類型。如果檢視是 TableView，則可以進一步存取其特定屬性。"}
    ],
    "keywords": ["outlook currentview", "explorer view settings", "tableview outlook", "calendarview outlook", "目前檢視", "檢視設定"]
},
{
    "name": "TableView.GroupByFields Property (Outlook View)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set groupByFieldsCollection = tableViewObject.GroupByFields",
    "description": "傳回一個 OrderFields 集合，代表用於在 TableView 中分組項目的欄位集。可以新增或移除分組欄位。",
    "parameters": [],
    "examples": [
        {"code": "Dim olExp As Object, olView As Object ' Outlook.TableView\nDim olGroupBy As Object ' Outlook.OrderFields\n' Set olExp = Application.ActiveExplorer\n' If olExp.CurrentFolder.DefaultItemType = olMailItem Then\n'   Set olView = olExp.CurrentView\n'   If olView.ViewType = olTableView Then\n'     Set olGroupBy = olView.GroupByFields\n'     olGroupBy.Clear ' Clear existing grouping\n'     olGroupBy.Add \"urn:schemas:httpmail:from\" ' Group by From field\n'     olGroupBy.Add \"urn:schemas:httpmail:subject\" ' Then group by Subject\n'     olView.Apply ' Apply changes to the view\n'     MsgBox \"目前郵件檢視已設定為按寄件者然後按主旨分組。\"\n'   End If\n' End If", "explanation": "如果目前 Outlook 檢視是 TableView (例如，典型的郵件列表)，則此程式碼會清除現有的分組，然後設定為先按「寄件者」(From) 欄位分組，再按「主旨」(Subject) 欄位分組。"}
    ],
    "keywords": ["outlook tableview groupby", "group emails outlook vba", "custom view grouping", "依欄位分組郵件"]
},
{
    "name": "TableView.SortFields Property (Outlook View)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set sortFieldsCollection = tableViewObject.SortFields",
    "description": "傳回一個 OrderFields 集合，代表用於在 TableView 中排序項目的欄位集。",
    "parameters": [],
    "examples": [
        {"code": "Dim olView As Object ' Outlook.TableView\nDim olSort As Object ' Outlook.OrderFields\n' ' Assume olView is the current TableView for emails\n' Set olView = Application.ActiveExplorer.CurrentView\n' If olView.ViewType = olTableView Then\n'   Set olSort = olView.SortFields\n'   olSort.Clear\n'   olSort.Add \"urn:schemas:httpmail:datereceived\", True ' True for Descending (newest first)\n'   olSort.Add \"urn:schemas:httpmail:sendername\", False ' False for Ascending\n'   olView.Apply\n'   MsgBox \"郵件檢視已排序：先按接收日期 (新到舊)，再按寄件者名稱 (A-Z)。\"\n' End If", "explanation": "設定郵件列表檢視的排序順序：首先按接收日期降冪排列 (最新的在前面)，然後在相同日期內按寄件者名稱升冪排列。"}
    ],
    "keywords": ["outlook tableview sortfields", "sort emails vba", "custom view sorting", "排序郵件檢視"]
},
{
    "name": "MeetingItem.GetAssociatedAppointment (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set olAppt = meetingItemObject.GetAssociatedAppointment(AddToCalendar As Boolean)",
    "description": "從會議邀請或更新 (MeetingItem) 中獲取關聯的 AppointmentItem。如果 AddToCalendar 為 True，且約會尚不存在於日曆中，則會將其新增到日曆。",
    "parameters": [{"name": "AddToCalendar", "description": "必需。布林值。"}],
    "examples": [
        {"code": "Dim olMeetingRequest As Object ' Outlook.MeetingItem (assuming it's selected)\nDim olAppt As Object ' Outlook.AppointmentItem\n' Set olMeetingRequest = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMeetingRequest) = \"MeetingItem\" Then\n'   ' Get the appointment, add to calendar if not already there\n'   Set olAppt = olMeetingRequest.GetAssociatedAppointment(True)\n'   If Not olAppt Is Nothing Then\n'     MsgBox \"已處理會議邀請 '\" & olAppt.Subject & \"' 並更新/新增至日曆。\"\n'     olAppt.Display ' Show the appointment in the calendar\n'   Else\n'     MsgBox \"無法從會議邀請獲取關聯的約會。\"\n'   End If\n' End If", "explanation": "如果選取的項目是會議邀請 (MeetingItem)，則獲取其關聯的約會。如果 AddToCalendar 設為 True，則該約會會被新增到使用者的日曆中（如果尚未存在）。"}
    ],
    "keywords": ["outlook getassociatedappointment", "process meeting request", "add meeting to calendar", "處理會議邀請", "新增會議至日曆"]
},
{
    "name": "AppointmentItem.Respond (Outlook Meeting Response)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set olResponse = appointmentItemObject.Respond(Response As OlMeetingResponse, [fNoUI As Boolean = False], [fAdditionalTextDialog As Boolean = False])",
    "description": "對會議邀請做出回應 (接受、暫訂、拒絕)。傳回一個 MeetingItem 物件，代表要傳送的回應。",
    "parameters": [
        {"name": "Response", "description": "必需。OlMeetingResponse 常數 (olMeetingAccepted, olMeetingDeclined, olMeetingTentative)。"},
        {"name": "fNoUI", "description": "可選。True 表示不顯示回應視窗。"},
        {"name": "fAdditionalTextDialog", "description": "可選。True 表示提示使用者輸入額外文字。"}
    ],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem (received meeting that needs response)\nDim olMeetingResponse As Object ' Outlook.MeetingItem\n' ' Assume olAppt points to a meeting invitation in the calendar or inbox\n' If olAppt.MeetingStatus = olMeetingReceived Then ' Check if it's an invitation awaiting response\n'   ' Accept the meeting and send response immediately without UI\n'   Set olMeetingResponse = olAppt.Respond(olMeetingAccepted, True)\n'   ' olMeetingResponse.Body = \"很高興能參加！\" ' Optional: Add a message to the response\n'   olMeetingResponse.Send\n'   MsgBox \"會議 '\" & olAppt.Subject & \"' 已接受，並已傳送回應。\"\n' End If", "explanation": "如果一個約會項目是收到的會議邀請且尚未回應，則此程式碼會自動接受該會議，並立即傳送回應，而不向使用者顯示任何介面。"}
    ],
    "keywords": ["outlook respond meeting", "accept meeting vba", "decline meeting vba", "meeting response automation", "回覆會議邀請"]
},
{
    "name": "Store Object (Outlook NameSpace)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set olStore = olNamespace.Stores(IndexOrStoreID)\nSet rootFolder = olStore.GetRootFolder()",
    "description": "代表 Outlook 設定檔中定義的訊息儲存區 (例如，Exchange 郵箱、PST 檔案、共用郵箱)。可以通過 NameSpace.Stores 集合存取。",
    "parameters": [
        {"name": "Stores(IndexOrStoreID)", "description": "集合的 Item 方法，可以按索引 (1-based) 或儲存區的 StoreID (字串) 存取。"},
        {"name": ".DisplayName", "description": "屬性：儲存區的顯示名稱。"},
        {"name": ".FilePath", "description": "屬性：對於 PST 檔案，傳回其檔案路徑。"},
        {"name": ".GetRootFolder()", "description": "方法：傳回代表此儲存區根目錄的 MAPIFolder 物件。"}
    ],
    "examples": [
        {"code": "Dim olNS As Object, olStore As Object, olRootFldr As Object\nSet olNS = Application.GetNamespace(\"MAPI\")\nIf olNS.Stores.Count > 0 Then\n  Debug.Print \"可用的郵件儲存區:\"\n  For Each olStore In olNS.Stores\n    Debug.Print \"  - \" & olStore.DisplayName & \" (ID: \" & olStore.StoreID & \")\"\n    ' Get the root folder of this store\n    Set olRootFldr = olStore.GetRootFolder()\n    Debug.Print \"    根資料夾: \" & olRootFldr.Name\n    ' You can then access olRootFldr.Folders, etc.\n  Next olStore\nEnd If", "explanation": "遍歷目前 Outlook 設定檔中的所有郵件儲存區 (例如，您的主郵箱、任何已連結的 PST 檔案或共用郵箱)，並列印每個儲存區的顯示名稱、StoreID 及其根資料夾的名稱。"}
    ],
    "keywords": ["outlook store object", "access pst file vba", "shared mailbox vba", "getrootfolder", "郵件儲存區", "存取PST檔案"]
},

{
    "name": "自動處理Outlook外出/自動回覆郵件並更新Excel追蹤表 (Outlook to Excel)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: When sending bulk emails for campaigns or important announcements, it's useful to track Out-of-Office (OOF) or other auto-replies. VBA can monitor the Inbox for these types of replies (identified by keywords in subject/body or specific X-headers), extract the sender's email, and update a status column in an Excel tracking sheet for that recipient (e.g., changing status from 'Sent' to 'OOF Reply Received').",
    "description": "此應用程式用於識別並記錄對群發郵件的自動回覆（如外出通知）。1. Excel郵件追蹤表 (“CampaignLog”)：包含原始收件人郵箱、發送日期、發送狀態、以及新增的“自動回覆狀態”列。2. Outlook事件處理或定期掃描：a. 監控收件匣中的新郵件。b. 對於每封新郵件，檢查其是否為自動回覆。判斷方法可以包括：  i. 主旨行是否包含常見的自動回覆關鍵詞 (例如，“Out of Office”, “Automatic Reply”, “自動答覆”, “不在辦公室”)。  ii. 郵件正文中是否包含典型的自動回覆短語。  iii. (高級) 檢查郵件標頭中是否有特定的自動回覆相關 X-Header (例如，`X-Auto-Response-Suppress`)。3. 匹配與更新Excel：a. 從自動回覆郵件中提取原始發件人（即自動回覆郵件的`SenderEmailAddress`，這對應於我們群發郵件的原始收件人）。b. 在Excel的“CampaignLog”表中查找該郵箱地址。c. 如果找到匹配記錄，則將其“自動回覆狀態”更新為“收到自動回覆”或更具體的類型 (例如，“外出通知”)，並可記錄收到自動回覆的日期。4. 郵件處理：可以將已識別的自動回覆郵件移動到一個專門的“自動回覆”文件夾。這個工具幫助郵件發送者了解哪些收件人可能暫時無法查看郵件，對於調整後續溝通策略或統計有效送達率有一定幫助。",
    "parameters": [
        {"name": "Excel Campaign Log Sheet", "description": "記錄群發郵件的收件人列表和追蹤狀態的工作表。"},
        {"name": "Outlook Folder for Incoming Replies", "description": "監控回覆郵件的Outlook文件夾。"},
        {"name": "Keywords/Rules for Identifying Auto-Replies", "description": "用於判斷一封郵件是否為自動回覆的關鍵詞或規則。"},
        {"name": "VBA Logic for Matching and Updating Excel", "description": "將自動回覆與原始發送記錄匹配並更新狀態的代碼。"}
    ],
    "examples": [
        {"code": "' --- Code for ThisOutlookSession module (Conceptual) ---\n' Private WithEvents campaignReplyItems As Outlook.Items\n'\n' Private Sub Application_Startup()\n'   Dim olNS As Outlook.Namespace\n'   Set olNS = Application.GetNamespace(\"MAPI\")\n'   ' Monitor Inbox or a specific folder where replies are expected\n'   Set campaignReplyItems = olNS.GetDefaultFolder(olFolderInbox).Items\n' End Sub\n'\n' Private Sub campaignReplyItems_ItemAdd(ByVal Item As Object)\n'   Dim olMail As Outlook.MailItem\n'   Dim xlSheet As Object ' Excel.Worksheet\n'   Dim excelPath As String: excelPath = \"C:\\Path\\To\\CampaignLog.xlsx\" ' **實際路徑**\n'   Dim sheetName As String: sheetName = \"EmailTracking\"\n'   Dim originalRecipientEmail As String\n'   Dim r As Long, lastRow As Long\n'   Dim xlApp As Object, xlBook As Object\n'\n'   If TypeOf Item Is MailItem Then\n'     Set olMail = Item\n'     ' --- Identify Auto-Replies (Simplified keyword check) ---\n'     Dim autoReplyKeywords As Variant\n'     autoReplyKeywords = Array(\"out of office\", \"automatic reply\", \"不在辦公室\", \"自動答覆\")\n'     Dim keyword As Variant, isAutoReply As Boolean: isAutoReply = False\n'     For Each keyword In autoReplyKeywords\n'       If InStr(1, LCase(olMail.Subject), LCase(keyword)) > 0 Or _\n'          InStr(1, LCase(olMail.Body), LCase(keyword)) > 0 Then\n'         isAutoReply = True\n'         Exit For\n'       End If\n'     Next keyword\n'\n'     If isAutoReply Then\n'       originalRecipientEmail = olMail.SenderEmailAddress ' The sender of OOF is our original recipient\n'       Debug.Print \"自動回覆偵測到來自: \" & originalRecipientEmail & \" 主旨: \" & olMail.Subject\n'\n'       ' --- Update Excel Log (Simplified: Opens Excel each time, better to keep instance) ---\n'       On Error Resume Next\n'       Set xlApp = GetObject(, \"Excel.Application\")\n'       If xlApp Is Nothing Then Set xlApp = CreateObject(\"Excel.Application\")\n'       If xlApp Is Nothing Then Debug.Print \"無法啟動Excel以更新日誌。\": Exit Sub\n'       Set xlBook = xlApp.Workbooks.Open(excelPath)\n'       Set xlSheet = xlBook.Sheets(sheetName)\n'       If xlSheet Is Nothing Then Debug.Print \"Excel日誌表 '\" & sheetName & \"' 未找到。\": xlBook.Close False: Set xlApp=Nothing: Exit Sub\n'       On Error GoTo 0\n'\n'       lastRow = xlSheet.Cells(Rows.Count, \"A\").End(xlUp).Row ' Assume Email in Col A, Status in Col D\n'       For r = 2 To lastRow\n'         If LCase(Trim(CStr(xlSheet.Cells(r, \"A\").Value))) = LCase(originalRecipientEmail) And _\n'            LCase(Trim(CStr(xlSheet.Cells(r, \"D\").Value))) <> \"oof reply received\" Then \n'           xlSheet.Cells(r, \"D\").Value = \"OOF Reply Received\"\n'           xlSheet.Cells(r, \"E\").Value = Now ' Reply Received Date (Col E)\n'           Debug.Print \"Excel日誌已更新為 '\" & originalRecipientEmail & \"' 的自動回覆。\"\n'           Exit For\n'         End If\n'       Next r\n'       xlBook.Close True ' Save changes and close\n'       ' If xlApp.Workbooks.Count = 0 Then xlApp.Quit ' Quit if no other workbooks by this instance\n'       Set xlSheet = Nothing: Set xlBook = Nothing: Set xlApp = Nothing\n'       \n'       olMail.UnRead = False\n'       ' olMail.Move Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox).Folders(\"AutoReplies\")\n'     End If\n'   End If\n'   Set olMail = Nothing\n' End Sub\n", "explanation": "此概念性Outlook VBA代碼 (放置於 `ThisOutlookSession`) 監控收件匣的新郵件。如果郵件的主旨或正文包含常見的自動回覆關鍵詞，則認為它是一個自動回覆。然後，腳本會獲取該自動回覆的發件人郵箱（這就是我們原始群發郵件的收件人），並在指定的Excel追蹤工作表 (`CampaignLog.xlsx` 中的 `EmailTracking` 表) 中查找該郵箱。如果找到匹配且狀態尚未更新，則將其狀態更新為“OOF Reply Received”並記錄收到日期。**重要提示**：此範例中更新Excel的邏輯是每次都打開和關閉Excel文件，對於頻繁的更新效率較低，更好的做法是保持Excel實例打開或使用ADO與已開啟的Excel文件交互。自動回覆的識別邏輯也比較基礎，可能需要根據實際情況進行調整。"}
    ],
    "keywords": ["outlook vba track auto-replies", "excel log out-of-office responses", "automate email campaign tracking", "oof detection vba", "追蹤Outlook自動回覆", "Excel記錄外出通知"]
},
{
    "name": "基於發件人域名和附件類型自動將郵件及附件歸檔到客戶/項目文件夾 (Outlook to FileSystem)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: VBA monitors an Outlook Inbox or specific project-related subfolders. When an email arrives from a known client domain (e.g., '@clientcompany.com') and contains specific types of attachments (e.g., '.pdf', '.docx', '.zip' but not '.exe'), the email itself (as .msg or .txt) and its relevant attachments are saved to a predefined network folder structure, typically organized by client name and then by project or date.",
    "description": "此應用程式用於自動將來自重要客戶的包含特定類型附件的郵件及其附件歸檔到文件系統中，方便項目管理和記錄保存。1. Excel配置表 (可選，或在VBA中硬編碼)：a. “ClientDomainMapping”表：客戶域名 (例如，“clientcompany.com”)，對應的客戶文件夾名稱 (例如，“Client_A_Company”)。b. “AllowedAttachmentTypes”表：允許自動歸檔的附件擴展名列表 (例如，“pdf”, “docx”, “xlsx”, “zip”)。2. Outlook事件處理 (`ItemAdd`)：a. 監控收件匣或特定項目郵件夾的新郵件。b. 發件人域名驗證：提取發件人郵箱的域名部分，並與“ClientDomainMapping”表中的列表進行匹配。3. 附件類型和名稱檢查：a. 如果發件人域名匹配，則遍歷郵件的所有附件。b. 檢查每個附件的擴展名是否在“AllowedAttachmentTypes”列表中。c. (可選) 可以排除特定名稱模式的附件 (例如，圖片簽名檔 `image001.png`)。4. 創建歸檔路徑：a. 根據匹配到的客戶域名，從“ClientDomainMapping”獲取客戶文件夾名稱。b. 構建完整的本地或網絡歸檔路徑，例如 `BaseArchivePath & ClientFolderName & \"\\\" & Format(olMail.ReceivedTime, \"yyyy-MM\") & \"\\\" & CleanSubjectForFolderName(olMail.Subject)`。可以按客戶、再按月份、再按郵件主旨（清理後）創建子文件夾。5. 保存郵件和附件：a. 將郵件本身以 `.msg` 格式 (或 `.txt` 格式保存正文) 保存到目標歸檔路徑。b. 將所有符合條件的附件也保存到同一路徑，注意處理同名文件（例如，在文件名後附加時間戳或序號）。6. 郵件標記與移動：已成功歸檔的郵件可以在Outlook中標記一個特定類別（例如，“已歸檔到文件系統”），並可選地移動到一個“已處理歸檔”的Outlook文件夾。7. 日誌記錄：將歸檔操作（時間、郵件主旨、發件人、歸檔路徑、保存的文件列表）記錄到Excel日誌表中。這個流程確保了重要客戶的相關文件和通信記錄被系統地存儲在中央文件位置，而不是僅僅散落在郵箱中。",
    "parameters": [
        {"name": "Monitored Outlook Folder", "description": "接收客戶郵件的Outlook文件夾。"},
        {"name": "Client Domain to Folder Mapping (Excel/VBA)", "description": "客戶郵箱域名與其對應的文件系統歸檔文件夾名稱的映射關係。"},
        {"name": "Allowed/Excluded Attachment Types/Names", "description": "定義哪些附件應該被歸檔，哪些應該被忽略的規則。"},
        {"name": "Archive Folder Structure Logic", "description": "如何在文件系統中組織客戶/項目歸檔文件夾的規則。"},
        {"name": "Error Handling for File Operations", "description": "處理文件保存時可能發生的錯誤（例如，路徑無效、權限不足、文件名衝突）。"}
    ],
    "examples": [
        {"code": "' --- Code for ThisOutlookSession module (Conceptual) ---\n' Private WithEvents monitoredItems As Outlook.Items\n' Private Const BASE_ARCHIVE_PATH As String = \"C:\\ClientArchives\\\" ' **實際基礎歸檔路徑**\n' Private allowedExtensions As Object ' Scripting.Dictionary\n'\n' Private Sub Application_Startup()\n'   Dim olNS As Outlook.Namespace\n'   Set olNS = Application.GetNamespace(\"MAPI\")\n'   Set monitoredItems = olNS.GetDefaultFolder(olFolderInbox).Items\n'   ' Initialize allowed extensions dictionary\n'   Set allowedExtensions = CreateObject(\"Scripting.Dictionary\")\n'   allowedExtensions.CompareMode = vbTextCompare ' Case-insensitive\n'   allowedExtensions.Add \"pdf\", True\n'   allowedExtensions.Add \"docx\", True\n'   allowedExtensions.Add \"xlsx\", True\n'   allowedExtensions.Add \"zip\", True\n' End Sub\n'\n' Private Sub monitoredItems_ItemAdd(ByVal Item As Object)\n'   Dim olMail As Outlook.MailItem\n'   Dim fso As Object: Set fso = CreateObject(\"Scripting.FileSystemObject\")\n'   Dim clientDomain As String, clientFolderName As String, mailArchiveSubPath As String, fullArchivePath As String\n'   Dim att As Outlook.Attachment, safeFileName As String, fileExt As String\n'\n'   If TypeOf Item Is MailItem Then\n'     Set olMail = Item\n'     If InStr(olMail.SenderEmailAddress, \"@\") > 0 Then\n'       clientDomain = LCase(Split(olMail.SenderEmailAddress, \"@\")(1))\n'       clientFolderName = GetClientFolderFromDomain(clientDomain) ' Custom function to map domain to folder name\n'\n'       If clientFolderName <> \"\" And olMail.Attachments.Count > 0 Then\n'         ' Create archive path: BasePath\\ClientFolder\\YYYY-MM\\CleanedSubject\\\n'         mailArchiveSubPath = clientFolderName & \"\\\" & Format(olMail.ReceivedTime, \"yyyy-mm\") & \"\\\" & CleanStringForPath(olMail.Subject)\n'         fullArchivePath = fso.BuildPath(BASE_ARCHIVE_PATH, mailArchiveSubPath)\n'         If Not fso.FolderExists(fullArchivePath) Then fso.CreateFolder fullArchivePath\n'\n'         ' Save email itself\n'         olMail.SaveAs fso.BuildPath(fullArchivePath, CleanStringForPath(olMail.Subject) & \".msg\"), olMSG\n'\n'         ' Save allowed attachments\n'         For Each att In olMail.Attachments\n'           fileExt = LCase(fso.GetExtensionName(att.FileName))\n'           If allowedExtensions.Exists(fileExt) Then\n'             safeFileName = CleanStringForPath(att.FileName)\n'             att.SaveAsFile fso.BuildPath(fullArchivePath, safeFileName)\n'             Debug.Print \"歸檔附件: \" & safeFileName & \" 到 \" & fullArchivePath\n'           End If\n'         Next att\n'\n'         olMail.Categories = \"已歸檔到文件系統\"\n'         olMail.Save\n'         ' olMail.Move GetOrCreateFolder(Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox), \"已處理歸檔\")\n'         Debug.Print \"郵件 '\" & olMail.Subject & \"' 已歸檔到 \" & fullArchivePath\n'       End If\n'     End If\n'   End If\n'   Set olMail = Nothing: Set fso = Nothing\n' End Sub\n'\n' Function GetClientFolderFromDomain(domain As String) As String\n'   ' Placeholder: Lookup in Excel sheet or hardcode\n'   Select Case domain\n'     Case \"clientA.com\": GetClientFolderFromDomain = \"ClientA_Company\"\n'     Case \"partnercorp.net\": GetClientFolderFromDomain = \"Partner_Corporation\"\n'     Case Else: GetClientFolderFromDomain = \"_OtherClients\"\n'   End Select\n' End Function\n'\n' Function CleanStringForPath(inputStr As String) As String\n'   Dim invalidChars As String: invalidChars = \"\\/:*?\"\"<>|\" & vbCrLf\n'   Dim i As Long, char As String\n'   CleanStringForPath = inputStr\n'   For i = 1 To Len(invalidChars)\n'     char = Mid(invalidChars, i, 1)\n'     CleanStringForPath = Replace(CleanStringForPath, char, \"_\")\n'   Next i\n'   If Len(CleanStringForPath) > 100 Then CleanStringForPath = Left(CleanStringForPath, 100)\n'   CleanStringForPath = Trim(CleanStringForPath)\n' End Function\n", "explanation": "此概念性Outlook VBA代碼 (放置於 `ThisOutlookSession`) 監控收件匣的新郵件。它使用一個輔助函數 `GetClientFolderFromDomain` (此處為簡化版，實際中可能查詢Excel表) 來根據發件人郵箱域名確定客戶特定的歸檔文件夾名稱。如果郵件包含附件，並且附件類型在允許的列表中（通過 `allowedExtensions` 字典檢查），則郵件本身（以.msg格式）和符合條件的附件會被保存到一個按客戶/年月/郵件主旨組織的文件夾結構中。`CleanStringForPath` 用於清理文件名和文件夾名中的非法字符。已處理的郵件會被加上類別並可選擇移動。"}
    ],
    "keywords": ["outlook vba archive email attachments to filesystem", "automate email filing", "save outlook attachments by sender domain", "organize client emails to folders", "郵件附件自動歸檔到文件夾", "按發件人域名整理郵件"]
},
{
    "name": "基於郵件內容的情緒分析初判並標記高風險客戶溝通 (Outlook, Excel, Text Analytics API - 概念)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Scenario: VBA monitors incoming client emails. For emails that are not standard auto-replies, it extracts the body text and sends it to a Text Analytics service (e.g., Azure Cognitive Services Text Analytics API - requires internet & API key) to get a sentiment score (positive, neutral, negative). If the sentiment is strongly negative, or contains specific怒氣詞彙 (defined in Excel), the email is flagged in Outlook (e.g., with a category 'High-Risk Sentiment'), and a log is made in an Excel 'ClientSentimentLog' sheet, prompting RM follow-up.",
    "description": "此高階應用旨在自動識別客戶郵件中的負面情緒，以便及時介入。1. Outlook郵件監控：使用 `ItemAdd` 事件監控新郵件。2. 初步過濾：排除已知的自動回覆或不相關的郵件。3. 文本提取：提取郵件正文的純文本內容。4. 情緒分析API調用 (核心)：  a. VBA構建一個HTTP請求（使用 `MSXML2.XMLHTTP` 或 `WinHttp.WinHttpRequest`）。  b. 將提取的郵件文本作為請求體發送到外部的情緒分析API服務端點（例如，Azure Text Analytics API的 `/sentiment` 端點）。請求中需要包含API密鑰和正確的內容格式（通常是JSON）。  c. 接收API返回的JSON響應，其中包含情緒評分（例如，一個介於0到1之間的分數，越接近0越負面）和/或主要情緒標籤（Positive, Neutral, Negative）。5. JSON解析與本地關鍵詞檢查：  a. 解析API返回的JSON以獲取情緒評分/標籤。  b. (可選補充) 在Excel的“NegativeKeywords”表中定義一個本地的負面/抱怨詞彙列表。檢查郵件正文是否包含這些詞彙，作為輔助判斷。6. 標記與記錄：  a. 如果API返回的情緒為“Negative”且置信度較高，或本地關鍵詞匹配達到一定數量，則：    i. 在Outlook中將該郵件標記一個特定類別，例如“客戶情緒預警”。    ii. 在Excel的“ClientSentimentLog”表中記錄郵件信息（發件人、日期、主旨摘要）、檢測到的情緒、以及觸發的關鍵詞（如果有）。7. 通知RM (可選)：可以創建一個Outlook任務或發送一封內部郵件給相關的客戶經理，提醒他們關注此高風險情緒郵件。重要考量：此方案依賴外部API服務，需要有效的API訂閱和密鑰，並且VBA執行環境需要能夠訪問互聯網。API調用涉及異步處理或等待，以及JSON的解析（需要輔助庫或函數）。本地關鍵詞庫的維護也很重要。保護API金鑰的安全是首要任務。",
    "parameters": [
        {"name": "Outlook Monitored Folder", "description": "監控客戶郵件的資料夾。"},
        {"name": "Text Analytics API Endpoint and Key", "description": "外部情緒分析服務的URL和API訪問密鑰。"},
        {"name": "JSON Parsing Logic/Library", "description": "用於解析API返回的JSON響應。"},
        {"name": "Local Negative Keyword List (Excel/VBA)", "description": "輔助識別負面情緒的本地詞彙表。"},
        {"name": "Excel Client Sentiment Log Sheet", "description": "記錄檢測到的高風險情緒郵件的日誌表。"},
        {"name": "Outlook Flagging/Notification Rules", "description": "如何在Outlook中標記預警郵件以及如何通知RM。"}
    ],
    "examples": [
        {"code": "' --- Conceptual VBA Snippet (Assumes an external API call function exists) ---\n' --- This requires a JSON parser and a function to call the Sentiment API. ---\n'\n' Private Const SENTIMENT_API_ENDPOINT As String = \"YOUR_AZURE_TEXT_ANALYTICS_ENDPOINT/text/analytics/v3.1/sentiment\"\n' Private Const SENTIMENT_API_KEY As String = \"YOUR_AZURE_TEXT_ANALYTICS_KEY\" ' **NEVER HARDCODE KEYS IN PRODUCTION!** Use secure storage.\n'\n' ' In ThisOutlookSession\n' Private Sub MonitoredItems_ItemAdd(ByVal Item As Object)\n'   Dim olMail As Outlook.MailItem\n'   Dim mailText As String, sentimentResultJson As String, sentimentLabel As String, sentimentScore As Double\n'   Dim isHighRisk As Boolean: isHighRisk = False\n'\n'   If TypeOf Item Is MailItem Then\n'     Set olMail = Item\n'     If Not IsAutoReply(olMail) And olMail.Importance <> olImportanceLow Then ' Basic filter\n'       mailText = olMail.Body ' Get plain text for analysis\n'       If Len(mailText) > 10 Then ' Min length for analysis\n'         ' --- Call Sentiment API (Conceptual function) ---\n'         sentimentResultJson = GetSentimentFromApi(mailText, SENTIMENT_API_ENDPOINT, SENTIMENT_API_KEY)\n'         If sentimentResultJson <> \"\" Then\n'           ' --- Parse JSON (Conceptual function - e.g., using VBA-JSON library) ---\n'           ' Dim parsedJson As Object: Set parsedJson = JsonConverter.ParseJson(sentimentResultJson)\n'           ' sentimentLabel = parsedJson(\"documents\")(1)(\"sentiment\") ' Example path in Azure response\n'           ' sentimentScore = parsedJson(\"documents\")(1)(\"confidenceScores\")(sentimentLabel) ' Example path\n'\n'           ' --- Dummy values for demonstration without real API call & parser ---\n'           If InStr(1, LCase(mailText), \"complaint\") > 0 Or InStr(1, LCase(mailText), \"very unhappy\") > 0 Then\n'               sentimentLabel = \"negative\": sentimentScore = 0.95\n'           ElseIf InStr(1, LCase(mailText), \"excellent service\") > 0 Then\n'               sentimentLabel = \"positive\": sentimentScore = 0.98\n'           Else\n'               sentimentLabel = \"neutral\": sentimentScore = 0.7\n'           End If\n'           ' --- End Dummy values ---\n'\n'           Debug.Print \"Mail: '\" & olMail.Subject & \"', Sentiment: \" & sentimentLabel & \" (Score: \" & sentimentScore & \")\"\n'           If LCase(sentimentLabel) = \"negative\" And sentimentScore > 0.75 Then ' Threshold for high risk\n'             isHighRisk = True\n'           End If\n'         End If\n'\n'         ' --- (Optional) Check local negative keywords from Excel ---\n'         ' If Not isHighRisk And ContainsLocalNegativeKeywords(mailText, ThisWorkbook.Sheets(\"NegativeKeywords\")) Then\n'         '   isHighRisk = True: sentimentLabel = sentimentLabel & \" (Local Keywords Triggered)\"\n'         ' End If\n'\n'         If isHighRisk Then\n'           olMail.Categories = \"客戶情緒預警, 待跟進\"\n'           olMail.FlagRequest = \"需立即跟進客戶情緒\"\n'           olMail.FlagDueBy = Now + 1\n'           olMail.Importance = olImportanceHigh\n'           olMail.Save\n'           LogSentimentAlertToExcel olMail, sentimentLabel, sentimentScore\n'           ' Optional: NotifyRMForHighRiskSentiment olMail\n'           Debug.Print \"高風險情緒郵件已標記並記錄: \" & olMail.Subject\n'         End If\n'       End If\n'     End If\n'   End If\n'   Set olMail = Nothing\n' End Sub\n'\n' Function GetSentimentFromApi(textToAnalyze As String, apiEndpoint As String, apiKey As String) As String\n'   ' Placeholder: This function would use MSXML2.XMLHTTP or WinHttp.WinHttpRequest\n'   ' to make a POST request to the sentiment API with 'textToAnalyze' in JSON format\n'   ' and return the JSON response string. Headers would include Ocp-Apim-Subscription-Key.\n'   GetSentimentFromApi = \"\" ' Simulate no response or error for now\n'   ' Example structure of request body for Azure Text Analytics:\n'   ' { \"documents\": [ { \"id\": \"1\", \"language\": \"en\", \"text\": \"Some text to analyze\" } ] }\n'   Debug.Print \"Simulating API call for: \" & Left(textToAnalyze, 50) & \"...\"\n'   ' Return a dummy negative response for testing:\n'   ' GetSentimentFromApi = \"{ \"\"documents\"\": [ { \"\"id\"\": \"\"1\"\", \"\"sentiment\"\": \"\"negative\"\", \"\"confidenceScores\"\": { \"\"positive\"\": 0.01, \"\"neutral\"\": 0.05, \"\"negative\"\": 0.94 } } ], \"\"errors\"\": [] }\"\n' End Function\n'\n' Sub LogSentimentAlertToExcel(mailItem As Outlook.MailItem, sentiment As String, score As Double)\n'   ' Placeholder: Code to write details to 'ClientSentimentLog' Excel sheet\n'   Debug.Print \"記錄到Excel - 發件人: \" & mailItem.SenderEmailAddress & \", 主旨: \" & mailItem.Subject & \", 情緒: \" & sentiment\n' End Sub\n' ' Other helper functions like IsAutoReply, ContainsLocalNegativeKeywords, NotifyRM would be needed.\n", "explanation": "此概念性Outlook VBA代碼 (放置於 `ThisOutlookSession`) 監控新郵件。它首先對郵件進行初步過濾（例如，排除自動回覆和低重要性郵件）。然後，它將郵件正文發送到一個假設的外部情緒分析API（通過 `GetSentimentFromApi` 函數，此處為佔位符，實際實現需要進行HTTP請求和JSON處理）。根據API返回的情緒標籤（例如，\"negative\"）和置信度評分，以及可選的本地負面關鍵詞庫檢查，如果郵件被判定為高風險負面情緒，則會在Outlook中為該郵件加上特定分類、標記跟進請求和高重要性，並調用 `LogSentimentAlertToExcel` 將其記錄到Excel日誌表中。**重要：** 此範例的核心部分——API調用和JSON解析——是概念性的，需要您實現或集成相應的庫。API金鑰管理也至關重要。"}
    ],
    "keywords": ["outlook vba sentiment analysis", "excel client email mood tracking", "text analytics api vba", "automate customer complaint flagging", "客戶郵件情緒分析", "Excel記錄負面反饋", "文本分析API"]
},
// Excel 核心操作
{
    "name": "Range.Font.FontStyle",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Font.FontStyle = \"Bold Italic\" ' Or \"Regular\", \"Italic\", \"Bold\"",
    "description": "設定或傳回儲存格文字的字型樣式 (例如，\"粗體 斜體\")。",
    "parameters": [{"name": "StyleString", "description": "字串，如 \"Bold\", \"Italic\", \"Bold Italic\", \"Regular\"。"}],
    "examples": [
        {"code": "Range(\"A1\").Font.FontStyle = \"Bold Italic\"\nMsgBox \"A1的字型樣式為: \" & Range(\"A1\").Font.FontStyle", "explanation": "將A1儲存格的字型樣式設為粗體斜體。"}
    ],
    "keywords": ["fontstyle", "字型樣式", "excel text format"]
},
{
    "name": "Range.Interior.PatternColorIndex",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Interior.PatternColorIndex = XlColorIndexConstant Or Index",
    "description": "設定或傳回儲存格內部背景圖樣的顏色索引。如果 Pattern 為 xlSolid，則這也類似於設定背景色。",
    "parameters": [{"name": "XlColorIndexConstant Or Index", "description": "顏色索引號或 XlColorIndex 常數 (例如 xlColorIndexAutomatic, xlColorIndexNone, 或1-56)。"}],
    "examples": [
        {"code": "With Range(\"A1\").Interior\n  .Pattern = xlGray16 ' 設定一個非實心圖樣\n  .PatternColorIndex = 5 ' 設定圖樣顏色為藍色 (索引5)\nEnd With\nMsgBox \"A1的背景圖樣顏色已設定。\"", "explanation": "為A1儲存格設定16%灰色背景圖樣，並將圖樣本身的顏色設為藍色。"}
    ],
    "keywords": ["patterncolorindex", "背景圖樣顏色", "excel cell shading"]
},
{
    "name": "Range.Borders(xlDiagonalDown).Weight",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Borders(xlDiagonalDown).Weight = XlBorderWeightConstant",
    "description": "設定從左上到右下對角線框線的粗細。",
    "parameters": [{"name": "XlBorderWeightConstant", "description": "例如 xlHairline, xlThin, xlMedium, xlThick。"}],
    "examples": [
        {"code": "With Range(\"A1\").Borders(xlDiagonalDown)\n  .LineStyle = xlContinuous\n  .Weight = xlThick\n  .Color = vbRed\nEnd With\nMsgBox \"A1已設定粗紅色左上到右下對角線。\"", "explanation": "為A1儲存格設定一條從左上到右下的粗紅色對角線。"}
    ],
    "keywords": ["diagonal border weight", "對角線粗細", "excel cell border"]
},
{
    "name": "Range.Hyperlinks.Item(Index).Address",
    "category": "Excel 核心操作",
    "syntax": "addressString = rangeObject.Hyperlinks.Item(Index).Address",
    "description": "傳回範圍中特定超連結的目標位址 (URL 或檔案路徑)。",
    "parameters": [{"name": "Index", "description": "必需。超連結在儲存格 Hyperlinks 集合中的索引 (1-based)。"}],
    "examples": [
        {"code": "ActiveSheet.Hyperlinks.Add Anchor:=Range(\"A1\"), Address:=\"http://www.example.com\"\nIf Range(\"A1\").Hyperlinks.Count > 0 Then\n  MsgBox \"A1中第一個超連結的位址: \" & Range(\"A1\").Hyperlinks.Item(1).Address\nEnd If", "explanation": "如果在A1儲存格中存在超連結，則顯示其第一個超連結的位址。"}
    ],
    "keywords": ["hyperlink address", "get link url", "超連結位址"]
},
{
    "name": "Range.Comment.Shape (Legacy Comment)",
    "category": "Excel 核心操作",
    "syntax": "Set commentShape = rangeObject.Comment.Shape",
    "description": "傳回代表舊版註解方塊的 Shape 物件。允許修改註解方塊的外觀，如大小、顏色等。",
    "parameters": [],
    "examples": [
        {"code": "Dim cmt As Comment, shpCmt As Shape\n' Range(\"A1\").ClearComments\n' Range(\"A1\").AddComment \"This is a legacy comment.\"\n' Set cmt = Range(\"A1\").Comment\n' If Not cmt Is Nothing Then\n'   Set shpCmt = cmt.Shape\n'   shpCmt.Fill.ForeColor.RGB = RGB(255, 255, 200) ' Light yellow background\n'   shpCmt.TextFrame.Characters.Font.Bold = True\n'   MsgBox \"A1儲存格的舊版註解外觀已修改。\"\n' End If", "explanation": "如果A1儲存格有舊版註解，則獲取其Shape物件並修改其背景色和文字字型。"}
    ],
    "keywords": ["comment shape", "format legacy comment", "註解圖案", "舊版註解格式"]
},
{
    "name": "Range.Validation.Type Property",
    "category": "Excel 核心操作",
    "syntax": "validationTypeConstant = rangeObject.Validation.Type",
    "description": "傳回一個 XlDVType 常數，表示應用於範圍的資料驗證類型。如果範圍中存在多種類型或無驗證，則可能傳回特定值或錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Validation.Add Type:=xlValidateList, Formula1:=\"Yes,No\"\nDim dvType As Long\nOn Error Resume Next ' In case no validation or mixed types\ndvType = Range(\"A1\").Validation.Type\nOn Error GoTo 0\nIf dvType > 0 Then\n  MsgBox \"A1的資料驗證類型是: \" & dvType & \" (例如，xlValidateList = \" & xlValidateList & \")\"\nElse\n  MsgBox \"A1沒有單一的資料驗證類型，或沒有驗證。\"\nEnd If", "explanation": "獲取A1儲存格的資料驗證類型並顯示其常數值。"}
    ],
    "keywords": ["validation type", "get data validation type", "資料驗證類型"]
},
{
    "name": "Worksheet.Phonetics.Count Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "count = worksheetObject.Phonetics.Count",
    "description": "傳回工作表上 Phonetic 物件的數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim ws As Worksheet\nSet ws = ActiveSheet\n' Add some phonetic text for testing\n' ws.Range(\"A1\").Value = \"日本\"\n' ws.Range(\"A1\").Phonetics.Add Start:=1, Length:=2, Text:=\"にほん\"\nMsgBox \"活動工作表上共有 \" & ws.Phonetics.Count & \" 個注音假名物件。\"", "explanation": "顯示活動工作表上注音假名物件的總數。"}
    ],
    "keywords": ["phonetics count", "count furigana", "注音假名計數"]
},
{
    "name": "Range.Cut (Destination)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Cut([Destination As Range])",
    "description": "將指定範圍的內容剪下並貼到剪貼簿或指定的目標位置。",
    "parameters": [{"name": "Destination", "description": "可選。Range 物件，指定剪下內容要貼上的新位置。如果省略，則剪下到剪貼簿。"}],
    "examples": [
        {"code": "Range(\"A1:A5\").Cut Destination:=Range(\"C1\")\nMsgBox \"A1:A5的內容已剪下並貼到C1開始的區域。\"", "explanation": "將範圍A1:A5的內容剪下並貼到以C1為左上角的儲存格。"}
    ],
    "keywords": ["剪下貼上", "移動儲存格", "excel cut paste", "move cells"]
},
{
    "name": "Range.AutoFill",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AutoFill(Destination As Range, [Type As XlAutoFillType = xlFillDefault])",
    "description": "對指定範圍內的儲存格執行自動填充。rangeObject 必須是 Destination 範圍的第一列或第一列。",
    "parameters": [
        {"name": "Destination", "description": "必需。要填充的 Range 物件。必須包含來源範圍。"},
        {"name": "Type", "description": "可選。XlAutoFillType 常數，指定填充類型。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 1\nRange(\"A2\").Value = 2\nRange(\"A1:A2\").AutoFill Destination:=Range(\"A1:A10\"), Type:=xlFillSeries\nMsgBox \"A1:A10已使用A1:A2的序列自動填充。\"", "explanation": "使用A1和A2中的值 (1, 2) 作為序列，自動填充A3到A10 (結果為3, 4, ..., 10)。"}
    ],
    "keywords": ["自動填充", "excel autofill", "fill series"]
},
{
    "name": "Range.Ungroup (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Ungroup",
    "description": "取消指定範圍中列或欄的分組 (大綱)。",
    "parameters": [],
    "examples": [
        {"code": "' Rows(\"3:6\").Group ' First group some rows\n' Rows(\"3:6\").Ungroup ' Then ungroup them\n' MsgBox \"先前分組的第3到6列已取消分組。\"", "explanation": "如果第3到6列之前被分組，則此程式碼將取消該分組。"}
    ],
    "keywords": ["ungroup rows", "ungroup columns", "remove outline excel", "取消分組"]
},
{
    "name": "Range.GoalSeek",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.GoalSeek(Goal, ChangingCell As Range) As Boolean",
    "description": "調整一個儲存格的值，直到包含特定公式的儲存格 (rangeObject) 達到指定的目標值 (Goal)。傳回 True 如果找到解。",
    "parameters": [
        {"name": "Goal", "description": "必需。希望 rangeObject 達到的值。"},
        {"name": "ChangingCell", "description": "必需。Range 物件，指定要更改以達到目標的儲存格。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 10 ' Input value\nRange(\"A2\").Value = 5  ' Input value\nRange(\"A3\").Formula = \"=A1*A2\" ' Formula cell (want this to be 100)\n' We want A3 to be 100 by changing A1\nIf Range(\"A3\").GoalSeek(Goal:=100, ChangingCell:=Range(\"A1\")) Then\n  MsgBox \"找到解: A1應為 \" & Range(\"A1\").Value & \" 以使A3等於100。\"\nElse\n  MsgBox \"目標搜尋未找到解。\"\nEnd If", "explanation": "在A3包含公式=A1*A2的情況下，通過調整A1的值，使A3的結果達到100。"}
    ],
    "keywords": ["目標搜尋", "what-if analysis", "excel goalseek", "單變數求解"]
},
{
    "name": "Worksheet.Select (ReplaceSelection Parameter)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Select([Replace As Boolean = True])",
    "description": "選取指定的工作表。Replace 引數決定此選取是否取代先前的選取。",
    "parameters": [
        {"name": "Replace", "description": "可選。True (預設) 表示新選取取代先前選取。False 表示將此工作表添加到現有選取的工作表集合中 (用於多選工作表)。"}
    ],
    "examples": [
        {"code": "Sheets(\"Sheet1\").Select ' Selects Sheet1 only\n' Select Sheet1 and Sheet3 together (if Sheet1 is already active and you want to add Sheet3)\n' Application.ScreenUpdating = False ' Recommended when selecting multiple sheets programmatically\n' Sheets(\"Sheet3\").Select Replace:=False\n' MsgBox ActiveWindow.SelectedSheets.Count & \" 個工作表已被選取。\"\n' Application.ScreenUpdating = True\n' Sheets(1).Select ' Reselect a single sheet to clear multi-select mode for user", "explanation": "演示如何選取單個工作表，以及如何使用 Replace:=False (概念性，通常結合Ctrl鍵在UI中操作) 來選取多個工作表。"}
    ],
    "keywords": ["選取多個工作表", "excel select multiple sheets", "worksheet select replace"]
},
{
    "name": "Worksheet.Protection.AllowFormattingCells Property",
    "category": "Excel 核心操作",
    "syntax": "isAllowed = worksheetObject.Protection.AllowFormattingCells",
    "description": "如果受保護的工作表允許格式化儲存格，則傳回 True。此屬性在呼叫 Worksheet.Protect 方法時設定。唯讀 (在工作表受保護後)。",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Protect AllowFormattingCells:=True ' Protect sheet but allow cell formatting\nIf ActiveSheet.Protection.AllowFormattingCells Then\n  MsgBox \"此受保護的工作表允許使用者格式化儲存格。\"\nElse\n  MsgBox \"此受保護的工作表不允許格式化儲存格。\"\nEnd If\nActiveSheet.Unprotect", "explanation": "保護工作表同時允許使用者格式化儲存格，然後檢查此保護屬性。"}
    ],
    "keywords": ["worksheet protection allow formatting", "protected sheet format cells", "保護工作表允許格式化"]
},
{
    "name": "Worksheet.ScrollArea Property",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.ScrollArea [= rangeAddressString]",
    "description": "設定或傳回允許捲動的範圍 (A1樣式參照)。超出此範圍的區域將無法被選取。設為空字串 \"\" 以移除捲動區域限制。",
    "parameters": [{"name": "rangeAddressString", "description": "字串，例如 \"A1:G20\"。"}],
    "examples": [
        {"code": "ActiveSheet.ScrollArea = \"A1:H30\"\nMsgBox \"活動工作表的捲動區域已限制為 A1:H30。\"\n' To remove restriction: ActiveSheet.ScrollArea = \"\"", "explanation": "將活動工作表的捲動區域限制在 A1:H30 範圍內。"}
    ],
    "keywords": ["捲動區域限制", "excel scrollarea", "limit scrolling range"]
},
{
    "name": "Worksheet.CustomProperties.Add",
    "category": "Excel 核心操作",
    "syntax": "Set cp = worksheetObject.CustomProperties.Add(Name As String, Value As Variant)",
    "description": "將自訂屬性新增到工作表的 CustomProperties 集合中。",
    "parameters": [
        {"name": "Name", "description": "必需。自訂屬性的名稱。"},
        {"name": "Value", "description": "必需。自訂屬性的值。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet, newProp As CustomProperty\nSet ws = ActiveSheet\nOn Error Resume Next ' In case property already exists\nSet newProp = ws.CustomProperties.Add(Name:=\"Version\", Value:=\"1.2.3\")\nIf Err.Number <> 0 Then ' Property might exist, try accessing\n    Err.Clear\n    ws.CustomProperties(\"Version\").Value = \"1.2.4\" ' Update if exists\nEnd If\nOn Error GoTo 0\nMsgBox \"工作表自訂屬性 'Version' 的值是: \" & ws.CustomProperties(\"Version\").Value", "explanation": "為活動工作表新增一個名為 \"Version\" 的自訂屬性並設定其值。如果已存在則更新它。"}
    ],
    "keywords": ["worksheet custom properties", "add custom property sheet", "工作表自訂屬性"]
},
{
    "name": "Workbook.HasPassword Property",
    "category": "Excel 核心操作",
    "syntax": "isPasswordProtected = workbookObject.HasPassword",
    "description": "如果活頁簿設定了開啟密碼，則傳回 True。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "If ThisWorkbook.HasPassword Then\n  MsgBox \"此活頁簿受開啟密碼保護。\"\nElse\n  MsgBox \"此活頁簿沒有設定開啟密碼。\"\nEnd If", "explanation": "檢查目前活頁簿是否設定了開啟密碼。"}
    ],
    "keywords": ["workbook haspassword", "check password protection", "活頁簿是否有密碼"]
},
{
    "name": "Workbook.Password Property (Set/Get)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.Password = passwordString ' Set password for opening\npasswordString = workbookObject.Password ' Get password (only works if you know it)",
    "description": "設定或傳回開啟活頁簿所需的密碼。設定密碼會在下次儲存時生效。獲取密碼通常不直接使用，因為您需要先能開啟檔案。",
    "parameters": [{"name": "passwordString", "description": "密碼字串。"}],
    "examples": [
        {"code": "' CAUTION: Setting password programmatically\n' ThisWorkbook.Password = \"MySecret123\" ' Sets password for next save\n' ThisWorkbook.Save ' Now it's password protected\n' MsgBox \"活頁簿已設定開啟密碼。下次開啟需要輸入。\"\n' ThisWorkbook.Password = \"\" ' Remove password (for next save)\n' ThisWorkbook.Save ' Save again to remove password protection", "explanation": "演示如何為活頁簿設定和移除開啟密碼。設定或移除密碼後需要儲存活頁簿才會生效。"}
    ],
    "keywords": ["workbook password", "set open password", "remove workbook password", "活頁簿密碼"]
},
{
    "name": "Workbook.WritePassword Property",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.WritePassword = passwordString",
    "description": "設定或傳回儲存活頁簿變更所需的寫入權限密碼 (寫入預留密碼)。",
    "parameters": [{"name": "passwordString", "description": "寫入權限密碼字串。設為空字串 \"\" 可移除。"}],
    "examples": [
        {"code": "ThisWorkbook.WritePassword = \"WritePass456\"\nThisWorkbook.Save\nMsgBox \"活頁簿已設定寫入預留密碼。修改並儲存時需要此密碼，否則只能唯讀開啟。\"\n' ThisWorkbook.WritePassword = \"\" ' To remove\n' ThisWorkbook.Save", "explanation": "為目前活頁簿設定寫入預留密碼。"}
    ],
    "keywords": ["workbook writepassword", "write reservation password", "寫入預留密碼"]
},
{
    "name": "Workbook.CreateForecastSheet (Excel 2016+)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.CreateForecastSheet(Timeline As Range, Values As Range, [ForecastStart], [ForecastEnd], [ConfInt As Double = 0.95], [Seasonality As Variant = 1], ...)",
    "description": "基於現有的時間序列資料建立一個新的預測工作表。",
    "parameters": [
        {"name": "Timeline", "description": "必需。包含日期或時間戳的 Range。"},
        {"name": "Values", "description": "必需。包含對應數值的 Range。"},
        {"name": "ForecastEnd", "description": "可選。預測結束的日期。"}
    ],
    "examples": [
        {"code": "' Assume Sheet1 A1:A10 contains dates (Timeline) and B1:B10 contains values\n' On Error Resume Next ' Requires Excel 2016 or later\n' ThisWorkbook.CreateForecastSheet Timeline:=Sheets(\"Sheet1\").Range(\"A1:A10\"), _\n'                                  Values:=Sheets(\"Sheet1\").Range(\"B1:B10\"), _\n'                                  ForecastEnd:=DateSerial(Year(Now) + 1, Month(Now), Day(Now))\n' If Err.Number = 0 Then\n'   MsgBox \"已基於 Sheet1!A1:B10 的資料建立預測工作表。\"\n' Else\n'   MsgBox \"無法建立預測工作表。錯誤: \" & Err.Description & \" (可能需要Excel 2016+)\"\n' End If\n' On Error GoTo 0", "explanation": "根據 Sheet1 中 A1:A10 的時間軸資料和 B1:B10 的數值資料，建立一個預測到明年今天的預測工作表。"}
    ],
    "keywords": ["create forecast sheet", "excel forecasting", "time series forecast", "建立預測工作表"]
},
{
    "name": "Application.Undo",
    "category": "Excel 核心操作",
    "syntax": "Application.Undo",
    "description": "撤銷使用者介面中執行的上一個動作。如果上一個動作無法撤銷，或者撤銷堆疊為空，則此方法無效。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Original Text\"\nRange(\"A1\").Value = \"New Text\" ' User action or VBA action\n' If the last action was undoable from UI:\nOn Error Resume Next ' Undo might fail if stack is empty or action not undoable\nApplication.Undo\nIf Err.Number = 0 Then\n  MsgBox \"上一個動作 (將A1設為 'New Text') 已被撤銷。A1現在是: '\" & Range(\"A1\").Value & \"'\"\nElse\n  MsgBox \"無法執行撤銷。\"\nEnd If\nOn Error GoTo 0", "explanation": "將A1設為 \"New Text\" 後，嘗試使用 Application.Undo 撤銷此操作。"}
    ],
    "keywords": ["撤銷", "excel undo", "undo last action"]
},
{
    "name": "Application.Build Property",
    "category": "Excel 核心操作",
    "syntax": "buildNumberString = Application.Build",
    "description": "傳回 Microsoft Excel 的組建編號 (字串)。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"Excel 組建編號: \" & Application.Build", "explanation": "顯示目前執行的 Excel 實例的組建編號。"}
    ],
    "keywords": ["excel build number", "application build", "Excel版本組建"]
},
{
    "name": "Application.CalculationInterruptKey Property",
    "category": "Excel 核心操作",
    "syntax": "Application.CalculationInterruptKey = XlCalculationInterruptKeyConstant",
    "description": "設定用於在計算期間中斷 Microsoft Excel 的按鍵。預設為 xlNoKey (沒有中斷鍵)。可以設為 xlEscKey 以允許 Esc 鍵中斷。",
    "parameters": [{"name": "XlCalculationInterruptKeyConstant", "description": "xlNoKey 或 xlEscKey。"}],
    "examples": [
        {"code": "Application.CalculationInterruptKey = xlEscKey\nMsgBox \"已設定 Esc 鍵可以中斷 Excel 計算。\"\n' Application.CalculationInterruptKey = xlNoKey ' Restore default", "explanation": "設定 Esc 鍵作為計算的中斷鍵。"}
    ],
    "keywords": ["calculation interrupt key", "stop calculation excel", "計算中斷鍵"]
},
{
    "name": "Application.CalculationState Property",
    "category": "Excel 核心操作",
    "syntax": "stateConstant = Application.CalculationState",
    "description": "傳回一個 XlCalculationState 常數，指出應用程式的計算狀態 (xlDone, xlCalculating, xlPending)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim calcState As Long\ncalcState = Application.CalculationState\nSelect Case calcState\n  Case 0: Debug.Print \"計算狀態: xlDone\"\n  Case 1: Debug.Print \"計算狀態: xlCalculating\"\n  Case 2: Debug.Print \"計算狀態: xlPending\"\nEnd Select\n' If calcState = xlCalculating Then MsgBox \"Excel目前正在計算中...\"", "explanation": "獲取並顯示 Excel 目前的計算狀態。"}
    ],
    "keywords": ["calculation state", "excel calculating status", "計算狀態"]
},
{
    "name": "Application.CentimetersToPoints",
    "category": "Excel 核心操作",
    "syntax": "pointValue = Application.CentimetersToPoints(Centimeters As Double)",
    "description": "將度量單位從公分轉換為點 (1 英吋 = 72 點；1 英吋 = 2.54 公分)。",
    "parameters": [{"name": "Centimeters", "description": "必需。要轉換的公分數值。"}],
    "examples": [
        {"code": "Dim widthInPoints As Double\nwidthInPoints = Application.CentimetersToPoints(5) ' Convert 5 cm to points\nMsgBox \"5 公分約等於 \" & Format(widthInPoints, \"0.00\") & \" 點。\"\n' ActiveSheet.PageSetup.LeftMargin = Application.CentimetersToPoints(2.5)", "explanation": "將5公分轉換為點數，並示範如何用於設定頁面邊距。"}
    ],
    "keywords": ["centimeters to points", "unit conversion cm", "公分轉點"]
},
{
    "name": "Application.ConvertFormula",
    "category": "Excel 核心操作",
    "syntax": "convertedFormulaString = Application.ConvertFormula(Formula As String, FromReferenceStyle As XlReferenceStyle, [ToReferenceStyle], [ToAbsolute As XlReferenceType], [RelativeTo As Range])",
    "description": "轉換儲存格參照在公式中的樣式 (例如，從 A1 到 R1C1) 和類型 (絕對/相對)。",
    "parameters": [
        {"name": "Formula", "description": "必需。要轉換的公式字串。"},
        {"name": "FromReferenceStyle", "description": "必需。XlReferenceStyle 常數，指定公式的原始參照樣式。"},
        {"name": "ToReferenceStyle", "description": "可選。XlReferenceStyle 常數，指定目標參照樣式。"},
        {"name": "ToAbsolute", "description": "可選。XlReferenceType 常數，指定轉換後的參照類型。"}
    ],
    "examples": [
        {"code": "Dim formulaA1 As String, formulaR1C1 As String\nformulaA1 = \"=SUM(B1:B10)\"\nformulaR1C1 = Application.ConvertFormula(Formula:=formulaA1, FromReferenceStyle:=xlA1, ToReferenceStyle:=xlR1C1)\nMsgBox \"A1樣式 '\" & formulaA1 & \"' 轉換為R1C1樣式是: '\" & formulaR1C1 & \"'\"", "explanation": "將 A1 樣式的公式 \"=SUM(B1:B10)\" 轉換為 R1C1 樣式。"}
    ],
    "keywords": ["convertformula", "formula reference style", "a1 to r1c1", "公式參照轉換"]
},
{
    "name": "Application.DefaultSheetDirection Property",
    "category": "Excel 核心操作",
    "syntax": "Application.DefaultSheetDirection = xlContext | xlLTR | xlRTL",
    "description": "設定或傳回新工作表的預設顯示方向 (從左到右 xlLTR，或從右到左 xlRTL)。xlContext 表示基於語言設定。",
    "parameters": [{"name": "DirectionConstant", "description": "xlContext, xlLTR, xlRTL。"}],
    "examples": [
        {"code": "MsgBox \"目前新工作表的預設方向常數是: \" & Application.DefaultSheetDirection\n' Application.DefaultSheetDirection = xlRTL ' Set new sheets to be Right-to-Left\n' Dim newWs As Worksheet: Set newWs = Worksheets.Add\n' MsgBox \"新建立的工作表方向是否為從右到左: \" & (newWs.DisplayRightToLeft = True)", "explanation": "顯示目前Excel應用程式為新工作表設定的預設方向。"}
    ],
    "keywords": ["default sheet direction", "rtl sheet excel", "新工作表方向"]
},
{
    "name": "Application.EnableAutoComplete Property",
    "category": "Excel 核心操作",
    "syntax": "Application.EnableAutoComplete [= Boolean]",
    "description": "如果啟用儲存格值的自動完成功能，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "Boolean", "description": "True 啟用，False 禁用。"}],
    "examples": [
        {"code": "If Application.EnableAutoComplete Then\n  MsgBox \"儲存格自動完成功能已啟用。\"\n  ' Application.EnableAutoComplete = False ' To disable\nEnd If", "explanation": "檢查並可切換Excel的儲存格自動完成功能。"}
    ],
    "keywords": ["enableautocomplete", "excel autocomplete cell", "儲存格自動完成"]
},
{
    "name": "Application.Iteration Property (Circular References)",
    "category": "Excel 核心操作",
    "syntax": "Application.Iteration = True | False",
    "description": "如果 Excel 將使用迭代來解析循環參照，則為 True。讀取/寫入布林值。",
    "parameters": [
        {"name": ".MaxChange", "description": "屬性：設定或傳回兩次迭代結果之間允許的最大變更量。"},
        {"name": ".MaxIterations", "description": "屬性：設定或傳回 Excel 在解析循環參照時可以進行的最大迭代次數。"}
    ],
    "examples": [
        {"code": "Application.Iteration = True\nApplication.MaxIterations = 1000\nApplication.MaxChange = 0.0001\nMsgBox \"已啟用迭代計算，最大迭代次數: \" & Application.MaxIterations & \", 最大變更: \" & Application.MaxChange\n' Range(\"A1\").Formula = \"=A1+1\" ' This would now iterate if Iteration is True", "explanation": "啟用迭代計算以處理循環參照，並設定最大迭代次數和最大變更量。"}
    ],
    "keywords": ["iteration calculation", "circular reference excel", "maxiterations", "maxchange", "迭代計算", "循環參照處理"]
},
{
    "name": "Application.MoveAfterReturn Property / .MoveAfterReturnDirection",
    "category": "Excel 核心操作",
    "syntax": "Application.MoveAfterReturn = True | False\nApplication.MoveAfterReturnDirection = XlDirectionConstant",
    "description": "MoveAfterReturn 控制按下 Enter 鍵後活動儲存格是否移動。MoveAfterReturnDirection 設定移動的方向。",
    "parameters": [
        {"name": "MoveAfterReturn (Boolean)", "description": "True (預設) 表示移動。"},
        {"name": "MoveAfterReturnDirection (XlDirectionConstant)", "description": "xlDown (預設), xlToRight, xlToLeft, xlUp。"}
    ],
    "examples": [
        {"code": "Application.MoveAfterReturn = True\nApplication.MoveAfterReturnDirection = xlToRight\nMsgBox \"按下Enter鍵後，活動儲存格將向右移動。\"\n' Restore defaults:\n' Application.MoveAfterReturnDirection = xlDown", "explanation": "設定Excel在用戶按下Enter鍵後將活動儲存格游標向右移動。"}
    ],
    "keywords": ["move after enter", "excel enter key behavior", "Enter鍵後移動"]
},
{
    "name": "Application.Path Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "appPathString = Application.Path",
    "description": "傳回包含 Excel.exe 執行檔的完整路徑 (字串)，不包括最後的反斜線。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"Excel應用程式的路徑是: \" & Application.Path", "explanation": "顯示Excel應用程式的安裝路徑。"}
    ],
    "keywords": ["application path excel", "excel installation path", "Excel程式路徑"]
},
{
    "name": "Application.SheetsInNewWorkbook Property",
    "category": "Excel 核心操作",
    "syntax": "Application.SheetsInNewWorkbook [= Long]",
    "description": "設定或傳回 Microsoft Excel 在建立新活頁簿時自動插入的工作表數量。",
    "parameters": [{"name": "Long", "description": "1 到 255 之間的整數。"}],
    "examples": [
        {"code": "Dim originalSheetCount As Long\noriginalSheetCount = Application.SheetsInNewWorkbook\nApplication.SheetsInNewWorkbook = 1 ' Set new workbooks to have only 1 sheet by default\nMsgBox \"新活頁簿的預設工作表數量已設為 1。\"\n' Workbooks.Add ' New workbook will have 1 sheet\nApplication.SheetsInNewWorkbook = originalSheetCount ' Restore original setting", "explanation": "設定當建立新活頁簿時，預設只包含一個工作表。"}
    ],
    "keywords": ["sheets in new workbook", "default number of sheets", "新活頁簿工作表數量"]
},
{
    "name": "Application.StandardFont / .StandardFontSize Properties",
    "category": "Excel 核心操作",
    "syntax": "Application.StandardFont = fontNameString\nApplication.StandardFontSize = pointSizeLong",
    "description": "設定或傳回 Excel 的標準 (預設) 字型名稱和大小。這些設定會影響新工作表和新活頁簿的預設字型。",
    "parameters": [
        {"name": "fontNameString", "description": "字型名稱。"},
        {"name": "pointSizeLong", "description": "字型大小 (點)。"}
    ],
    "examples": [
        {"code": "MsgBox \"目前標準字型: \" & Application.StandardFont & \", 大小: \" & Application.StandardFontSize\n' Application.StandardFont = \"Verdana\"\n' Application.StandardFontSize = 10\n' MsgBox \"標準字型已更改 (下次啟動Excel或新建工作簿時生效)。\"", "explanation": "顯示Excel的目前標準字型和大小。修改這些屬性通常需要重新啟動Excel或創建新工作簿才能看到對新內容的影響。"}
    ],
    "keywords": ["standard font excel", "default font size", "標準字型", "預設字型大小"]
},
{
    "name": "Application.StartupPath Property",
    "category": "Excel 核心操作",
    "syntax": "startupFolderPathString = Application.StartupPath",
    "description": "傳回 Excel 啟動資料夾的完整路徑。Excel 啟動時會自動開啟此資料夾中的任何檔案。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"Excel的啟動資料夾路徑是: \" & Application.StartupPath", "explanation": "顯示 Excel 的主啟動資料夾路徑。"}
    ],
    "keywords": ["excel startuppath", "startup folder", "Excel啟動路徑"]
},
{
    "name": "Application.AltStartupPath Property",
    "category": "Excel 核心操作",
    "syntax": "altStartupFolderPathString = Application.AltStartupPath",
    "description": "傳回或設定備用啟動資料夾的名稱。如果設定了此路徑，Excel 啟動時也會自動開啟此資料夾中的檔案。",
    "parameters": [],
    "examples": [
        {"code": "If Application.AltStartupPath <> \"\" Then\n  MsgBox \"Excel的備用啟動資料夾是: \" & Application.AltStartupPath\nElse\n  MsgBox \"未設定備用啟動資料夾。\"\nEnd If\n' Application.AltStartupPath = \"C:\\MyExcelAddins\\Startup\" ' Example to set it", "explanation": "檢查並顯示Excel的備用啟動資料夾路徑。"}
    ],
    "keywords": ["excel altstartuppath", "alternate startup folder", "備用啟動路徑"]
},
{
    "name": "Application.Version Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "versionString = Application.Version",
    "description": "傳回 Microsoft Excel 的版本號 (字串，例如 \"16.0\" 對應 Excel 2016/2019/365)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"您正在使用的 Excel 版本是: \" & Application.Version", "explanation": "顯示目前執行的 Excel 應用程式的版本號。"}
    ],
    "keywords": ["excel version", "application version", "Excel版本號"]
},
{
    "name": "Window.Caption Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowCaptionString = windowObject.Caption\nwindowObject.Caption = newCaptionString",
    "description": "設定或傳回顯示在視窗標題列中的文字。對於活頁簿視窗，預設是活頁簿的檔案名稱。",
    "parameters": [{"name": "newCaptionString", "description": "視窗的新標題。"}],
    "examples": [
        {"code": "Dim mainExcelWindow As Window\nSet mainExcelWindow = Application.Windows(1) ' Get the first main Excel window (usually the app window)\nMsgBox \"目前視窗的標題是: \" & mainExcelWindow.Caption\nDim originalCaption As String: originalCaption = mainExcelWindow.Caption\n' mainExcelWindow.Caption = \"My Custom Excel Title\"\n' Application.Wait Now + TimeValue(\"00:00:02\")\n' mainExcelWindow.Caption = originalCaption ' Restore", "explanation": "獲取目前Excel主視窗的標題，並示範如何修改它 (修改應用程式視窗標題通常作用不大，更多用於活頁簿視窗)。"}
    ],
    "keywords": ["window caption excel", "set window title", "視窗標題"]
},
{
    "name": "Window.DisplayFormulas Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.DisplayFormulas = True | False",
    "description": "如果視窗顯示公式，則為 True；如果顯示值，則為 False。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示公式。"}],
    "examples": [
        {"code": "ActiveWindow.DisplayFormulas = True\nMsgBox \"目前視窗現在顯示公式 (等同於按 Ctrl+`)。\"\nActiveWindow.DisplayFormulas = False ' Restore to show values", "explanation": "將活動視窗設定為顯示公式而不是儲存格的值。"}
    ],
    "keywords": ["display formulas excel", "show formulas", "toggle formula view", "顯示公式"]
},
{
    "name": "Window.DisplayZeros Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.DisplayZeros = True | False",
    "description": "如果視窗顯示值為零的儲存格，則為 True。讀取/寫入布林值。這是視窗級別的設定，影響該視窗中所有工作表。",
    "parameters": [{"name": "True | False", "description": "True (預設) 表示顯示零值。"}],
    "examples": [
        {"code": "ActiveWindow.DisplayZeros = False\nMsgBox \"目前視窗現在將不顯示值為零的儲存格 (除非它們是公式結果)。\"\n' ActiveWindow.DisplayZeros = True ' Restore to show zeros", "explanation": "設定活動視窗不顯示值為零的儲存格。"}
    ],
    "keywords": ["display zeros excel", "hide zero values", "顯示零值"]
},
{
    "name": "Window.FreezePanes Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.FreezePanes = True | False",
    "description": "如果分割窗格被凍結，則為 True。讀取/寫入布林值。要凍結窗格，需先選取要凍結位置右下方的一個儲存格，然後將此屬性設為 True。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"C3\").Select ' Select cell below and to the right of desired freeze point\nActiveWindow.FreezePanes = True\nMsgBox \"已在C3左上方凍結窗格。\"\n' ActiveWindow.FreezePanes = False ' To unfreeze", "explanation": "選取C3儲存格，然後凍結其上方和左側的窗格。"}
    ],
    "keywords": ["freeze panes", "excel freeze rows columns", "凍結窗格"]
},
{
    "name": "Window.GridlineColor Property / .GridlineColorIndex (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.GridlineColor = RGBColor\nwindowObject.GridlineColorIndex = XlColorIndexConstantOrInteger",
    "description": "設定或傳回格線的顏色。GridlineColor 使用 RGB 值，GridlineColorIndex 使用顏色索引。",
    "parameters": [
        {"name": "RGBColor", "description": "RGB 長整數值。"},
        {"name": "XlColorIndexConstantOrInteger", "description": "顏色索引號 (1-56) 或 xlColorIndexAutomatic。"}
    ],
    "examples": [
        {"code": "ActiveWindow.GridlineColor = RGB(0, 128, 0) ' Dark Green gridlines\nMsgBox \"活動視窗的格線顏色已變更為深綠色。\"\n' ActiveWindow.GridlineColorIndex = xlColorIndexAutomatic ' Restore default", "explanation": "將活動視窗的格線顏色設定為深綠色。"}
    ],
    "keywords": ["gridline color", "excel grid color", "格線顏色"]
},
{
    "name": "Window.NewWindow Method (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set newWin = windowObject.NewWindow()",
    "description": "為指定的視窗 (通常是活頁簿視窗) 建立一個新的視窗。傳回代表新視窗的 Window 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim originalWindow As Window, newCopyWindow As Window\nSet originalWindow = ActiveWindow\nSet newCopyWindow = originalWindow.NewWindow\nMsgBox \"已為 '\" & originalWindow.Caption & \"' 建立一個新視窗: '\" & newCopyWindow.Caption & \"'\"", "explanation": "為目前活動的活頁簿視窗建立一個新的檢視視窗。"}
    ],
    "keywords": ["new window excel", "duplicate window view", "建立新視窗"]
},
{
    "name": "Window.Panes(Index).ScrollRow / .ScrollColumn (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.Panes(Index).ScrollRow = rowNumber\nwindowObject.Panes(Index).ScrollColumn = columnNumber",
    "description": "在分割窗格中，設定或傳回指定窗格左上角可見的列號或欄號。",
    "parameters": [
        {"name": "Index", "description": "窗格的索引號 (1-4)。"},
        {"name": "rowNumber / columnNumber", "description": "要捲動到的列號或欄號。"}
    ],
    "examples": [
        {"code": "' ActiveWindow.SplitColumn = 200 ' Split window for example\n' If ActiveWindow.Panes.Count > 1 Then\n'   ActiveWindow.Panes(2).ScrollColumn = 5 ' Scroll the second pane (right or bottom) to show column E at its left\n'   MsgBox \"第二個窗格已捲動以顯示第5欄為起始。\"\n' Else\n'   MsgBox \"視窗未分割或只有一個窗格。\"\n' End If\n' ' ActiveWindow.Split = False ' Remove split", "explanation": "如果視窗已分割 (例如，在約200點位置分割欄)，則將第二個窗格捲動使其最左側顯示第5欄。"}
    ],
    "keywords": ["scroll pane excel", "window pane scroll", "分割窗格捲動"]
},
{
    "name": "Window.Split Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.Split = True | False",
    "description": "如果視窗被分割，則為 True。讀取/寫入布林值。設定為 False 以移除所有分割。",
    "parameters": [],
    "examples": [
        {"code": "' ActiveWindow.SplitColumn = 200 ' Create a vertical split\n' If ActiveWindow.Split Then\n'   MsgBox \"視窗目前是分割的。現在移除分割。\"\n'   ActiveWindow.Split = False\n' Else\n'   MsgBox \"視窗未分割。\"\n' End If", "explanation": "如果視窗已分割，則移除分割。"}
    ],
    "keywords": ["split window excel", "remove split panes", "分割視窗", "移除分割"]
},
{
    "name": "Window.View Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.View = XlWindowViewConstant",
    "description": "設定或傳回視窗的檢視模式。",
    "parameters": [
        {"name": "XlWindowViewConstant", "description": "xlNormalView, xlPageBreakPreview, xlPageLayoutView。"}
    ],
    "examples": [
        {"code": "ActiveWindow.View = xlPageBreakPreview\nMsgBox \"活動視窗已切換到分頁預覽模式。\"\nApplication.Wait Now + TimeValue(\"00:00:02\")\nActiveWindow.View = xlNormalView\nMsgBox \"活動視窗已還原到標準模式。\"", "explanation": "將活動視窗切換到分頁預覽模式，等待2秒，然後再切換回標準檢視模式。"}
    ],
    "keywords": ["excel window view", "page break preview", "page layout view", "視窗檢視模式"]
},
{
    "name": "Range.Address (External with Sheet Name)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Address(External:=True)",
    "description": "當 External 引數設為 True 時，Address 屬性會傳回包含活頁簿名稱 (方括號內) 和工作表名稱的完整外部參照字串。",
    "parameters": [
        {"name": "External:=True", "description": "指定傳回外部參照。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook, ws As Worksheet, rng As Range\nSet wb = ThisWorkbook\nSet ws = wb.Sheets(1)\nSet rng = ws.Range(\"C5\")\nMsgBox rng.Address(External:=True) ' 可能傳回類似 \"[MyWorkbook.xlsm]Sheet1!$C$5\"", "explanation": "獲取 Sheet1 上 C5 儲存格的完整外部位址，包括活頁簿和工作表名稱。"}
    ],
    "keywords": ["外部位址", "完整儲存格參照", "excel", "external address", "full cell reference", "workbook and sheet address"]
},
{
    "name": "Worksheet.UsedRange.Rows.Count",
    "category": "Excel 核心操作",
    "syntax": "rowCount = worksheetObject.UsedRange.Rows.Count",
    "description": "傳回工作表已使用範圍內的總列數。這對於確定資料表的實際行數很有用，而不是工作表的總最大列數。",
    "parameters": [],
    "examples": [
        {"code": "Dim activeSheetDataRows As Long\nactiveSheetDataRows = ActiveSheet.UsedRange.Rows.Count\nMsgBox \"活動工作表的已使用範圍包含 \" & activeSheetDataRows & \" 列數據。\"", "explanation": "計算並顯示活動工作表上實際包含數據（或格式）的列數。"}
    ],
    "keywords": ["已使用列數", "數據行數", "excel", "used rows count", "number of data rows"]
},
{
    "name": "Worksheet.UsedRange.Columns.Count",
    "category": "Excel 核心操作",
    "syntax": "colCount = worksheetObject.UsedRange.Columns.Count",
    "description": "傳回工作表已使用範圍內的總欄數。",
    "parameters": [],
    "examples": [
        {"code": "Dim activeSheetDataCols As Long\nactiveSheetDataCols = ActiveSheet.UsedRange.Columns.Count\nMsgBox \"活動工作表的已使用範圍包含 \" & activeSheetDataCols & \" 欄數據。\"", "explanation": "計算並顯示活動工作表上實際包含數據（或格式）的欄數。"}
    ],
    "keywords": ["已使用欄數", "數據欄數", "excel", "used columns count", "number of data columns"]
},
{
    "name": "Range.CopyPicture",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.CopyPicture(Appearance As XlPictureAppearance, Format As XlCopyPictureFormat)",
    "description": "將選定的範圍複製為圖片到剪貼簿。",
    "parameters": [
        {"name": "Appearance", "description": "必需。XlPictureAppearance 常數 (xlScreen - 如螢幕所示，xlPrinter - 如列印所示)。"},
        {"name": "Format", "description": "必需。XlCopyPictureFormat 常數 (xlBitmap - 點陣圖，xlPicture - 圖片 (通常是 EMF))。"}
    ],
    "examples": [
        {"code": "Range(\"A1:C5\").CopyPicture Appearance:=xlScreen, Format:=xlBitmap\n' The picture is now on the clipboard. You can paste it, e.g.:\n' ActiveSheet.Paste Destination:=Range(\"E1\")\n' Or paste into Word/PowerPoint\nMsgBox \"範圍 A1:C5 已作為點陣圖複製到剪貼簿。\"", "explanation": "將範圍 A1:C5 的螢幕外觀複製為點陣圖圖片到剪貼簿。"}
    ],
    "keywords": ["複製為圖片", "範圍轉圖片", "excel", "copy as picture", "range to image"]
},
// --- More Word ---
{
    "name": "Paragraphs.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "longCount = documentOrRangeObject.Paragraphs.Count",
    "description": "傳回指定文件或範圍中段落的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' MsgBox \"此文件共有 \" & wdDoc.Paragraphs.Count & \" 個段落。\"", "explanation": "顯示活動文件中的總段落數。"}
    ],
    "keywords": ["word paragraph count", "number of paragraphs", "段落計數"]
},
{
    "name": "Range.Words (Word)",
    "category": "Word 文件處理",
    "syntax": "Set wordsCollection = rangeObject.Words",
    "description": "傳回一個 Words 集合，代表範圍中的所有單字。每個單字也是一個 Range 物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdRange As Object ' Word.Range\nDim firstWord As Object ' Word.Range\n' Set wdRange = ActiveDocument.Paragraphs(1).Range\n' If wdRange.Words.Count > 0 Then\n'   Set firstWord = wdRange.Words(1)\n'   firstWord.Font.Bold = True\n'   MsgBox \"第一個段落的第一個單字 '\" & Trim(firstWord.Text) & \"' 已設為粗體。\"\n' End If", "explanation": "獲取第一個段落的範圍，然後將其第一個單字的字型設為粗體。"}
    ],
    "keywords": ["word words collection", "iterate words", "format individual words", "單字集合", "格式化單字"]
},
// --- More Outlook ---
{
    "name": "MailItem.VotingOptions Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.VotingOptions = \"Option1;Option2;Option3\"",
    "description": "設定或傳回一個字串，指定郵件的投票選項。選項之間用分號分隔。設定此屬性會自動將投票按鈕新增到郵件中。",
    "parameters": [{"name": "String", "description": "包含投票選項的分號分隔字串 (例如 \"Yes;No;Maybe\")。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.Subject = \"團隊午餐投票\"\nolMail.Body = \"請選擇您偏好的午餐地點：\"\nolMail.VotingOptions = \"中餐館;西餐廳;日式料理\"\nolMail.To = \"team@example.com\"\nolMail.Display", "explanation": "建立一封新郵件，並設定投票按鈕選項為“中餐館”、“西餐廳”和“日式料理”。"}
    ],
    "keywords": ["outlook voting buttons", "email voting options", "投票按鈕", "郵件投票"]
},
{
    "name": "MailItem.FlagRequest Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.FlagRequest = \"Request String\"",
    "description": "設定或傳回一個字串，表示郵件的標記要求。例如，\"Follow up\"、\"Review\"、\"Call\"。",
    "parameters": [{"name": "Request String", "description": "標記要求的文字。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.ActiveExplorer.Selection.Item(1) ' Get selected email\n' If TypeName(olMail) = \"MailItem\" Then\n'   olMail.FlagRequest = \"請於本週五前回覆\"\n'   olMail.FlagDueBy = Date + 5 ' Set due date for flag\n'   olMail.Save\n'   MsgBox \"郵件已標記要求。\"\n' End If", "explanation": "為所選郵件設定一個標記要求和到期日。"}
    ],
    "keywords": ["outlook flag email", "set email flag", "follow up flag", "標記郵件", "待辦標記"]
},
// --- More PowerPoint ---
{
    "name": "Shapes.AddChart2 (PowerPoint/Excel)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set shpChart = targetObject.Shapes.AddChart2([Style], [XlChartType], [Left], [Top], [Width], [Height], [NewLayout])",
    "description": "在投影片 (PowerPoint) 或工作表 (Excel) 上新增一個圖表。這是較新的新增圖表方法，提供更多選項。targetObject 可以是 Slide (PPT) 或 Worksheet (Excel)。",
    "parameters": [
        {"name": "Style", "description": "可選。圖表樣式編號。"},
        {"name": "XlChartType", "description": "可選。XlChartType 常數。"},
        {"name": "NewLayout", "description": "可選。True 表示使用新的動態圖表版面配置 (如果適用)。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim chartShape As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides(1)\n' ' Add a default column chart\n' Set chartShape = pptSlide.Shapes.AddChart2(Style:=-1, XlChartType:=xlColumnClustered, _\n'                                       Left:=100, Top:=100, Width:=400, Height:=250)\n' With chartShape.Chart\n'   ' .ChartData.Workbook.Worksheets(1).Range(\"A1:B5\").Value = ... ' Populate data\n'   .HasTitle = True\n'   .ChartTitle.Text = \"新圖表 (AddChart2)\"\n' End With", "explanation": "在第一張投影片上使用 AddChart2 方法新增一個簇狀柱形圖。然後可以設定其資料和標題。"}
    ],
    "keywords": ["powerpoint addchart2", "excel addchart2", "insert chart new method", "新增圖表 (新)"]
},
// --- More FSO ---
{
    "name": "TextStream.SkipLine (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "textStreamObject.SkipLine",
    "description": "從開啟的 TextStream 檔案中讀取時跳過下一整行。檔案指標會移至被跳過行之後緊接的那一行的開頭。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, ts As Object, line2 As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Assume C:\\Temp\\MyLines.txt has at least 2 lines\n' Set ts = fso.OpenTextFile(\"C:\\Temp\\MyLines.txt\", 1) ' ForReading\n' If Not ts.AtEndOfStream Then ts.SkipLine ' Skip the first line\n' If Not ts.AtEndOfStream Then line2 = ts.ReadLine\n' ts.Close\n' MsgBox \"第二行內容是: \" & line2", "explanation": "打開一個文字檔案，使用 SkipLine 跳過第一行，然後讀取第二行的內容。"}
    ],
    "keywords": ["fso skipline", "skip line text file", "textstream skip", "跳過文字行"]
},
// --- More Math/Date ---
{
    "name": "WeekdayName Function",
    "category": "數學、日期與時間",
    "syntax": "WeekdayName(weekday As Long, [abbreviate As Boolean = False], [firstdayofweek As VbDayOfWeek = vbSunday]) As String",
    "description": "傳回一個字串，表示星期幾的名稱。",
    "parameters": [
        {"name": "weekday", "description": "必需。代表星期幾的數字 (1 到 7)。"},
        {"name": "abbreviate", "description": "可選。True 表示傳回縮寫名稱 (例如 \"Mon\")。預設為 False。"},
        {"name": "firstdayofweek", "description": "可選。VbDayOfWeek 常數，指定一週的第一天。"}
    ],
    "examples": [
        {"code": "MsgBox \"今天是: \" & WeekdayName(Weekday(Date), False, vbMonday)", "explanation": "顯示今天的完整星期名稱 (假設週一為一週的第一天)。"},
        {"code": "MsgBox \"週三的縮寫: \" & WeekdayName(4, True, vbMonday) ' 4 is Wednesday if Monday is 1st day", "explanation": "顯示星期三的縮寫名稱。"}
    ],
    "keywords": ["weekdayname", "day of week name", "星期名稱", "日期名稱"]
},
// --- More Program Flow ---
{
    "name": "WithEvents Keyword (Class Modules)",
    "category": "程式流程與結構控制",
    "syntax": "Private WithEvents MyObject As ObjectType",
    "description": "在類別模組或使用者表單模組中，用於宣告一個物件變數，使其可以回應其來源物件觸發的事件。ObjectType 必須是一個具有可觸發事件的物件類型 (例如，Application, Workbook, Worksheet, CommandButton)。",
    "parameters": [
        {"name": "MyObject", "description": "要宣告的物件變數名稱。"},
        {"name": "ObjectType", "description": "物件的類別名稱。"}
    ],
    "examples": [
        {"code": "' In a Class Module named 'AppEventHandler':\n' Private WithEvents App As Excel.Application\n'\n' Private Sub Class_Initialize()\n'   Set App = Application ' Hook into the current Excel application instance\n' End Sub\n'\n' Private Sub App_NewWorkbook(ByVal Wb As Workbook)\n'   MsgBox \"一個新的活頁簿已建立: \" & Wb.Name\n' End Sub\n'\n' ' In a Standard Module to test:\n' Dim myAppHandler As AppEventHandler\n' Sub InitializeAppHandler()\n'   Set myAppHandler = New AppEventHandler\n'   MsgBox \"應用程式事件處理常式已初始化。嘗試建立一個新活頁簿。\"\n' End Sub", "explanation": "此範例 (概念性，需要在類別模組和標準模組中分別放置) 演示如何使用 WithEvents 來捕捉 Excel Application 物件的 NewWorkbook 事件。當一個新活頁簿建立時，App_NewWorkbook 事件程序會被觸發。"}
    ],
    "keywords": ["withevents", "event handling", "object events", "class module events", "事件處理", "物件事件"]
},
{
    "name": "Environ (Return Value Length)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "Environ 函數返回的字串長度限制為 255 個字元。如果環境變數的值超過此長度，則返回的字串將被截斷。對於需要獲取長環境變數（如 PATH）的完整值，可能需要使用 Windows API 函數，如 GetEnvironmentVariable。",
    "syntax": "Environ(envstring | number)",
    "parameters": [],
    "examples": [
        {"code": "Dim longPath As String\nlongPath = Environ(\"PATH\")\nIf Len(longPath) = 255 Then\n  Debug.Print \"PATH 環境變數可能已被截斷，長度達到255字符上限。\"\nElse\n  Debug.Print \"PATH 環境變數長度: \" & Len(longPath)\nEnd If\n' Debug.Print longPath", "explanation": "檢查 Environ(\"PATH\") 返回的字串長度。如果長度正好是255，則提示可能發生了截斷。"}
    ],
    "keywords": ["environ length limit", "long environment variable", "get complete path", "環境變數長度限制"]
},
{
    "name": "Shell (Wait and Exit Code)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "Shell 函數可以非同步執行程式 (預設情況下 VBA 不會等待程式結束)。若要等待程式結束並獲取其結束代碼，通常需要結合 Windows API 函數，如 `OpenProcess`, `WaitForSingleObject`, 和 `GetExitCodeProcess`。這比簡單的 Shell 呼叫要複雜得多。",
    "syntax": "TaskID = Shell(PathName, [WindowStyle])",
    "parameters": [],
    "examples": [
        {"code": "' --- This example shows simple Shell, not the waiting part ---\nDim taskID As Variant\ntaskID = Shell(\"notepad.exe\", vbNormalFocus)\nIf taskID <> 0 Then\n  MsgBox \"記事本已啟動，任務ID: \" & taskID & \". VBA不會等待它結束。\"\nElse\n  MsgBox \"啟動記事本失敗。\"\nEnd If\n' --- For waiting, more complex API calls are needed --- \n' ' Example of conceptual wait (pseudo-code):\n' ' Dim procHandle As Long, exitCode As Long\n' ' procHandle = OpenProcess(PROCESS_QUERY_INFORMATION Or SYNCHRONIZE, False, taskID)\n' ' If procHandle <> 0 Then\n' '   WaitForSingleObject procHandle, INFINITE (-1)\n' '   GetExitCodeProcess procHandle, exitCode\n' '   CloseHandle procHandle\n' '   MsgBox \"記事本已結束，結束代碼: \" & exitCode\n' ' End If", "explanation": "簡單的 Shell 呼叫會立即返回任務ID，VBA不會等待外部程式結束。註解部分概念性地展示了等待外部程式結束並獲取其結束代碼所需的API步驟。"}
    ],
    "keywords": ["shell wait for process", "get exit code shell", "synchronous shell execute", "等待外部程式結束"]
},
{
    "name": "CreateObject (Error Handling for Non-Existent ProgID)",
    "category": "程式流程與結構控制",
    "description": "當使用 CreateObject 嘗試建立一個系統中未註冊或不存在的 ProgID 的物件時，會觸發執行階段錯誤 429「ActiveX 元件無法建立物件」。應使用錯誤處理來優雅地處理這種情況。",
    "syntax": "On Error Resume Next\nSet obj = CreateObject(\"NonExistent.Application\")\nIf Err.Number <> 0 Then ...\nOn Error GoTo 0",
    "parameters": [],
    "examples": [
        {"code": "Dim myObj As Object\nDim progIDToTest As String: progIDToTest = \"SomeApp.ThatDoesNotExist\"\nOn Error Resume Next ' Enable error trapping\nSet myObj = CreateObject(progIDToTest)\nIf Err.Number = 429 Then\n  MsgBox \"無法建立物件 '\" & progIDToTest & \"'. 請確認該應用程式已正確安裝並註冊。\"\nElseIf Err.Number <> 0 Then\n  MsgBox \"建立物件時發生未預期錯誤: \" & Err.Description\nElse\n  MsgBox \"物件 '\" & progIDToTest & \"' 成功建立 (這不應該發生於此範例)。\"\n  ' ... use myObj ...\n  Set myObj = Nothing\nEnd If\nOn Error GoTo 0 ' Disable error trapping", "explanation": "嘗試建立一個不存在的 ProgID 的物件。使用 On Error Resume Next 捕獲可能發生的錯誤 429，並向使用者顯示一條友好的錯誤訊息。"}
    ],
    "keywords": ["createobject error 429", "activex component can't create object", "handle createobject failure", "progid not found", "錯誤429處理"]
},
{
    "name": "Application.Caller Property (Excel UDF Context)",
    "category": "Excel VBA 開發與表單",
    "syntax": "Set callingCellOrRange = Application.Caller",
    "description": "在使用者定義函數 (UDF) 中使用時，Application.Caller 傳回一個 Range 物件，代表呼叫該UDF的儲存格或儲存格範圍。如果UDF是從VBA程序中呼叫的，而不是從工作表儲存格公式中呼叫的，則Application.Caller會產生錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Function MyUDF_ShowCaller() As String\n  On Error Resume Next ' Handle if not called from a cell\n  Dim callerRange As Range\n  Set callerRange = Application.Caller\n  If Err.Number = 0 And Not callerRange Is Nothing Then\n    MyUDF_ShowCaller = \"此UDF由儲存格 \" & callerRange.Address & \" 呼叫。\"\n  Else\n    MyUDF_ShowCaller = \"此UDF不是由工作表儲存格呼叫的。\"\n  End If\n  On Error GoTo 0\nEnd Function\n' In an Excel cell, type: =MyUDF_ShowCaller()", "explanation": "定義一個UDF，它會嘗試使用Application.Caller來確定是哪個儲存格呼叫了它，並返回包含該儲存格位址的字串。"}
    ],
    "keywords": ["application.caller", "udf calling cell", "user defined function context", "UDF呼叫者"]
},
{
    "name": "Static Array Initialization with Array Function",
    "category": "陣列、集合與字典",
    "description": "雖然靜態陣列的大小在宣告時固定，但可以使用 Array 函數在宣告後立即為其元素賦值 (前提是陣列被宣告為 Variant 類型，或者Array函數返回的元素類型與靜態陣列的元素類型兼容)。然而，更常見的做法是將 Array 函數的結果直接賦給一個 Variant 變數，該變數會自動變成一個數組。",
    "syntax": "Dim MyStaticVariantArray As Variant\nMyStaticVariantArray = Array(\"Apple\", \"Banana\", \"Cherry\")",
    "parameters": [],
    "examples": [
        {"code": "Dim fixedNames() As String ' This is dynamic until ReDim\n' ReDim fixedNames(0 To 2) ' Now it's fixed size for this scope\n' fixedNames = Array(\"Alice\", \"Bob\", \"Carol\") ' This direct assignment works for variant arrays or if types match\n' For this to work with a typed array like String(), the elements of Array() must be strings.\n\n' More common and safer for typed static arrays:\nDim staticNames(0 To 2) As String\nstaticNames(0) = \"Alice\"\nstaticNames(1) = \"Bob\"\nstaticNames(2) = \"Carol\"\nDebug.Print staticNames(1)\n\n' Using Array() with a Variant variable:\nDim variantArray As Variant\nvariantArray = Array(10, 20, \"Text\", Date)\nDebug.Print TypeName(variantArray(2)) ' Output: String", "explanation": "演示了如何使用 Array() 函數初始化 Variant 數組，並與靜態類型陣列的逐個賦值進行比較。直接將 Array() 的結果賦給一個已 ReDim 的固定類型陣列通常是可以的，只要元素類型兼容。"}
    ],
    "keywords": ["static array initialize", "array function initialization", "variant array fill", "靜態陣列初始化"]
},
{
    "name": "Looping Through a Collection Backwards (For Deleting Items)",
    "category": "陣列、集合與字典",
    "description": "當需要在迴圈中從 Collection 中移除項目時，從後向前遍歷 (例如 `For i = MyCollection.Count To 1 Step -1`) 是推薦的做法。如果在向前遍歷時移除項目，會導致後續項目的索引改變，可能會跳過某些項目或產生錯誤。",
    "syntax": "For i = MyCollection.Count To 1 Step -1\n  If ConditionToRemove(MyCollection(i)) Then\n    MyCollection.Remove i\n  End If\nNext i",
    "parameters": [],
    "examples": [
        {"code": "Dim names As New Collection\nnames.Add \"Alice\"\nnames.Add \"Bob_Remove\"\nnames.Add \"Charlie\"\nnames.Add \"David_Remove\"\nnames.Add \"Eve\"\n\nDim i As Long\n' Loop backwards to safely remove items\nFor i = names.Count To 1 Step -1\n  If InStr(1, names(i), \"_Remove\") > 0 Then\n    Debug.Print \"正在移除: \" & names(i)\n    names.Remove i\n  End If\nNext i\n\nDebug.Print \"剩餘項目:\"\nFor i = 1 To names.Count\n  Debug.Print names(i)\nNext i", "explanation": "建立一個包含多個姓名的 Collection。然後從後向前遍歷，移除所有包含 \"_Remove\" 的項目。這樣可以安全地移除項目而不會影響迴圈的索引。"}
    ],
    "keywords": ["collection loop backwards delete", "remove from collection loop", "safe deletion loop", "反向迴圈刪除集合"]
},
{
    "name": "ChDir vs CurDir vs App.Path vs ThisWorkbook.Path",
    "category": "檔案與資料夾管理",
    "description": "ChDir: 更改目前的預設目錄。\nCurDir: 傳回目前磁碟機的預設目錄路徑。\nApplication.Path: 傳回 Office 應用程式 (例如 Excel.exe) 的安裝路徑。\nThisWorkbook.Path: 傳回包含目前執行中 VBA 程式碼的活頁簿的儲存路徑。如果活頁簿未儲存，則傳回空字串。",
    "parameters": [],
    "examples": [
        {"code": "Debug.Print \"CurDir (Initial): \" & CurDir\nOn Error Resume Next ' ChDir might fail if path doesn't exist\nChDir Environ(\"SystemRoot\") ' Change to Windows directory\nDebug.Print \"CurDir (After ChDir): \" & CurDir\nChDir ThisWorkbook.Path ' Change back to workbook's directory (if saved)\nDebug.Print \"CurDir (Back to Workbook Path): \" & CurDir\nDebug.Print \"Application Path: \" & Application.Path\nDebug.Print \"ThisWorkbook Path: \" & ThisWorkbook.Path", "explanation": "演示 ChDir, CurDir, Application.Path 和 ThisWorkbook.Path 之間的區別和用法。"}
    ],
    "keywords": ["chdir", "curdir", "application.path", "thisworkbook.path", "directory functions", "路徑函數區別"]
},
{
    "name": "Shell (Executing Commands with cmd.exe)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "可以使用 Shell 函數結合 `cmd.exe /c` (執行命令後終止) 或 `cmd.exe /k` (執行命令後保持視窗開啟) 來執行內部命令提示符命令或批次檔。",
    "syntax": "Shell \"cmd.exe /c YourCommandHere\"",
    "parameters": [{"name": "YourCommandHere", "description": "要執行的命令提示符命令，例如 `DIR C:\\ > C:\\Temp\\dir.txt`。"}],
    "examples": [
        {"code": "Dim cmdString As String\n' Example: List files in C:\\Windows and output to a temp file\ncmdString = \"cmd.exe /c DIR C:\\Windows\\*.exe > C:\\Temp\\ExeList.txt\"\nOn Error Resume Next\nShell cmdString, vbHide ' Run hidden\nIf Err.Number = 0 Then\n  MsgBox \"已嘗試執行 DIR 命令並將輸出重定向到 C:\\Temp\\ExeList.txt。請檢查該檔案。\"\nElse\n  MsgBox \"執行命令失敗: \" & Err.Description\nEnd If\nOn Error GoTo 0", "explanation": "使用 Shell 和 cmd.exe 執行 DIR 命令，並將輸出重定向到一個文字檔案。vbHide 使命令提示符視窗在執行時保持隱藏。"}
    ],
    "keywords": ["shell cmd.exe", "run dos command vba", "execute batch file vba", "執行命令提示符"]
},
{
    "name": "RGB Function (Color Components)",
    "category": "綜合應用案例與技巧",
    "description": "RGB(red, green, blue) 函數接受三個介於 0 到 255 之間的整數參數，分別代表紅、綠、藍三種顏色成分的強度，並傳回一個代表該顏色的 Long 整數值。0 表示該顏色成分的最低強度，255 表示最高強度。",
    "parameters": [],
    "examples": [
        {"code": "Dim colorPureRed As Long: colorPureRed = RGB(255, 0, 0)\nDim colorPureGreen As Long: colorPureGreen = RGB(0, 255, 0)\nDim colorPureBlue As Long: colorPureBlue = RGB(0, 0, 255)\nDim colorBlack As Long: colorBlack = RGB(0, 0, 0)\nDim colorWhite As Long: colorWhite = RGB(255, 255, 255)\nDim colorYellow As Long: colorYellow = RGB(255, 255, 0) ' Red + Green\nDim colorCyan As Long: colorCyan = RGB(0, 255, 255)   ' Green + Blue\nDim colorMagenta As Long: colorMagenta = RGB(255, 0, 255) ' Red + Blue\nDim colorGray As Long: colorGray = RGB(128, 128, 128)\n\nDebug.Print \"紅色值: \" & colorPureRed\nDebug.Print \"灰色值: \" & colorGray", "explanation": "定義並顯示一些常見顏色的 RGB 值。這些值可以用於設定各種物件的顏色屬性。"}
    ],
    "keywords": ["rgb colors", "color definition", "red green blue values", "顏色組成", "RGB值"]
},
{
    "name": "CreateObject(\"Shell.Application\") for Shell Operations",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "Shell.Application 物件 (ProgID: \"Shell.Application\") 提供了比 WScript.Shell 更豐富的功能，用於與 Windows Shell 互動，例如瀏覽資料夾、開啟控制台項目、獲取Shell命名空間等。",
    "syntax": "Set oShell = CreateObject(\"Shell.Application\")",
    "parameters": [
        {"name": ".BrowseForFolder(hWnd, Title, Options, [RootFolder])", "description": "方法：顯示「瀏覽資料夾」對話框。"},
        {"name": ".Open(vDir)", "description": "方法：開啟指定的資料夾或檔案。"},
        {"name": ".NameSpace(vDir)", "description": "方法：傳回代表指定資料夾的 Folder 物件 (Shell32.Folder)。"},
        {"name": ".ShellExecute(File, [Arguments], [Directory], [Operation], [ShowCmd])", "description": "方法：與 API ShellExecute 類似。"}
    ],
    "examples": [
        {"code": "Sub OpenMyDocumentsFolder()\n    Dim oShellApp As Object\n    Set oShellApp = CreateObject(\"Shell.Application\")\n    ' Open the My Documents folder\n    oShellApp.Open CreateObject(\"WScript.Shell\").SpecialFolders(\"MyDocuments\")\n    MsgBox \"我的文件資料夾已嘗試開啟。\"\n    Set oShellApp = Nothing\nEnd Sub\n\nSub BrowseForAnyFolder()\n    Dim oShellApp As Object, oFolder As Object\n    Set oShellApp = CreateObject(\"Shell.Application\")\n    ' hWnd = 0 (Desktop window), Title, Options (e.g., &H1 for non-editable path, &H40 for new style dialog)\n    Set oFolder = oShellApp.BrowseForFolder(0, \"請選擇一個資料夾:\", &H40 + &H1)\n    If Not oFolder Is Nothing Then\n        MsgBox \"選擇的資料夾是: \" & oFolder.Self.Path ' Self.Path to get string path\n    Else\n        MsgBox \"未選擇資料夾。\"\n    End If\n    Set oFolder = Nothing: Set oShellApp = Nothing\nEnd Sub", "explanation": "第一個範例 OpenMyDocumentsFolder 使用 Shell.Application 物件開啟「我的文件」資料夾。第二個範例 BrowseForAnyFolder 顯示一個「瀏覽資料夾」對話框，讓使用者選擇一個資料夾，然後顯示所選資料夾的路徑。"}
    ],
    "keywords": ["shell.application", "browse for folder vba", "open folder vba", "windows shell automation", "瀏覽資料夾", "開啟Shell項目"]
},
{
    "name": "Application.PathSeparator (Usage)",
    "category": "檔案與資料夾管理",
    "description": "使用 Application.PathSeparator 屬性來建構檔案路徑可以使您的 VBA 程式碼在不同作業系統之間更具可攜性 (儘管 VBA 主要在 Windows 上執行，PathSeparator 總是傳回 \"\\\")。這是一種良好的程式設計習慣。",
    "syntax": "fullPath = folderPath & Application.PathSeparator & fileName",
    "parameters": [],
    "examples": [
        {"code": "Dim myFolder As String, myFile As String, fullFilePath As String\nmyFolder = \"C:\\MyData\"\nmyFile = \"Report.xlsx\"\n' Ensure myFolder doesn't already end with a separator\nIf Right(myFolder, 1) = Application.PathSeparator Then\n    fullFilePath = myFolder & myFile\nElse\n    fullFilePath = myFolder & Application.PathSeparator & myFile\nEnd If\nDebug.Print \"建構的路徑: \" & fullFilePath", "explanation": "演示如何安全地使用 Application.PathSeparator 來組合資料夾路徑和檔案名稱，避免出現雙重路徑分隔符號。"}
    ],
    "keywords": ["pathseparator usage", "build file path", "cross-platform path", "建構檔案路徑"]
},
{
    "name": "Timer Function (Elapsed Time Calculation)",
    "category": "數學、日期與時間",
    "description": "Timer 函數傳回自午夜以來的秒數 (Single)。要計算一段程式碼的執行時間，可以在程式碼區段開始前記錄 Timer 的值，在其結束後再次記錄 Timer 的值，然後計算兩者之差。",
    "syntax": "Dim StartTime As Single, EndTime As Single\nStartTime = Timer\n' Code to measure...\nEndTime = Timer\nMsgBox \"Elapsed: \" & (EndTime - StartTime) & \" seconds.\"",
    "parameters": [],
    "examples": [
        {"code": "Sub MeasureLoopTime()\n  Dim sTime As Single, eTime As Single, i As Long, temp As Double\n  sTime = Timer\n  For i = 1 To 1000000 ' A loop that does some work\n    temp = Sqr(i) ' Example operation\n  Next i\n  eTime = Timer\n  Debug.Print \"執行一百萬次開方運算耗時: \" & Format(eTime - sTime, \"0.000\") & \" 秒。\"\nEnd Sub", "explanation": "記錄一個執行一百萬次開方運算的迴圈的開始和結束時間，然後計算並列印總耗時。"}
    ],
    "keywords": ["measure execution time", "code profiling vba", "timer for performance", "計算執行時間"]
},
{
    "name": "Do...Loop While/Until (Exit Do)",
    "category": "程式流程與結構控制",
    "description": "在 Do...Loop 結構中，可以使用 Exit Do 語句來立即跳出迴圈，無論迴圈的 While 或 Until 條件是否已滿足。這通常用於在迴圈內部檢測到某個特定條件時提前終止迴圈。",
    "syntax": "Do While condition1\n  ' Statements\n  If condition2 Then Exit Do\n  ' More Statements\nLoop",
    "parameters": [],
    "examples": [
        {"code": "Dim counter As Integer: counter = 0\nDim found As Boolean: found = False\nDim arrValues() As Variant: arrValues = Array(10, 20, 30, \"STOP\", 40, 50)\n\nDo While counter < UBound(arrValues) + 1\n  If arrValues(counter) = \"STOP\" Then\n    Debug.Print \"在索引 \" & counter & \" 找到 'STOP'，提前退出迴圈。\"\n    found = True\n    Exit Do ' Exit the Do...Loop\n  End If\n  Debug.Print \"處理項目: \" & arrValues(counter)\n  counter = counter + 1\nLoop\nIf Not found Then Debug.Print \"未找到 'STOP'。\"", "explanation": "遍歷一個陣列。如果陣列元素是 \"STOP\"，則使用 Exit Do 提前退出迴圈。"}
    ],
    "keywords": ["exit do loop", "break do while", "premature loop exit", "提前退出Do迴圈"]
},
{
    "name": "For...Next Loop (Exit For)",
    "category": "程式流程與結構控制",
    "description": "在 For...Next 迴圈中，可以使用 Exit For 語句來立即跳出迴圈，即使迴圈的計數器尚未達到其結束值。",
    "syntax": "For counter = start To end\n  ' Statements\n  If condition Then Exit For\n  ' More Statements\nNext counter",
    "parameters": [],
    "examples": [
        {"code": "Dim i As Integer, sum As Long: sum = 0\nConst MAX_SUM As Long = 100\nFor i = 1 To 50\n  sum = sum + i\n  Debug.Print \"目前 i=\" & i & \", sum=\" & sum\n  If sum > MAX_SUM Then\n    Debug.Print \"總和已超過 \" & MAX_SUM & \"，在 i=\" & i & \" 時退出迴圈。\"\n    Exit For ' Exit the For...Next loop\n  End If\nNext i\nMsgBox \"最終總和: \" & sum", "explanation": "一個 For 迴圈從1加到50，但如果累計總和超過100，則使用 Exit For 提前終止迴圈。"}
    ],
    "keywords": ["exit for loop", "break for next", "premature for loop exit", "提前退出For迴圈"]
},
{
    "name": "Collection (Check if Key Exists Before Adding)",
    "category": "陣列、集合與字典",
    "description": "在向 Collection 新增帶有鍵 (Key) 的項目時，如果該鍵已存在，則會產生執行階段錯誤 '457' (此鍵已與此集合的元素相關聯)。為了避免此錯誤，可以在新增前檢查鍵是否存在。然而，Collection 物件本身沒有內建的 Exists 方法。通常的解決方案是嘗試存取該鍵並處理錯誤，或者使用 Scripting.Dictionary (它有 Exists 方法)。",
    "syntax": "On Error Resume Next\nMyCollection.Add ItemValue, KeyName\nIf Err.Number = 457 Then ' Key already exists\n  Err.Clear\n  ' Handle existing key, e.g., update item or ignore\nElseIf Err.Number <> 0 Then\n  ' Handle other errors\nEnd If\nOn Error GoTo 0",
    "parameters": [],
    "examples": [
        {"code": "Dim productSales As New Collection\nDim pName As String, pSales As Double\n\nSub AddOrUpdateSale(product As String, sales As Double)\n  On Error Resume Next ' Temporarily disable error handling\n  productSales.Add sales, product ' Try to add with product name as key\n  If Err.Number = 457 Then ' Error 457: This key is already associated...\n    Err.Clear\n    ' Key exists, so update the existing item (remove and re-add or update if item is object)\n    productSales.Remove product\n    productSales.Add sales, product\n    Debug.Print \"產品 '\" & product & \"' 的銷售額已更新為: \" & sales\n  ElseIf Err.Number = 0 Then ' No error, item was added\n    Debug.Print \"產品 '\" & product & \"' 的銷售額已新增: \" & sales\n  Else ' Some other error occurred\n    Debug.Print \"新增/更新 '\" & product & \"' 時發生錯誤: \" & Err.Description\n    Err.Clear\n  End If\n  On Error GoTo 0 ' Restore error handling\nEnd Sub\n\nSub TestCollectionAddOrUpdate()\n  AddOrUpdateSale \"Apple\", 100\n  AddOrUpdateSale \"Banana\", 150\n  AddOrUpdateSale \"Apple\", 120 ' This should update Apple's sales\nEnd Sub", "explanation": "AddOrUpdateSale 子程序嘗試向 productSales 集合中新增一個項目，以產品名稱作為鍵。如果鍵已存在 (觸發錯誤457)，它會清除錯誤，移除舊項目，然後重新新增新項目，從而達到更新的效果。"}
    ],
    "keywords": ["collection add key exists", "vba collection error 457", "update collection item by key", "檢查Collection鍵是否存在"]
},
{
    "name": "IsEmpty vs Len(Trim(var)) = 0 (For Strings)",
    "category": "資料類型、轉換與驗證",
    "description": "IsEmpty(var) 僅對 Variant 變數有效，用於檢查其是否未初始化。對於 String 變數，即使它是空字串 (\"\" 或 vbNullString)，IsEmpty(StringVariable) 也會傳回 False，因為它已初始化為一個字串。要檢查一個字串變數是否真的不包含任何可見字元 (即為空或僅包含空格)，應使用 `Len(Trim(StringVariable)) = 0`。",
    "parameters": [],
    "examples": [
        {"code": "Dim myVariant As Variant ' IsEmpty is True\nDim myString1 As String  ' IsEmpty is False, myString1 = \"\"\nDim myString2 As String: myString2 = \"   \" ' IsEmpty is False\nDim myString3 As String: myString3 = \"Hello\"\n\nDebug.Print \"myVariant - IsEmpty: \" & IsEmpty(myVariant) ' True\nDebug.Print \"myString1 - IsEmpty: \" & IsEmpty(myString1) ' False\nDebug.Print \"myString1 - Len(Trim()) = 0: \" & (Len(Trim(myString1)) = 0) ' True\n\nDebug.Print \"myString2 - Len(Trim()) = 0: \" & (Len(Trim(myString2)) = 0) ' True\nDebug.Print \"myString3 - Len(Trim()) = 0: \" & (Len(Trim(myString3)) = 0) ' False", "explanation": "演示 IsEmpty 對於未初始化的 Variant 和已初始化的 String (即使是空字串) 的不同行為。對於判斷字串是否實質為空（無可見內容），Len(Trim(var)) = 0 是更可靠的方法。"}
    ],
    "keywords": ["isempty string", "check empty string vba", "len trim empty", "string validation", "判斷空字串"]
},
{
    "name": "Application.OnTime (Schedule Macro)",
    "category": "程式流程與結構控制",
    "syntax": "Application.OnTime(EarliestTime, Procedure, [LatestTime], [Schedule As Boolean = True])",
    "description": "在指定的時間執行一個公共的 Sub 過程。可以用於安排宏在未來某個時間點自動執行，或定期執行。",
    "parameters": [
        {"name": "EarliestTime", "description": "必需。希望程序執行的最早時間。"},
        {"name": "Procedure", "description": "必需。要執行的 Sub 程序的名稱 (字串)。"},
        {"name": "LatestTime", "description": "可選。如果 Excel 未處於就緒模式，程序在 此時間之後將不會執行。"},
        {"name": "Schedule", "description": "可選。True (預設) 表示安排新程序。False 表示清除先前設定的 OnTime 程序。"}
    ],
    "examples": [
        {"code": "Public Sub ScheduleMyTask()\n    Dim runWhen As Date\n    runWhen = Now + TimeValue(\"00:00:10\") ' Schedule to run in 10 seconds\n    Application.OnTime EarliestTime:=runWhen, Procedure:=\"MyScheduledTask\"\n    MsgBox \"'MyScheduledTask' 已被安排在 \" & Format(runWhen, \"hh:mm:ss\") & \" 執行。\"\nEnd Sub\n\nPublic Sub MyScheduledTask()\n    MsgBox \"已排程的任務在 \" & Time & \" 執行了！\"\n    ' To make it recurring, schedule the next run from within this sub:\n    ' Call ScheduleMyTask ' Or a modified version for next interval\nEnd Sub\n\nPublic Sub CancelScheduledTask()\n    ' To cancel, you need the EXACT EarliestTime and Procedure name used to set it.\n    ' This can be tricky if time has passed or it's recurring.\n    ' It's often better to use a global variable to store 'runWhen' if cancellation is needed.\n    On Error Resume Next ' In case no schedule with that exact time is pending\n    ' Application.OnTime EarliestTime:=TimeValueStoredInGlobalVar, Procedure:=\"MyScheduledTask\", Schedule:=False\n    MsgBox \"嘗試取消排程任務 (如果參數匹配)。\"\n    On Error GoTo 0\nEnd Sub", "explanation": "ScheduleMyTask 安排 MyScheduledTask 子程序在10秒後執行。MyScheduledTask 執行時會顯示一條訊息，並且可以重新安排自身以實現定期執行。CancelScheduledTask 演示了如何取消一個已安排的 OnTime 事件（需要精確的時間和過程名稱）。"}
    ],
    "keywords": ["application.ontime", "schedule macro vba", "timed execution", "recurring task vba", "排程宏", "定時執行"]
},
// Excel 核心操作
{
    "name": "Application.CommandBars Property (Ribbon/Menu Customization)",
    "category": "Excel VBA 開發與表單",
    "syntax": "Set cbars = Application.CommandBars",
    "description": "傳回一個 CommandBars 集合，代表應用程式中的命令列 (包括功能表列、工具列和捷徑功能表)。雖然 Office 2007 及更高版本引入了 Ribbon UI，但 CommandBars 物件模型仍然存在，主要用於自訂傳統選單、工具列 (在相容模式下或舊版 Office) 和捷徑功能表。對於 Ribbon 的自訂，通常使用 RibbonX (XML)。",
    "parameters": [],
    "examples": [
        {"code": "Sub ListCommandBarNames()\n    Dim cb As CommandBar\n    For Each cb In Application.CommandBars\n        Debug.Print cb.Name & \" (Type: \" & cb.Type & \", Visible: \" & cb.Visible & \")\"\n    Next cb\nEnd Sub\n\nSub AddCustomButtonToCellContextMenu()\n    Dim cellMenu As CommandBar\n    Dim newButton As CommandBarButton\n    ' Get the cell context menu (right-click menu for cells)\n    Set cellMenu = Application.CommandBars(\"Cell\")\n    ' Remove old button if it exists (important for re-running code)\n    On Error Resume Next\n    cellMenu.Controls(\"MyCustomCellAction\").Delete\n    On Error GoTo 0\n    ' Add a new button\n    Set newButton = cellMenu.Controls.Add(Type:=msoControlButton, Before:=1) ' Before the first item\n    With newButton\n        .Caption = \"執行我的巨集\"\n        .Style = msoButtonCaption ' Show caption only\n        .OnAction = \"MyMacroToRun\" ' Name of the Sub to run\n        .Tag = \"MyCustomCellAction\" ' Tag for easy identification\n    End With\n    MsgBox \"已嘗試將自訂按鈕新增到儲存格捷徑功能表。\"\nEnd Sub\n\nSub MyMacroToRun()\n    MsgBox \"自訂捷徑功能表按鈕已點擊！選取的儲存格是: \" & Selection.Address\nEnd Sub", "explanation": "ListCommandBarNames 列印所有可用命令列的名稱。AddCustomButtonToCellContextMenu 將一個新的按鈕新增到儲存格的右鍵捷徑功能表的頂部，該按鈕會執行名為 \"MyMacroToRun\" 的宏。"}
    ],
    "keywords": ["commandbars", "custom menu excel", "right-click menu vba", "add toolbar button", "命令列", "自訂選單", "捷徑功能表"]
},
{
    "name": "Screen.MousePointer Property (General VBA)",
    "category": "綜合應用案例與技巧",
    "syntax": "Screen.MousePointer = vbHourglass ' Or vbDefault, etc.",
    "description": "設定滑鼠指標的形狀。這是一個較舊的屬性，主要用於 VBA (例如在 Access 或獨立的 VB6 應用中)。在 Office 應用程式 (Excel, Word) 中，通常使用 `Application.Cursor` 更為合適。",
    "parameters": [
        {"name": "vbHourglass (Constant 11)", "description": "沙漏 (忙碌) 指標。"},
        {"name": "vbDefault (Constant 0)", "description": "預設指標。"},
        {"name": "Other constants", "description": "如 vbArrow, vbIBeam, vbSizeNS, etc."}
    ],
    "examples": [
        {"code": "Sub ChangeMousePointerScreen()\n  On Error Resume Next ' Screen object might not be fully available in all Office VBA hosts for this\n  Screen.MousePointer = 11 ' vbHourglass\n  MsgBox \"滑鼠指標已嘗試設定為沙漏 (使用 Screen.MousePointer)。\"\n  Dim i As Long\n  For i = 1 To 5000000: DoEvents: Next ' Simulate work\n  Screen.MousePointer = 0  ' vbDefault\n  MsgBox \"滑鼠指標已還原。\"\n  On Error GoTo 0\nEnd Sub", "explanation": "嘗試使用 Screen.MousePointer 將滑鼠指標變更為沙漏形狀，然後再恢復預設。在 Excel VBA 中，`Application.Cursor` 是首選。"}
    ],
    "keywords": ["screen.mousepointer", "vba mouse cursor", "vb hourglass", "滑鼠指標形狀 (舊版)"]
},
{
    "name": "UserForm Control Properties (General)",
    "category": "Excel VBA 開發與表單",
    "description": "UserForm 上的控制項 (如 TextBox, ComboBox, ListBox, CommandButton, Label, CheckBox, OptionButton, Frame, MultiPage) 具有多種通用和特定的屬性，用於控制其外觀和行為。",
    "parameters": [
        {"name": ".Name", "description": "控制項的程式設計名稱。"},
        {"name": ".Caption (Label, CommandButton, Frame, CheckBox, OptionButton)", "description": "控制項上顯示的文字。"},
        {"name": ".Value (TextBox, ComboBox, ListBox, CheckBox, OptionButton)", "description": "控制項的主要值。"},
        {"name": ".Text (TextBox, ComboBox - if Style is DropdownCombo)", "description": "控制項中顯示的文字。"},
        {"name": ".Visible", "description": "True/False，控制項是否可見。"},
        {"name": ".Enabled", "description": "True/False，控制項是否可用 (可互動)。"},
        {"name": ".Left, .Top, .Width, .Height", "description": "控制項的位置和大小 (以點為單位)。"},
        {"name": ".ControlTipText", "description": "滑鼠懸停在控制項上時顯示的工具提示文字。"},
        {"name": ".TabIndex", "description": "控制項在 Tab 鍵順序中的索引。"},
        {"name": ".TabStop", "description": "True/False，控制項是否可以透過 Tab 鍵獲得焦點。"},
        {"name": ".Font (Name, Size, Bold, Italic, Color)", "description": "控制項文字的字型屬性。"},
        {"name": ".ForeColor / .BackColor", "description": "控制項的前景 (文字) 顏色和背景顏色。"}
    ],
    "examples": [
        {"code": "' --- In a UserForm's code module (e.g., UserForm1) ---\n' Private Sub UserForm_Initialize()\n'   Me.Caption = \"我的資料輸入表單\"\n'\n'   With Me.TextBox1 ' Assuming a TextBox named TextBox1 exists\n'     .Value = \"預設文字\"\n'     .MaxLength = 50\n'     .ToolTipText = \"請在此輸入您的姓名\"\n'     .Width = 200\n'   End With\n'\n'   With Me.CommandButton1 ' Assuming CommandButton1 exists\n'     .Caption = \"提交資料\"\n'     .Enabled = False ' Initially disabled until form is valid\n'   End With\n'\n'   With Me.Label1\n'     .Caption = \"重要提示:\"\n'     .ForeColor = RGB(255, 0, 0) ' Red text\n'   End With\n' End Sub\n'\n' ' Event for a CheckBox named CheckBoxAgree\n' Private Sub CheckBoxAgree_Click()\n'   If Me.CheckBoxAgree.Value = True Then\n'     Me.CommandButton1.Enabled = True ' Enable submit button if checkbox is checked\n'   Else\n'     Me.CommandButton1.Enabled = False\n'   End If\n' End Sub", "explanation": "概念性地展示了在 UserForm_Initialize 事件中如何設定標題、文字方塊的預設值和屬性、命令按鈕的標題和啟用狀態，以及標籤的文字和顏色。CheckBoxAgree_Click 事件根據核取方塊的狀態來啟用或禁用提交按鈕。"}
    ],
    "keywords": ["userform control properties", "textbox properties", "commandbutton properties", "label properties", "checkbox properties", "UserForm控制項屬性", "表單設計"]
},
{
    "name": "ListBox Control (UserForm)",
    "category": "Excel VBA 開發與表單",
    "description": "ListBox 控制項用於顯示一個項目列表，使用者可以從中選擇一個或多個項目。",
    "parameters": [
        {"name": ".AddItem Item, [Index]", "description": "方法：將項目新增到列表框。Index 是可選的插入位置 (0-based)。"},
        {"name": ".RemoveItem Index", "description": "方法：移除指定索引處的項目。"},
        {"name": ".Clear", "description": "方法：移除列表框中的所有項目。"},
        {"name": ".List(Index, [Column])", "description": "屬性：存取特定項目和欄 (如果有多欄) 的值。"},
        {"name": ".ListCount", "description": "屬性：傳回列表中的項目數量。"},
        {"name": ".ListIndex", "description": "屬性：傳回目前選取項目的索引 (-1 表示未選取)。"},
        {"name": ".Selected(Index)", "description": "屬性 (用於 MultiSelect)：檢查或設定特定項目是否被選取。"},
        {"name": ".MultiSelect (fmMultiSelectSingle, fmMultiSelectMulti, fmMultiSelectExtended)", "description": "屬性：設定選擇模式。"},
        {"name": ".ColumnCount", "description": "屬性：設定列表框的欄數。"},
        {"name": ".ColumnWidths", "description": "屬性：設定各欄的寬度 (字串，例如 \"50 pt;75 pt\")。"},
        {"name": ".BoundColumn", "description": "屬性：指定當 Value 屬性被讀取時，傳回哪一欄的值。"},
        {"name": ".TextColumn", "description": "屬性：指定哪一欄的內容會顯示在 ComboBox 的文字部分 (如果 ListBox 用作 ComboBox 的 RowSource)。"}
    ],
    "examples": [
        {"code": "' --- In a UserForm's code module (UserForm1) ---\n' ' Assume ListBox1 exists on the form\n' Private Sub UserForm_Initialize()\n'   With Me.ListBox1\n'     .AddItem \"蘋果\"\n'     .AddItem \"香蕉\"\n'     .AddItem \"櫻桃\"\n'     .ColumnCount = 2\n'     .ColumnWidths = \"70;30\" ' First column 70 points, second 30 points\n'     .List(0, 1) = \"紅色\" ' Second column for first item (Apple)\n'     .List(1, 1) = \"黃色\"\n'     .List(2, 1) = \"紅色\"\n'     .MultiSelect = 1 ' fmMultiSelectMulti\n'   End With\n' End Sub\n'\n' Private Sub CommandButtonShowSelected_Click() ' Assume a button to show selected items\n'   Dim i As Long, selectedItemsMsg As String\n'   selectedItemsMsg = \"選取的項目:\\n\"\n'   With Me.ListBox1\n'     If .ListIndex = -1 And .MultiSelect = 0 Then ' fmMultiSelectSingle and nothing selected\n'       MsgBox \"沒有選取任何項目。\"\n'       Exit Sub\n'     End If\n'     For i = 0 To .ListCount - 1\n'       If .Selected(i) Then\n'         selectedItemsMsg = selectedItemsMsg & .List(i, 0) & \" (\" & .List(i, 1) & \")\\n\"\n'       End If\n'     Next i\n'   End With\n'   MsgBox selectedItemsMsg\n' End Sub", "explanation": "在 UserForm_Initialize 中，向 ListBox1 新增水果名稱及其顏色作為兩欄。設定為允許多選。CommandButtonShowSelected_Click 事件則遍歷 ListBox1 中的所有項目，並顯示所有被選取的項目及其顏色。"}
    ],
    "keywords": ["userform listbox", "listbox additem", "listbox multiselect", "listbox columns", "UserForm列表框", "列表框多選"]
},
{
    "name": "ComboBox Control (UserForm)",
    "category": "Excel VBA 開發與表單",
    "description": "ComboBox 控制項結合了文字方塊和列表框的功能。使用者可以直接在文字方塊部分輸入值，或者從下拉清單中選擇一個值。",
    "parameters": [
        {"name": ".AddItem Item, [Index]", "description": "方法：將項目新增到下拉清單部分。"},
        {"name": ".RemoveItem Index", "description": "方法：移除下拉清單中的項目。"},
        {"name": ".Clear", "description": "方法：清除下拉清單和文字方塊部分。"},
        {"name": ".List", "description": "屬性：存取下拉清單中的項目陣列。"},
        {"name": ".ListCount", "description": "屬性：傳回下拉清單中的項目數量。"},
        {"name": ".ListIndex", "description": "屬性：傳回目前在下拉清單中選取項目的索引。"},
        {"name": ".Text", "description": "屬性：設定或傳回文字方塊部分的文字。"},
        {"name": ".Value", "description": "屬性：設定或傳回控制項的值 (通常與 Text 或選取項目的值相同)。"},
        {"name": ".Style (fmStyleDropDownCombo, fmStyleDropDownList)", "description": "屬性：fmStyleDropDownCombo (預設) 允許輸入和選擇；fmStyleDropDownList 只允許從清單選擇。"},
        {"name": ".MatchRequired", "description": "屬性 (Boolean)：True 表示輸入的文字必須符合清單中的某個項目。"},
        {"name": ".RowSource", "description": "屬性：可以設定為一個Excel工作表範圍 (例如 \"Sheet1!A1:A10\")，以該範圍的內容填充下拉清單。"}
    ],
    "examples": [
        {"code": "' --- In a UserForm's code module (UserForm1) ---\n' ' Assume ComboBox1 exists on the form\n' Private Sub UserForm_Initialize()\n'   With Me.ComboBox1\n'     .AddItem \"選項 A\"\n'     .AddItem \"選項 B\"\n'     .AddItem \"選項 C\"\n'     .Style = 2 ' fmStyleDropDownList (forces selection from list)\n'     .ListIndex = 0 ' Select the first item by default\n'   End With\n'\n'   ' Example using RowSource with a named range \"MyCategories\"\n'   ' Me.ComboBox2.RowSource = \"MyCategories\"\n' End Sub\n'\n' Private Sub ComboBox1_Change()\n'   ' This event fires when the selection changes or text is typed (if style allows)\n'   If Me.ComboBox1.ListIndex > -1 Then ' An item from list is selected\n'     Debug.Print \"ComboBox1 選取變更: \" & Me.ComboBox1.Value & \" (索引: \" & Me.ComboBox1.ListIndex & \")\"\n'   Else ' User might be typing new text (if style is fmStyleDropDownCombo)\n'     Debug.Print \"ComboBox1 文字變更: \" & Me.ComboBox1.Text\n'   End If\n' End Sub\n'\n' Private Sub CommandButtonGetValue_Click() ' Button to get ComboBox value\n'   MsgBox \"ComboBox1 目前的值是: \" & Me.ComboBox1.Value\n' End Sub", "explanation": "在 UserForm_Initialize 中，向 ComboBox1 新增幾個選項，並設定其樣式為只能從清單中選擇，同時預選第一個項目。ComboBox1_Change 事件會在選擇改變時觸發。CommandButtonGetValue_Click 則獲取 ComboBox 的當前值。還展示了如何使用 RowSource (註解中)。"}
    ],
    "keywords": ["userform combobox", "combobox additem", "combobox rowsourcem", "combobox style", "UserForm下拉式方塊", "下拉清單方塊"]
},
{
    "name": "Frame Control (UserForm)",
    "category": "Excel VBA 開發與表單",
    "description": "Frame 控制項用於在 UserForm 上對其他控制項進行視覺分組。它可以有自己的標題 (Caption)。",
    "parameters": [
        {"name": ".Caption", "description": "框架的標題文字。"},
        {"name": ".Controls", "description": "集合：包含框架內所有控制項。"}
    ],
    "examples": [
        {"code": "' --- In UserForm_Initialize for UserForm1 ---\n' ' Assume Frame1 exists, and it contains RadioButton1 and RadioButton2\n' Private Sub UserForm_Initialize()\n'   Me.Frame1.Caption = \"選擇您的性別\"\n'   Me.Frame1.Font.Bold = True\n'\n'   ' To loop through controls within a frame:\n'   Dim ctrl As MSForms.Control\n'   For Each ctrl In Me.Frame1.Controls\n'     If TypeOf ctrl Is MSForms.OptionButton Then\n'       Debug.Print \"框架內的選項按鈕: \" & ctrl.Name & \" - 標題: \" & ctrl.Caption\n'     End If\n'   Next ctrl\n' End Sub", "explanation": "設定 UserForm 上一個名為 Frame1 的框架的標題和字型。同時演示如何遍歷框架內的控制項 (例如，檢查其中的 OptionButton)。"}
    ],
    "keywords": ["userform frame control", "group controls userform", "UserForm框架", "控制項分組"]
},
{
    "name": "MultiPage Control (UserForm)",
    "category": "Excel VBA 開發與表單",
    "description": "MultiPage 控制項允許在一個 UserForm 上創建多個標籤頁 (Pages)，每個頁面可以包含不同的控制項集。這對於組織大量輸入欄位或不同步驟的表單非常有用。",
    "parameters": [
        {"name": ".Pages", "description": "集合：代表 MultiPage 控制項中所有 Page 物件的集合。"},
        {"name": ".Value / .SelectedItem", "description": "屬性：設定或傳回目前活動頁面的索引 (0-based) 或 Page 物件。"},
        {"name": "Page Object Properties (.Name, .Caption, .Index, .Controls)", "description": "每個 Page 物件有其自己的名稱、標題、索引和包含的控制項集合。"}
    ],
    "examples": [
        {"code": "' --- In UserForm_Initialize for UserForm1 ---\n' ' Assume MultiPage1 exists with at least 2 pages\n' Private Sub UserForm_Initialize()\n'   With Me.MultiPage1\n'     .Value = 0 ' Select the first page (index 0)\n'\n'     ' Set captions for pages\n'     If .Pages.Count >= 1 Then .Pages(0).Caption = \"基本資料\"\n'     If .Pages.Count >= 2 Then .Pages(1).Caption = \"詳細設定\"\n'\n'     ' Add a control to the first page programmatically (example)\n'     Dim newLabel As MSForms.Label\n'     Set newLabel = .Pages(0).Controls.Add(\"Forms.Label.1\", \"lblInfoOnPage1\", True)\n'     With newLabel\n'       .Caption = \"這是第一頁的標籤\"\n'       .Left = 10: .Top = 10\n'     End With\n'   End With\n' End Sub\n'\n' Private Sub MultiPage1_Change()\n'   ' This event fires when the selected page changes\n'   MsgBox \"已切換到頁面: \" & Me.MultiPage1.SelectedItem.Caption & \" (索引: \" & Me.MultiPage1.Value & \")\"\n' End Sub", "explanation": "在 UserForm_Initialize 中，選取 MultiPage1 的第一個頁面，並設定其兩個頁面的標題。同時，示範如何以程式設計方式向特定頁面新增控制項。MultiPage1_Change 事件會在使用者切換頁面時觸發。"}
    ],
    "keywords": ["userform multipage", "tabbed dialog vba", "userform pages", "UserForm多頁控制項", "標籤頁"]
},
{
    "name": "TabStrip Control (UserForm)",
    "category": "Excel VBA 開發與表單",
    "description": "TabStrip 控制項與 MultiPage 類似，提供標籤頁切換功能。但不同的是，TabStrip 本身不包含控制項；所有控制項都直接放在 UserForm 上，然後根據 TabStrip 的當前選定標籤來動態顯示或隱藏這些控制項。MultiPage 的每個 Page 則是一個獨立的控制項容器。",
    "parameters": [
        {"name": ".Tabs", "description": "集合：代表 TabStrip 中所有 Tab 物件的集合。"},
        {"name": ".Value / .SelectedItem", "description": "屬性：設定或傳回目前活動標籤的索引 (0-based) 或 Tab 物件。"},
        {"name": "Tab Object Properties (.Caption, .Name, .Index, .Tag)", "description": "每個 Tab 物件有其標題、名稱等。"}
    ],
    "examples": [
        {"code": "' --- In UserForm_Initialize for UserForm1 ---\n' ' Assume TabStrip1 exists, and TextBoxA, TextBoxB exist directly on UserForm\n' Private Sub UserForm_Initialize()\n'   With Me.TabStrip1\n'     If .Tabs.Count = 0 Then ' Add tabs if not designed already\n'       .Tabs.Add \"TabInfo\", \"個人資料\"\n'       .Tabs.Add \"TabPrefs\", \"偏好設定\"\n'     Else\n'       .Tabs(0).Caption = \"個人資料更新\"\n'       .Tabs(1).Caption = \"偏好設定更新\"\n'     End If\n'     .Value = 0 ' Select first tab\n'   End With\n'   Call TabStrip1_Change ' Call Change event manually to set initial visibility\n' End Sub\n'\n' Private Sub TabStrip1_Change()\n'   ' This event fires when the selected tab changes\n'   Select Case Me.TabStrip1.Value\n'     Case 0 ' First tab selected (e.g., Personal Info)\n'       Me.TextBoxA.Visible = True ' Assume TextBoxA is for Personal Info\n'       Me.TextBoxB.Visible = False ' Assume TextBoxB is for Preferences\n'       Debug.Print \"TabStrip 切換到: 個人資料\"\n'     Case 1 ' Second tab selected (e.g., Preferences)\n'       Me.TextBoxA.Visible = False\n'       Me.TextBoxB.Visible = True\n'       Debug.Print \"TabStrip 切換到: 偏好設定\"\n'     ' Add more cases for other tabs\n'   End Select\n' End Sub", "explanation": "在 UserForm_Initialize 中，為 TabStrip1 設定標籤頁的標題，並預選第一個標籤。TabStrip1_Change 事件會在標籤切換時觸發，並根據當前選定的標籤索引來動態設定 UserForm 上其他控制項 (例如 TextBoxA, TextBoxB) 的可見性。"}
    ],
    "keywords": ["userform tabstrip", "tab control vba", "dynamic control visibility", "UserForm標籤條", "標籤控制項"]
},
{
    "name": "UserForm Control Events (General)",
    "category": "Excel VBA 開發與表單",
    "description": "UserForm 及其上的控制項可以回應各種事件，允許您編寫VBA代碼來處理使用者互動。常見事件包括：\nUserForm: Initialize (載入時), Activate, Click, DblClick, KeyDown, QueryClose (關閉前), Terminate (卸載後)。\nCommandButton: Click.\nTextBox/ComboBox: Change (內容改變時), Enter (獲得焦點時), Exit (失去焦點時), KeyDown, KeyPress, KeyUp.\nCheckBox/OptionButton: Click, Change.\nListBox: Click, DblClick, Change.\nFrame/Label: 通常較少使用事件，但也有 Click, DblClick 等。",
    "parameters": [],
    "examples": [
        {"code": "' --- In a UserForm's code module (e.g., UserForm1) ---\n' Private Sub UserForm_Initialize()\n'   Me.TextBox1.Text = \"請輸入文字...\"\n' End Sub\n'\n' Private Sub TextBox1_Change()\n'   Me.LabelStatus.Caption = \"TextBox1 內容已變更為: \" & Me.TextBox1.Text\n' End Sub\n'\n' Private Sub TextBox1_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)\n'   If KeyCode = vbKeyReturn Then ' Enter key pressed in TextBox1\n'     MsgBox \"在 TextBox1 中按下了 Enter 鍵！\"\n'     KeyCode = 0 ' Optional: Prevent Enter key from further processing (e.g. closing form)\n'   End If\n' End Sub\n'\n' Private Sub CommandButtonOK_Click()\n'   MsgBox \"確定按鈕被點擊。TextBox1 的值: \" & Me.TextBox1.Text\n'   Unload Me ' Close the form\n' End Sub\n'\n' Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)\n'   ' CloseMode = 0 (vbFormControlMenu) means user clicked the 'X' button\n'   If CloseMode = vbFormControlMenu Then\n'     If MsgBox(\"您確定要關閉表單嗎？未儲存的資料將會遺失。\", vbYesNo + vbQuestion, \"關閉確認\") = vbNo Then\n'       Cancel = True ' Prevent the form from closing\n'     End If\n'   End If\n' End Sub", "explanation": "展示了幾個常用事件：UserForm_Initialize (初始化文字方塊)，TextBox1_Change (當文字方塊內容改變時更新標籤)，TextBox1_KeyDown (偵測在文字方塊中按下Enter鍵)，CommandButtonOK_Click (處理按鈕點擊)，以及 UserForm_QueryClose (在用戶嘗試透過標題列的 'X' 按鈕關閉表單時進行確認)。"}
    ],
    "keywords": ["userform events", "control events vba", "textbox change event", "button click event", "userform initialize", "userform queryclose", "UserForm事件", "控制項事件"]
},
{
    "name": "Collection (Using String Keys for Item Retrieval)",
    "category": "陣列、集合與字典",
    "description": "向 Collection 新增項目時，可以指定一個唯一的字串鍵 (Key)。之後就可以使用這個鍵來快速檢索、更新或移除該項目，而不必依賴其數字索引 (數字索引在移除項目後可能會改變)。",
    "syntax": "MyCollection.Add ItemValue, KeyNameAsString\nretrievedItem = MyCollection(KeyNameAsString)\nMyCollection.Remove KeyNameAsString",
    "parameters": [],
    "examples": [
        {"code": "Dim employeeData As New Collection\n' Add employees with their ID as the key\nemployeeData.Add \"Alice Wonderland (Sales)\", \"EMP101\"\nemployeeData.Add \"Bob The Builder (Ops)\", \"EMP102\"\nemployeeData.Add \"Charlie Brown (IT)\", \"EMP103\"\n\n' Retrieve employee by ID\nDim empName As String\nOn Error Resume Next ' In case key doesn't exist\nempName = employeeData(\"EMP102\")\nIf Err.Number = 0 Then\n  Debug.Print \"員工 EMP102 的姓名是: \" & empName\nElse\n  Debug.Print \"未找到員工 EMP102。\"\nEnd If\nErr.Clear\nOn Error GoTo 0\n\n' Remove an employee by ID\nemployeeData.Remove \"EMP101\"\nDebug.Print \"移除 EMP101 後，集合數量: \" & employeeData.Count\n\n' Try to access removed item (will cause error if not handled)\nOn Error Resume Next\nempName = employeeData(\"EMP101\")\nIf Err.Number <> 0 Then Debug.Print \"嘗試存取已移除的 EMP101 失敗 (預期中)。\"\nOn Error GoTo 0", "explanation": "演示如何使用字串鍵向 Collection 新增員工數據，然後按鍵檢索特定員工，以及按鍵移除員工。"}
    ],
    "keywords": ["collection string key", "vba collection key retrieval", "named collection items", "Collection字串鍵", "按鍵名存取集合"]
},
{
    "name": "Environ Function (Checking for Existence)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "如果嘗試使用 Environ 函數獲取一個不存在的環境變數，它會傳回一個零長度字串 (空字串 \"\")。",
    "syntax": "value = Environ(\"NonExistentVariable\")\nIf value = \"\" Then ...",
    "parameters": [],
    "examples": [
        {"code": "Dim varValue As String\nvarValue = Environ(\"MY_CUSTOM_APP_SETTING\")\nIf varValue = \"\" Then\n  Debug.Print \"環境變數 'MY_CUSTOM_APP_SETTING' 未設定或為空。\"\nElse\n  Debug.Print \"環境變數 'MY_CUSTOM_APP_SETTING' 的值是: \" & varValue\nEnd If\n\nDebug.Print \"USERNAME (exists): \" & Environ(\"USERNAME\")", "explanation": "檢查一個通常不存在的環境變數 \"MY_CUSTOM_APP_SETTING\"。如果 Environ 傳回空字串，則表示該變數未找到或其值本身就是空的。"}
    ],
    "keywords": ["environ check variable exists", "vba environment variable null", "檢查環境變數是否存在"]
},
{
    "name": "Shell and Wait (Using WScript.Shell)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "使用 WScript.Shell 物件的 Run 方法比 VBA 內建的 Shell 函數提供了更多控制，包括等待外部程式結束並獲取其結束代碼的功能。",
    "syntax": "Set wsh = CreateObject(\"WScript.Shell\")\nexitCode = wsh.Run(Command, [WindowStyle], [WaitOnReturn As Boolean])",
    "parameters": [
        {"name": "Command", "description": "要執行的命令字串。"},
        {"name": "WindowStyle", "description": "可選。視窗的顯示樣式 (例如 0=隱藏, 1=正常, 7=最小化)。"},
        {"name": "WaitOnReturn", "description": "可選。True (預設) 表示 VBA 等待程式完成後再繼續；False 表示立即返回。"}
    ],
    "examples": [
        {"code": "Dim wshShell As Object\nDim commandToRun As String\nDim returnCode As Long\n\nSet wshShell = CreateObject(\"WScript.Shell\")\ncommandToRun = \"notepad.exe\"\n\nMsgBox \"即將開啟記事本並等待其關閉...\"\n' Run Notepad, show normal window (1), and wait for it to close (True)\nreturnCode = wshShell.Run(commandToRun, 1, True)\n\nMsgBox \"記事本已關閉。結束代碼: \" & returnCode\nSet wshShell = Nothing", "explanation": "使用 WScript.Shell 的 Run 方法啟動記事本。由於 `WaitOnReturn` 參數設為 True (或省略，因為它是預設值)，VBA 腳本會暫停，直到記事本應用程式被關閉。然後，它會顯示記事本的結束代碼。"}
    ],
    "keywords": ["wscript.shell run", "vba wait for shell process", "get exit code wsh", "同步執行外部程式"]
},
{
    "name": "CreateObject (Specific Version of Application)",
    "category": "程式流程與結構控制",
    "description": "使用 CreateObject 時，可以指定應用程式的特定版本 (如果已安裝並註冊)。例如，`CreateObject(\"Excel.Application.16\")` 會嘗試建立 Excel 2016 (或更新版本，因為版號可能向上兼容) 的實例。省略版本號 (例如 `CreateObject(\"Excel.Application\")`) 通常會啟動預設或最新安裝的版本。",
    "syntax": "Set obj = CreateObject(\"ApplicationName.ClassName.Version\")",
    "parameters": [{"name": "Version", "description": "應用程式的版本號，例如 Word 的 \"Word.Application.16\"。"}],
    "examples": [
        {"code": "Dim wdAppSpecificVer As Object\nOn Error Resume Next\n' Try to create an instance of Word (version corresponding to .16, e.g., Word 2016/365)\nSet wdAppSpecificVer = CreateObject(\"Word.Application.16\")\nIf Err.Number = 0 And Not wdAppSpecificVer Is Nothing Then\n  MsgBox \"成功建立 Word.Application.16 的實例。版本: \" & wdAppSpecificVer.Version\n  wdAppSpecificVer.Quit\nElse\n  MsgBox \"無法建立 Word.Application.16。錯誤: \" & Err.Description & vbCrLf & \"將嘗試通用版本...\"\n  Err.Clear\n  Set wdAppSpecificVer = CreateObject(\"Word.Application\")\n  If Not wdAppSpecificVer Is Nothing Then\n    MsgBox \"成功建立通用 Word.Application 的實例。版本: \" & wdAppSpecificVer.Version\n    wdAppSpecificVer.Quit\n  Else\n    MsgBox \"無法建立任何 Word 實例。\"\n  End If\nEnd If\nOn Error GoTo 0\nSet wdAppSpecificVer = Nothing", "explanation": "嘗試建立一個特定版本的 Word 應用程式物件 (例如，對應於 Office 2016 的版本 16)。如果失敗，則回退到嘗試建立通用的 Word.Application 物件。"}
    ],
    "keywords": ["createobject specific version", "application version progid", "ole versioning", "指定版本建立物件"]
},
{
    "name": "Application.Caller (Details and Limitations)",
    "category": "Excel VBA 開發與表單",
    "description": "Application.Caller 在UDF中傳回呼叫該UDF的Range物件。但有一些限制和注意事項：\n1. **僅在由儲存格公式呼叫時有效**：如果UDF是從另一個VBA程序中呼叫的，Application.Caller會產生錯誤。需要使用 `On Error Resume Next` 處理。\n2. **多儲存格陣列公式**：如果UDF作為多儲存格陣列公式的一部分被輸入，Application.Caller會傳回包含整個陣列公式的Range物件。\n3. **條件格式公式**：在條件格式公式中使用UDF時，Application.Caller通常會參照套用該條件格式的範圍中的第一個儲存格。\n4. **圖表**：如果UDF用於圖表系列公式，Application.Caller可能傳回代表圖表或系列的不預期物件，或產生錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Function MyUDF_CallerDetails() As String\n    Dim callerInfo As String\n    On Error Resume Next ' Important when Caller might not be a Range\n    If TypeName(Application.Caller) = \"Range\" Then\n        Dim callerRange As Range\n        Set callerRange = Application.Caller\n        callerInfo = \"由儲存格 \" & callerRange.Address(False, False) & \" 在工作表 '\" & callerRange.Worksheet.Name & \"' 中呼叫。\"\n        If callerRange.Cells.CountLarge > 1 Then\n            callerInfo = callerInfo & \" (作為陣列公式的一部分，範圍大小: \" & callerRange.Address(False, False) & \")\"\n        End If\n    ElseIf TypeName(Application.Caller) = \"String\" Then ' e.g. called from Macro dialog with a name\n        callerInfo = \"由名稱 '\" & Application.Caller & \"' 呼叫 (可能來自巨集對話框或按鈕)。\"\n    ElseIf Err.Number <> 0 Then\n        callerInfo = \"無法確定呼叫者 (錯誤 \" & Err.Number & \")。可能從VBA呼叫。\"\n    Else\n        callerInfo = \"由未知類型的物件呼叫: \" & TypeName(Application.Caller)\n    End If\n    On Error GoTo 0\n    MyUDF_CallerDetails = callerInfo\nEnd Function\n' In Excel cell: =MyUDF_CallerDetails()", "explanation": "一個更詳細的UDF，它使用 TypeName(Application.Caller) 來嘗試確定呼叫者的類型，並相應地提供更詳細的信息，包括處理從儲存格、作為陣列公式、或從VBA過程（導致錯誤）調用的情況。"}
    ],
    "keywords": ["application.caller details", "udf context", "caller range array formula", "Application.Caller限制"]
},
{
    "name": "Collection (Iterating and Type Checking)",
    "category": "陣列、集合與字典",
    "description": "遍歷 Collection 時，如果集合包含不同資料類型的項目 (包括物件)，可以使用 `TypeName` 函數或 `TypeOf...Is` 運算子來檢查每個項目的類型，然後再進行相應處理。",
    "syntax": "For Each item In MyCollection\n  If TypeOf item Is Worksheet Then ...\n  ElseIf IsNumeric(item) Then ...\nNext item",
    "parameters": [],
    "examples": [
        {"code": "Dim mixedCollection As New Collection\nmixedCollection.Add \"Hello\"\nmixedCollection.Add 123\nmixedCollection.Add Date\nmixedCollection.Add ThisWorkbook.Sheets(1)\n\nDim element As Variant\nFor Each element In mixedCollection\n  Select Case TypeName(element)\n    Case \"String\": Debug.Print \"字串: \" & element\n    Case \"Integer\", \"Long\", \"Double\", \"Currency\", \"Single\", \"Byte\"\n      Debug.Print \"數字: \" & element\n    Case \"Date\": Debug.Print \"日期: \" & Format(element, \"yyyy-mm-dd\")\n    Case Else\n      If TypeOf element Is Excel.Worksheet Then\n        Dim ws As Worksheet: Set ws = element\n        Debug.Print \"工作表物件: \" & ws.Name\n      ElseIf TypeOf element Is Object Then\n        Debug.Print \"其他物件類型: \" & TypeName(element)\n      Else\n        Debug.Print \"未知類型: \" & TypeName(element)\n      End If\n  End Select\nNext element", "explanation": "建立一個包含不同資料類型項目（字串、數字、日期、Worksheet物件）的 Collection。然後遍歷該集合，使用 Select Case TypeName(element) 和 TypeOf...Is 來識別每個項目的類型並進行相應的處理/列印。"}
    ],
    "keywords": ["collection iterate types", "typeof in collection loop", "handle mixed types collection", "遍歷集合檢查類型"]
},

{
    "name": "Range.Find (SearchFormat and ReplaceFormat)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Find(..., SearchFormat:=True)\nrangeObject.Replace(..., ReplaceFormat:=True, Replacement:=newFormatObjectOrValue)",
    "description": "Find 和 Replace 方法的 SearchFormat 和 ReplaceFormat 引數允許基於儲存格格式進行搜尋和取代。當 SearchFormat 為 True 時，Excel 會搜尋與使用 Application.FindFormat 設定的格式相符的儲存格。當 ReplaceFormat 為 True 時，Excel 會將找到的儲存格的格式更改為使用 Application.ReplaceFormat 設定的格式。",
    "parameters": [
        {"name": "Application.FindFormat.Clear", "description": "清除先前的搜尋格式設定。"},
        {"name": "Application.FindFormat.[Property] = Value", "description": "設定要搜尋的特定格式屬性 (例如 .Font.Bold, .Interior.Color)。"},
        {"name": "Application.ReplaceFormat.Clear", "description": "清除先前的取代格式設定。"},
        {"name": "Application.ReplaceFormat.[Property] = Value", "description": "設定要套用於取代的格式屬性。"}
    ],
    "examples": [
        {"code": "' Find all cells in column A that are bold and change their interior color to yellow\nApplication.FindFormat.Clear\nApplication.FindFormat.Font.Bold = True\nApplication.ReplaceFormat.Clear\nApplication.ReplaceFormat.Interior.Color = vbYellow\nColumns(\"A\").Replace What:=\"*\", Replacement:=\"\", SearchFormat:=True, ReplaceFormat:=True\nMsgBox \"A欄中所有粗體文字的儲存格背景已變更為黃色。What:='*'是必要的，即使只改格式。\"", "explanation": "此範例首先清除並設定 Application.FindFormat 以搜尋粗體字型，然後清除並設定 Application.ReplaceFormat 以將背景色改為黃色。接著，對A欄執行 Replace 操作，What:=\"*\" 用於匹配任何內容 (因為我們主要是基於格式)，SearchFormat:=True 指示 Excel 使用 FindFormat 的設定，ReplaceFormat:=True 指示 Excel 套用 ReplaceFormat 的設定。"}
    ],
    "keywords": ["find by format", "replace by format", "excel searchformat", "excel replaceformat", "格式搜尋", "格式取代"]
},
{
    "name": "Application.Speech.Speak (Excel/Word/PowerPoint)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "Application.Speech.Speak(Text As String, [SpeakAsync As Boolean = False], [SpeakXML As Boolean = False], [Purge As Boolean = False])",
    "description": "使用文字轉語音 (TTS) 引擎朗讀指定的文字。需要安裝支援的 TTS 引擎和語音。",
    "parameters": [
        {"name": "Text", "description": "必需。要朗讀的文字。"},
        {"name": "SpeakAsync", "description": "可選。True 表示非同步朗讀 (VBA繼續執行)，False (預設) 表示同步朗讀 (VBA等待朗讀完成)。"},
        {"name": "SpeakXML", "description": "可選。True 表示 Text 參數是包含語音合成標記語言 (SSML) 的 XML 字串。"}
    ],
    "examples": [
        {"code": "On Error Resume Next ' Speech may not be available or configured\nApplication.Speech.Speak \"Hello, this is a VBA test.\"\nIf Err.Number <> 0 Then MsgBox \"文字轉語音功能不可用或發生錯誤。\"\nErr.Clear\n' Application.Speech.Speak \"This will be spoken asynchronously.\", SpeakAsync:=True", "explanation": "嘗試朗讀一句英文文字。如果系統支援 TTS，則會聽到語音。第二個被註解的範例演示非同步朗讀。"}
    ],
    "keywords": ["text to speech", "vba speech speak", "tts excel", "read text aloud", "文字轉語音", "朗讀文字", "通用"]
},
{
    "name": "Shell (Return Value and AppActivate)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "Shell 函數在成功啟動程式時，會傳回該程式的「任務ID」(一個 Double 值)。這個任務ID可以被 AppActivate 函數用來將焦點切換到該已啟動的程式視窗，這比僅依賴視窗標題更可靠，因為視窗標題可能改變或與其他視窗衝突。",
    "syntax": "taskID = Shell(PathName, [WindowStyle])\nIf taskID <> 0 Then AppActivate taskID",
    "parameters": [],
    "examples": [
        {"code": "Dim calcTaskID As Variant\nOn Error Resume Next ' In case Shell fails\ncalcTaskID = Shell(\"CALC.EXE\", vbNormalFocus)\nIf Err.Number = 0 And calcTaskID <> 0 Then\n  MsgBox \"計算機已啟動，任務ID: \" & calcTaskID & \". 現在嘗試啟動它。\"\n  Application.Wait Now + TimeValue(\"00:00:01\") ' Give it a moment to initialize\n  AppActivate calcTaskID ' Activate the Calculator window using its Task ID\n  If Err.Number <> 0 Then ' AppActivate might fail if window not ready\n    MsgBox \"AppActivate 失敗 (可能視窗尚未完全準備好或ID無效): \" & Err.Description\n  End If\nElse\n  MsgBox \"啟動計算機失敗。錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0", "explanation": "啟動計算機，獲取其任務ID，然後使用該任務ID透過 AppActivate 函數來嘗試將計算機視窗帶到前景。"}
    ],
    "keywords": ["shell task id", "appactivate task id", "activate shelled application", "Shell任務ID", "啟動外部程式"]
},
{
    "name": "CreateObject (Check if Object Creation Succeeded)",
    "category": "程式流程與結構控制",
    "description": "使用 CreateObject 後，應檢查返回的物件變數是否為 Nothing，以確認物件是否成功建立。如果 CreateObject 失敗 (例如，ProgID 無效或元件未註冊)，它通常會觸發錯誤 429，但某些情況下也可能返回 Nothing 或導致後續操作失敗。",
    "syntax": "Set obj = CreateObject(\"ProgID\")\nIf obj Is Nothing Then ...",
    "parameters": [],
    "examples": [
        {"code": "Dim fsObj As Object\nDim testProgID As String: testProgID = \"Scripting.FileSystemObject\" ' Valid ProgID\n' Dim testProgID_Invalid As String: testProgID_Invalid = \"Invalid.ProgID\" ' Invalid ProgID\n\nOn Error Resume Next ' Temporarily disable error handling for CreateObject\nSet fsObj = CreateObject(testProgID)\nIf Err.Number <> 0 Then\n  MsgBox \"使用 CreateObject(\"\"\" & testProgID & \"\"\") 失敗。錯誤: \" & Err.Description\n  Set fsObj = Nothing ' Ensure it's Nothing if creation failed with error\nEnd If\nOn Error GoTo 0 ' Restore error handling\n\nIf fsObj Is Nothing Then\n  MsgBox \"無法建立 FileSystemObject。腳本無法繼續。\"\nElse\n  MsgBox \"FileSystemObject 已成功建立。\"\n  ' ... use fsObj ...\n  Debug.Print \"Drives count: \" & fsObj.Drives.Count\n  Set fsObj = Nothing\nEnd If", "explanation": "嘗試建立 FileSystemObject。使用 On Error Resume Next 來捕獲 CreateObject 可能產生的錯誤。如果發生錯誤 (Err.Number <> 0) 或返回的物件是 Nothing，則認為建立失敗。"}
    ],
    "keywords": ["createobject check success", "is object nothing after create", "validate createobject", "確認物件建立成功"]
},
{
    "name": "Application.Caller (Worksheet Name Context)",
    "category": "Excel VBA 開發與表單",
    "description": "在由工作表儲存格公式呼叫的UDF中，可以使用 `Application.Caller.Worksheet.Name` 來獲取包含該呼叫儲存格的工作表的名稱。",
    "syntax": "callingWorksheetName = Application.Caller.Worksheet.Name",
    "parameters": [],
    "examples": [
        {"code": "Function GetCallingSheetName() As String\n  On Error Resume Next\n  If TypeName(Application.Caller) = \"Range\" Then\n    GetCallingSheetName = \"此UDF由工作表 '\" & Application.Caller.Worksheet.Name & \"' 呼叫。\"\n  Else\n    GetCallingSheetName = \"UDF 未從工作表儲存格呼叫。\"\n  End If\n  On Error GoTo 0\nEnd Function\n' In an Excel cell (e.g., on Sheet2), type: =GetCallingSheetName()", "explanation": "這個UDF會返回一條訊息，指出是哪個工作表上的儲存格呼叫了它。"}
    ],
    "keywords": ["application.caller worksheet name", "udf calling sheet", "UDF呼叫工作表"]
},
{
    "name": "Collection (Iterating with For i = 1 To Count vs For Each)",
    "category": "陣列、集合與字典",
    "description": "遍歷 Collection 有兩種主要方式：\n1. `For i = 1 To MyCollection.Count ... MyCollection(i) ... Next i`：使用數字索引存取項目。如果需要在迴圈中移除項目，必須從後向前遍歷 (`For i = MyCollection.Count To 1 Step -1`)。\n2. `For Each element In MyCollection ... Next element`：使用 For Each 迴圈。這種方式更簡潔，但如果在迴圈內部修改集合 (新增或移除項目)，可能會產生錯誤或非預期行為。因此，當需要在迴圈中修改集合時，通常推薦使用帶索引的 For 迴圈 (並從後向前，如果涉及刪除)。",
    "parameters": [],
    "examples": [
        {"code": "Dim letters As New Collection\nletters.Add \"A\": letters.Add \"B\": letters.Add \"C\": letters.Add \"D\"\n\nDim i As Long\nDebug.Print \"使用索引遍歷:\"\nFor i = 1 To letters.Count\n  Debug.Print \"Index \" & i & \": \" & letters(i)\nNext i\n\nDim item As Variant\nDebug.Print \"使用 For Each 遍歷:\"\nFor Each item In letters\n  Debug.Print \"Item: \" & item\nNext item\n\n' Attempting to remove during For Each can be problematic (conceptual, might error or skip)\n' For Each item In letters\n'   If item = \"B\" Then letters.Remove (?) ' How to get index or key here for removal?\n' Next item\n' Correct way to remove \"B\" (if key is not known or not used):\nFor i = letters.Count To 1 Step -1\n    If letters(i) = \"B\" Then letters.Remove i\nNext i\nDebug.Print \"移除 'B' 後，剩餘: \" & letters.Count", "explanation": "演示兩種遍歷 Collection 的方法，並強調在迴圈中移除項目時應使用從後向前的索引迴圈。"}
    ],
    "keywords": ["collection iteration methods", "for each vs for loop collection", "remove items while iterating collection", "集合遍歷方式"]
},
{
    "name": "ChDrive (Error Handling)",
    "category": "檔案與資料夾管理",
    "description": "如果 ChDrive 語句嘗試切換到一個不存在或無法存取的磁碟機 (例如，沒有軟碟的 A: 磁碟機，或未掛載的網路磁碟機)，會產生執行階段錯誤 '68' (裝置無法使用) 或類似錯誤。應使用錯誤處理來捕獲此類情況。",
    "syntax": "On Error Resume Next\nChDrive driveLetterString\nIf Err.Number <> 0 Then ...",
    "parameters": [],
    "examples": [
        {"code": "Dim targetDrive As String: targetDrive = \"X\" ' Assume X: drive does not exist\nDim originalDrive As String: originalDrive = Left(CurDir, 1)\n\nOn Error Resume Next ' Enable error trapping\nChDrive targetDrive\nIf Err.Number = 0 Then\n  MsgBox \"成功切換到磁碟機 \" & targetDrive & \":。目前目錄: \" & CurDir\n  ChDrive originalDrive ' Switch back\nElse\n  MsgBox \"無法切換到磁碟機 \" & targetDrive & \":。錯誤 \" & Err.Number & \": \" & Err.Description\nEnd If\nOn Error GoTo 0 ' Disable error trapping", "explanation": "嘗試切換到一個可能不存在的磁碟機 X:。使用 On Error Resume Next 來捕獲可能發生的錯誤，並向用戶顯示適當的訊息。"}
    ],
    "keywords": ["chdrive error handling", "drive not available error", "vba error 68", "切換磁碟機錯誤處理"]
},
{
    "name": "Environ Function (Case Sensitivity)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "Environ 函數的 `envstring` (環境變數名稱) 參數在 Windows 上通常不區分大小寫。例如，`Environ(\"USERNAME\")` 和 `Environ(\"username\")` 會傳回相同的結果。",
    "syntax": "Environ(\"VariableName\")",
    "parameters": [],
    "examples": [
        {"code": "Dim userName1 As String, userName2 As String\nuserName1 = Environ(\"USERNAME\")\nuserName2 = Environ(\"username\")\nIf userName1 = userName2 And userName1 <> \"\" Then\n  Debug.Print \"Environ的變數名稱不區分大小寫。 USERNAME = \" & userName1\nElseIf userName1 = \"\" Then\n  Debug.Print \"環境變數 USERNAME 未找到。\"\nElse\n  Debug.Print \"Environ的變數名稱似乎區分大小寫或結果不同。\"\nEnd If", "explanation": "比較使用全大寫 \"USERNAME\" 和全小寫 \"username\" 呼叫 Environ 函數的結果，以驗證其在 Windows 上的不區分大小寫行為。"}
    ],
    "keywords": ["environ case sensitivity", "environment variable case", "環境變數大小寫"]
},
{
    "name": "Shell (WindowStyle Argument Details)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "Shell 函數的 `windowstyle` 引數接受 VbAppWinStyle 列舉中的常數來控制被啟動程式的視窗外觀：\nvbHide (0): 視窗被隱藏，但程式有焦點。\nvbNormalFocus (1): 視窗具有焦點並恢復其原始大小和位置。\nvbMinimizedFocus (2): 視窗顯示為帶焦點的圖示。\nvbMaximizedFocus (3): 視窗最大化並具有焦點。\nvbNormalNoFocus (4): 視窗恢復其最近的大小和位置，當前活動視窗保持活動。\nvbMinimizedNoFocus (6): 視窗顯示為圖示，當前活動視窗保持活動。",
    "syntax": "Shell(PathName, WindowStyleConstant)",
    "parameters": [],
    "examples": [
        {"code": "Dim result As Variant\n' Open Notepad hidden, with focus (though hidden means focus is not very useful)\n' result = Shell(\"notepad.exe\", vbHide)\n' Debug.Print \"Notepad (Hidden) TaskID: \" & result\n\n' Open Calculator minimized, but with focus\n' result = Shell(\"calc.exe\", vbMinimizedFocus)\n' Debug.Print \"Calculator (MinimizedFocus) TaskID: \" & result\n\n' Open WordPad normal, without stealing focus from Excel\n' result = Shell(\"write.exe\", vbNormalNoFocus)\n' Debug.Print \"WordPad (NormalNoFocus) TaskID: \" & result\nMsgBox \"已嘗試以不同視窗樣式啟動程式 (請檢查立即視窗的 TaskID)。\"", "explanation": "概念性地演示了使用 Shell 函數的不同 `windowstyle` 常數來以不同方式啟動外部程式。實際測試時可以取消註解對應的 Shell 呼叫。"}
    ],
    "keywords": ["shell windowstyle", "vbhide", "vbnormalfocus", "vbminimizedfocus", "Shell視窗樣式"]
},
{
    "name": "RGB Function (Common Color Values)",
    "category": "綜合應用案例與技巧",
    "description": "一些常用的 RGB 顏色值：\nBlack: RGB(0, 0, 0)\nWhite: RGB(255, 255, 255)\nRed: RGB(255, 0, 0)\nGreen: RGB(0, 255, 0) (or RGB(0,128,0) for darker green)\nBlue: RGB(0, 0, 255) (or RGB(0,0,128) for darker blue)\nYellow: RGB(255, 255, 0)\nCyan: RGB(0, 255, 255)\nMagenta: RGB(255, 0, 255)\nGray (50%): RGB(128, 128, 128)\nLight Gray: RGB(192, 192, 192)\nDark Gray: RGB(64, 64, 64)",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Interior.Color = RGB(255, 165, 0) ' Orange\nRange(\"A2\").Font.Color = RGB(128, 0, 128)    ' Purple\nMsgBox \"A1背景設為橘色，A2字型設為紫色。\"", "explanation": "設定儲存格A1的背景色為橘色，儲存格A2的字型顏色為紫色，使用 RGB 函數。"}
    ],
    "keywords": ["common rgb colors", "standard colors vba", "常用RGB顏色"]
},
{
    "name": "Application.CommandBars.ExecuteMso (Ribbon Control)",
    "category": "Excel VBA 開發與表單",
    "syntax": "Application.CommandBars.ExecuteMso(idMso As String)",
    "description": "執行 Ribbon UI 中由其 idMso 識別的內建控制項的動作。idMso 是 Microsoft 為每個 Ribbon 控制項定義的唯一字串。",
    "parameters": [{"name": "idMso", "description": "必需。Ribbon 控制項的 idMso (字串)。"}],
    "examples": [
        {"code": "' Example: Simulate clicking the 'Save' button on the Ribbon\nOn Error Resume Next ' In case command is not available or context is wrong\nApplication.CommandBars.ExecuteMso (\"FileSave\")\nIf Err.Number = 0 Then\n  MsgBox \"已嘗試執行 'FileSave' (儲存檔案) 命令。\"\nElse\n  MsgBox \"執行 'FileSave' 命令失敗。錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\n\n' Example: Simulate clicking 'PivotTableAnalyzeContextualTab' (if a PivotTable is selected)\n' This might just activate the tab.\n' If Not ActiveCell.PivotTable Is Nothing Then Application.CommandBars.ExecuteMso (\"PivotTableAnalyzeContextualTab\")", "explanation": "使用 ExecuteMso 方法模擬點擊 Ribbon 上的「儲存檔案」按鈕 (其 idMso 是 \"FileSave\")。還提供了一個註解掉的例子，用於在選定樞紐分析表時嘗試啟用其分析上下文標籤頁。"}
    ],
    "keywords": ["executemso", "ribbon control vba", "simulate ribbon click", "idmso", "執行Ribbon控制項"]
},
{
    "name": "Application.CommandBars.GetEnabledMso (Ribbon Control)",
    "category": "Excel VBA 開發與表單",
    "syntax": "isEnabled = Application.CommandBars.GetEnabledMso(idMso As String)",
    "description": "傳回一個布林值，指出具有指定 idMso 的 Ribbon 控制項目前是否已啟用。",
    "parameters": [{"name": "idMso", "description": "必需。Ribbon 控制項的 idMso。"}],
    "examples": [
        {"code": "If Application.CommandBars.GetEnabledMso(\"Copy\") Then\n  MsgBox \"Ribbon上的 '複製 (Copy)' 命令目前已啟用。\"\nElse\n  MsgBox \"Ribbon上的 '複製 (Copy)' 命令目前已禁用 (例如，沒有選取任何內容)。\"\nEnd If", "explanation": "檢查 Ribbon 上的「複製」命令 (idMso: \"Copy\") 目前是否可用。"}
    ],
    "keywords": ["getenabledmso", "check ribbon control enabled", "ribbon button state", "檢查Ribbon按鈕是否啟用"]
},
{
    "name": "Application.CommandBars.GetVisibleMso (Ribbon Control)",
    "category": "Excel VBA 開發與表單",
    "syntax": "isVisible = Application.CommandBars.GetVisibleMso(idMso As String)",
    "description": "傳回一個布林值，指出具有指定 idMso 的 Ribbon 控制項目前是否可見。",
    "parameters": [{"name": "idMso", "description": "必需。Ribbon 控制項的 idMso。"}],
    "examples": [
        {"code": "If Application.CommandBars.GetVisibleMso(\"FormatPainter\") Then\n  MsgBox \"Ribbon上的 '格式刷 (FormatPainter)' 命令目前是可見的。\"\nElse\n  MsgBox \"Ribbon上的 '格式刷 (FormatPainter)' 命令目前是不可見的。\"\nEnd If", "explanation": "檢查 Ribbon 上的「格式刷」命令 (idMso: \"FormatPainter\") 目前是否可見。"}
    ],
    "keywords": ["getvisiblemso", "check ribbon control visible", "ribbon button visibility", "檢查Ribbon按鈕是否可見"]
},
{
    "name": "Application.CommandBars.GetPressedMso (Ribbon Control)",
    "category": "Excel VBA 開發與表單",
    "syntax": "isPressed = Application.CommandBars.GetPressedMso(idMso As String)",
    "description": "傳回一個布林值，指出具有指定 idMso 的 Ribbon 切換按鈕 (toggle button) 目前是否處於按下狀態。",
    "parameters": [{"name": "idMso", "description": "必需。Ribbon 切換按鈕控制項的 idMso。"}],
    "examples": [
        {"code": "' Example for a toggle button like 'Bold'\nIf Application.CommandBars.GetPressedMso(\"Bold\") Then\n  MsgBox \"Ribbon上的 '粗體 (Bold)' 切換按鈕目前處於按下狀態。\"\nElse\n  MsgBox \"Ribbon上的 '粗體 (Bold)' 切換按鈕目前未被按下。\"\nEnd If", "explanation": "檢查 Ribbon 上的「粗體」切換按鈕 (idMso: \"Bold\") 目前是否處於按下狀態。"}
    ],
    "keywords": ["getpressedmso", "check ribbon toggle state", "ribbon button pressed", "檢查Ribbon切換按鈕狀態"]
},
{
    "name": "Collection.Item (Default Member)",
    "category": "陣列、集合與字典",
    "description": "Item 方法是 Collection 物件的預設成員。這意味著您可以省略 `.Item` 而直接使用括號來存取項目，例如 `MyCollection(IndexOrKey)` 等同於 `MyCollection.Item(IndexOrKey)`。",
    "syntax": "value = MyCollection(IndexOrKey)",
    "parameters": [],
    "examples": [
        {"code": "Dim fruits As New Collection\nfruits.Add \"Apple\", \"F1\"\nfruits.Add \"Banana\" ' Index will be 2\n\nDebug.Print \"使用預設成員按鍵: \" & fruits(\"F1\") ' Same as fruits.Item(\"F1\")\nDebug.Print \"使用預設成員按索引: \" & fruits(2)  ' Same as fruits.Item(2)\n\n' This also means you can iterate using index with default member syntax:\nDim i As Long\nFor i = 1 To fruits.Count\n    Debug.Print \"Item \" & i & \": \" & fruits(i)\nNext i", "explanation": "演示如何使用 Collection 的預設成員 Item 來通過鍵或索引存取項目，省略了 `.Item` 的書寫。"}
    ],
    "keywords": ["collection default member", "collection item shortcut", "access collection item without .item", "集合預設成員"]
},
{
    "name": "Dir (Attribute vbDirectory)",
    "category": "檔案與資料夾管理",
    "description": "Dir 函數的第二個引數 `attributes` 可以用來篩選要傳回的檔案或資料夾。使用 `vbDirectory` 常數可以專門檢查或列出資料夾。",
    "syntax": "Dir(PathName, vbDirectory)",
    "parameters": [{"name": "vbDirectory (Constant 16)", "description": "僅傳回符合 PathName 的目錄 (資料夾)。"}],
    "examples": [
        {"code": "Dim folderPath As String: folderPath = \"C:\\Windows\"\nDim subFolderName As String\n\n' Check if a specific subfolder exists\nIf Dir(folderPath & \"\\System32\", vbDirectory) <> \"\" Then\n    Debug.Print \"資料夾 'System32' 存在於 \" & folderPath\nElse\n    Debug.Print \"資料夾 'System32' 不存在於 \" & folderPath\nEnd If\n\n' List all subfolders in folderPath\nDebug.Print \"--- \" & folderPath & \" 中的子資料夾 ---\"\nsubFolderName = Dir(folderPath & \"\\*\", vbDirectory) ' Get first entry\nDo While subFolderName <> \"\"\n    If subFolderName <> \".\" And subFolderName <> \"..\" Then ' Exclude current and parent dir entries\n        If (GetAttr(folderPath & \"\\\" & subFolderName) And vbDirectory) = vbDirectory Then ' Double check it's a directory\n            Debug.Print subFolderName\n        End If\n    End If\n    subFolderName = Dir ' Get next entry\nLoop", "explanation": "第一個範例檢查 C:\\Windows\\System32 資料夾是否存在。第二個範例列出 C:\\Windows 資料夾下的所有直接子資料夾。需要注意 Dir 返回 \".\" 和 \"..\"，並且 GetAttr 用於確認項目確實是目錄。"}
    ],
    "keywords": ["dir vbdirectory", "list subfolders vba", "check if folder exists dir", "列出子資料夾", "檢查資料夾存在"]
},
{
    "name": "CreateObject(\"WScript.Network\")",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "建立一個 WScript.Network 物件，它提供了存取網路上共用資源的功能，例如映射網路磁碟機、新增印表機連線，以及獲取使用者、電腦和網域資訊。",
    "syntax": "Set oNet = CreateObject(\"WScript.Network\")",
    "parameters": [
        {"name": ".UserName", "description": "屬性：傳回目前登入使用者的名稱。"},
        {"name": ".UserDomain", "description": "屬性：傳回使用者所屬的網域名稱。"},
        {"name": ".ComputerName", "description": "屬性：傳回電腦的名稱。"},
        {"name": ".MapNetworkDrive LocalName, RemoteName, [UpdateProfile], [UserName], [Password]", "description": "方法：將共用網路磁碟機映射到本機磁碟機代號。"},
        {"name": ".RemoveNetworkDrive Drive, [Force], [UpdateProfile]", "description": "方法：移除網路磁碟機映射。"},
        {"name": ".AddPrinterConnection LocalName, RemoteName, [UpdateProfile], [UserName], [Password]", "description": "方法：新增網路印表機連線。"},
        {"name": ".RemovePrinterConnection Name, [Force], [UpdateProfile]", "description": "方法：移除網路印表機連線。"},
        {"name": ".SetDefaultPrinter PrinterName", "description": "方法：設定預設印表機。"}
    ],
    "examples": [
        {"code": "Dim oNet As Object\nSet oNet = CreateObject(\"WScript.Network\")\nMsgBox \"使用者名稱: \" & oNet.UserName & vbCrLf & _\n       \"網域名稱: \" & oNet.UserDomain & vbCrLf & _\n       \"電腦名稱: \" & oNet.ComputerName\n\n' Example: Map a network drive (use with caution, ensure path and credentials are correct)\n' On Error Resume Next\n' oNet.MapNetworkDrive \"Z:\", \"\\\\ServerName\\ShareName\", False ' False for not updating profile\n' If Err.Number = 0 Then\n'   MsgBox \"網路磁碟機 Z: 已映射到 \\\\ServerName\\ShareName\"\n'   oNet.RemoveNetworkDrive \"Z:\", True ' Remove it, True for force\n' Else\n'   MsgBox \"映射網路磁碟機失敗: \" & Err.Description\n' End If\n' On Error GoTo 0\nSet oNet = Nothing", "explanation": "顯示目前使用者的名稱、網域名稱和電腦名稱。註解部分演示了如何映射然後移除一個網路磁碟機 (需要將 `\\\\ServerName\\ShareName` 替換為實際的網路路徑)。"}
    ],
    "keywords": ["wscript.network", "map network drive vba", "network printer vba", "user domain computer name", "網路物件", "映射網路磁碟"]
},
{
    "name": "Application.FileDialog (msoFileDialogFilePicker)",
    "category": "Excel 核心操作",
    "syntax": "Set fd = Application.FileDialog(msoFileDialogFilePicker)",
    "description": "使用 FileDialog 物件的 msoFileDialogFilePicker 類型來顯示一個對話框，允許使用者選擇一個或多個檔案。",
    "parameters": [
        {"name": "msoFileDialogFilePicker (Constant)", "description": "FileDialog 類型，用於選擇檔案。"},
        {"name": ".AllowMultiSelect", "description": "屬性 (Boolean)：True 允許選擇多個檔案，False (預設) 只允許選擇一個。"},
        {"name": ".Filters.Add Description, Extensions, [Position]", "description": "方法：新增檔案類型篩選器。"},
        {"name": ".InitialFileName", "description": "屬性：設定對話框開啟時的初始路徑或檔名。"},
        {"name": ".SelectedItems", "description": "屬性：傳回一個包含所選檔案完整路徑的字串集合。"}
    ],
    "examples": [
        {"code": "Dim fd As FileDialog, selectedFile As Variant\nSet fd = Application.FileDialog(msoFileDialogFilePicker)\nWith fd\n  .Title = \"請選擇一個或多個Excel檔案\"\n  .AllowMultiSelect = True\n  .Filters.Clear ' Clear existing filters\n  .Filters.Add \"Excel 檔案\", \"*.xlsx; *.xlsm; *.xls\", 1 ' Add Excel filter as first\n  .Filters.Add \"所有檔案\", \"*.*\", 2\n  .InitialFileName = \"C:\\Reports\\\"\n  If .Show = -1 Then ' User clicked OK\n    If .SelectedItems.Count > 0 Then\n      MsgBox .SelectedItems.Count & \" 個檔案被選取:\"\n      For Each selectedFile In .SelectedItems\n        Debug.Print selectedFile\n      Next selectedFile\n    Else\n        MsgBox \"沒有檔案被選取 (這不應該發生如果Show=-1)。\"\n    End If\n  Else\n    MsgBox \"使用者取消了選擇。\"\n  End If\nEnd With\nSet fd = Nothing", "explanation": "顯示一個檔案選擇對話框，設定標題、允許多選、新增檔案類型篩選器 (Excel檔案和所有檔案)，並設定初始目錄。如果使用者選擇了檔案並點擊確定，則列印所有選取檔案的路徑。"}
    ],
    "keywords": ["filedialog filepicker", "select files dialog", "choose files vba", "msofiledialogfilepicker", "檔案選擇器", "選擇多個檔案"]
},
{
    "name": "FileSystemObject.GetParentFolderName (Path with no extension)",
    "category": "檔案與資料夾管理",
    "description": "如果傳遞給 GetParentFolderName 的路徑是一個沒有副檔名的檔案名 (例如 \"C:\\MyFolder\\MyFile\")，FSO 會將其視為一個資料夾，並嘗試傳回其父資料夾 (\"C:\\MyFolder\")。如果路徑本身就是一個資料夾路徑 (例如 \"C:\\MyFolder\\SubFolder\")，它也會正確傳回父資料夾 (\"C:\\MyFolder\")。",
    "syntax": "parentPath = fso.GetParentFolderName(PathSpec)",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nDebug.Print \"Parent of 'C:\\A\\B\\File.txt': \" & fso.GetParentFolderName(\"C:\\A\\B\\File.txt\") ' C:\\A\\B\nDebug.Print \"Parent of 'C:\\A\\B\\Folder': \" & fso.GetParentFolderName(\"C:\\A\\B\\Folder\")   ' C:\\A\\B\nDebug.Print \"Parent of 'C:\\A\\B': \" & fso.GetParentFolderName(\"C:\\A\\B\")           ' C:\\A\nDebug.Print \"Parent of 'C:\\A': \" & fso.GetParentFolderName(\"C:\\A\")             ' C:\\\nDebug.Print \"Parent of 'C:\\': \" & fso.GetParentFolderName(\"C:\\\")               ' C:\\ (root returns itself)\nSet fso = Nothing", "explanation": "演示 GetParentFolderName 對不同類型路徑的行為，包括帶副檔名的檔案、不帶副檔名的名稱 (被視為資料夾) 以及多層資料夾路徑。"}
    ],
    "keywords": ["fso getparentfoldername no extension", "parent directory fso", "獲取父資料夾 (無擴展名)"]
},
{
    "name": "FileSystemObject.FileExists (vs FolderExists for paths)",
    "category": "檔案與資料夾管理",
    "description": "FileExists 方法專門用於檢查指定路徑是否指向一個存在的檔案。FolderExists 方法專門用於檢查指定路徑是否指向一個存在的資料夾。如果用 FileExists 檢查一個資料夾路徑，它會傳回 False，反之亦然。",
    "syntax": "fso.FileExists(FilePath)\nfso.FolderExists(FolderPath)",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nDim testFilePath As String: testFilePath = Environ(\"SystemRoot\") & \"\\System32\\notepad.exe\"\nDim testFolderPath As String: testFolderPath = Environ(\"SystemRoot\") & \"\\System32\"\n\nDebug.Print \"Notepad.exe - FileExists: \" & fso.FileExists(testFilePath) ' True\nDebug.Print \"Notepad.exe - FolderExists: \" & fso.FolderExists(testFilePath) ' False\n\nDebug.Print \"System32 - FileExists: \" & fso.FileExists(testFolderPath)   ' False\nDebug.Print \"System32 - FolderExists: \" & fso.FolderExists(testFolderPath) ' True\nSet fso = Nothing", "explanation": "演示 FileExists 和 FolderExists 對於已知檔案路徑和資料夾路徑的不同傳回值。"}
    ],
    "keywords": ["fso fileexists vs folderexists", "check if path is file or folder", "區分檔案與資料夾存在"]
},
{
    "name": "Name Statement (Moving Files across Directories on Same Drive)",
    "category": "檔案與資料夾管理",
    "description": "VBA 的 Name 陳述式不僅可以用於重命名同一目錄下的檔案，還可以用於將檔案移動到同一磁碟機上的不同目錄中，同時可以重命名它。如果新舊路徑跨越不同磁碟機，則 Name 會產生錯誤。",
    "syntax": "Name OldPathAndFileName As NewPathAndFileName",
    "parameters": [],
    "examples": [
        {"code": "Dim oldPath As String, newPath As String\noldPath = \"C:\\Temp\\OriginalFile.txt\"\nnewPath = \"C:\\Temp\\Archive\\MovedAndRenamedFile.txt\"\n' Ensure OriginalFile.txt exists and C:\\Temp\\Archive folder exists for this to work\n' On Error Resume Next\n' ' Create dummy file and folder for testing\n' ' CreateObject(\"Scripting.FileSystemObject\").CreateTextFile oldPath, True\n' ' If Not CreateObject(\"Scripting.FileSystemObject\").FolderExists(\"C:\\Temp\\Archive\") Then\n' '   CreateObject(\"Scripting.FileSystemObject\").CreateFolder \"C:\\Temp\\Archive\"\n' ' End If\n'\n' Name oldPath As newPath\n' If Err.Number = 0 Then\n'   MsgBox \"檔案已成功從 '\" & oldPath & \"' 移動並重命名為 '\" & newPath & \"'.\"\n' Else\n'   MsgBox \"移動/重命名檔案失敗。錯誤: \" & Err.Description & vbCrLf & \"(確保源檔案存在，目標資料夾存在，且在同一磁碟機)。\"\n' End If\n' On Error GoTo 0", "explanation": "演示如何使用 Name 陳述式將 C:\\Temp\\OriginalFile.txt 移動到 C:\\Temp\\Archive\\ 資料夾並同時將其重命名為 MovedAndRenamedFile.txt。此操作僅限於同一磁碟機內。"}
    ],
    "keywords": ["name statement move file", "vba move file same drive", "rename and move file", "Name移動檔案"]
},
{
    "name": "Range.Font.ColorIndex (vs .Color)",
    "category": "Excel 核心操作",
    "description": "Range.Font.ColorIndex 設定字型顏色為 Excel 內建調色盤中的一個索引顏色 (通常是1到56)。Range.Font.Color 設定字型顏色為一個 RGB 長整數值。使用 .Color 可以獲得更廣泛的顏色選擇。如果同時設定了兩者，.Color 的設定通常會覆蓋 .ColorIndex。如果 .ColorIndex 設為 xlColorIndexAutomatic (-4105)，則使用自動顏色；設為 xlColorIndexNone (-4142) 則表示無顏色 (透明，不常用於字型)。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = \"ColorIndex Test\"\nRange(\"A1\").Font.ColorIndex = 3 ' Red from palette\nMsgBox \"A1 字型顏色設為索引 3 (紅色)。\"\n\nRange(\"A2\").Value = \"RGB Color Test\"\nRange(\"A2\").Font.Color = RGB(0, 128, 0) ' Dark Green\nMsgBox \"A2 字型顏色設為 RGB 深綠色。\"\n\nRange(\"A3\").Value = \"ColorIndex then RGB\"\nRange(\"A3\").Font.ColorIndex = 5 ' Blue from palette\nRange(\"A3\").Font.Color = RGB(255, 165, 0) ' Orange (This will override ColorIndex)\nMsgBox \"A3 先設 ColorIndex 為藍色，再設 Color 為橘色。最終應為橘色。\"", "explanation": "演示使用 ColorIndex 和 Color 屬性設定字型顏色，並說明 Color 屬性通常會覆蓋 ColorIndex 的設定。"}
    ],
    "keywords": ["font.colorindex", "font.color", "excel font color rgb vs index", "字型顏色索引與RGB"]
},
{
    "name": "Range.Interior.ColorIndex (vs .Color)",
    "category": "Excel 核心操作",
    "description": "與字型顏色類似，Range.Interior.ColorIndex 設定儲存格背景填充色為調色盤索引顏色，而 Range.Interior.Color 設定為 RGB 值。如果同時設定，.Color 的設定會覆蓋 .ColorIndex。xlColorIndexNone (-4142) 表示無填充。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"B1\").Interior.ColorIndex = 6 ' Yellow from palette\nMsgBox \"B1 背景顏色設為索引 6 (黃色)。\"\n\nRange(\"B2\").Interior.Color = RGB(173, 216, 230) ' Light Blue\nMsgBox \"B2 背景顏色設為 RGB 淺藍色。\"\n\nRange(\"B3\").Interior.Pattern = xlSolid ' Ensure pattern is solid for ColorIndex to show clearly\nRange(\"B3\").Interior.ColorIndex = xlColorIndexNone ' No fill\nMsgBox \"B3 背景已設為無填充。\"", "explanation": "演示使用 ColorIndex 和 Color 設定儲存格背景色，以及如何使用 xlColorIndexNone 移除填充。"}
    ],
    "keywords": ["interior.colorindex", "interior.color", "excel cell background color", "儲存格背景色索引與RGB"]
},
{
    "name": "WorksheetFunction (Error Handling)",
    "category": "Excel 核心操作",
    "description": "當從 VBA 中呼叫 Application.WorksheetFunction 的函數時，如果該函數在工作表上會傳回錯誤值 (例如，VLOOKUP 找不到值會傳回 #N/A)，則在 VBA 中它會觸發一個執行階段錯誤 (通常是錯誤 1004)。因此，在使用這些函數時，需要使用 `On Error Resume Next` 或 `On Error GoTo Label` 來處理潛在的錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Dim lookupValue As String: lookupValue = \"NonExistentProduct\"\nDim dataTable As Range: Set dataTable = Range(\"A1:B5\") ' Assume A1:B5 is lookup table\nDim result As Variant\n\nOn Error Resume Next ' Enable error trapping for WorksheetFunction\nresult = Application.WorksheetFunction.VLookup(lookupValue, dataTable, 2, False)\nIf Err.Number <> 0 Then\n  MsgBox \"VLOOKUP 錯誤: \" & Err.Description & \" (錯誤號: \" & Err.Number & \")\" & vbCrLf & _\n         \"可能是因為值 '\" & lookupValue & \"' 未在範圍 \" & dataTable.Address & \" 中找到。\"\n  result = \"[未找到]\" ' Assign a default value or handle error\n  Err.Clear ' Clear the error object\nElse\n  MsgBox \"VLOOKUP 結果: \" & result\nEnd If\nOn Error GoTo 0 ' Disable error trapping\nDebug.Print \"最終結果: \" & result", "explanation": "嘗試使用 VLOOKUP 查找一個不存在的值。如果 VLOOKUP 失敗並產生錯誤 (例如錯誤 1004)，On Error Resume Next 會捕獲它，然後可以檢查 Err.Number 並相應地處理。"}
    ],
    "keywords": ["worksheetfunction error handling", "vba vlookup error", "application.worksheetfunction error 1004", "工作表函數錯誤處理"]
},
{
    "name": "Name Object (Scope: Workbook vs Worksheet)",
    "category": "Excel 核心操作",
    "description": "已定義名稱 (Named Ranges) 可以有兩種範圍：\n1. **活頁簿範圍 (Workbook Scope)**：名稱在整個活頁簿中唯一且可用。透過 `ThisWorkbook.Names.Add` 或在名稱管理員中直接建立。在公式中可以直接使用名稱，例如 `=SalesTotal`。\n2. **工作表範圍 (Worksheet Scope)**：名稱僅在定義它的特定工作表中直接可用，在其他工作表中引用時需要加上工作表名稱前綴 (例如，`=Sheet1!MySheetLevelName`)。透過 `WorksheetObject.Names.Add` 建立。工作表範圍的名稱在其工作表內優先於同名的活頁簿範圍名稱。",
    "parameters": [],
    "examples": [
        {"code": "' Workbook-level name\nOn Error Resume Next ' In case it already exists\nThisWorkbook.Names.Add Name:=\"GlobalTaxRate\", RefersTo:=\"=0.075\"\nIf Err.Number <> 0 Then ThisWorkbook.Names(\"GlobalTaxRate\").RefersTo = \"=0.075\"\nErr.Clear\n\n' Worksheet-level name for Sheet1\nDim ws1 As Worksheet: Set ws1 = ThisWorkbook.Sheets(\"Sheet1\")\nws1.Names.Add Name:=\"Sheet1LocalData\", RefersToR1C1:=\"=Sheet1!R1C1:R5C3\"\nIf Err.Number <> 0 Then ws1.Names(\"Sheet1LocalData\").RefersToR1C1 = \"=Sheet1!R1C1:R5C3\"\nErr.Clear\nOn Error GoTo 0\n\nMsgBox \"全域稅率: \" & [GlobalTaxRate]\nMsgBox \"Sheet1 本地資料範圍位址 (在Sheet1上可直接用 [Sheet1LocalData]): \" & ws1.Range(\"Sheet1LocalData\").Address\n' From another sheet, Sheet1LocalData would be referenced as [Sheet1!Sheet1LocalData]\n\n' If Sheet1 also had a name \"GlobalTaxRate\", on Sheet1, [GlobalTaxRate] would refer to Sheet1's version.", "explanation": "演示如何建立一個活頁簿範圍的名稱 (\"GlobalTaxRate\") 和一個工作表範圍的名稱 (\"Sheet1LocalData\" on Sheet1)。並解釋了它們的引用方式和優先級。"}
    ],
    "keywords": ["named range scope", "workbook vs worksheet name", "global vs local named range", "名稱範圍"]
},
{
    "name": "CommandBars(\"Cell\").Reset (Excel Context Menu)",
    "category": "Excel VBA 開發與表單",
    "description": "重設指定的內建命令列 (例如儲存格右鍵捷徑功能表) 回其預設設定。這會移除任何透過 VBA 或增益集對該命令列所做的自訂 (例如，新增的按鈕)。",
    "syntax": "Application.CommandBars(CommandBarNameOrIndex).Reset",
    "parameters": [{"name": "CommandBarNameOrIndex", "description": "命令列的名稱 (例如 \"Cell\", \"Row\", \"Column\") 或索引。"}],
    "examples": [
        {"code": "' First, add a custom button (see CommandBars.ExecuteMso example for adding)\n' Sub AddButtonToCellMenu()\n'    Application.CommandBars(\"Cell\").Controls.Add Type:=msoControlButton, Before:=1, ID:=295 ' Example ID\n' End Sub\n' Call AddButtonToCellMenu ' Call this once to add a button\n\n' Now, reset the Cell context menu\nIf MsgBox(\"是否要重設儲存格右鍵選單回預設狀態？這會移除所有自訂按鈕。\", vbYesNo + vbQuestion) = vbYes Then\n  Application.CommandBars(\"Cell\").Reset\n  MsgBox \"儲存格右鍵選單已重設。\"\nEnd If", "explanation": "提示使用者是否要重設儲存格的右鍵捷徑功能表。如果選擇是，則會移除所有對該捷徑功能表的自訂，包括透過 VBA 新增的按鈕。"}
    ],
    "keywords": ["reset commandbar", "excel context menu reset", "default right click menu", "重設命令列", "還原捷徑功能表"]
},
{
    "name": "WScript.Shell RegRead / RegWrite / RegDelete (Registry)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "WScript.Shell 物件提供了直接讀取、寫入和刪除 Windows 登錄檔機碼和值的方法。這比 GetSetting/SaveSetting 提供了更廣泛的登錄檔存取能力 (例如，可以存取 HKEY_LOCAL_MACHINE 或處理不同的資料類型)，但需要更小心操作。",
    "syntax": "value = wshShell.RegRead(Name)\nwshShell.RegWrite Name, Value, [Type]\nwshShell.RegDelete Name",
    "parameters": [
        {"name": "Name (RegRead/RegWrite/RegDelete)", "description": "必需。登錄檔機碼或值的完整路徑 (例如 \"HKCU\\Software\\MyCompany\\MyApp\\Setting1\")。對於 RegRead 預設值，以反斜線結尾。"},
        {"name": "Value (RegWrite)", "description": "必需。要寫入的值。"},
        {"name": "Type (RegWrite)", "description": "可選。要寫入的資料類型 (例如 \"REG_SZ\", \"REG_DWORD\", \"REG_BINARY\", \"REG_EXPAND_SZ\")。"}
    ],
    "examples": [
        {"code": "Dim wshShell As Object, regPath As String, regVal As Variant\nSet wshShell = CreateObject(\"WScript.Shell\")\nregPath = \"HKCU\\Software\\VB and VBA Program Settings\\MyVBAApp\\TestSettings\\\"\n\n' Write a string value\nOn Error Resume Next\nwshShell.RegWrite regPath & \"UserPreference\", \"DarkMode\", \"REG_SZ\"\nIf Err.Number <> 0 Then Debug.Print \"寫入登錄檔失敗: \" & Err.Description: GoTo ReadSection\nDebug.Print \"已寫入登錄檔: \" & regPath & \"UserPreference = DarkMode\"\nErr.Clear\n\n' Write a DWORD value\nwshShell.RegWrite regPath & \"MaxItems\", 100, \"REG_DWORD\"\nDebug.Print \"已寫入登錄檔: \" & regPath & \"MaxItems = 100\"\nErr.Clear\n\nReadSection:\n' Read the string value\nregVal = wshShell.RegRead(regPath & \"UserPreference\")\nDebug.Print \"讀取 UserPreference: \" & regVal\nErr.Clear\n\n' Read the DWORD value\nregVal = wshShell.RegRead(regPath & \"MaxItems\")\nDebug.Print \"讀取 MaxItems: \" & regVal\nErr.Clear\n\n' Delete a value\n' wshShell.RegDelete regPath & \"UserPreference\"\n' Debug.Print \"已刪除 UserPreference\"\n' Delete a key (and all its values/subkeys) - use with extreme caution!\n' wshShell.RegDelete regPath ' This deletes TestSettings key and MaxItems under it\n' Debug.Print \"已刪除機碼: \" & regPath\nOn Error GoTo 0\nSet wshShell = Nothing\nMsgBox \"登錄檔操作範例已執行 (部分結果在立即視窗)。\"", "explanation": "演示如何使用 WScript.Shell 的 RegWrite 方法寫入字串 (REG_SZ) 和 DWORD (REG_DWORD) 類型的登錄檔值到 `HKCU\\Software\\VB and VBA Program Settings\\MyVBAApp\\TestSettings\\` 路徑下，然後使用 RegRead 讀取它們。註解部分顯示了如何使用 RegDelete 刪除值或整個機碼。**操作登錄檔具有風險，請務必小心。**"}
    ],
    "keywords": ["wscript.shell registry", "regread", "regwrite", "regdelete", "vba access registry", "讀寫登錄檔 (WSH)"]
},
{
    "name": "FileSystemObject.GetSpecialFolder (More Folders)",
    "category": "檔案與資料夾管理",
    "description": "GetSpecialFolder 方法可以傳回多種 Windows 特殊資料夾的 Folder 物件。除了 WindowsFolder (0), SystemFolder (1), TemporaryFolder (2) 之外，還有一些可以通過字串名稱來存取 (雖然不直接是 GetSpecialFolder 的參數，但 WScript.Shell.SpecialFolders 支援這些)：\n\"AllUsersDesktop\", \"AllUsersStartMenu\", \"AllUsersPrograms\", \"AllUsersStartup\", \"Desktop\", \"Favorites\", \"Fonts\", \"MyDocuments\", \"NetHood\", \"PrintHood\", \"Programs\", \"Recent\", \"SendTo\", \"StartMenu\", \"Startup\", \"Templates\"。",
    "syntax": "Set fldr = fso.GetSpecialFolder(FolderSpecConstant) ' For 0,1,2\n' folderPath = CreateObject(\"WScript.Shell\").SpecialFolders(\"FolderNameString\") ' For others",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, wsh As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet wsh = CreateObject(\"WScript.Shell\")\n\nDebug.Print \"Windows Folder (FSO): \" & fso.GetSpecialFolder(0).Path ' WindowsFolder\nDebug.Print \"System Folder (FSO): \" & fso.GetSpecialFolder(1).Path  ' SystemFolder\nDebug.Print \"Temp Folder (FSO): \" & fso.GetSpecialFolder(2).Path   ' TemporaryFolder\n\nDebug.Print \"--- Using WScript.Shell.SpecialFolders ---\"\nDebug.Print \"My Documents: \" & wsh.SpecialFolders(\"MyDocuments\")\nDebug.Print \"Desktop: \" & wsh.SpecialFolders(\"Desktop\")\nDebug.Print \"Application Data: \" & wsh.SpecialFolders(\"AppData\")\nDebug.Print \"Favorites: \" & wsh.SpecialFolders(\"Favorites\")\nDebug.Print \"Startup Folder: \" & wsh.SpecialFolders(\"Startup\")\nDebug.Print \"Templates Folder: \" & wsh.SpecialFolders(\"Templates\")\n\nSet fso = Nothing: Set wsh = Nothing", "explanation": "演示使用 FileSystemObject.GetSpecialFolder 獲取 Windows、System 和 Temp 資料夾路徑。然後使用 WScript.Shell.SpecialFolders 屬性獲取更多其他特殊資料夾的路徑，如「我的文件」、「桌面」、「應用程式資料」等。"}
    ],
    "keywords": ["getspecialfolder more", "wscript.shell specialfolders list", "windows system folders", "更多特殊資料夾"]
},
{
    "name": "ShellExecute (Open vs Explore vs Print)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ShellExecute API 的 `lpOperation` 參數可以指定不同的操作：\n\"open\": 開啟檔案或執行程式。對於文件，會使用其預設關聯程式開啟。\n\"explore\": 開啟檔案總管並定位到指定的檔案或資料夾。\n\"print\": 列印指定的檔案 (使用其預設列印處理常式)。\n\"edit\": 開啟檔案進行編輯 (如果應用程式支援)。\n如果為 vbNullString 或省略，則通常執行預設操作 (通常是 \"open\")。",
    "syntax": "ShellExecute(hWnd, Operation, File, Parameters, Directory, ShowCmd)",
    "parameters": [],
    "examples": [
        {"code": "#If VBA7 Then\n  Private Declare PtrSafe Function ShellExecute Lib \"shell32.dll\" Alias \"ShellExecuteA\" (ByVal hwnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As LongPtr\n#Else\n  Private Declare Function ShellExecute Lib \"shell32.dll\" Alias \"ShellExecuteA\" (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long\n#End If\nConst SW_SHOWNORMAL As Long = 1\n\nSub TestShellExecuteOperations()\n    Dim filePath As String: filePath = \"C:\\Temp\\MyTestDoc.txt\" ' Create this file for testing\n    ' If Not CreateObject(\"Scripting.FileSystemObject\").FileExists(filePath) Then CreateObject(\"Scripting.FileSystemObject\").CreateTextFile filePath\n\n    ' 1. Open the file (default program)\n    ShellExecute 0, \"open\", filePath, vbNullString, vbNullString, SW_SHOWNORMAL\n    MsgBox filePath & \" 已嘗試用預設程式開啟。\"\n    Application.Wait Now + TimeValue(\"00:00:02\")\n\n    ' 2. Explore the folder containing the file\n    ShellExecute 0, \"explore\", \"C:\\Temp\\\", vbNullString, vbNullString, SW_SHOWNORMAL\n    MsgBox \"C:\\Temp\\ 資料夾已在檔案總管中開啟。\"\n    Application.Wait Now + TimeValue(\"00:00:02\")\n\n    ' 3. Print the file (sends to default printer)\n    ' ShellExecute 0, \"print\", filePath, vbNullString, vbNullString, 0 ' 0 = SW_HIDE for background print\n    ' MsgBox filePath & \" 已嘗試傳送至預設印表機。\"\nEnd Sub", "explanation": "演示如何使用 ShellExecute API 執行三種不同的操作：\"open\" (開啟檔案)，\"explore\" (瀏覽資料夾)，以及 \"print\" (列印檔案，此處註解掉以防實際列印)。"}
    ],
    "keywords": ["shellexecute operations", "open file api", "explore folder api", "print file api", "ShellExecute操作"]
},
{
    "name": "InternetExplorer.Application (DocumentComplete Event)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "InternetExplorer.Application 物件有一個 DocumentComplete 事件，當網頁 (或框架頁面中的框架) 完全載入完成時觸發。這比使用 Busy 屬性和 ReadyState 迴圈等待更可靠，尤其對於包含多個框架或複雜腳本的頁面。",
    "syntax": "Private WithEvents MyIE As InternetExplorer ' In Class Module or UserForm/Sheet module\n...\nPrivate Sub MyIE_DocumentComplete(ByVal pDisp As Object, URL As Variant)\n  ' pDisp is the IDispatch of the window or frame that completed loading\n  ' URL is the URL of the window or frame\n  If pDisp Is MyIE.Application Then ' Check if the top-level document completed\n    ' Page is fully loaded, proceed with actions\n  End If\nEnd Sub",
    "parameters": [],
    "examples": [
        {"code": "' --- This code requires a Class Module named 'IEEventHandler' ---\n' --- In Class Module 'IEEventHandler': ---\n' Public WithEvents WebBrowser As InternetExplorer ' Changed from MyIE for clarity\n' Public PageLoaded As Boolean ' Flag to indicate page load completion\n'\n' Private Sub WebBrowser_DocumentComplete(ByVal pDisp As Object, URL As Variant)\n'   If pDisp Is WebBrowser.Application Then ' Top-level document\n'     Debug.Print \"DocumentComplete: Top-level document loaded - \" & URL\n'     PageLoaded = True\n'   Else ' A frame within the document completed\n'     Debug.Print \"DocumentComplete: Frame loaded - \" & URL\n'   End If\n' End Sub\n'\n' --- In a Standard Module: ---\n' Dim ieHandler As IEEventHandler\n' Dim globalIE As InternetExplorer ' To keep IE object alive\n'\n' Sub NavigateAndWaitWithEvent()\n'   Set globalIE = CreateObject(\"InternetExplorer.Application\")\n'   Set ieHandler = New IEEventHandler\n'   Set ieHandler.WebBrowser = globalIE ' Assign the IE instance to the WithEvents variable\n'   ieHandler.PageLoaded = False ' Reset flag\n'\n'   globalIE.Visible = True\n'   globalIE.Navigate \"http://www.example.com\"\n'\n'   Dim timeout As Date: timeout = Now + TimeValue(\"00:00:30\") ' 30 second timeout\n'   Do While Not ieHandler.PageLoaded And Now < timeout\n'     DoEvents ' Allow IE events to process\n'   Loop\n'\n'   If ieHandler.PageLoaded Then\n'     MsgBox \"頁面 '\" & globalIE.LocationURL & \"' 已透過 DocumentComplete 事件確認載入完成。\"\n'     Dim htmlDoc As Object: Set htmlDoc = globalIE.Document\n'     Debug.Print \"標題: \" & htmlDoc.Title\n'   Else\n'     MsgBox \"頁面載入超時或發生錯誤。\"\n'   End If\n'\n'   globalIE.Quit\n'   Set globalIE = Nothing: Set ieHandler = Nothing\n' End Sub", "explanation": "此範例使用一個類別模組 `IEEventHandler` 來處理 Internet Explorer 的 `DocumentComplete` 事件。標準模組中的 `NavigateAndWaitWithEvent` 過程建立 IE 實例和事件處理常式類別的實例，然後導航到一個網頁。它會等待，直到事件處理常式中的 `PageLoaded` 旗標被 `DocumentComplete` 事件設為 True (或超時)。這是一種比迴圈檢查 `Busy` 和 `ReadyState` 更可靠的等待頁面載入的方法。"}
    ],
    "keywords": ["ie documentcomplete event", "wait for page load vba ie", "internet explorer events", "IE載入完成事件"]
},
{
    "name": "ADODB.Connection (State Property)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Connection 物件的 State 屬性傳回一個長整數，指示連接目前是開啟 (adStateOpen = 1) 還是關閉 (adStateClosed = 0)。也可以是其他狀態，如 adStateConnecting (2), adStateExecuting (4), adStateFetching (8)。在嘗試執行命令或關閉連接之前檢查此屬性是個好習慣。",
    "syntax": "currentState = adoConnectionObject.State",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object ' ADODB.Connection\nDim connStr As String: connStr = \"Provider=Microsoft.ACE.OLEDB.12.0;Data Source=C:\\NonExistentDB.accdb;\"\nSet conn = CreateObject(\"ADODB.Connection\")\n\nDebug.Print \"初始狀態: \" & conn.State ' Should be 0 (adStateClosed)\nOn Error Resume Next\nconn.Open connStr\nIf Err.Number <> 0 Then\n  Debug.Print \"連接失敗。錯誤: \" & Err.Description\nEnd If\nDebug.Print \"開啟後狀態: \" & conn.State ' 1 if successful, 0 if failed immediately\n\nIf conn.State = 1 Then ' adStateOpen\n  Debug.Print \"資料庫已成功連接。\"\n  conn.Close\n  Debug.Print \"關閉後狀態: \" & conn.State ' Should be 0\nElse\n  Debug.Print \"資料庫未連接。\"\nEnd If\nOn Error GoTo 0\nSet conn = Nothing", "explanation": "演示如何檢查 ADODB Connection 物件的 State 屬性，以確定連接在不同操作（初始、嘗試開啟、成功開啟後、關閉後）時的狀態。"}
    ],
    "keywords": ["adodb connection state", "adstateopen", "adstateclosed", "check database connection status", "連接狀態ADO"]
},
{
    "name": "ADODB.Recordset (RecordCount with Static/Keyset Cursor)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 RecordCount 屬性僅在資料指標類型 (CursorType) 支援時才傳回準確的記錄總數。對於 `adOpenStatic` (3) 或 `adOpenKeyset` (1) 資料指標，RecordCount 通常會傳回實際的記錄數。但對於預設的 `adOpenForwardOnly` (0) 資料指標，RecordCount 可能傳回 -1 (表示未知) 或僅傳回已提取的記錄數，直到遍歷完所有記錄。如果需要準確的總記錄數且允許額外開銷，應使用支援的資料指標類型。",
    "syntax": "rs.CursorType = adOpenStatic ' Or adOpenKeyset\nrs.Open SQL, Connection\ncount = rs.RecordCount",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object, rs As Object, rsForwardOnly As Object\nDim sql As String: sql = \"SELECT * FROM SomeTable\" ' Assume SomeTable exists\n' Set conn = CreateObject(\"ADODB.Connection\")\n' ' ... conn.Open ...\n\n' ' Using Static cursor for accurate RecordCount\n' Set rs = CreateObject(\"ADODB.Recordset\")\n' rs.CursorType = 3 ' adOpenStatic\n' rs.Open sql, conn\n' If Not rs.EOF Then Debug.Print \"靜態資料指標 RecordCount: \" & rs.RecordCount Else Debug.Print \"靜態資料指標: 無記錄。\"\n' rs.Close\n\n' ' Using default ForwardOnly cursor\n' Set rsForwardOnly = CreateObject(\"ADODB.Recordset\")\n' rsForwardOnly.Open sql, conn\n' Debug.Print \"僅向前資料指標 RecordCount (可能為-1 或已讀取數): \" & rsForwardOnly.RecordCount\n' ' To get count with forward-only, you might need to loop or do SELECT COUNT(*)\n' rsForwardOnly.Close\n' ' conn.Close\n' Set rs = Nothing: Set rsForwardOnly = Nothing: Set conn = Nothing", "explanation": "演示使用靜態資料指標 (adOpenStatic) 時 RecordCount 通常能提供準確的記錄總數，而預設的僅向前資料指標 (adOpenForwardOnly) 的 RecordCount 行為可能不同。"}
    ],
    "keywords": ["adodb recordcount", "cursortype recordcount", "static cursor count", "記錄數ADO"]
},
{
    "name": "ADODB.Command (Parameters.Refresh Method for Stored Procs)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "當使用 ADODB.Command 物件執行預存程序時，如果在設定 `CommandText` (預存程序名稱) 和 `CommandType = adCmdStoredProc` 之後呼叫 `Command.Parameters.Refresh` 方法，ADO 會嘗試從資料來源查詢預存程序的參數資訊，並自動填充 Command 物件的 Parameters 集合。這可以省去手動為每個參數呼叫 `CreateParameter` 和 `Parameters.Append` 的步驟，但會產生一次額外的資料庫往返。",
    "syntax": "cmd.CommandType = adCmdStoredProc\ncmd.CommandText = \"YourStoredProcedureName\"\ncmd.Parameters.Refresh ' ADO queries DB for SP parameters\n' Now cmd.Parameters collection is populated. Set .Value for input params.\ncmd.Parameters(\"@ParamName\").Value = SomeValue",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object, cmd As Object, rs As Object\n' Set conn = CreateObject(\"ADODB.Connection\")\n' ' ... conn.Open \"your_connection_string_to_sql_server_or_other_db_with_sps\" ...\n'\n' Set cmd = CreateObject(\"ADODB.Command\")\n' Set cmd.ActiveConnection = conn\n' cmd.CommandType = 4 ' adCmdStoredProc\n' cmd.CommandText = \"GetOrdersByCustomerID\" ' Assume this SP exists and takes @CustomerID\n'\n' On Error Resume Next\n' cmd.Parameters.Refresh ' Populate parameters automatically from the database\n' If Err.Number <> 0 Then\n'   MsgBox \"Parameters.Refresh 失敗 (可能SP不存在或不支援): \" & Err.Description\n'   GoTo CleanUpCmdExample\n' End If\n' On Error GoTo 0\n'\n' If cmd.Parameters.Count > 0 Then\n'   ' Assume first parameter is @CustomerID (or check by name)\n'   cmd.Parameters(0).Value = \"ALFKI\" ' Set input parameter value (or cmd.Parameters(\"@CustomerID\").Value)\n'   Set rs = cmd.Execute\n'   If Not rs.EOF Then Debug.Print \"找到客戶ALFKI的訂單。第一筆訂單ID: \" & rs.Fields(0).Value Else Debug.Print \"未找到訂單。\"\n'   rs.Close\n' Else\n'   MsgBox \"預存程序似乎沒有參數。\"\n' End If\n'\n' CleanUpCmdExample:\n' ' If Not rs Is Nothing Then If rs.State = 1 Then rs.Close\n' ' Set rs = Nothing: Set cmd = Nothing\n' ' If conn.State = 1 Then conn.Close\n' ' Set conn = Nothing", "explanation": "演示如何設定 ADODB.Command 物件以執行一個名為 \"GetOrdersByCustomerID\" 的預存程序。呼叫 `Parameters.Refresh` 後，ADO 會嘗試從資料庫獲取該預存程序的參數定義，然後您可以為輸入參數賦值並執行命令。此方法對於參數眾多的預存程序可以簡化程式碼。"}
    ],
    "keywords": ["adodb command parameters refresh", "ado stored procedure parameters", "auto populate parameters ado", "自動獲取預存程序參數"]
},
{
    "name": "MSXML2.DOMDocument (setProperty \"SelectionLanguage\" XPath)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "在使用 MSXML2.DOMDocument (特別是較舊版本如 3.0 或未指定版本時，它可能預設為舊的 XSLPattern 查詢語言) 進行 XPath 查詢時，明確設定 \"SelectionLanguage\" 屬性為 \"XPath\" 是個好習慣，以確保 `selectNodes` 和 `selectSingleNode` 方法使用標準的 XPath 語法。",
    "syntax": "xmlDoc.setProperty \"SelectionLanguage\", \"XPath\"",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object ' MSXML2.DOMDocument\nDim books As Object ' IXMLDOMNodeList\nDim xmlString As String\nxmlString = \"<catalog><book id='bk101'><author>Gambardella, Matthew</author><title>XML Developer's Guide</title></book></catalog>\"\n\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\") ' Version 6.0 usually defaults to XPath\nxmlDoc.async = False\nxmlDoc.LoadXML xmlString\n\nIf xmlDoc.parseError.errorCode <> 0 Then\n    MsgBox \"XML 載入錯誤: \" & xmlDoc.parseError.reason\n    Exit Sub\nEnd If\n\n' Explicitly set selection language to XPath (good practice, though often default in 6.0)\nOn Error Resume Next ' setProperty might not be supported or needed in all MSXML versions exactly like this for default behavior\nxmlDoc.setProperty \"SelectionLanguage\", \"XPath\"\nIf Err.Number <> 0 Then Debug.Print \"setProperty SelectionLanguage XPath 失敗或不需要。\"\nErr.Clear\nOn Error GoTo 0\n\nSet books = xmlDoc.selectNodes(\"//book/author\")\nIf Not books Is Nothing Then\n    Debug.Print \"找到 \" & books.Length & \" 個作者。\"\n    If books.Length > 0 Then Debug.Print \"第一個作者: \" & books(0).Text\nElse\n    Debug.Print \"selectNodes 未傳回有效物件。\"\nEnd If\nSet xmlDoc = Nothing: Set books = Nothing", "explanation": "建立一個 DOMDocument 物件，載入 XML 字串，然後在執行 XPath 查詢 (`selectNodes`) 之前，明確地將 \"SelectionLanguage\" 屬性設定為 \"XPath\"。這確保了 XPath 語法的正確解釋，尤其是在與可能預設為不同查詢語言的舊版 MSXML 交互時。對於 MSXML 6.0，這通常是預設行為，但明確設定無害。"}
    ],
    "keywords": ["msxml selectionlanguage xpath", "xml query language", "ensure xpath syntax", "設定XPath查詢語言"]
},
{
    "name": "IXMLDOMNode.transformNode (XSLT Transformation)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "IXMLDOMNode 物件 (通常是 IXMLDOMDocument) 的 transformNode 方法使用 XSLT (Extensible Stylesheet Language Transformations) 樣式表來轉換 XML 節點及其子節點，並傳回包含轉換結果的字串 (通常是 HTML、XML 或純文字)。",
    "syntax": "resultString = xmlNodeOrDoc.transformNode(stylesheetNodeOrDoc As Object)",
    "parameters": [{"name": "stylesheetNodeOrDoc", "description": "必需。一個 IXMLDOMNode，通常是另一個已載入 XSLT 樣式表的 DOMDocument 物件。"}],
    "examples": [
        {"code": "Dim xmlData As Object, xsltStyle As Object ' MSXML2.DOMDocument60\nDim htmlOutput As String\nDim xmlContent As String, xsltContent As String\n\nxmlContent = \"<employees><employee><name>John Doe</name><title>Manager</title></employee>\" & _\n             \"<employee><name>Jane Smith</name><title>Developer</title></employee></employees>\"\nxsltContent = \"<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>\" & _\n              \"<xsl:template match='/'><html><body><h2>Employee List</h2>\" & _\n              \"<table border='1'><xsl:for-each select='employees/employee'><tr>\" & _\n              \"<td><xsl:value-of select='name'/></td><td><xsl:value-of select='title'/></td>\" & _\n              \"</tr></xsl:for-each></table></body></html></xsl:template></xsl:stylesheet>\"\n\nSet xmlData = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlData.async = False\nxmlData.LoadXML xmlContent\n\nSet xsltStyle = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxsltStyle.async = False\nxsltStyle.LoadXML xsltContent\n\nIf xmlData.parseError.errorCode = 0 And xsltStyle.parseError.errorCode = 0 Then\n  htmlOutput = xmlData.transformNode(xsltStyle)\n  Debug.Print \"--- XSLT 轉換結果 (HTML) ---\"\n  Debug.Print htmlOutput\n  ' You could save htmlOutput to a .html file or display in a WebBrowser control\nElse\n  If xmlData.parseError.errorCode <> 0 Then Debug.Print \"XML Data Error: \" & xmlData.parseError.reason\n  If xsltStyle.parseError.errorCode <> 0 Then Debug.Print \"XSLT Style Error: \" & xsltStyle.parseError.reason\nEnd If\nSet xmlData = Nothing: Set xsltStyle = Nothing", "explanation": "建立兩個 DOMDocument 物件：一個用於載入 XML 資料，另一個用於載入 XSLT 樣式表。然後，使用 XML 資料物件的 transformNode 方法，並將 XSLT 樣式表物件作為參數傳入，以將 XML 轉換為 HTML 字串。結果 HTML 會列印到立即視窗。"}
    ],
    "keywords": ["ixmldomnode transformnode", "xslt transformation vba", "xml to html vba", "msxml xslt", "XSLT轉換", "XML轉換HTML"]
},
{
    "name": "DateSerial with Invalid Month/Day (Normalization)",
    "category": "數學、日期與時間",
    "description": "DateSerial 函數會自動正規化無效的月份或日期值。例如，如果月份大於12，則年份會相應增加。如果日期大於該月的最大天數，則月份和可能的年份會增加。",
    "parameters": [],
    "examples": [
        {"code": "Dim invalidDate1 As Date, invalidDate2 As Date, invalidDate3 As Date\n' Month 13 becomes January of next year\ninvalidDate1 = DateSerial(2023, 13, 15) ' Result: 2024-01-15\nDebug.Print \"DateSerial(2023, 13, 15) = \" & Format(invalidDate1, \"yyyy-mm-dd\")\n\n' Day 35 of January becomes February 4th (Jan has 31 days, 35-31=4)\ninvalidDate2 = DateSerial(2023, 1, 35)  ' Result: 2023-02-04\nDebug.Print \"DateSerial(2023, 1, 35) = \" & Format(invalidDate2, \"yyyy-mm-dd\")\n\n' Day 0 of March becomes last day of February\ninvalidDate3 = DateSerial(2023, 3, 0)   ' Result: 2023-02-28 (2023 is not a leap year)\nDebug.Print \"DateSerial(2023, 3, 0) = \" & Format(invalidDate3, \"yyyy-mm-dd\")", "explanation": "演示 DateSerial 函數如何處理超出正常範圍的月份和日期參數，自動將它們調整為有效的日期。"}
    ],
    "keywords": ["dateserial normalization", "invalid date parts", "date calculation overflow", "日期正規化"]
},
{
    "name": "Timer Function (Return Type Single)",
    "category": "數學、日期與時間",
    "description": "Timer 函數傳回一個 Single (單精度浮點數)，表示自午夜以來經過的秒數。由於它是 Single 類型，它可以表示小數秒，提供比僅使用整數秒更高的時間解析度。",
    "parameters": [],
    "examples": [
        {"code": "Dim preciseTime As Single\npreciseTime = Timer\nMsgBox \"自午夜以來已過 \" & preciseTime & \" 秒。\" & vbCrLf & _\n       \"TypeName is: \" & TypeName(preciseTime)", "explanation": "獲取並顯示 Timer 函數的傳回值及其資料類型 (Single)。"}
    ],
    "keywords": ["timer single precision", "fractional seconds vba", "Timer函數精度"]
},
{
    "name": "Shell (Return Value is Task ID - Double)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "VBA 的 Shell 函數在成功啟動一個應用程式時，會傳回一個 Variant(Double)，其中包含該應用程式的任務ID。如果 Shell 函數無法啟動指定的程式，則會產生一個執行階段錯誤 (如果未使用 On Error 處理) 或傳回零 (如果使用了 On Error Resume Next 且啟動失敗)。",
    "parameters": [],
    "examples": [
        {"code": "Dim taskID As Variant\nOn Error Resume Next ' It's good practice to use error handling with Shell\ntaskID = Shell(\"mspaint.exe\", vbNormalFocus) ' Open MS Paint\nIf Err.Number = 0 And Not IsEmpty(taskID) And taskID <> 0 Then\n    Debug.Print \"MS Paint 啟動成功。任務 ID: \" & taskID & \" (類型: \" & TypeName(taskID) & \")\"\n    ' You can use this taskID with AppActivate if needed quickly\n    ' AppActivate taskID\nElse\n    Debug.Print \"啟動 MS Paint 失敗。錯誤: \" & Err.Description & \" (TaskID: \" & taskID & \")\"\nEnd If\nOn Error GoTo 0", "explanation": "啟動小畫家 (mspaint.exe)，並檢查 Shell 函數的傳回值。如果成功，會列印任務ID及其類型 (應為 Double)。"}
    ],
    "keywords": ["shell return value", "task id data type", "vba shell double", "Shell傳回值類型"]
},
{
    "name": "WithEvents (Limitations)",
    "category": "程式流程與結構控制",
    "description": "WithEvents 關鍵字有一些限制：\n1. 只能在類別模組、使用者表單模組或文件/工作表模組中使用，不能在標準模組中使用。\n2. 用 WithEvents 宣告的物件變數必須是模組層級的 (在宣告區宣告，不能在過程內部)。\n3. 不能宣告為陣列。\n4. 不能使用 As New 同時宣告和實例化 (必須分開 Set)。\n5. 物件必須具有可觸發的事件來源介面。",
    "parameters": [],
    "examples": [
        {"code": "' --- In a Class Module 'clsMyTimer' ---\n' Private WithEvents Ticker As TimerObject ' Assume TimerObject is a custom class with a Tick event\n'\n' ' --- NOT ALLOWED in Standard Module directly ---\n' ' Private WithEvents myButton As MSForms.CommandButton ' This would error if in Standard Module\n'\n' Sub ExampleLimitations()\n'   ' Dim WithEvents localVar As Object ' Error: WithEvents only at module level\n'   ' Dim WithEvents objArray(2) As Object ' Error: WithEvents cannot be an array\n'   ' Dim WithEvents newObj As New SomeClass ' Error: Cannot use As New with WithEvents\n'   MsgBox \"WithEvents 有特定的宣告位置和方式限制。\"\n' End Sub", "explanation": "概念性地指出了 WithEvents 使用的一些限制，例如它不能在標準模組的過程內部使用，不能是陣列，也不能與 As New 一起使用。"}
    ],
    "keywords": ["withevents limitations", "vba event variable restrictions", "WithEvents使用限制"]
},
{
    "name": "Name Statement (Error if Different Drives)",
    "category": "檔案與資料夾管理",
    "description": "使用 `Name OldPath As NewPath` 陳述式移動檔案時，如果 OldPath 和 NewPath 指向不同的磁碟機 (例如，從 C:\\ 移到 D:\\)，則會產生執行階段錯誤 75「路徑/檔案存取錯誤」。Name 陳述式只能在同一磁碟機內移動和/或重命名檔案。要跨磁碟機移動檔案，應使用 FileCopy 然後 Kill，或 FileSystemObject.MoveFile。",
    "parameters": [],
    "examples": [
        {"code": "Dim sourceFile As String, destFileOnDifferentDrive As String\nsourceFile = \"C:\\Temp\\TestForName.txt\"\ndestFileOnDifferentDrive = \"D:\\Temp\\TestForNameMoved.txt\" ' Assuming D: exists\n\n' ' Create a dummy source file for testing\n' On Error Resume Next\n' CreateObject(\"Scripting.FileSystemObject\").CreateTextFile sourceFile, True\n' CreateObject(\"Scripting.FileSystemObject\").CreateFolder \"D:\\Temp\"\n' On Error GoTo 0\n\nOn Error Resume Next ' Trap the expected error\nName sourceFile As destFileOnDifferentDrive\nIf Err.Number = 75 Then\n  MsgBox \"使用 Name 陳述式跨磁碟機移動檔案失敗 (錯誤 75)，這是預期的。\"\n  ' Alternative: Use FileSystemObject\n  ' Dim fso As Object: Set fso = CreateObject(\"Scripting.FileSystemObject\")\n  ' If fso.FileExists(sourceFile) Then\n  '   fso.MoveFile sourceFile, destFileOnDifferentDrive\n  '   If fso.FileExists(destFileOnDifferentDrive) Then MsgBox \"已使用 FSO.MoveFile 成功跨磁碟機移動。\"\n  ' End If\nElseIf Err.Number = 0 Then\n  MsgBox \"檔案似乎已成功移動 (這不應發生於跨磁碟機)。\"\nElse\n  MsgBox \"發生其他錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\n' ' Clean up dummy file if created\n' ' On Error Resume Next: Kill sourceFile: Kill destFileOnDifferentDrive : On Error GoTo 0", "explanation": "嘗試使用 Name 陳述式將檔案從 C: 磁碟機移動到 D: 磁碟機。這會產生錯誤 75。註解中提示了使用 FileSystemObject.MoveFile 作為跨磁碟機移動的正確方法。"}
    ],
    "keywords": ["name statement different drives", "vba move file across drives", "error 75 path file access", "Name陳述式跨磁碟機錯誤"]
},
{
    "name": "Range.Validation.Delete (Before Adding New)",
    "category": "Excel 核心操作",
    "description": "在為一個範圍新增資料驗證規則之前，如果該範圍可能已存在驗證規則，最好先呼叫 `Range.Validation.Delete`。否則，如果嘗試新增的驗證與現有驗證衝突或類型不同，`Add` 方法可能會失敗或產生非預期的結果。刪除現有驗證可確保一個乾淨的狀態。",
    "syntax": "rangeObject.Validation.Delete\nrangeObject.Validation.Add Type:=..., Formula1:=...",
    "parameters": [],
    "examples": [
        {"code": "With Range(\"A1\").Validation\n    .Delete ' Remove any existing validation first\n    .Add Type:=xlValidateDecimal, _\n         AlertStyle:=xlValidAlertWarning, _\n         Operator:=xlBetween, Formula1:=\"0.5\", Formula2:=\"99.99\"\n    .InputMessage = \"請輸入0.5到99.99之間的小數。\"\n    .ErrorMessage = \"輸入的值必須是0.5到99.99之間的小數。\"\n    .ShowInput = True\n    .ShowError = True\nEnd With\nMsgBox \"儲存格A1的資料驗證已更新 (先刪除舊的)。\"", "explanation": "在為儲存格A1新增小數驗證規則之前，先呼叫 .Delete 方法清除任何可能已存在的驗證規則。"}
    ],
    "keywords": ["validation delete before add", "excel data validation best practice", "clear old validation", "先刪除再新增驗證"]
},
{
    "name": "Range.Phonetics Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set phs = rangeObject.Phonetics",
    "description": "傳回代表範圍中所有 Phonetic 物件的 Phonetics 集合。主要用於日文版 Excel 中的注音假名 (拼音指南) 操作。",
    "parameters": [
        {"name": ".Add(Start, Length, Text)", "description": "方法：新增注音假名到儲存格文字的特定部分。"},
        {"name": ".Delete", "description": "方法：刪除儲存格的所有注音假名。"},
        {"name": ".Item(Index)", "description": "屬性：傳回集合中單個 Phonetic 物件。"},
        {"name": ".Count", "description": "屬性：傳回注音假名物件的數量。"}
    ],
    "examples": [
        {"code": "Dim r As Range\nSet r = Range(\"A1\")\nr.Value = \"日本銀行\"\n' Add phonetic info for the first two characters \"日本\"\nOn Error Resume Next ' Phonetics features may not be enabled/supported in all versions/languages\nr.Phonetics.Add Start:=1, Length:=2, Text:=\"にほん\"\nIf Err.Number = 0 Then\n    r.Phonetic.Visible = True ' Make phonetics visible above text\n    MsgBox \"已為A1儲存格的 '日本' 新增注音 'にほん'。\"\n    Debug.Print \"A1中注音假名數量: \" & r.Phonetics.Count\n    If r.Phonetics.Count > 0 Then Debug.Print \"第一個注音文本: \" & r.Phonetics(1).Text\n    ' r.Phonetics.Delete ' To remove all phonetics from the cell\nElse\n    MsgBox \"無法新增注音假名。錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0", "explanation": "為儲存格A1中的文字 \"日本銀行\" 的前兩個字元 \"日本\" 新增注音假名 \"にほん\"，並使其可見。然後列印該儲存格的注音假名數量和第一個注音的文本。"}
    ],
    "keywords": ["phonetics collection", "add furigana excel", "japanese phonetics vba", "注音假名集合"]
},
{
    "name": "Workbook.ForceFullCalculation Property (Excel 2007+)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.ForceFullCalculation = True | False",
    "description": "設定或傳回一個布林值，指定是否強制在下次重新計算時對活頁簿進行完整計算，而不是僅重新計算相依項。設為 True 可確保所有公式都被計算，但可能會降低效能。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示強制完整計算。"}],
    "examples": [
        {"code": "ThisWorkbook.ForceFullCalculation = True\nMsgBox \"活頁簿 '\" & ThisWorkbook.Name & \"' 已設定為在下次重新計算時執行完整計算。\"\n' ThisWorkbook.Calculate ' Trigger the full recalculation\n' ThisWorkbook.ForceFullCalculation = False ' Reset to default behavior after calculation", "explanation": "將目前活頁簿設定為在下一次執行 `Calculate` 方法或Excel觸發重新計算時，執行一個完整的、不依賴智慧計算引擎的重新計算。"}
    ],
    "keywords": ["forcefullcalculation", "excel full recalculation", "workbook calculation mode", "強制完整計算"]
},
{
    "name": "Range.ListNames Method (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ListNames",
    "description": "將活頁簿中所有非隱藏的已定義名稱貼到指定範圍 (rangeObject 必須是單一儲存格，作為貼上區域的左上角) 開始的工作表區域。它會創建一個兩欄的列表：第一欄是名稱，第二欄是名稱所參照的內容。",
    "parameters": [],
    "examples": [
        {"code": "ThisWorkbook.Names.Add Name:=\"TestRate\", RefersTo:=\"=0.05\"\nThisWorkbook.Names.Add Name:=\"SalesData\", RefersTo:=\"=Sheet1!$A$1:$B$10\"\n' Paste the list of names starting at cell D1 on the active sheet\nRange(\"D1\").ListNames\nMsgBox \"所有非隱藏的已定義名稱及其參照已列在D1開始的區域。\"", "explanation": "先建立兩個已定義名稱，然後使用 ListNames 方法將活頁簿中所有非隱藏的名稱及其參照貼到以D1為起點的區域。"}
    ],
    "keywords": ["listnames", "paste names excel", "list all named ranges", "列出所有名稱"]
},
{
    "name": "Range.Validation.IgnoreBlank Property",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.IgnoreBlank = True | False",
    "description": "如果資料驗證規則忽略空白儲存格，則為 True。讀取/寫入布林值。預設為 True。",
    "parameters": [{"name": "True | False", "description": "True (預設) 表示空白儲存格不會觸發驗證錯誤。False 表示空白儲存格也會根據驗證規則進行檢查。"}],
    "examples": [
        {"code": "With Range(\"A1\").Validation\n  .Delete\n  .Add Type:=xlValidateWholeNumber, Operator:=xlGreater, Formula1:=\"0\"\n  .IgnoreBlank = False ' Blank cells will now be considered invalid if this validation is applied\n  .ErrorMessage = \"此儲存格必須包含一個大於0的數字，且不能為空。\"\nEnd With\nRange(\"A1\").Value = \"\" ' This would trigger validation error if user tried to leave it blank\nMsgBox \"A1的資料驗證已設定為不忽略空白儲存格。\"", "explanation": "為A1儲存格設定資料驗證，要求輸入大於0的整數，並將 IgnoreBlank 設為 False，這樣如果使用者嘗試將儲存格保留為空，也會觸發驗證錯誤。"}
    ],
    "keywords": ["validation ignoreblank", "data validation empty cells", "不忽略空白驗證"]
},
{
    "name": "Range.DirectDependents / .DirectPrecedents (Cross-Sheet)",
    "category": "Excel 核心操作",
    "description": "DirectDependents 和 DirectPrecedents 屬性僅追蹤活動工作表上的相依儲存格。如果相依項或前導項位於不同的工作表或不同的活頁簿，這些屬性將不會在其傳回的 Range 物件中包含這些跨工作表/活頁簿的參照。",
    "parameters": [],
    "examples": [
        {"code": "Sheets(\"Sheet1\").Range(\"A1\").Value = 100\nSheets(\"Sheet2\").Range(\"B1\").Formula = \"=Sheet1!A1 * 2\"\n' Activate Sheet1 to check dependents of Sheet1!A1\nSheets(\"Sheet1\").Activate\nDim depsOnS1A1 As Range\nSet depsOnS1A1 = Range(\"A1\").DirectDependents ' This will NOT find Sheet2!B1\nIf depsOnS1A1 Is Nothing Then\n  Debug.Print \"在Sheet1上，A1沒有直接的本工作表引用儲存格。\"\nElse\n  Debug.Print \"Sheet1!A1 的本工作表直接引用儲存格: \" & depsOnS1A1.Address\nEnd If\n' Activate Sheet2 to check precedents of Sheet2!B1\nSheets(\"Sheet2\").Activate\nDim precsForS2B1 As Range\nSet precsForS2B1 = Range(\"B1\").DirectPrecedents ' This will NOT find Sheet1!A1\nIf precsForS2B1 Is Nothing Then\n  Debug.Print \"在Sheet2上，B1沒有直接的本工作表前導儲存格。\"\nElse\n  Debug.Print \"Sheet2!B1 的本工作表直接前導儲存格: \" & precsForS2B1.Address\nEnd If", "explanation": "演示 DirectDependents 和 DirectPrecedents 只考慮活動工作表上的參照。Sheet2!B1 依賴 Sheet1!A1，但當 Sheet1 為活動工作表時，查詢 A1 的 DirectDependents 不會包含 Sheet2!B1。反之亦然。"}
    ],
    "keywords": ["direct dependents cross sheet", "direct precedents cross sheet", "formula trace limitation", "跨工作表追蹤限制"]
},
// Word Document Processing
{
    "name": "Selection.Information Property (Word)",
    "category": "Word 文件處理",
    "syntax": "infoValue = selectionObject.Information(Type As WdInformation)",
    "description": "傳回有關目前選取範圍的資訊。與 Range.Information 類似，但應用於 Selection 物件。",
    "parameters": [
        {"name": "Type", "description": "必需。WdInformation 常數。"}
    ],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\n' Set sel = Application.Selection\n' MsgBox \"目前選取範圍在第 \" & sel.Information(wdActiveEndPageNumber) & \" 頁。\"\n' MsgBox \"選取範圍是否在表格中: \" & sel.Information(wdWithInTable)", "explanation": "顯示目前選取範圍所在的頁碼，以及選取範圍是否位於表格中。"}
    ],
    "keywords": ["word selection information", "get selection page number", "is selection in table", "選取範圍資訊"]
},
{
    "name": "Document.Styles(IndexOrName).Delete (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Styles(IndexOrName).Delete",
    "description": "從文件中刪除指定的樣式。無法刪除內建樣式。",
    "parameters": [{"name": "IndexOrName", "description": "必需。樣式的索引號或名稱 (字串)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' On Error Resume Next ' Attempt to delete a custom style\n' wdDoc.Styles(\"MyCustomStyle\").Delete\n' If Err.Number = 0 Then\n'   MsgBox \"自訂樣式 'MyCustomStyle' 已被刪除。\"\n' Else\n'   MsgBox \"無法刪除樣式 'MyCustomStyle' (可能是內建樣式或不存在)。 錯誤: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "嘗試刪除一個名為 \"MyCustomStyle\" 的自訂樣式。如果樣式是內建的或不存在，則會失敗。"}
    ],
    "keywords": ["word delete style", "remove custom style", "刪除樣式"]
},
{
    "name": "Style Object Properties (Word - Font, ParagraphFormat)",
    "category": "Word 文件處理",
    "syntax": "styleObject.Font.Name = \"Arial\"\nstyleObject.ParagraphFormat.Alignment = wdAlignParagraphCenter",
    "description": "Style 物件具有 Font 和 ParagraphFormat 屬性，允許您讀取或修改樣式的字元格式和段落格式。",
    "parameters": [],
    "examples": [
        {"code": "Dim normalStyle As Object ' Word.Style\n' Set normalStyle = ActiveDocument.Styles(wdStyleNormal)\n' With normalStyle.Font\n'   .Name = \"Garamond\"\n'   .Size = 12\n' End With\n' With normalStyle.ParagraphFormat\n'   .LineSpacingRule = wdLineSpaceSingle\n'   .SpaceAfter = 6\n' End With\n' ' ActiveDocument.UpdateStyles ' Optional: Update all instances if needed\n' MsgBox \"'Normal' 樣式的字型和段落格式已修改。\"", "explanation": "修改活動文件中 \"Normal\" (標準) 樣式的預設字型和部分段落格式設定。"}
    ],
    "keywords": ["word style font", "word style paragraphformat", "modify style definition", "修改樣式字型段落"]
},
// Outlook Mail & Item Management
{
    "name": "MailItem.SendUsingAccount Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set acc = mailItemObject.SendUsingAccount\nmailItemObject.SendUsingAccount = accountObject",
    "description": "設定或傳回一個 Account 物件，代表用於傳送 MailItem 的帳戶。如果郵件是使用預設帳戶傳送的，則此屬性為 Null。僅當郵件尚未傳送時才可設定。",
    "parameters": [{"name": "accountObject", "description": "Account 物件，指定要使用的傳送帳戶。"}],
    "examples": [
        {"code": "Dim olApp As Object, olMail As Object, olAccount As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olMail = olApp.CreateItem(0)\nolMail.Subject = \"Test Sending Account\"\nolMail.To = \"test@example.com\"\n' Find a specific account to send from (e.g., second configured account)\nIf olApp.Session.Accounts.Count >= 2 Then\n  Set olAccount = olApp.Session.Accounts.Item(2)\n  olMail.SendUsingAccount = olAccount\n  MsgBox \"郵件將嘗試使用帳戶 '\" & olAccount.DisplayName & \"' 傳送。\"\nElseIf olApp.Session.Accounts.Count = 1 Then\n  Set olAccount = olApp.Session.Accounts.Item(1)\n  MsgBox \"只有一個帳戶可用: '\" & olAccount.DisplayName & \"'，郵件將使用它傳送。\"\nElse\n  MsgBox \"Outlook中未設定帳戶。\"\nEnd If\nolMail.Display ' Or .Send", "explanation": "如果 Outlook 中設定了多個帳戶，則嘗試將新郵件設定為使用第二個帳戶傳送。"}
    ],
    "keywords": ["outlook sendusingaccount", "send email from specific account", "multiple outlook accounts", "指定帳戶傳送郵件"]
},
{
    "name": "NameSpace.Accounts Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set accsCollection = olNamespace.Accounts",
    "description": "傳回一個 Accounts 集合物件，代表目前設定檔中定義的所有帳戶。",
    "parameters": [],
    "examples": [
        {"code": "Dim olNS As Object, acc As Object ' Outlook.Account\nSet olNS = CreateObject(\"Outlook.Application\").GetNamespace(\"MAPI\")\nIf olNS.Accounts.Count > 0 Then\n  Debug.Print \"設定檔中的帳戶:\"\n  For Each acc In olNS.Accounts\n    Debug.Print \"  顯示名稱: \" & acc.DisplayName & \", 用戶名: \" & acc.UserName & \", SMTP地址: \" & acc.SmtpAddress\n  Next acc\nElse\n  MsgBox \"此Outlook設定檔中沒有帳戶。\"\nEnd If", "explanation": "遍歷目前 Outlook 設定檔中的所有已設定帳戶，並列印其顯示名稱、用戶名和 SMTP 地址。"}
    ],
    "keywords": ["outlook accounts collection", "list outlook accounts", "get account info", "帳戶集合", "列出Outlook帳戶"]
},
{
    "name": "AppointmentItem.MeetingStatus Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "apptItemObject.MeetingStatus = OlMeetingStatusConstant\nstatus = apptItemObject.MeetingStatus",
    "description": "設定或傳回一個 OlMeetingStatus 常數，表示約會的會議狀態。",
    "parameters": [
        {"name": "OlMeetingStatusConstant", "description": "olNonMeeting (0, 約會), olMeeting (1, 會議), olMeetingAccepted (3, 已接受), olMeetingCanceled (5, 已取消), olMeetingReceived (7, 收到的會議邀請), olMeetingTentative (2, 暫訂接受)。"}
    ],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem\nSet olAppt = CreateObject(\"Outlook.Application\").CreateItem(1) ' olAppointmentItem\nolAppt.Subject = \"專案討論\"\nolAppt.Start = Now + 2\nolAppt.Duration = 30\n' To make it a meeting, add recipients and then typically send\nolAppt.MeetingStatus = 1 ' olMeeting (marks it as a meeting)\nolAppt.Recipients.Add \"attendee@example.com\"\nolAppt.Display\nMsgBox \"約會 '\" & olAppt.Subject & \"' 的會議狀態是: \" & olAppt.MeetingStatus", "explanation": "建立一個約會，將其 MeetingStatus 設為 olMeeting，新增一個收件者，然後顯示它。這使其成為一個會議邀請草稿。"}
    ],
    "keywords": ["outlook meetingstatus", "appointment status", "set as meeting", "會議狀態", "約會類型"]
},
// PowerPoint Presentation Creation
{
    "name": "Slide.Shapes.AddOLEObject (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set oleShape = slideObject.Shapes.AddOLEObject([Left], [Top], [Width], [Height], [ClassName], [FileName], [LinkToFile As MsoTriState = msoFalse], [DisplayAsIcon As MsoTriState = msoFalse], [IconFileName], [IconIndex], [IconLabel])",
    "description": "在投影片上建立一個 OLE 物件 (例如，嵌入的 Excel 工作表、Word 文件)。",
    "parameters": [
        {"name": "ClassName", "description": "可選。要建立的物件的 ProgID (例如 \"Excel.Sheet.12\")。"},
        {"name": "FileName", "description": "可選。如果從檔案建立物件，則為檔案路徑。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, excelChartShape As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, ppLayoutBlank)\n' ' Embed a new Excel Chart\n' Set excelChartShape = pptSlide.Shapes.AddOLEObject(Left:=50, Top:=50, Width:=480, Height:=320, ClassName:=\"Excel.Chart\")\n' If Not excelChartShape Is Nothing Then\n'   MsgBox \"已在投影片上嵌入新的Excel圖表物件。您可以啟用它進行編輯。\"\n'   ' excelChartShape.OLEFormat.Activate ' Or .Verb(VerbIndex:=...) \n' End If", "explanation": "在新投影片上嵌入一個新的 Excel 圖表物件。使用者可以稍後啟用此物件以在 Excel 環境中編輯其資料和格式。"}
    ],
    "keywords": ["powerpoint addoleobject", "embed excel chart ppt", "insert ole object", "嵌入OLE物件PPT"]
},
{
    "name": "Presentation.PrintOut (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "presentationObject.PrintOut([From As Long], [To As Long], [PrintToFile As String], [Copies As Long], [Collate As MsoTriState])",
    "description": "列印指定的簡報或其一部分。",
    "parameters": [
        {"name": "From / To", "description": "可選。要列印的起始和結束投影片編號。"},
        {"name": "Copies", "description": "可選。要列印的份數。"},
        {"name": "PrintToFile", "description": "可選。如果列印到檔案，則為檔案路徑和名稱。"}
    ],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\n' Set pptPres = ActivePresentation\n' ' Print slides 2 to 5, 1 copy\n' On Error Resume Next ' Handle printer errors\n' pptPres.PrintOut From:=2, To:=5, Copies:=1\n' If Err.Number = 0 Then\n'   MsgBox \"投影片 2 到 5 已傳送至印表機。\"\n' Else\n'   MsgBox \"列印失敗: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "列印目前簡報的第2到第5張投影片，共1份。"}
    ],
    "keywords": ["powerpoint print presentation", "print slides", "列印簡報PPT"]
},
// FSO
{
    "name": "Folder.Files Property (FSO - Iteration)",
    "category": "檔案與資料夾管理",
    "syntax": "For Each fileInFolder In folderObject.Files\n  ' Process fileInFolder (which is a File object)\nNext",
    "description": "Folder 物件的 Files 屬性傳回一個 Files 集合，其中包含該資料夾中的所有 File 物件。可以使用 For Each 迴圈來遍歷此集合。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, targetFolder As Object, f As Object ' Scripting.File\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet targetFolder = fso.GetFolder(\"C:\\Windows\\System32\") ' Example\nDebug.Print \"--- \" & targetFolder.Path & \" 中的檔案 (前10個) ---\"\nDim fileCount As Long: fileCount = 0\nFor Each f In targetFolder.Files\n  Debug.Print f.Name & \" (\" & f.Size & \" bytes, Type: \" & f.Type & \")\"\n  fileCount = fileCount + 1\n  If fileCount >= 10 Then Exit For ' Limit output for demo\nNext f\nMsgBox \"已列印前10個檔案資訊 (如果存在)。總檔案數: \" & targetFolder.Files.Count", "explanation": "獲取 C:\\Windows\\System32 資料夾的 Folder 物件，然後遍歷其 Files 集合，列印前10個檔案的名稱、大小和類型。"}
    ],
    "keywords": ["fso folder files collection", "iterate files in folder", "list folder contents", "遍歷資料夾檔案"]
},
{
    "name": "Folder.SubFolders Property (FSO - Iteration)",
    "category": "檔案與資料夾管理",
    "syntax": "For Each subFldr In folderObject.SubFolders\n  ' Process subFldr (which is a Folder object)\nNext",
    "description": "Folder 物件的 SubFolders 屬性傳回一個 Folders 集合，其中包含該資料夾中的所有直接子資料夾。可以使用 For Each 迴圈來遍歷此集合。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, parentFolder As Object, sf As Object ' Scripting.Folder\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet parentFolder = fso.GetFolder(\"C:\\Program Files\") ' Example\nDebug.Print \"--- \" & parentFolder.Path & \" 中的子資料夾 ---\"\nIf parentFolder.SubFolders.Count > 0 Then\n  For Each sf In parentFolder.SubFolders\n    Debug.Print sf.Name & \" (Path: \" & sf.Path & \")\"\n  Next sf\nElse\n  Debug.Print \"(沒有子資料夾)\"\nEnd If", "explanation": "獲取 C:\\Program Files 資料夾的 Folder 物件，然後遍歷其 SubFolders 集合，列印每個子資料夾的名稱和路徑。"}
    ],
    "keywords": ["fso folder subfolders collection", "iterate subfolders", "list subdirectories fso", "遍歷子資料夾"]
},
// String
{
    "name": "vbCrLf (vs vbCr vs vbLf in MsgBox)",
    "category": "字串與文本操作",
    "description": "在 MsgBox 中，vbCrLf (回車+換行) 是在 Windows 上創建新行的標準方式。\n單獨使用 vbCr (回車) 可能只將游標移到行首，後續文字會覆蓋該行。\n單獨使用 vbLf (換行) 在 MsgBox 中通常也能實現換行，但 vbCrLf 更明確。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"Line 1 using vbCrLf.\" & vbCrLf & \"Line 2.\"\nMsgBox \"Line A using vbCr.\" & vbCr & \"Line B (might overwrite A or appear oddly).\"\nMsgBox \"Line X using vbLf.\" & vbLf & \"Line Y (usually works for new line in MsgBox).\"", "explanation": "比較在 MsgBox 中使用 vbCrLf, vbCr, 和 vbLf 進行換行的效果。"}
    ],
    "keywords": ["msgbox newline", "vbcrlf in msgbox", "vbcr", "vblf", "訊息框換行"]
},
// Math
{
    "name": "WorksheetFunction.Round (vs VBA Round)",
    "category": "數學、日期與時間",
    "description": "Application.WorksheetFunction.Round 與 VBA 內建的 Round 函數在處理四捨五入到 .5 的情況時行為可能不同。\nVBA Round 函數使用「四捨六入五取偶」(Banker's Rounding 或 Round-Half-To-Even) 的規則，即如果小數部分是 .5，則向最接近的偶數四捨五入 (例如 Round(2.5) = 2, Round(3.5) = 4)。\nWorksheetFunction.Round 則遵循 Excel 工作表 ROUND 函數的規則，通常是「四捨五入到最接近的數字，小數為 .5 時遠離零」 (例如 ROUND(2.5,0) = 3)。",
    "parameters": [],
    "examples": [
        {"code": "Debug.Print \"VBA Round(2.5) = \" & Round(2.5)   ' Output: 2\nDebug.Print \"VBA Round(3.5) = \" & Round(3.5)   ' Output: 4\nDebug.Print \"VBA Round(2.6) = \" & Round(2.6)   ' Output: 3\n\nDebug.Print \"WSFunc.Round(2.5, 0) = \" & Application.WorksheetFunction.Round(2.5, 0) ' Output: 3\nDebug.Print \"WSFunc.Round(3.5, 0) = \" & Application.WorksheetFunction.Round(3.5, 0) ' Output: 4\nDebug.Print \"WSFunc.Round(2.4, 0) = \" & Application.WorksheetFunction.Round(2.4, 0) ' Output: 2", "explanation": "比較 VBA 內建的 Round 函數和 Excel 工作表函數 Round (透過 WorksheetFunction) 在處理 .5 四捨五入時的不同行為。"}
    ],
    "keywords": ["vba round vs worksheetfunction round", "bankers rounding", "round half to even", "四捨六入五取偶", "Excel Round函數差異"]
},
// Data Types
{
    "name": "VarType (Return Value for Array)",
    "category": "資料類型、轉換與驗證",
    "description": "當 VarType 函數的參數是一個陣列時，其傳回值是 `vbArray` (常數值 8192) 與該陣列元素的 `VarType` 值 (例如 vbInteger, vbString) 的總和。例如，一個整數陣列的 VarType 會是 `vbArray + vbInteger` (8192 + 2 = 8194)。",
    "syntax": "arrayVarType = VarType(ArrayVariable)",
    "parameters": [],
    "examples": [
        {"code": "Dim intArray(5) As Integer\nDim strArray() As String: ReDim strArray(2)\nDim varArray As Variant: varArray = Array(1, \"Two\", Date)\n\nDebug.Print \"VarType of Integer Array: \" & VarType(intArray) & _\n            \" (vbArray + vbInteger = \" & vbArray + vbInteger & \")\"\nDebug.Print \"VarType of String Array: \" & VarType(strArray) & _\n            \" (vbArray + vbString = \" & vbArray + vbString & \")\"\nDebug.Print \"VarType of Variant Array (containing mixed types): \" & VarType(varArray) & _\n            \" (vbArray + vbVariant = \" & vbArray + vbVariant & \")\"", "explanation": "顯示不同類型陣列 (整數陣列、字串陣列、包含不同類型元素的Variant陣列) 的 VarType 傳回值，並說明其是如何由 vbArray 和元素的基本類型常數組合而成的。"}
    ],
    "keywords": ["vartype array", "vbarray constant", "array data type code", "陣列類型代碼"]
},
// Program Flow
{
    "name": "Optional Argument (IsMissing with Non-Variant)",
    "category": "程式流程與結構控制",
    "description": "IsMissing 函數只能用於檢查宣告為 Variant 類型的 Optional 參數是否被省略。如果 Optional 參數被宣告為其他特定資料類型 (例如 `Optional count As Integer`)，則不能使用 IsMissing。對於這類參數，如果呼叫時未提供，它們會自動被賦予其資料類型的預設初始值 (例如，Integer 為 0，String 為 \"\"，Boolean 為 False)。您需要檢查這些預設值來判斷參數是否被「省略」(實際上是被賦予了預設值)。更好的做法是為非 Variant 的 Optional 參數提供明確的預設值。",
    "syntax": "Sub MyProc(Optional num As Integer = -1)\n  If num = -1 Then ' Check against default value\n    ' Parameter was likely omitted\n  End If\nEnd Sub",
    "parameters": [],
    "examples": [
        {"code": "Sub ProcessData(param1 As String, Optional flag As Boolean = False, Optional limit As Long = 100)\n  Debug.Print \"Param1: \" & param1\n  Debug.Print \"Flag: \" & flag ' Will be False if omitted\n  Debug.Print \"Limit: \" & limit ' Will be 100 if omitted\n  If flag = False And limit = 100 Then\n    Debug.Print \"  (Flag and Limit likely used default values or were explicitly set to them)\"\n  End If\nEnd Sub\nSub TestOptionalNonVariant()\n  ProcessData \"Test1\" ' flag=False, limit=100\n  ProcessData \"Test2\", True ' flag=True, limit=100\n  ProcessData \"Test3\", , 50  ' flag=False, limit=50 (Note: need comma placeholder for omitted flag)\n  ProcessData \"Test4\", True, 200\nEnd Sub", "explanation": "演示如何為非 Variant 的 Optional 參數提供預設值，並在過程內部檢查這些值來推斷它們是否被省略 (或者被明確設定為預設值)。"}
    ],
    "keywords": ["optional argument non-variant", "ismissing limitation", "default parameter value", "非Variant可選參數"]
},
// External API
{
    "name": "WScript.Shell.Popup (Advanced MsgBox)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "buttonPressed = wshShell.Popup(Text, [SecondsToWait], [Title], [ButtonsAndIcon])",
    "description": "顯示一個比 VBA 內建 MsgBox 功能更豐富的彈出訊息框。它可以設定自動關閉的秒數，並傳回使用者點擊的按鈕或超時狀態。",
    "parameters": [
        {"name": "Text", "description": "訊息框中顯示的文字。"},
        {"name": "SecondsToWait", "description": "可選。訊息框自動關閉前等待的秒數。0 表示永不自動關閉。"},
        {"name": "Title", "description": "可選。訊息框的標題。"},
        {"name": "ButtonsAndIcon", "description": "可選。一個數字，指定按鈕和圖示的組合 (與 MsgBox 的 Buttons 引數類似，但常數值可能不同)。"}
    ],
    "examples": [
        {"code": "Dim wsh As Object, userChoice As Integer\nSet wsh = CreateObject(\"WScript.Shell\")\n' Button values for wsh.Popup:\n' 0 = OK; 1 = OK, Cancel; 2 = Abort, Retry, Ignore; 3 = Yes, No, Cancel;\n' 4 = Yes, No; 5 = Retry, Cancel.\n' Icon values (add to button value):\n' 16 = Stop Mark; 32 = Question Mark; 48 = Exclamation Mark; 64 = Information Mark.\n' Return values for button pressed:\n' 1=OK, 2=Cancel, 3=Abort, 4=Retry, 5=Ignore, 6=Yes, 7=No. If timed out, returns -1.\n\nuserChoice = wsh.Popup(\"此訊息將在10秒後自動關閉，或者您可以點擊按鈕。\\n是否繼續操作？\", 10, \"自動關閉提示框\", 4 + 32) ' Yes/No buttons + Question icon\n\nSelect Case userChoice\n  Case 6: MsgBox \"使用者選擇了 [是]。\"\n  Case 7: MsgBox \"使用者選擇了 [否]。\"\n  Case -1: MsgBox \"訊息框超時自動關閉。\"\n  Case Else: MsgBox \"使用者關閉了訊息框或點擊了其他按鈕 (如果適用)。\"\nEnd Select\nSet wsh = Nothing", "explanation": "顯示一個 WScript.Shell.Popup 訊息框，包含「是/否」按鈕和一個問題圖示。該訊息框會在10秒後自動關閉，或者在使用者點擊按鈕後關閉。然後根據使用者的選擇或超時狀態顯示不同的訊息。"}
    ],
    "keywords": ["wscript.shell popup", "timed messagebox", "advanced msgbox vba", "自動關閉訊息框", "進階提示框"]
},

{
    "name": "FileSystemObject.GetBaseName (vs GetFileName)",
    "category": "檔案與資料夾管理",
    "description": "GetBaseName 傳回路徑中最後一個元件的基本名稱，不含副檔名。GetFileName 傳回包含副檔名的完整檔案名稱或最後一個資料夾的名稱。",
    "syntax": "baseName = fso.GetBaseName(Path)\nfileName = fso.GetFileName(Path)",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nDim myPath As String: myPath = \"C:\\MyFolder\\MyReport.2023.xlsx\"\nDebug.Print \"Path: \" & myPath\nDebug.Print \"GetBaseName: \" & fso.GetBaseName(myPath) ' Output: MyReport.2023\nDebug.Print \"GetFileName: \" & fso.GetFileName(myPath) ' Output: MyReport.2023.xlsx\n\nDim folderPath As String: folderPath = \"C:\\MyFolder\\SubDir\"\nDebug.Print \"Path: \" & folderPath\nDebug.Print \"GetBaseName (for folder): \" & fso.GetBaseName(folderPath) ' Output: SubDir\nDebug.Print \"GetFileName (for folder): \" & fso.GetFileName(folderPath) ' Output: SubDir\nSet fso = Nothing", "explanation": "演示 GetBaseName 和 GetFileName 對於包含多個點的檔案名稱以及資料夾路徑的行為。GetBaseName 只移除最後一個點及其後的副檔名。對於資料夾，兩者行為相似。"}
    ],
    "keywords": ["fso getbasename", "fso getfilename", "filename vs basename", "檔案基本名與全名"]
},
{
    "name": "Chr(0) vs vbNullChar vs vbNullString",
    "category": "字串與文本操作",
    "description": "Chr(0) 和 vbNullChar 都代表 ASCII/Unicode 值為 0 的空字元。vbNullString 是一個特殊的空字串常量，它指向一個空指標，主要用於 API 呼叫，表示一個空字串，而不是包含空字元的字串。在 VBA 內部比較時，`vbNullString = \"\"` 為 True，但 `vbNullChar = \"\"` 為 False。",
    "parameters": [],
    "examples": [
        {"code": "Debug.Print \"Chr(0) == vbNullChar: \" & (Chr(0) = vbNullChar) ' True\nDebug.Print \"Len(vbNullChar): \" & Len(vbNullChar)       ' 1\nDebug.Print \"Len(vbNullString): \" & Len(vbNullString)   ' 0\nDebug.Print \"vbNullChar = Empty String (\\\"\\\"): \" & (vbNullChar = \"\") ' False\nDebug.Print \"vbNullString = Empty String (\\\"\\\"): \" & (vbNullString = \"\") ' True\n' Debug.Print \"Asc(vbNullString) causes error because it's not a character.\"", "explanation": "比較 Chr(0), vbNullChar 和 vbNullString。vbNullChar 是長度為1的包含空字元的字串，而 vbNullString 是長度為0的空字串指標。"}
    ],
    "keywords": ["chr(0)", "vbnullchar", "vbnullstring", "null character vs empty string", "空字元與空字串"]
},
{
    "name": "WorksheetFunction.Transpose (Array Handling)",
    "category": "陣列、集合與字典",
    "syntax": "transposedArray = Application.WorksheetFunction.Transpose(SourceArrayOrRange)",
    "description": "將陣列或儲存格範圍的行和列進行轉置。如果傳入的是一維陣列，Transpose 會將其轉換為一個二維的單列陣列 (如果原為水平陣列則轉為垂直，如果原已為垂直則可能不變或轉為水平，行為可能不穩定)。如果傳入的是二維陣列，則行和列互換。",
    "parameters": [{"name": "SourceArrayOrRange", "description": "必需。要轉置的陣列或 Range 物件。"}],
    "examples": [
        {"code": "Dim arrHorizontal(1 To 3) As String\narrHorizontal(1) = \"A\": arrHorizontal(2) = \"B\": arrHorizontal(3) = \"C\"\nDim arrVertical As Variant\narrVertical = Application.WorksheetFunction.Transpose(arrHorizontal)\n' arrVertical will be a 2D array (3 Rows, 1 Column): arrVertical(1,1)=\"A\", arrVertical(2,1)=\"B\", ...\nDebug.Print \"Transposed(A,B,C) to vertical: UBound(arrVertical,1)=\" & UBound(arrVertical,1) & \", UBound(arrVertical,2)=\" & UBound(arrVertical,2)\n\nDim arr2D(1 To 2, 1 To 3) As Integer ' 2 rows, 3 cols\narr2D(1,1)=1: arr2D(1,2)=2: arr2D(1,3)=3\narr2D(2,1)=4: arr2D(2,2)=5: arr2D(2,3)=6\nDim transposed2D As Variant\ntransposed2D = Application.WorksheetFunction.Transpose(arr2D)\n' transposed2D will be 3 rows, 2 cols\nDebug.Print \"Transposed 2x3 array to: \" & UBound(transposed2D,1) & \"x\" & UBound(transposed2D,2)", "explanation": "演示如何使用 Transpose 函數轉置一維水平陣列為二維垂直陣列，以及轉置一個二維陣列。"}
    ],
    "keywords": ["transpose array", "worksheetfunction transpose", "swap rows columns array", "陣列轉置"]
},
{
    "name": "DateValue (String to Date Conversion Robustness)",
    "category": "數學、日期與時間",
    "description": "DateValue 函數嘗試將一個表示日期的字串轉換為 Date 資料類型。它能識別多種日期格式，但其識別能力依賴於系統的地區設定。對於不明確的格式 (如 \"01/02/03\")，它會根據系統設定解釋 (例如，可能是月/日/年或日/月/年)。為確保可靠轉換，最好提供明確的日期字串格式，如 \"yyyy-mm-dd\" 或 \"Month dd, yyyy\"。",
    "syntax": "DateValue(DateString)",
    "parameters": [],
    "examples": [
        {"code": "Dim dt1 As Date, dt2 As Date, dt3 As Date\nOn Error Resume Next ' In case a format is totally unrecognizable\ndt1 = DateValue(\"2023-10-26\")\nDebug.Print \"DateValue('2023-10-26'): \" & Format(dt1, \"Long Date\")\ndt2 = DateValue(\"26 October 2023\")\nDebug.Print \"DateValue('26 October 2023'): \" & Format(dt2, \"Long Date\")\n' Ambiguous format, depends on system settings (M/D/Y or D/M/Y)\ndt3 = DateValue(\"01/02/2024\") \nDebug.Print \"DateValue('01/02/2024'): \" & Format(dt3, \"Long Date\") & \" (Interpretation depends on system locale!)\"\nIf Err.Number <> 0 Then Debug.Print \"Error converting '01/02/2024': \" & Err.Description\nOn Error GoTo 0", "explanation": "演示 DateValue 對不同日期字串格式的轉換。對於像 \"01/02/2024\" 這樣不明確的格式，結果會因系統的地區日期設定而異。"}
    ],
    "keywords": ["datevalue string format", "convert string to date robust", "regional settings date", "字串轉日期格式問題"]
},
{
    "name": "CDate (vs DateValue)",
    "category": "資料類型、轉換與驗證",
    "description": "CDate 函數和 DateValue 函數都用於將字串或數字轉換為 Date 資料類型。\nDateValue: 主要用於從字串中提取日期部分，並忽略時間部分 (時間設為午夜 00:00:00)。如果字串只包含時間，DateValue 會產生錯誤。\nCDate: 更通用，可以轉換包含日期、時間或兩者的字串或數字。如果字串只包含時間，CDate 會傳回日期部分為 #12/30/1899# (VBA的日期基准零點) 的日期時間值。",
    "parameters": [],
    "examples": [
        {"code": "Dim strDateOnly As String: strDateOnly = \"2023-11-15\"\nDim strDateTime As String: strDateTime = \"2023-11-15 14:30:00\"\nDim strTimeOnly As String: strTimeOnly = \"10:45 AM\"\n\nDebug.Print \"DateValue from '\" & strDateOnly & \"': \" & DateValue(strDateOnly)\nDebug.Print \"CDate from '\" & strDateOnly & \"': \" & CDate(strDateOnly)\n\nDebug.Print \"DateValue from '\" & strDateTime & \"': \" & DateValue(strDateTime) ' Ignores time\nDebug.Print \"CDate from '\" & strDateTime & \"': \" & CDate(strDateTime) ' Includes time\n\nOn Error Resume Next\nDim dvTime As Date: dvTime = DateValue(strTimeOnly)\nIf Err.Number <> 0 Then Debug.Print \"DateValue from '\" & strTimeOnly & \"' caused error: \" & Err.Description Else Debug.Print \"DateValue from '\" & strTimeOnly & \"': \" & dvTime\nErr.Clear\nOn Error GoTo 0\nDim cdTime As Date: cdTime = CDate(strTimeOnly)\nDebug.Print \"CDate from '\" & strTimeOnly & \"': \" & cdTime & \" (Date part is \" & Format(cdTime, \"yyyy-mm-dd\") & \")\"", "explanation": "比較 CDate 和 DateValue 在處理只包含日期、包含日期和時間、以及只包含時間的字串時的行為。"}
    ],
    "keywords": ["cdate vs datevalue", "string to date time", "convert time string", "CDate與DateValue區別"]
},
{
    "name": "Scripting.Dictionary (Object as Item)",
    "category": "陣列、集合與字典",
    "description": "Scripting.Dictionary 的項目 (Item) 可以是任何資料類型，包括其他物件 (例如，另一個 Dictionary、一個 Collection、一個類別實例，或一個 Excel 物件如 Range 或 Worksheet)。",
    "syntax": "Set dict = CreateObject(\"Scripting.Dictionary\")\nSet innerObject = ...\ndict.Add Key, innerObject",
    "parameters": [],
    "examples": [
        {"code": "Dim mainDict As Object, wsDictValue As Object\nDim personInfo As Object\nSet mainDict = CreateObject(\"Scripting.Dictionary\")\n\n' Example 1: Storing a Worksheet object\nSet wsDictValue = ThisWorkbook.Sheets(1)\nmainDict.Add \"Sheet1Object\", wsDictValue\nIf mainDict.Exists(\"Sheet1Object\") Then\n  Debug.Print \"Stored Sheet1 object. Name: \" & mainDict(\"Sheet1Object\").Name\nEnd If\n\n' Example 2: Storing another Dictionary as an item\nSet personInfo = CreateObject(\"Scripting.Dictionary\")\npersonInfo(\"Name\") = \"John Smith\"\npersonInfo(\"Age\") = 35\nmainDict.Add \"P001\", personInfo\nIf mainDict.Exists(\"P001\") Then\n  Debug.Print \"Person P001's Age: \" & mainDict(\"P001\")(\"Age\")\nEnd If\nSet mainDict = Nothing: Set wsDictValue = Nothing: Set personInfo = Nothing", "explanation": "演示如何在 Scripting.Dictionary 中將一個 Worksheet 物件和另一個 Dictionary 物件作為項目儲存，並如何存取這些巢狀物件的屬性。"}
    ],
    "keywords": ["dictionary object item", "nested dictionary", "store object in dictionary", "字典儲存物件", "巢狀字典"]
},
{
    "name": "TypeName (For Object Type Checking - Generic)",
    "category": "資料類型、轉換與驗證",
    "description": "TypeName(objectVariable) 可以傳回物件變數的實際類別名稱 (字串)。這對於在晚期繫結或處理通用 Object 變數時識別物件類型很有用。例如，它可以傳回 \"Range\", \"Worksheet\", \"MailItem\", \"Document\", \"Collection\", \"Dictionary\" 等。",
    "syntax": "objectClassNameString = TypeName(MyObject)",
    "parameters": [],
    "examples": [
        {"code": "Dim obj1 As Object, obj2 As Object, obj3 As Object\nSet obj1 = ThisWorkbook.Sheets(1).Range(\"A1\")\nSet obj2 = CreateObject(\"Scripting.FileSystemObject\")\nSet obj3 = New Collection\n\nDebug.Print \"obj1 is a: \" & TypeName(obj1) ' Expected: Range\nDebug.Print \"obj2 is a: \" & TypeName(obj2) ' Expected: FileSystemObject\nDebug.Print \"obj3 is a: \" & TypeName(obj3) ' Expected: Collection\n\nIf TypeName(obj1) = \"Range\" Then\n  MsgBox \"obj1 是一個 Excel Range 物件。\"\nEnd If\nSet obj1 = Nothing: Set obj2 = Nothing: Set obj3 = Nothing", "explanation": "為不同類型的物件 (Excel Range, FileSystemObject, Collection) 顯示 TypeName 的傳回值。"}
    ],
    "keywords": ["typename object type", "get object class name", "check object class vba", "識別物件類型"]
},
{
    "name": "GetObject (File Path with Class - Forcing Application)",
    "category": "程式流程與結構控制",
    "description": "GetObject(FilePath, ClassName) 可以用於開啟一個文件並確保它由指定的應用程式類別的實例處理。如果該應用程式已執行且能處理該文件，則可能使用現有實例；否則，可能會啟動一個新實例。如果省略 ClassName，則系統會使用預設關聯程式開啟文件。",
    "syntax": "Set appObj = GetObject(FilePath, ClassName)",
    "parameters": [],
    "examples": [
        {"code": "Dim wdApp As Object, wordDocPath As String\nwordDocPath = \"C:\\Temp\\MyTestDocument.docx\" ' Ensure this file exists\n' If Not CreateObject(\"Scripting.FileSystemObject\").FileExists(wordDocPath) Then\n'   Dim tempDoc As Object: Set tempDoc = CreateObject(\"Word.Application\").Documents.Add\n'   tempDoc.SaveAs2 wordDocPath: tempDoc.Close: tempDoc.Parent.Quit: Set tempDoc = Nothing\n' End If\n\n' Try to open the document with Word.Application specifically\nOn Error Resume Next\nSet wdApp = GetObject(wordDocPath, \"Word.Application\")\nIf Err.Number = 0 And Not wdApp Is Nothing Then\n  MsgBox \"'\" & wordDocPath & \"' 已被 Word.Application 實例開啟/關聯。\"\n  ' wdApp is the Document object in this case, not the Application object if Word was not running\n  ' If Word was already running and opened it, wdApp might be the Application object\n  ' To get the application from the document: wdApp.Parent or wdApp.Application\n  Debug.Print \"GetObject returned TypeName: \" & TypeName(wdApp)\n  If TypeName(wdApp) = \"Document\" Then\n    wdApp.Application.Visible = True\n    ' wdApp.Close False ' Close the document\n    ' If wdApp.Application.Documents.Count = 0 Then wdApp.Application.Quit ' Quit if last doc\n  ElseIf TypeName(wdApp) = \"Application\" Then ' If Word was already running\n    wdApp.Visible = True\n    ' wdApp.Documents(wordDocPath).Close False ' Close specific doc\n    ' If wdApp.Documents.Count = 0 Then wdApp.Quit\n  End If\nElse\n  MsgBox \"使用 GetObject(\"...\", \"Word.Application\") 開啟 '\" & wordDocPath & \"' 失敗。錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\nSet wdApp = Nothing", "explanation": "嘗試使用 GetObject 並明確指定 \"Word.Application\" 作為類別名稱來開啟一個 Word 文件。這有助於確保文件是由 Word 處理的。GetObject 返回的物件類型 (Document 或 Application) 可能因 Word 是否已在執行而異。"}
    ],
    "keywords": ["getobject classname", "open file with specific application", "force application open file", "GetObject指定應用開啟"]
},
{
    "name": "Clipboard Operations (MSForms.DataObject - Advanced)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "除了 Range.Copy/Paste，VBA 可以使用 MSForms.DataObject (需要 Microsoft Forms 2.0 Object Library 引用，或晚期繫結 CreateObject(\"Forms.DataObject.1\")) 來與系統剪貼簿進行更底層的文字互動。它可以將文字放入剪貼簿、從剪貼簿獲取文字，以及檢查剪貼簿內容的格式。",
    "syntax": "Dim clipboard As MSForms.DataObject\nSet clipboard = New MSForms.DataObject ' Early binding\n' OR: Set clipboard = CreateObject(\"Forms.DataObject.1\") ' Late binding\nclipboard.SetText \"Text to copy\"\nclipboard.PutInClipboard\nclipboard.GetFromClipboard\nretrievedText = clipboard.GetText()",
    "parameters": [
        {"name": ".SetText Text, [Format]", "description": "方法：將文字放入資料物件。"},
        {"name": ".PutInClipboard", "description": "方法：將資料物件的內容放入系統剪貼簿。"},
        {"name": ".GetFromClipboard", "description": "方法：從系統剪貼簿獲取內容到資料物件。"},
        {"name": ".GetText([Format])", "description": "方法：從資料物件獲取文字。"},
        {"name": ".GetFormat(Format)", "description": "方法 (Boolean)：檢查資料物件是否包含指定格式的資料。"}
    ],
    "examples": [
        {"code": "Dim dataObj As Object ' MSForms.DataObject\nDim textToCopy As String, copiedText As String\n\nOn Error Resume Next ' Forms.DataObject might not be available on all systems (rare)\nSet dataObj = CreateObject(\"Forms.DataObject.1\")\nIf Err.Number <> 0 Then\n  MsgBox \"無法建立 DataObject。此功能可能不可用。錯誤: \" & Err.Description\n  Exit Sub\nEnd If\nOn Error GoTo 0\n\n' Put text ONTO clipboard\ntextToCopy = \"這是從VBA複製到剪貼簿的文字 - \" & Now\ndataObj.SetText textToCopy\ndataObj.PutInClipboard\nMsgBox \"'\" & textToCopy & \"' 已複製到剪貼簿。您可以貼到記事本試試。\"\n\n' Get text FROM clipboard\ndataObj.GetFromClipboard\nIf dataObj.GetFormat(1) Then ' 1 = vbCFText\n  copiedText = dataObj.GetText(1)\n  MsgBox \"從剪貼簿讀取的文字是: \" & vbCrLf & copiedText\nElse\n  MsgBox \"剪貼簿中沒有文字內容。\"\nEnd If\nSet dataObj = Nothing", "explanation": "演示如何使用 MSForms.DataObject 將文字複製到系統剪貼簿，然後再從剪貼簿讀取文字內容。需要 Microsoft Forms 2.0 Object Library 的引用 (通常隨 Office 安裝) 或使用晚期繫結。"}
    ],
    "keywords": ["msforms.dataobject", "vba clipboard operations", "copy text to clipboard", "get text from clipboard", "剪貼簿操作", "複製貼上文字"]
},
{
    "name": "Application.Build (Distinguish Office Versions)",
    "category": "Excel 核心操作",
    "description": "Application.Build 屬性傳回 Excel 的組建編號 (一個字串，但通常只包含數字)。Application.Version 傳回主要版本號 (例如 \"16.0\")。結合這兩個屬性可以更精確地識別 Office 的更新版本或頻道。例如，Excel 2016、2019 和 Microsoft 365 Excel 的 Application.Version 可能都是 \"16.0\"，但它們的 Application.Build 會不同。",
    "parameters": [],
    "examples": [
        {"code": "Dim excelVersion As String: excelVersion = Application.Version\nDim excelBuild As String: excelBuild = Application.Build\nDim fullVersionInfo As String\n\nfullVersionInfo = \"Excel 版本: \" & excelVersion & \" (組建: \" & excelBuild & \")\"\nMsgBox fullVersionInfo\n\n' Example of checking for a specific build range (conceptual)\n' Dim buildNumberPart As Long\n' On Error Resume Next ' In case Build is not purely numeric or contains other chars\n' buildNumberPart = CLng(Split(excelBuild, \".\")(0)) ' Get main part of build number if dot separated\n' If Err.Number = 0 Then\n'   If excelVersion = \"16.0\" And buildNumberPart >= 10000 Then\n'     Debug.Print \"可能是較新的 Microsoft 365 組建。\"\n'   ElseIf excelVersion = \"16.0\" And buildNumberPart < 10000 Then\n'     Debug.Print \"可能是較舊的 Office 2016/2019 組建。\"\n'   End If\n' End If\n' On Error GoTo 0", "explanation": "顯示 Excel 的版本號和組建編號。註解部分概念性地展示了如何嘗試解析組建編號以區分基於 \"16.0\" 版本的不同 Office 產品 (例如，舊版 Office 2016/2019 與較新的 Microsoft 365 版本)。實際的組建編號判斷邏輯會更複雜。"}
    ],
    "keywords": ["application.build vs application.version", "excel precise version", "office build number", "區分Office版本"]
},
{
    "name": "Workbook.UpdateLink Method (Excel)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.UpdateLink([Name As String], [Type As XlLinkType = xlLinkTypeExcelLinks])",
    "description": "更新活頁簿中的一個連結或所有連結。",
    "parameters": [
        {"name": "Name", "description": "可選。要更新的連結來源檔案的名稱 (字串)。如果省略，則更新所有連結。"},
        {"name": "Type", "description": "可選。XlLinkType 常數，指定要更新的連結類型。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook\nSet wb = ActiveWorkbook\n' Update a specific Excel link\nOn Error Resume Next ' In case link doesn't exist or cannot be updated\nwb.UpdateLink Name:=\"C:\\DataSource\\ExternalData.xlsx\", Type:=xlLinkTypeExcelLinks\nIf Err.Number = 0 Then\n  MsgBox \"已嘗試更新名為 'C:\\DataSource\\ExternalData.xlsx' 的連結。\"\nElse\n  MsgBox \"更新特定連結失敗: \" & Err.Description\nEnd If\nErr.Clear\n\n' Update all Excel links in the workbook\nwb.UpdateLink Type:=xlLinkTypeExcelLinks\nMsgBox \"已嘗試更新活頁簿中的所有 Excel 連結。\"\nOn Error GoTo 0", "explanation": "演示如何更新活頁簿中特定的外部 Excel 檔案連結，以及如何更新所有 Excel 連結。"}
    ],
    "keywords": ["updatelink", "excel refresh external links", "update data connections", "更新連結", "刷新外部資料"]
},
{
    "name": "Workbook.LinkSources Method (Excel)",
    "category": "Excel 核心操作",
    "syntax": "linkSourcesArray = workbookObject.LinkSources([Type As XlLinkType = xlLinkTypeExcelLinks])",
    "description": "傳回一個包含活頁簿中指定類型連結來源名稱的 Variant 陣列。如果沒有指定類型的連結，則傳回 Empty。",
    "parameters": [
        {"name": "Type", "description": "可選。XlLinkType 常數，指定要列出的連結類型。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook\nDim excelLinks As Variant, oleLinks As Variant\nSet wb = ThisWorkbook\n\nexcelLinks = wb.LinkSources(xlLinkTypeExcelLinks)\nIf Not IsEmpty(excelLinks) Then\n  Debug.Print \"--- Excel 連結來源 ---\"\n  Dim i As Long\n  For i = LBound(excelLinks) To UBound(excelLinks)\n    Debug.Print excelLinks(i)\n  Next i\nElse\n  Debug.Print \"此活頁簿沒有外部 Excel 連結。\"\nEnd If\n\noleLinks = wb.LinkSources(xlLinkTypeOLELinks)\nIf Not IsEmpty(oleLinks) Then\n  Debug.Print \"--- OLE 連結來源 ---\"\n  For i = LBound(oleLinks) To UBound(oleLinks)\n    Debug.Print oleLinks(i)\n  Next i\nElse\n  Debug.Print \"此活頁簿沒有 OLE 連結。\"\nEnd If", "explanation": "列出目前活頁簿中的所有外部 Excel 連結來源和 OLE 連結來源。"}
    ],
    "keywords": ["linksources", "list external links excel", "get data connection sources", "列出外部連結來源"]
},
{
    "name": "Range.PrintPreview (Excel - Specific Range)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.PrintPreview([EnableChanges As Boolean = False])",
    "description": "顯示指定儲存格範圍的預覽列印。只有該範圍會被預覽和列印。",
    "parameters": [{"name": "EnableChanges", "description": "可選。True 允許在預覽中修改頁面設定。"}],
    "examples": [
        {"code": "Range(\"A1:D10\").PrintPreview\nMsgBox \"範圍 A1:D10 正在預覽列印模式下顯示。\"", "explanation": "僅預覽列印活動工作表上的 A1:D10 範圍。"}
    ],
    "keywords": ["print preview range", "preview specific area excel", "範圍預覽列印"]
},
{
    "name": "Dialogs(xlDialogPrint).Show (Excel - Print Dialog)",
    "category": "Excel 核心操作",
    "syntax": "wasOKClicked = Application.Dialogs(xlDialogPrint).Show",
    "description": "顯示 Excel 的標準「列印」對話框，允許使用者選擇印表機、列印範圍、份數等。如果使用者點擊「確定」 (或「列印」)，則 Show 方法傳回 True，並執行列印。如果點擊「取消」，則傳回 False。",
    "parameters": [],
    "examples": [
        {"code": "If Application.Dialogs(xlDialogPrint).Show Then\n  MsgBox \"列印已開始 (或文件已傳送至佇列)。\"\nElse\n  MsgBox \"使用者取消了列印操作。\"\nEnd If", "explanation": "顯示 Excel 的列印對話框。如果使用者確認列印，則執行列印動作。"}
    ],
    "keywords": ["excel print dialog", "show print dialog vba", "xldialogprint", "列印對話框"]
},
{
    "name": "Range.AdvancedFilter (xlFilterInPlace)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AdvancedFilter Action:=xlFilterInPlace, [CriteriaRange], [Unique As Boolean = False]",
    "description": "使用進階準則直接在原始資料範圍上篩選清單 (就地篩選)。不符合條件的列將被隱藏。",
    "parameters": [
        {"name": "Action:=xlFilterInPlace", "description": "指定就地篩選。"},
        {"name": "CriteriaRange", "description": "包含篩選準則的範圍。"},
        {"name": "Unique", "description": "True 表示僅顯示唯一記錄。"}
    ],
    "examples": [
        {"code": "' Assume A1:C100 is data, E1:E2 is criteria (e.g., E1=Header, E2=Condition)\n' Range(\"A1:C100\").AdvancedFilter Action:=xlFilterInPlace, CriteriaRange:=Range(\"E1:E2\")\n' MsgBox \"資料已在A1:C100範圍內就地篩選。\"\n' ' To show all data again:\n' ' If ActiveSheet.FilterMode Then ActiveSheet.ShowAllData", "explanation": "對 A1:C100 範圍執行就地進階篩選，使用 E1:E2 的準則。不符合的列會被隱藏。"}
    ],
    "keywords": ["advanced filter inplace", "excel filter list inplace", "就地進階篩選"]
},
{
    "name": "Name.Visible Property (Excel Named Range)",
    "category": "Excel 核心操作",
    "syntax": "nameObject.Visible [= True | False]",
    "description": "設定或傳回一個布林值，指出已定義名稱是否在「名稱管理員」對話框中可見。設為 False 可以隱藏名稱，但它仍然可以透過 VBA 或在公式中 (如果直接輸入) 使用。",
    "parameters": [{"name": "True | False", "description": "True (預設) 表示可見，False 表示隱藏。"}],
    "examples": [
        {"code": "Dim hiddenName As Name\nOn Error Resume Next\nThisWorkbook.Names(\"MyHiddenConstant\").Delete ' Delete if exists from previous run\nOn Error GoTo 0\nSet hiddenName = ThisWorkbook.Names.Add(Name:=\"MyHiddenConstant\", RefersTo:=\"=12345\", Visible:=False)\nMsgBox \"已建立一個名為 'MyHiddenConstant' 的隱藏名稱，其值為: \" & [MyHiddenConstant] & vbCrLf & _\n       \"它不會顯示在名稱管理員中。\"", "explanation": "建立一個名為 \"MyHiddenConstant\" 的已定義名稱，並將其 Visible 屬性設為 False，使其在「名稱管理員」中被隱藏。"}
    ],
    "keywords": ["hide named range", "visible name property", "excel hidden name", "隱藏已定義名稱"]
},
{
    "name": "Worksheet.Names.Add (Worksheet-Level Named Range)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Names.Add(Name As String, RefersTo As String, [Visible], ...)",
    "description": "在指定的工作表級別定義一個新的名稱。此名稱僅在該工作表中直接可用 (不需工作表前綴)。",
    "parameters": [
        {"name": "Name", "description": "必需。新名稱的文字。"},
        {"name": "RefersTo", "description": "必需。名稱所參照的公式或值 (A1樣式或R1C1樣式)。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet: Set ws = Sheets(\"Sheet1\")\nOn Error Resume Next\nws.Names(\"LocalSalesRegion\").Delete\nOn Error GoTo 0\nws.Names.Add Name:=\"LocalSalesRegion\", RefersTo:=\"='Sheet1'!$D$1:$D$10\"\nMsgBox \"工作表 'Sheet1' 級別的名稱 'LocalSalesRegion' 已建立。\" & vbCrLf & _\n       \"在 Sheet1 上可以直接用 [LocalSalesRegion] 參照。\" & vbCrLf & _\n       \"在其他工作表上需用 [Sheet1!LocalSalesRegion]。\"", "explanation": "在 Sheet1 上建立一個名為 \"LocalSalesRegion\" 的工作表級別已命名範圍。"}
    ],
    "keywords": ["worksheet level named range", "local named range", "sheet specific name", "工作表級別名稱"]
},
// Word
{
    "name": "Document.Tables.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "numberOfTables = documentObject.Tables.Count",
    "description": "傳回指定文件中表格的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' MsgBox \"此文件共有 \" & wdDoc.Tables.Count & \" 個表格。\"", "explanation": "計算並顯示活動文件中的表格總數。"}
    ],
    "keywords": ["word table count", "number of tables in document", "表格計數"]
},
{
    "name": "Range.Font.ColorIndex (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.ColorIndex = WdColorIndexConstant",
    "description": "設定或傳回指定範圍文字的顏色，使用 WdColorIndex 常數 (例如 wdRed, wdBlue, wdYellow)。",
    "parameters": [{"name": "WdColorIndexConstant", "description": "WdColorIndex 常數。"}],
    "examples": [
        {"code": "Dim selText As Object ' Word.Range\n' Set selText = Selection.Range\n' selText.Font.ColorIndex = wdDarkYellow ' Set to dark yellow\n' MsgBox \"選取文字的顏色已使用ColorIndex設為暗黃色。\"", "explanation": "將目前選取文字的顏色設為暗黃色，使用 WdColorIndex 常數。"}
    ],
    "keywords": ["word font colorindex", "text color word", "wdcolorindex", "字型顏色索引Word"]
},
{
    "name": "Range.ParagraphFormat.SpaceBefore / SpaceAfter (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.ParagraphFormat.SpaceBefore = Points\nrangeObject.ParagraphFormat.SpaceAfter = Points",
    "description": "設定或傳回範圍中段落的段前或段後間距 (以點為單位)。",
    "parameters": [{"name": "Points", "description": "間距的點數值。"}],
    "examples": [
        {"code": "Dim paraFmt As Object ' Word.ParagraphFormat\n' Set paraFmt = Selection.Paragraphs(1).Format ' Get format of the first paragraph in selection\n' paraFmt.SpaceBefore = 12 ' 12 points before\n' paraFmt.SpaceAfter = 6   ' 6 points after\n' MsgBox \"選取範圍第一個段落的段前/段後間距已設定。\"", "explanation": "設定選取範圍中第一個段落的段前間距為12點，段後間距為6點。"}
    ],
    "keywords": ["word paragraph spacing", "spacebefore", "spaceafter", "段落間距Word"]
},
{
    "name": "Table.Cell(Row, Col).Range.Text (Word)",
    "category": "Word 文件處理",
    "syntax": "cellText = tableObject.Cell(Row, Column).Range.Text\ntableObject.Cell(Row, Column).Range.Text = newText",
    "description": "設定或傳回 Word 表格中特定儲存格的文字內容。注意，讀取時 .Text 會包含儲存格結束標記 (通常是 Chr(13) & Chr(7))，寫入時則不需要包含。",
    "parameters": [
        {"name": "Row", "description": "列號 (1-based)。"},
        {"name": "Column", "description": "欄號 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\n' Set tbl = ActiveDocument.Tables(1)\n' ' Write to cell\n' tbl.Cell(1, 1).Range.Text = \"新標題\"\n' ' Read from cell and clean\n' Dim rawText As String: rawText = tbl.Cell(1, 1).Range.Text\n' Dim cleanedText As String: cleanedText = Left(rawText, Len(rawText) - 2) ' Remove last 2 cell markers\n' MsgBox \"表格(1,1)的文字 (清理後): '\" & cleanedText & \"'\"", "explanation": "向活動文件第一個表格的 (1,1) 儲存格寫入文字，然後讀取該儲存格的文字並清理掉尾部的儲存格標記。"}
    ],
    "keywords": ["word table cell text", "get set cell value word", "表格儲存格文字Word"]
},
{
    "name": "Bookmark.Range.Delete (Word)",
    "category": "Word 文件處理",
    "syntax": "bookmarkObject.Range.Delete",
    "description": "刪除與書籤關聯的文字內容，但書籤本身 (名稱) 仍然存在於該位置 (變成一個空書籤)。要完全刪除書籤，應使用 `bookmarkObject.Delete`。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object, bk As Object ' Word.Bookmark\n' Set wdDoc = ActiveDocument\n' ' Assume bookmark \"MyData\" exists and contains text\n' If wdDoc.Bookmarks.Exists(\"MyData\") Then\n'   Set bk = wdDoc.Bookmarks(\"MyData\")\n'   bk.Range.Delete ' Deletes the text content of the bookmark\n'   MsgBox \"書籤 'MyData' 的內容已被刪除，但書籤標記本身仍在。\"\n'   ' bk.Delete ' This would delete the bookmark itself\n' End If", "explanation": "如果存在名為 \"MyData\" 的書籤，則刪除該書籤所標記的文字內容，但書籤本身的位置標記會保留。"}
    ],
    "keywords": ["word delete bookmark content", "clear bookmark text", "刪除書籤內容"]
},
// Outlook
{
    "name": "MailItem.AlternateRecipientAllowed Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.AlternateRecipientAllowed = True | False",
    "description": "如果郵件可以轉寄，則為 True。讀取/寫入布林值。如果設為 False，則「轉寄」按鈕可能會被禁用 (取決於Outlook版本和策略)。",
    "parameters": [{"name": "True | False", "description": "True (預設) 允許轉寄。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.Subject = \"高度機密 - 禁止轉寄\"\nolMail.To = \"internal.user@example.com\"\nolMail.AlternateRecipientAllowed = False\nolMail.Body = \"此郵件包含敏感資訊，請勿轉發。\"\nolMail.Display", "explanation": "建立一封新郵件，並將其設定為不允許收件者轉寄。"}
    ],
    "keywords": ["outlook disallow forward", "prevent email forwarding", "禁止轉寄"]
},
{
    "name": "MailItem.PermissionService Property (Outlook IRM)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.PermissionService = OlPermissionServiceConstant",
    "description": "設定或傳回一個 OlPermissionService 常數，指定用於保護 MailItem 的權限服務。主要用於資訊版權管理 (IRM)。",
    "parameters": [
        {"name": "OlPermissionServiceConstant", "description": "例如 olUnknown (0), olWindows (1, Windows RMS), olADS (2, Azure RMS)。"}
    ],
    "examples": [
        {"code": "Dim olMail As Object\n' Set olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\n' ' This usually works in conjunction with setting .Permission and .PermissionTemplateGuid\n' olMail.Permission = olPermissionTemplate\n' olMail.PermissionTemplateGuid = \"{YOUR-IRM-TEMPLATE-GUID}\"\n' ' The PermissionService might be automatically determined or set if needed by the template\n' ' olMail.PermissionService = olWindows ' Or olADS, depending on IRM setup\n' Debug.Print \"郵件的權限服務 (如果已設定IRM): \" & olMail.PermissionService", "explanation": "與 .Permission 和 .PermissionTemplateGuid 一起使用，用於設定郵件的資訊版權管理 (IRM)。PermissionService 指定使用的 RMS 服務類型。"}
    ],
    "keywords": ["outlook irm service", "permission service", "information rights management", "IRM權限服務"]
},
{
    "name": "AppointmentItem.ReminderOverrideDefault Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "apptItemObject.ReminderOverrideDefault = True | False",
    "description": "如果約會的提醒行為覆寫預設的提醒設定，則為 True。讀取/寫入布林值。如果為 True，則使用 ReminderMinutesBeforeStart；如果為 False，則使用日曆資料夾的預設提醒時間。",
    "parameters": [{"name": "True | False", "description": "True 表示覆寫預設提醒。"}],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem\n' Set olAppt = Application.CreateItem(olAppointmentItem)\n' olAppt.Subject = \"重要會議 - 自訂提醒\"\n' olAppt.Start = Now + TimeValue(\"03:00:00\")\n' olAppt.ReminderSet = True\n' olAppt.ReminderOverrideDefault = True ' Override the default calendar reminder\n' olAppt.ReminderMinutesBeforeStart = 45  ' Set specific reminder for 45 minutes before\n' olAppt.Display", "explanation": "建立一個約會，啟用提醒，並設定 ReminderOverrideDefault 為 True，以便使用自訂的 ReminderMinutesBeforeStart (45分鐘前)，而不是日曆的預設提醒時間。"}
    ],
    "keywords": ["outlook reminder override", "custom appointment reminder", "自訂約會提醒"]
},
// PowerPoint
{
    "name": "Presentation.SlideShowSettings.ShowScrollbar (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "presentationObject.SlideShowSettings.ShowScrollbar = MsoTriStateConstant",
    "description": "如果指定簡報在投影片放映期間顯示捲軸，則為 True (msoTrue)。讀取/寫入 MsoTriState。",
    "parameters": [{"name": "MsoTriStateConstant", "description": "msoTrue, msoFalse, msoCTrue。"}],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\n' Set pptPres = ActivePresentation\n' pptPres.SlideShowSettings.ShowScrollbar = msoTrue\n' MsgBox \"投影片放映時將顯示捲軸 (如果適用於檢視類型)。\"", "explanation": "設定活動簡報在投影片放映時顯示捲軸。這在某些自訂放映或kiosk模式下可能有用。"}
    ],
    "keywords": ["powerpoint slideshow scrollbar", "show scrollbar in slideshow", "放映時顯示捲軸"]
},
{
    "name": "Slide.NotesMaster Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set notesMasterObj = slideObject.NotesMaster",
    "description": "傳回一個 Master 物件，代表指定投影片的備忘稿母片。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object, nm As Object ' PowerPoint.Master (Notes Master)\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set nm = pptSlide.NotesMaster\n' ' Example: Add a fixed text to all notes pages via the notes master\n' On Error Resume Next ' Placeholder for footer might not exist\n' nm.HeadersFooters.Footer.Text = \"內部備忘稿 - CONFIDENTIAL\"\n' nm.HeadersFooters.Footer.Visible = msoTrue\n' On Error GoTo 0\n' MsgBox \"已嘗試在所有備忘稿頁的母片頁尾新增文字。\"", "explanation": "獲取第一張投影片的備忘稿母片，並嘗試在其頁尾新增統一的文字。"}
    ],
    "keywords": ["powerpoint notes master", "slide notes template", "備忘稿母片"]
},
// FSO
{
    "name": "FileSystemObject.GetTempName (Uniqueness)",
    "category": "檔案與資料夾管理",
    "description": "GetTempName 方法傳回一個隨機產生的暫存檔案名稱。它不實際建立檔案。名稱通常以 \"rad\" 開頭，後跟十六進制數字，副檔名為 \".tmp\"。雖然它盡力產生唯一的名稱，但在極端情況下或短時間內大量呼叫時，仍有極小的機率產生重複名稱。如果絕對唯一性至關重要，應檢查檔案是否已存在，或結合其他唯一標識符 (如GUID)。",
    "syntax": "tempFileName = fso.GetTempName",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, tempName1 As String, tempName2 As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\ntempName1 = fso.GetTempName\ntempName2 = fso.GetTempName\nDebug.Print \"第一個暫存名稱: \" & tempName1\nDebug.Print \"第二個暫存名稱: \" & tempName2\nIf tempName1 <> tempName2 Then\n  Debug.Print \"兩個產生的暫存名稱不同。\"\nElse\n  Debug.Print \"警告：連續兩次產生的暫存名稱相同 (機率極低)。\"\nEnd If\nSet fso = Nothing", "explanation": "連續兩次呼叫 GetTempName 並比較結果。它們幾乎總是不同的。"}
    ],
    "keywords": ["fso gettempname uniqueness", "temporary file name collision", "隨機暫存檔名唯一性"]
},
// Math
{
    "name": "WorksheetFunction.Rank_Eq (Excel)",
    "category": "數學、日期與時間",
    "syntax": "rankValue = Application.WorksheetFunction.Rank_Eq(Number, Ref As Range, [Order As Long = 0])",
    "description": "使用 Excel 的 RANK.EQ 工作表函數，傳回一個數字在一組數字中的排名。如果多個值具有相同的排名，則傳回該組值的最高排名。",
    "parameters": [
        {"name": "Number", "description": "必需。要找出其排名的數字。"},
        {"name": "Ref", "description": "必需。包含數字列表的儲存格範圍或陣列。"},
        {"name": "Order", "description": "可選。0 (預設) 或非零值。0 表示降冪排名，非零值表示升冪排名。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A5\").Value = Application.Transpose(Array(100, 85, 95, 100, 70))\nDim rankOfA3 As Long\n' Rank A3 (value 95) within A1:A5, descending order (highest is 1)\nrankOfA3 = Application.WorksheetFunction.Rank_Eq(Range(\"A3\").Value, Range(\"A1:A5\"), 0)\nMsgBox \"儲存格A3的值 (95) 在A1:A5中的排名 (降冪) 是: \" & rankOfA3 ' A3 (95) is 3rd. Two 100s are rank 1.\n\nDim rankOfA5Asc As Long\n' Rank A5 (value 70) within A1:A5, ascending order (lowest is 1)\nrankOfA5Asc = Application.WorksheetFunction.Rank_Eq(Range(\"A5\").Value, Range(\"A1:A5\"), 1)\nMsgBox \"儲存格A5的值 (70) 在A1:A5中的排名 (升冪) 是: \" & rankOfA5Asc ' A5 (70) is rank 1.", "explanation": "演示如何使用 RANK.EQ 函數計算一個數字在一組數字中的降冪和升冪排名。"}
    ],
    "keywords": ["rank.eq", "excel rank function vba", "data ranking", "排名函數"]
},
// Program Flow
{
    "name": "Declare Sub/Function (Alias Name with Special Characters)",
    "category": "程式流程與結構控制",
    "description": "當外部 DLL 函數的實際名稱包含在 VBA 中不允許作為程序名稱的字元 (例如，底線開頭 `_MyFunction`，或包含 `.` 或 `@`)，或者與 VBA 關鍵字衝突時，可以使用 `Alias` 子句為該外部函數指定一個在 VBA 中有效的別名。",
    "syntax": "Declare PtrSafe Function MyVBAFuncName Lib \"MyDLL.dll\" Alias \"_ActualDllFuncName@4\" (...) As Long",
    "parameters": [{"name": "Alias \"ActualDllFuncName@4\"", "description": "指定 DLL 中函數的真實名稱，可能包含特殊修飾。"}],
    "examples": [
        {"code": "' Example: Assume a DLL 'MyCustom.dll' has a function named '_CalculateSum@8'\n' which takes two Longs and returns a Long. The @8 might be part of name mangling for stdcall.\n' #If VBA7 Then\n' Private Declare PtrSafe Function CalculateSum Lib \"MyCustom.dll\" Alias \"_CalculateSum@8\" (\n'     ByVal Num1 As Long, ByVal Num2 As Long) As Long\n' #Else\n' Private Declare Function CalculateSum Lib \"MyCustom.dll\" Alias \"_CalculateSum@8\" (\n'     ByVal Num1 As Long, ByVal Num2 As Long) As Long\n' #End If\n'\n' Sub TestAliasName()\n'   Dim result As Long\n'   On Error Resume Next ' If MyCustom.dll or function is not found\n'   ' result = CalculateSum(10, 20) ' Call using the VBA alias\n'   If Err.Number = 0 Then\n'     ' MsgBox \"CalculateSum(10, 20) via Alias = \" & result\n'     MsgBox \"(概念性) 已嘗試透過別名呼叫 CalculateSum。實際執行需 MyCustom.dll 存在。\"\n'   Else\n'     MsgBox \"呼叫 CalculateSum 失敗 (可能是DLL或函數未找到)。錯誤: \" & Err.Description\n'   End If\n'   On Error GoTo 0\n' End Sub", "explanation": "演示如何使用 Declare 語句中的 Alias 子句。假設有一個名為 `_CalculateSum@8` 的 DLL 函數，在 VBA 中可以通過別名 `CalculateSum` 來呼叫它。此範例為概念性，執行時需要實際的 `MyCustom.dll`。"}
    ],
    "keywords": ["declare alias name", "api function alias", "dll function name mangling", "API別名"]
},
// Final one, for good measure
{
    "name": "Worksheet.EnableFormatConditionsCalculation Property (Excel 2010+)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.EnableFormatConditionsCalculation [= Boolean]",
    "description": "如果啟用條件格式的自動計算和評估，則為 True。設為 False 可以暫停條件格式的更新，這在大量更改可能觸發複雜條件格式計算時有助於提高效能。讀取/寫入布林值。預設為 True。",
    "parameters": [{"name": "Boolean", "description": "True (預設) 啟用，False 禁用。"}],
    "examples": [
        {"code": "Dim ws As Worksheet: Set ws = ActiveSheet\nws.EnableFormatConditionsCalculation = False\n' ... Perform many data updates that might affect conditional formatting ...\nRange(\"A1:A1000\").Value = Rnd() ' Example update\nws.EnableFormatConditionsCalculation = True\n' Conditional formats will now update/re-evaluate based on the changes.\n' May need Application.ScreenUpdating = False/True around this if updates cause flicker.\nMsgBox \"條件格式計算已先禁用，執行操作後再啟用。\"", "explanation": "在執行可能觸發大量條件格式重新評估的操作之前，先禁用條件格式的自動計算，完成操作後再重新啟用它。"}
    ],
    "keywords": ["enableformatconditionscalculation", "excel conditional formatting performance", "stop conditional format update", "條件格式計算控制"]
},
{
    "name": "Application.FindFormat / .ReplaceFormat Properties (Excel)",
    "category": "Excel 核心操作",
    "description": "這兩個 Application 級別的屬性本身是 Range 物件 (但僅用於儲存格式設定，不能直接讀寫儲存格值)。它們用於與 Range.Find 和 Range.Replace 方法的 SearchFormat 和 ReplaceFormat 引數配合使用，以基於儲存格格式進行搜尋和取代。您需要先清除 FindFormat/ReplaceFormat，然後設定其 Font, Interior, NumberFormat 等屬性，再執行 Find/Replace。",
    "syntax": "Application.FindFormat.Clear\nApplication.FindFormat.Font.Bold = True\nSet foundCell = Range(\"A:A\").Find(What:=\"*\", SearchFormat:=True)\n\nApplication.ReplaceFormat.Clear\nApplication.ReplaceFormat.Interior.Color = vbYellow\nRange(\"A:A\").Replace What:=\"*\", Replacement:=\"\", SearchFormat:=True, ReplaceFormat:=True",
    "parameters": [],
    "examples": [
        {"code": "Dim foundBoldCell As Range\n' Clear any previous FindFormat settings\nApplication.FindFormat.Clear\n' Specify the format to find: Bold text\nApplication.FindFormat.Font.Bold = True\n' Search for any cell in column B that is bold\nSet foundBoldCell = Columns(\"B\").Find(What:=\"*\", After:=Cells(Rows.Count, \"B\"), SearchFormat:=True, SearchDirection:=xlNext)\nIf Not foundBoldCell Is Nothing Then\n  MsgBox \"在B欄找到第一個粗體儲存格: \" & foundBoldCell.Address & \" 其內容為: '\" & foundBoldCell.Value & \"'\"\n  foundBoldCell.Select\n  ' Clear FindFormat for next regular find operations\n  Application.FindFormat.Clear\nElse\n  MsgBox \"在B欄未找到粗體儲存格。\"\nEnd If", "explanation": "演示如何使用 Application.FindFormat 來搜尋B欄中第一個具有粗體字型格式的儲存格。`What:=\"*\"` 用於匹配任何內容，因為搜尋主要基於格式。"}
    ],
    "keywords": ["application.findformat", "application.replaceformat", "excel search by formatting", "excel replace formatting", "格式搜尋設定", "格式取代設定"]
},
{
    "name": "Shapes.Range Property (Excel/PowerPoint)",
    "category": "Excel 核心操作",
    "syntax": "Set shapeRangeObject = shapesCollection.Range(Index As Variant)",
    "description": "從 Shapes 集合中傳回一個 ShapeRange 物件，代表一個或一組圖案。Index 可以是單個圖案的名稱或索引號，也可以是包含多個圖案名稱或索引號的陣列。",
    "parameters": [{"name": "Index", "description": "必需。圖案的名稱、索引號，或包含名稱/索引的陣列。"}],
    "examples": [
        {"code": "' In Excel:\n' ActiveSheet.Shapes.AddShape msoShapeRectangle, 50, 50, 100, 50 .Name = \"Rect1\"\n' ActiveSheet.Shapes.AddShape msoShapeOval, 150, 50, 100, 50 .Name = \"Oval1\"\n' ActiveSheet.Shapes.AddShape msoShapeTriangle, 250, 50, 100, 50 .Name = \"Tri1\"\n\n' Dim selectedShapes As ShapeRange\n' Set selectedShapes = ActiveSheet.Shapes.Range(Array(\"Rect1\", \"Tri1\"))\n' selectedShapes.Fill.ForeColor.RGB = RGB(0, 0, 255) ' Make selected shapes blue\n' selectedShapes.Group ' Group the selected shapes\n' MsgBox \"名為 'Rect1' 和 'Tri1' 的圖案已被選取、填色並群組。\"", "explanation": "在 Excel 工作表上建立三個圖案，然後使用 Shapes.Range 屬性透過名稱陣列選取其中的兩個 (\"Rect1\" 和 \"Tri1\")，將它們的填充色設為藍色，並將它們群組起來。此概念也適用於 PowerPoint 的 Shapes 集合。"}
    ],
    "keywords": ["shapes.range", "select multiple shapes", "shaperange object", "選取多個圖案", "圖案範圍", "通用"]
},
{
    "name": "ShapeRange.Group / .Ungroup (Excel/PowerPoint)",
    "category": "Excel 核心操作",
    "syntax": "Set groupedShape = shapeRangeObject.Group()\nSet ungroupedShapesArray = groupedShapeObject.Ungroup()",
    "description": "Group 方法將 ShapeRange 集合中的所有圖案組合成一個單一的 GroupShape 物件。Ungroup 方法則將一個 GroupShape 物件分解回其原始的個別 Shape 物件。",
    "parameters": [],
    "examples": [
        {"code": "' In Excel (continuing from Shapes.Range example):\n' ' Assume 'Rect1' and 'Oval1' are existing shapes\n' Dim shpArray As Variant: shpArray = Array(\"Rect1\", \"Oval1\")\n' Dim sr As ShapeRange: Set sr = ActiveSheet.Shapes.Range(shpArray)\n' If sr.Count > 1 Then\n'   Dim grpShp As GroupShape\n'   Set grpShp = sr.Group\n'   grpShp.Name = \"MyGroupedShapes\"\n'   MsgBox \"圖案 'Rect1' 和 'Oval1' 已被群組為 '\" & grpShp.Name & \"'.\"\n'   Application.Wait Now + TimeValue(\"00:00:02\")\n'   ' To ungroup:\n'   ' Dim ungrpdShps As ShapeRange: Set ungrpdShps = grpShp.Ungroup\n'   ' MsgBox \"'MyGroupedShapes' 已被取消群組。現在有 \" & ungrpdShps.Count & \" 個獨立圖案。\"\n' End If", "explanation": "選取工作表上的 \"Rect1\" 和 \"Oval1\" 圖案，將它們群組，並為群組命名。註解部分顯示了如何取消群組。"}
    ],
    "keywords": ["shape group", "shape ungroup", "groupshape", "combine shapes", "群組圖案", "取消群組圖案", "通用"]
},
{
    "name": "ShapeRange.Align / .Distribute (Excel/PowerPoint)",
    "category": "Excel 核心操作",
    "syntax": "shapeRangeObject.Align(AlignCmd As MsoAlignCmd, RelativeTo As MsoTriState)\nshapeRangeObject.Distribute(DistributeCmd As MsoDistributeCmd, RelativeTo As MsoTriState)",
    "description": "Align 方法對齊 ShapeRange 集合中的多個圖案。Distribute 方法均勻分佈 ShapeRange 集合中的圖案。",
    "parameters": [
        {"name": "AlignCmd", "description": "MsoAlignCmd 常數 (例如 msoAlignLefts, msoAlignTops, msoAlignCenter)。"},
        {"name": "DistributeCmd", "description": "MsoDistributeCmd 常數 (例如 msoDistributeHorizontally, msoDistributeVertically)。"},
        {"name": "RelativeTo", "description": "MsoTriState 常數。msoFalse (預設) 表示相對於選取的圖案對齊/分佈；msoTrue 表示相對於頁面/投影片對齊/分佈。"}
    ],
    "examples": [
        {"code": "' In Excel (assuming shp1, shp2, shp3 are existing Shape objects):\n' Dim shp1 As Shape, shp2 As Shape, shp3 As Shape\n' ' Set shp1 = ActiveSheet.Shapes(\"ShapeA\")\n' ' Set shp2 = ActiveSheet.Shapes(\"ShapeB\")\n' ' Set shp3 = ActiveSheet.Shapes(\"ShapeC\")\n'\n' ' Select multiple shapes to align/distribute\n' ' Application.ActiveSheet.Shapes.Range(Array(shp1.Name, shp2.Name, shp3.Name)).Select\n' ' Align selected shapes to their collective left edges\n' ' Selection.ShapeRange.Align msoAlignLefts, msoFalse\n' ' Distribute selected shapes horizontally with equal spacing between them\n' ' Selection.ShapeRange.Distribute msoDistributeHorizontally, msoFalse\n' MsgBox \"(概念性) 已嘗試對選取的圖案執行對齊和分佈。\"", "explanation": "概念性地演示如何選取多個圖案，然後將它們左對齊，並水平均勻分佈。實際操作需要先確保這些圖案已被選取 (`.Select`)，然後對 `Selection.ShapeRange` 進行操作。"}
    ],
    "keywords": ["align shapes", "distribute shapes", "shape formatting", "對齊圖案", "分佈圖案", "通用"]
},
// Word
{
    "name": "Range.GoToEditableRange (Word Protected Document)",
    "category": "Word 文件處理",
    "syntax": "Set editableRange = rangeObject.GoToEditableRange([EditorID As WdEditorType])",
    "description": "在受保護的文件中，將範圍移動到下一個允許目前使用者或指定使用者群組編輯的區域，並傳回代表該可編輯區域的 Range 物件。如果找不到可編輯區域，則傳回 Nothing。",
    "parameters": [
        {"name": "EditorID", "description": "可選。WdEditorType 常數或代表特定使用者/群組的字串。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim currentRange As Object, nextEditRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' ' Assume document is protected with some editable regions\n' If wdDoc.ProtectionType <> wdNoProtection Then\n'   Set currentRange = wdDoc.Range(0, 0) ' Start from beginning\n'   Do\n'     Set nextEditRange = currentRange.GoToEditableRange()\n'     If Not nextEditRange Is Nothing Then\n'       Debug.Print \"找到可編輯區域: \" & nextEditRange.AddressLocal\n'       ' nextEditRange.Select ' Select it\n'       ' Application.Wait Now + TimeValue(\"00:00:01\") ' Pause to see\n'       Set currentRange = nextEditRange ' Move start for next search\n'       currentRange.Collapse wdCollapseEnd ' Collapse to end to find next *different* range\n'     Else\n'       Debug.Print \"未找到更多可編輯區域。\"\n'       Exit Do\n'     End If\n'   Loop\n' Else\n'   MsgBox \"文件未受保護，或沒有特定的可編輯區域。\"\n' End If", "explanation": "如果文件受保護，則從文件開頭開始，循環查找並列印所有允許目前使用者編輯的區域的位址。"}
    ],
    "keywords": ["word gotoeditablerange", "protected document navigation", "find editable sections", "受保護文件可編輯區域"]
},
{
    "name": "TablesOfContents.MarkEntry (Word TOC)",
    "category": "Word 文件處理",
    "syntax": "documentObject.TablesOfContents.MarkEntry(Range As Range, [Entry As String], [EntryAutoText As String], [TableID As String], [Level As Long = 1])",
    "description": "在指定範圍之後插入一個 TC (目錄項目) 功能變數。TC 功能變數用於手動標記要包含在目錄中的項目，而不是僅依賴標題樣式。",
    "parameters": [
        {"name": "Range", "description": "必需。TC 功能變數將插入於其後。"},
        {"name": "Entry", "description": "可選。要在目錄中顯示的文字。"},
        {"name": "Level", "description": "可選。目錄的級別 (1-9)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, targetRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' ' Mark the current selection as a Level 2 TOC entry\n' Set targetRange = Selection.Range\n' wdDoc.TablesOfContents.MarkEntry Range:=targetRange, Entry:=targetRange.Text, Level:=2\n' MsgBox \"選取的文字已被標記為目錄項目 (級別2)。您需要更新目錄才能看到它。\"", "explanation": "將目前選取的文字標記為一個2級目錄項目。之後需要更新現有目錄或插入新目錄才能看到此項目。"}
    ],
    "keywords": ["word mark toc entry", "tc field", "manual table of contents entry", "標記目錄項目"]
},
// Outlook
{
    "name": "NameSpace.GetFolderFromID (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set fldr = olNamespace.GetFolderFromID(EntryIDFolder As String, [EntryIDStore As String])",
    "description": "傳回一個 MAPIFolder 物件，代表具有指定 EntryID 的資料夾。EntryID 是 MAPI 儲存區中資料夾的唯一識別碼。",
    "parameters": [
        {"name": "EntryIDFolder", "description": "必需。資料夾的 EntryID。"},
        {"name": "EntryIDStore", "description": "可選。資料夾所在儲存區的 StoreID。如果省略，則在預設儲存區中尋找。"}
    ],
    "examples": [
        {"code": "Dim olNS As Object, inbox As Object, inboxID As String, retrievedInbox As Object\nSet olNS = Application.GetNamespace(\"MAPI\")\nSet inbox = olNS.GetDefaultFolder(olFolderInbox)\ninboxID = inbox.EntryID\n' Now retrieve the Inbox folder using its EntryID\nSet retrievedInbox = olNS.GetFolderFromID(inboxID)\nIf Not retrievedInbox Is Nothing Then\n  MsgBox \"透過 EntryID 成功獲取資料夾: \" & retrievedInbox.Name\nElse\n  MsgBox \"無法透過 EntryID 獲取資料夾。\"\nEnd If", "explanation": "獲取收件匣的 EntryID，然後使用 GetFolderFromID 方法透過該 EntryID 重新獲取收件匣資料夾物件。"}
    ],
    "keywords": ["outlook getfolderfromid", "entryid folder", "access folder by id", "依ID獲取資料夾"]
},
{
    "name": "MailItem.PropertyAccessor Property (Outlook - Read/Write Custom Properties)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set pa = mailItemObject.PropertyAccessor\nvalue = pa.GetProperty(SchemaName As String)\npa.SetProperty SchemaName As String, Value",
    "description": "提供對 Outlook 項目 (如 MailItem) 的 MAPI 屬性的低階存取，包括標準屬性和自訂屬性。屬性透過其 MAPI 命名空間 URI (SchemaName) 來識別。",
    "parameters": [
        {"name": "GetProperty(SchemaName)", "description": "方法：獲取指定屬性的值。"},
        {"name": "SetProperty(SchemaName, Value)", "description": "方法：設定指定屬性的值。"},
        {"name": "SchemaName (String)", "description": "MAPI屬性的命名空間URI，例如 \"http://schemas.microsoft.com/mapi/string/{GUID}/MyCustomPropName\" 或標準屬性的簡寫 (例如 \"urn:schemas:mailheader:subject\")。"}
    ],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\nDim pa As Object ' Outlook.PropertyAccessor\nDim propName As String, propValue As String\n' Set olMail = Application.CreateItem(olMailItem)\n' Set pa = olMail.PropertyAccessor\n' ' Example: Set a custom string property (GUID can be generated using GuidGen.exe or online tool)\n' propName = \"http://schemas.microsoft.com/mapi/string/{00020329-0000-0000-C000-000000000046}/MyInternalTrackingID\"\n' propValue = \"ProjectX-Task123\"\n' On Error Resume Next ' Setting custom properties can sometimes fail if not defined or type mismatch\n' pa.SetProperty propName, propValue\n' If Err.Number = 0 Then\n'   Dim retrievedValue As String\n'   retrievedValue = pa.GetProperty(propName)\n'   MsgBox \"自訂屬性 'MyInternalTrackingID' 已設定為: \" & retrievedValue\n' Else\n'   MsgBox \"設定自訂屬性失敗: \" & Err.Description\n' End If\n' On Error GoTo 0\n' olMail.Close olDiscard ' Close without saving if just testing\n' Set pa = Nothing: Set olMail = Nothing", "explanation": "演示如何使用 PropertyAccessor 為郵件項目設定和獲取一個自訂的字串屬性。需要一個唯一的 GUID 和屬性名稱來定義 SchemaName。這對於儲存應用程式特定的元數據到 Outlook 項目中很有用。"}
    ],
    "keywords": ["outlook propertyaccessor", "mapi properties vba", "custom email property", "read write mapi props", "存取MAPI屬性", "自訂郵件屬性"]
},
// PowerPoint
{
    "name": "Presentation.Designs Property / Design Object (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set designsColl = presentationObject.Designs\nSet firstDesign = presentationObject.Designs(1)",
    "description": "Designs 屬性傳回一個 Designs 集合，代表簡報中所有可用的設計範本 (包括目前套用的和內建的)。Design 物件代表單個設計範本，可以套用於投影片母片或個別投影片。",
    "parameters": [
        {"name": "Design.Name", "description": "屬性：設計範本的名稱。"},
        {"name": "Design.AddToSlideMaster()", "description": "方法：將此設計套用於投影片母片。"},
        {"name": "Presentation.ApplyTemplate(FileName)", "description": "方法：將一個 .potx 或 .thmx 檔案中的設計套用於整個簡報。"}
    ],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\nDim des As Object ' PowerPoint.Design\n' Set pptPres = ActivePresentation\n' If pptPres.Designs.Count > 0 Then\n'   Debug.Print \"簡報中可用的設計範本:\"\n'   For Each des In pptPres.Designs\n'     Debug.Print \"  - \" & des.Name\n'   Next des\n'   ' Apply the second available design (if more than one exists) to the slide master\n'   If pptPres.Designs.Count >= 2 Then\n'     ' pptPres.SlideMaster.Design = pptPres.Designs(2)\n'     ' OR more directly for entire presentation:\n'     ' pptPres.Designs(2).AddToSlideMaster ' This is conceptual, usually .ApplyTemplate is used for files\n'     ' A more common way to apply a design from the presentation's own collection:\n'     ' pptPres.Designs(2).MoveToPres ThemeData:=True ' This is also complex for just applying theme.\n'     ' Usually, you apply a template file, or modify the current master.\n'     MsgBox \"(概念性) 已嘗試存取第二個設計範本。套用設計通常使用 ApplyTemplate。\"\n'   End If\n' Else\n'   MsgBox \"此簡報沒有多個設計範本可供列出或切換。\"\n' End If", "explanation": "遍歷活動簡報中可用的設計範本並列印其名稱。註解部分概念性地提到了如何套用簡報中現有的另一個設計或透過檔案套用設計。直接從 Designs 集合套用一個設計到母片比較複雜，通常是透過 `ApplyTemplate` 方法載入一個 `.potx` 或 `.thmx` 檔案，或者直接修改 `SlideMaster.Design` 來引用一個已存在於簡報中的設計。"}
    ],
    "keywords": ["powerpoint designs collection", "presentation themes", "apply design template ppt", "設計範本集合", "套用簡報主題"]
},
{
    "name": "TextRange.ParagraphFormat Property (PowerPoint Shape Text)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set paraFmt = shapeObject.TextFrame.TextRange.ParagraphFormat",
    "description": "傳回一個 ParagraphFormat 物件，代表指定文字範圍的段落格式。允許設定對齊、縮排、間距等。",
    "parameters": [
        {"name": "ParagraphFormat.Alignment", "description": "PpParagraphAlignment 常數。"},
        {"name": "ParagraphFormat.SpaceBefore / .SpaceAfter", "description": "段前/段後間距 (點)。"},
        {"name": "ParagraphFormat.LineRuleBefore / .LineRuleAfter / .LineRuleWithin", "description": "MsoTriState，控制段落間距是否包含字型行距。"},
        {"name": "ParagraphFormat.Bullet", "description": "BulletFormat 物件，用於設定項目符號。"}
    ],
    "examples": [
        {"code": "Dim shp As Object ' PowerPoint.Shape (e.g., a TextBox)\nDim pf As Object ' PowerPoint.ParagraphFormat\n' Set shp = ActiveWindow.Selection.ShapeRange(1) ' Assume a shape is selected\n' If shp.HasTextFrame And shp.TextFrame.HasText Then\n'   Set pf = shp.TextFrame.TextRange.ParagraphFormat\n'   With pf\n'     .Alignment = ppAlignCenter ' ppAlignCenter = 2\n'     .SpaceAfter = 10 ' 10 points after paragraph\n'     With .Bullet\n'       .Visible = msoTrue\n'       .Type = ppBulletUnnumbered ' Or ppBulletNumbered, ppBulletPicture\n'       .Character = 8226 ' Bullet character code (●)\n'       .Font.Name = \"Symbol\"\n'     End With\n'   End With\n'   MsgBox \"選取圖案中文字的段落格式已修改 (置中、段後間距、項目符號)。\"\n' End If", "explanation": "獲取選取圖案中文字的 ParagraphFormat 物件，將其段落設為置中對齊，增加段後間距，並套用一個圓點項目符號。"}
    ],
    "keywords": ["powerpoint paragraph format", "textframe paragraph", "shape text alignment", "ppt bullet points", "文字框段落格式", "項目符號PPT"]
},
// FSO
{
    "name": "TextStream.Line Property (FSO - Read-only)",
    "category": "檔案與資料夾管理",
    "description": "TextStream 物件的 Line 屬性是一個唯讀的 Long，它傳回目前檔案指標在 TextStream 檔案中的行號 (1-based)。",
    "syntax": "currentLineNumber = textStreamObject.Line",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, ts As Object, lineData As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Assume C:\\Temp\\MyDataFile.txt exists and has multiple lines\n' Set ts = fso.OpenTextFile(\"C:\\Temp\\MyDataFile.txt\", 1) ' ForReading\n' Do While Not ts.AtEndOfStream\n'   lineData = ts.ReadLine\n'   Debug.Print \"行號: \" & ts.Line -1 & \" (讀取前是 \" & ts.Line -1 & \", 讀取後指向下一行 \" & ts.Line & \"), 內容: \" & lineData\n'   If ts.Line > 5 Then Exit Do ' Read first 5 lines for demo\n' Loop\n' ts.Close\n' Set fso = Nothing: Set ts = Nothing", "explanation": "打開一個文字檔案並逐行讀取。在讀取每一行之後，ts.Line 會指向下一行的行號。所以，如果想獲取剛讀取那行的行號，通常是 ts.Line - 1 (假設在讀取前檢查或讀取後立即檢查)。"}
    ],
    "keywords": ["fso textstream line number", "current line file reading", "文字流目前行號"]
},
// String
{
    "name": "Space Function (vs Space$)",
    "category": "字串與文本操作",
    "description": "Space(Number) 函數傳回一個包含指定數量空格的 Variant (String)。Space$(Number) 函數傳回一個 String。在現代VBA中，兩者功能上幾乎無差異，效能差異也通常可以忽略。使用 `$` 後綴的函數是早期BASIC中表示傳回字串的習慣。",
    "syntax": "Space(Number As Long) As Variant\nSpace$(Number As Long) As String",
    "parameters": [],
    "examples": [
        {"code": "Dim spacesVariant As Variant\nDim spacesString As String\nspacesVariant = Space(5)\nspacesString = Space$(5)\nDebug.Print \"Space(5) TypeName: \" & TypeName(spacesVariant) & \", Value: '\" & spacesVariant & \"'\"\nDebug.Print \"Space$(5) TypeName: \" & TypeName(spacesString) & \", Value: '\" & spacesString & \"'\"\nIf spacesVariant = spacesString Then Debug.Print \"Space(5) and Space$(5) are equal in value.\"", "explanation": "比較 Space 和 Space$ 函數的傳回類型和值。"}
    ],
    "keywords": ["space function vs space$", "vba string functions typed", "空格字串函數"]
},
// Math
{
    "name": "WorksheetFunction.CountA (Excel)",
    "category": "數學、日期與時間",
    "syntax": "count = Application.WorksheetFunction.CountA(Arg1, [Arg2], ...)",
    "description": "使用 Excel 的 COUNTA 工作表函數，計算參數清單中不為空的參數個數。參數可以是儲存格範圍、陣列或直接的值。",
    "parameters": [{"name": "Arg1, Arg2, ...", "description": "1到255個要檢查的參數。"}],
    "examples": [
        {"code": "Dim rng As Range: Set rng = Range(\"A1:A5\")\nRange(\"A1\").Value = \"Text\"\nRange(\"A2\").Value = 123\nRange(\"A3\").Value = Empty ' This is blank\nRange(\"A4\").Value = True\nRange(\"A5\").Formula = \"=1/0\" ' This is an error, but CountA counts errors\nDim nonBlankCount As Long\nnonBlankCount = Application.WorksheetFunction.CountA(rng)\nMsgBox \"A1:A5 中不為空的儲存格 (包括錯誤值) 數量: \" & nonBlankCount ' Expected: 4 (A1,A2,A4,A5)", "explanation": "計算範圍 A1:A5 中不為空的儲存格數量。注意 COUNTA 會將包含錯誤值 (如 #DIV/0!) 的儲存格也計入。"}
    ],
    "keywords": ["counta function", "excel counta vba", "count non-empty cells", "計數非空儲存格"]
},
// Data Types
{
    "name": "Null Constant (Variant)",
    "category": "資料類型、轉換與驗證",
    "syntax": "variantVariable = Null",
    "description": "Null 是一個關鍵字，表示 Variant 變數包含無效數據或沒有數據。它與 Empty (未初始化) 或零長度字串 (\" \") 或數值零 (0) 都不同。通常用於資料庫操作中表示欄位值未知或不存在。",
    "parameters": [],
    "examples": [
        {"code": "Dim myData As Variant\nmyData = Null ' Assign Null value\nIf IsNull(myData) Then\n  Debug.Print \"myData 包含 Null。\"\nEnd If\nIf myData <> 0 And myData <> \"\" And Not IsEmpty(myData) Then\n  Debug.Print \"(This won't print if myData is Null, as comparisons with Null yield Null)\"\nElseIf IsNull(myData)\n  Debug.Print \"直接與0或空字串比較 Null 會產生 Null，而不是 True/False。需用 IsNull 判斷。\"\nEnd If\n' Any expression containing Null usually evaluates to Null\nDim result As Variant\nresult = 10 + myData ' result will be Null\nDebug.Print \"10 + Null = Null is: \" & IsNull(result)", "explanation": "演示如何將 Null 賦予 Variant 變數，以及如何使用 IsNull 檢查。同時說明了包含 Null 的表達式通常會評估為 Null，以及直接比較 Null 與其他值 (如0或空字串) 的行為。"}
    ],
    "keywords": ["null constant", "variant null value", "isnull function", "database null", "無效數據Null"]
},
// Program Flow
{
    "name": "Erl Property (Error Line Number)",
    "category": "錯誤處理與調試",
    "syntax": "errorLine = Erl",
    "description": "在錯誤處理常式中，Erl 屬性傳回發生錯誤的程式行的行號 (如果該行有行號的話)。如果發生錯誤的行沒有行號，Erl 傳回 0。由於現代 VBA 程式碼通常不使用行號，Erl 的用途有限。Err.Source 提供了更實用的錯誤位置資訊。",
    "parameters": [],
    "examples": [
        {"code": "Sub TestErlProperty()\n  On Error GoTo ErrorHandler_Erl\n10  Dim x As Integer\n20  x = 10 / 0 ' Error occurs on line with number 20\n30  Exit Sub\nErrorHandler_Erl:\n  MsgBox \"錯誤發生在行號: \" & Erl & vbCrLf & _\n         \"錯誤描述: \" & Err.Description\nEnd Sub", "explanation": "此範例中，程式碼行使用了行號。當第20行的除零錯誤發生時，錯誤處理常式中的 Erl 會傳回 20。如果移除程式碼中的行號，Erl 會傳回 0。"}
    ],
    "keywords": ["erl property", "error line number", "vba line numbers", "錯誤行號"]
},
// External API
{
    "name": "WScript.Shell.ExpandEnvironmentStrings",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "expandedString = wshShell.ExpandEnvironmentStrings(StringContainingEnvVars As String)",
    "description": "展開包含環境變數 (例如 %TEMP%, %USERNAME%) 的字串，將環境變數替換為其目前的值。",
    "parameters": [
        {"name": "StringContainingEnvVars", "description": "必需。包含一個或多個用百分號 (%) 包圍的環境變數的字串。"}
    ],
    "examples": [
        {"code": "Dim wshShell As Object\nDim pathToExpand As String, expandedPath As String\nSet wshShell = CreateObject(\"WScript.Shell\")\npathToExpand = \"%USERPROFILE%\\Documents\\MyReport.docx\"\nexpandedPath = wshShell.ExpandEnvironmentStrings(pathToExpand)\nMsgBox \"原始路徑: \" & pathToExpand & vbCrLf & \"展開後路徑: \" & expandedPath\n\nDim appDataPath As String\nappDataPath = wshShell.ExpandEnvironmentStrings(\"%APPDATA%\\MyApplication\")\nDebug.Print \"應用程式資料路徑: \" & appDataPath\nSet wshShell = Nothing", "explanation": "使用 ExpandEnvironmentStrings 方法將包含 %USERPROFILE% 和 %APPDATA% 環境變數的字串展開為其實際路徑。"}
    ],
    "keywords": ["wscript.shell expandenvironmentstrings", "resolve environment variables", "expand path vba", "展開環境變數字串"]
},
{
    "name": "MSXML2.DOMDocument setProperty \"ProhibitDTD\" (Security)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "在處理來自不受信任來源的 XML 時，設定 MSXML2.DOMDocument 物件的 \"ProhibitDTD\" 屬性為 True 可以提高安全性。這會禁止處理 XML 文件中的文件類型定義 (DTD)，從而幫助防止某些類型的攻擊，例如 XML 外部實體 (XXE) 攻擊。預設值通常是 False (允許 DTD)。",
    "syntax": "xmlDoc.setProperty \"ProhibitDTD\", True",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object ' MSXML2.DOMDocument60\nDim xmlString As String\n' XML with a DTD that might try to access local file (conceptual XXE attempt)\nxmlString = \"<?xml version='1.0' encoding='UTF-8'?>\" & _\n            \"<!DOCTYPE foo [ <!ENTITY xxe SYSTEM 'file:///c:/windows/win.ini'> ]>\" & _\n            \"<foo>&xxe;</foo>\"\n\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\n\n' Prohibit DTD processing for security\nxmlDoc.setProperty \"ProhibitDTD\", True\n\nIf xmlDoc.LoadXML(xmlString) Then\n    Debug.Print \"XML 載入成功 (DTD 可能已被忽略或禁止)。\"\n    Debug.Print \"XML Content: \" & xmlDoc.XML\n    ' If DTD was prohibited, &xxe; entity would not be expanded.\nElse\n    Debug.Print \"XML 載入失敗: \" & xmlDoc.parseError.reason\nEnd If\n\n' Now try loading WITH DTD allowed (default or explicitly False)\nxmlDoc.setProperty \"ProhibitDTD\", False ' This is usually the default\nIf xmlDoc.LoadXML(xmlString) Then\n    Debug.Print \"XML 載入成功 (DTD 允許處理 - 可能有安全風險)。\"\n    Debug.Print \"XML Content (with DTD allowed): \" & xmlDoc.XML\n    ' If DTD processing is allowed and file access is possible, &xxe; might be expanded.\nElse\n    Debug.Print \"XML 載入失敗 (DTD 允許): \" & xmlDoc.parseError.reason\nEnd If\n\nSet xmlDoc = Nothing", "explanation": "演示如何設定 ProhibitDTD 屬性。當 ProhibitDTD 為 True 時，XML 文件中的 DTD (包括外部實體宣告) 將不會被處理，這有助於防範 XXE 攻擊。範例 XML 包含一個嘗試讀取本地檔案的外部實體。在實際測試中，MSXML 預設的安全設定可能已經阻止了此類本地檔案存取，但明確設定 ProhibitDTD 提供了額外的控制層。"}
    ],
    "keywords": ["msxml prohibitdtd", "xml security vba", "xxe prevention vba", "disable dtd processing", "禁止DTD處理", "XML安全"]
},
// Excel 核心操作
{
    "name": "Range.Style Property",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Style [= styleNameOrObject]",
    "description": "設定或傳回代表範圍樣式的 Style 物件或樣式名稱 (字串)。樣式是格式特徵 (如字型、數字格式、對齊方式) 的集合，可以命名並套用於儲存格。",
    "parameters": [{"name": "styleNameOrObject", "description": "樣式的名稱或 Style 物件。"}],
    "examples": [
        {"code": "Range(\"A1:C1\").Value = \"標題\"\n' Apply a built-in style\nRange(\"A1:C1\").Style = \"Heading 1\"\nMsgBox \"A1:C1 已套用 'Heading 1' 樣式。\"\n\n' Check current style\nIf Range(\"A1\").Style = \"Heading 1\" Then Debug.Print \"A1 的樣式是 Heading 1。\"\n\n' Create or modify a custom style (conceptual, usually done via UI or Styles collection)\n' Dim myStyle As Style\n' On Error Resume Next\n' Set myStyle = ActiveWorkbook.Styles(\"MyCustomDataStyle\")\n' If myStyle Is Nothing Then Set myStyle = ActiveWorkbook.Styles.Add(\"MyCustomDataStyle\")\n' On Error GoTo 0\n' If Not myStyle Is Nothing Then\n'   myStyle.Font.Bold = True\n'   myStyle.Interior.Color = vbYellow\n'   Range(\"A2:C5\").Style = \"MyCustomDataStyle\"\n' End If", "explanation": "將內建的 \"Heading 1\" 樣式套用於範圍 A1:C1。並概念性地展示了如何檢查樣式和建立/修改自訂樣式。"}
    ],
    "keywords": ["range style", "excel cell style", "apply style vba", "儲存格樣式", "套用樣式"]
},
{
    "name": "Name.RefersToLocal Property (Excel Named Range)",
    "category": "Excel 核心操作",
    "syntax": "nameObject.RefersToLocal [= formulaStringLocalA1]",
    "description": "設定或傳回已定義名稱所參照的公式，使用使用者語言和 A1 樣式參照。與 RefersTo (使用英文函數名稱和 A1 樣式) 和 RefersToR1C1Local (使用使用者語言和 R1C1 樣式) 相對應。",
    "parameters": [{"name": "formulaStringLocalA1", "description": "使用本地化函數名稱和 A1 樣式參照的公式字串。"}],
    "examples": [
        {"code": "Dim myName As Name\n' Create a name, RefersTo uses English SUM\nSet myName = ThisWorkbook.Names.Add(Name:=\"LocalTotal\", RefersTo:=\"=SUM(Sheet1!A1:A5)\")\n' Read its RefersToLocal property (will show SUM if Excel is English, or localized equivalent)\nMsgBox \"名稱 'LocalTotal' 的 RefersToLocal: \" & myName.RefersToLocal\n\n' Set using local formula (e.g., if Excel is German, use SUMME)\n' On Error Resume Next ' This will fail if Excel is not German and SUMME is not valid\n' myName.RefersToLocal = \"=SUMME(Sheet1!B1:B5)\" ' Example for German Excel\n' If Err.Number = 0 Then MsgBox \"RefersToLocal 已更新為德文 SUMME 公式。\" Else Err.Clear\n' On Error GoTo 0", "explanation": "建立一個已定義名稱，其 RefersTo 屬性使用標準英文函數名稱。然後讀取 RefersToLocal 屬性，它會以 Excel 目前的語言設定顯示該公式。同時，概念性地展示了如何使用本地化函數名稱設定 RefersToLocal。"}
    ],
    "keywords": ["name.referstolocal", "localized named range formula", "excel name refers to local", "本地化名稱參照"]
},
// Word
{
    "name": "Range.Revisions Property (Word Track Changes)",
    "category": "Word 文件處理",
    "syntax": "Set revsInRange = rangeObject.Revisions",
    "description": "傳回一個 Revisions 集合，代表指定範圍內的所有追蹤修訂。",
    "parameters": [],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\nDim rev As Object ' Word.Revision\n' Set selRange = Selection.Range\n' If selRange.Revisions.Count > 0 Then\n'   MsgBox \"選取範圍內有 \" & selRange.Revisions.Count & \" 個追蹤修訂。\"\n'   For Each rev In selRange.Revisions\n'     Debug.Print \"修訂類型: \" & rev.Type & \", 作者: \" & rev.Author & \", 日期: \" & rev.Date\n'     ' rev.Accept ' Or rev.Reject\n'   Next rev\n' Else\n'   MsgBox \"選取範圍內沒有追蹤修訂。\"\n' End If", "explanation": "如果目前選取範圍包含追蹤修訂，則計算修訂數量並遍歷每個修訂，列印其類型、作者和日期。"}
    ],
    "keywords": ["word range revisions", "get revisions in selection", "track changes range", "範圍內修訂"]
},
{
    "name": "Revision.Accept / .Reject (Word Track Changes)",
    "category": "Word 文件處理",
    "syntax": "revisionObject.Accept\nrevisionObject.Reject",
    "description": "Accept 方法接受指定的追蹤修訂。Reject 方法拒絕指定的追蹤修訂。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object, rev As Object ' Word.Revision\n' Set wdDoc = ActiveDocument\n' If wdDoc.Revisions.Count > 0 Then\n'   Set rev = wdDoc.Revisions(1) ' Get the first revision\n'   If MsgBox(\"接受第一個修訂 ('\" & Left(rev.Range.Text, 20) & \"...') 嗎?\", vbYesNo) = vbYes Then\n'     rev.Accept\n'     MsgBox \"第一個修訂已接受。\"\n'   Else\n'     rev.Reject\n'     MsgBox \"第一個修訂已拒絕。\"\n'   End If\n' End If", "explanation": "獲取文件中的第一個追蹤修訂，並根據使用者的選擇接受或拒絕它。"}
    ],
    "keywords": ["word accept revision", "word reject revision", "process track changes", "接受修訂", "拒絕修訂"]
},
// Outlook
{
    "name": "MailItem.PermissionTemplateGuid Property (Outlook IRM)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.PermissionTemplateGuid = guidString",
    "description": "設定或傳回一個字串，表示要套用於 MailItem 的資訊版權管理 (IRM) 權限範本的 GUID。此屬性與 Permission 屬性設為 olPermissionTemplate 時一起使用。",
    "parameters": [{"name": "guidString", "description": "權限範本的 GUID 字串。"}],
    "examples": [
        {"code": "Dim olMail As Object\n' Set olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\n' olMail.Subject = \"受IRM保護的郵件\"\n' olMail.To = \"user@example.com\"\n' olMail.Permission = olPermissionTemplate ' 2 = olPermissionTemplate\n' ' The GUID below is a placeholder, replace with an actual template GUID from your IRM server\n' olMail.PermissionTemplateGuid = \"{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\"\n' On Error Resume Next ' Applying IRM might fail if service not available or template invalid\n' olMail.Save ' Or .Send\n' If Err.Number = 0 Then\n'   MsgBox \"郵件已嘗試套用指定的IRM權限範本。\"\n' Else\n'   MsgBox \"套用IRM範本失敗: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "建立一封新郵件，將其權限類型設為使用範本，然後指定一個權限範本的 GUID 來套用 IRM 保護。需要有效的 IRM 環境和範本 GUID。"}
    ],
    "keywords": ["outlook irm template", "permissiontemplateguid", "apply irm policy", "IRM權限範本"]
},
{
    "name": "AppointmentItem.ResponseRequested Property (Outlook Meeting)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "apptItemObject.ResponseRequested = True | False",
    "description": "設定或傳回一個布林值，指出會議召集人是否要求與會者回覆此會議邀請。預設為 True。",
    "parameters": [{"name": "True | False", "description": "True 表示要求回覆。"}],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem\n' Set olAppt = Application.CreateItem(olAppointmentItem)\n' olAppt.MeetingStatus = olMeeting\n' olAppt.Subject = \"資訊分享會 (不需回覆)\"\n' olAppt.Start = Now + TimeValue(\"24:00:00\") ' Next day at current time\n' olAppt.Recipients.Add \"allstaff@example.com\"\n' olAppt.ResponseRequested = False ' Do not request responses\n' olAppt.Send\n' MsgBox \"已傳送不要求回覆的會議邀請。\"", "explanation": "建立一個會議邀請，並將其 ResponseRequested 屬性設為 False，這樣與會者就不會被明確要求回覆 (但他們仍然可以選擇回覆)。"}
    ],
    "keywords": ["outlook meeting response requested", "no response required meeting", "會議不需回覆"]
},
// PowerPoint
{
    "name": "Slide.SlideShowTransition.SoundEffect Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set se = slideObject.SlideShowTransition.SoundEffect",
    "description": "傳回一個 SoundEffect 物件，代表在投影片切換期間播放的聲音。",
    "parameters": [
        {"name": "SoundEffect.Name", "description": "聲音效果的名稱 (例如 \"Arrow\", \"Cash Register\")。"},
        {"name": "SoundEffect.ImportFromFile(FileName)", "description": "方法：從聲音檔案匯入聲音。"},
        {"name": "SoundEffect.Play()", "description": "方法：播放聲音效果。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, sst As Object ' PowerPoint.SlideShowTransition\nDim sound As Object ' PowerPoint.SoundEffect\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set sst = pptSlide.SlideShowTransition\n' sst.EntryEffect = ppEffectPushRight ' Example transition\n' Set sound = sst.SoundEffect\n' sound.Name = \"Applause\" ' Set to a built-in sound\n' ' Or import from file: sound.ImportFromFile \"C:\\Sounds\\MySound.wav\"\n' If sound.Name <> \"\" Then\n'   MsgBox \"第一張投影片的切換音效已設為: \" & sound.Name\n'   ' sound.Play ' Play the sound (might need UI context)\n' End If", "explanation": "設定第一張投影片的切換效果，並將其切換音效設為內建的 \"Applause\" 聲音。"}
    ],
    "keywords": ["powerpoint transition sound", "slideshow soundeffect", "切換音效"]
},
{
    "name": "Shape.OLEFormat Property (PowerPoint/Excel)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set oleFmt = shapeObject.OLEFormat",
    "description": "如果指定的圖案是 OLE 物件 (例如，嵌入的 Excel 工作表、Word 文件、音訊/視訊檔)，則傳回代表其 OLE 特性的 OLEFormat 物件。",
    "parameters": [
        {"name": "OLEFormat.Activate() / .Verb(VerbIndex)", "description": "方法：啟用 OLE 物件或執行其特定動作。"},
        {"name": "OLEFormat.Object", "description": "屬性：傳回 OLE 物件本身 (例如，如果嵌入 Excel 工作表，則傳回 Excel.Worksheet 物件)。"},
        {"name": "OLEFormat.ProgID", "description": "屬性：傳回 OLE 物件的程式設計識別碼。"}
    ],
    "examples": [
        {"code": "Dim shp As Object ' PowerPoint.Shape or Excel.Shape\nDim oleFormatObj As Object ' OLEFormat\nDim embeddedExcelSheet As Object ' Excel.Worksheet (if that's what's embedded)\n' ' Assume shp is a shape that is an embedded Excel sheet\n' ' Set shp = ActivePresentation.Slides(1).Shapes(\"Object 1\")\n' If shp.Type = msoEmbeddedOLEObject Then\n'   Set oleFormatObj = shp.OLEFormat\n'   MsgBox \"OLE 物件的 ProgID 是: \" & oleFormatObj.ProgID\n'   ' Activate the object for editing\n'   oleFormatObj.Activate\n'   ' Get the actual embedded object (e.g., Worksheet)\n'   Set embeddedExcelSheet = oleFormatObj.Object\n'   If Not embeddedExcelSheet Is Nothing And TypeName(embeddedExcelSheet) = \"Worksheet\" Then\n'     embeddedExcelSheet.Cells(1, 1).Value = \"已從VBA更新\"\n'     MsgBox \"嵌入的Excel工作表A1儲存格已更新。\"\n'     ' Need to handle closing/deactivating the OLE object server application\n'     ' embeddedExcelSheet.Parent.Application.Quit ' Or similar, depending on how it was activated\n'   End If\n' End If", "explanation": "如果選取的圖案是一個嵌入的 OLE 物件 (例如 Excel 工作表)，則獲取其 OLEFormat 物件，顯示其 ProgID，啟用它，然後嘗試存取其內部物件 (例如，Worksheet 物件) 並修改其內容。"}
    ],
    "keywords": ["oleformat", "embedded object vba", "activate ole object", "OLE物件格式", "通用"]
},
// FSO
{
    "name": "TextStream.Column Property (FSO - Read-only)",
    "category": "檔案與資料夾管理",
    "description": "TextStream 物件的 Column 屬性是一個唯讀的 Long，它傳回目前檔案指標在目前行中的欄位位置 (1-based)。",
    "syntax": "currentColumnNumber = textStreamObject.Column",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, ts As Object, char As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Set ts = fso.OpenTextFile(\"C:\\Temp\\MyText.txt\", 1) ' ForReading\n' If Not ts.AtEndOfStream Then\n'   char = ts.Read(5) ' Read first 5 characters\n'   Debug.Print \"讀取了 '\" & char & \"'。目前指標在第 \" & ts.Column & \" 欄。\" ' Column will be 6\n' End If\n' If Not ts.AtEndOfStream Then\n'   ts.ReadLine ' Read rest of the line\n'   Debug.Print \"讀完一行後，指標在下一行的第 \" & ts.Column & \" 欄。\" ' Column will be 1\n' End If\n' ts.Close\n' Set fso = Nothing: Set ts = Nothing", "explanation": "打開一個文字檔案，讀取前5個字元，然後顯示目前的欄位位置 (應為6)。接著讀取該行的剩餘部分，並顯示指標在新行開始時的欄位位置 (應為1)。"}
    ],
    "keywords": ["fso textstream column", "current column in file", "文字流目前欄位"]
},
// String
{
    "name": "InStr (Start Position and Compare Method)",
    "category": "字串與文本操作",
    "description": "InStr 函數的 start 引數指定搜尋的起始位置。compare 引數 (vbBinaryCompare, vbTextCompare, vbDatabaseCompare) 指定字串比較的方法。vbBinaryCompare (預設) 區分大小寫，vbTextCompare 不區分大小寫。",
    "syntax": "InStr([Start As Long = 1], String1 As String, String2 As String, [Compare As VbCompareMethod = vbBinaryCompare]) As Long",
    "parameters": [],
    "examples": [
        {"code": "Dim mainStr As String: mainStr = \"VBA is Fun, VBA is Powerful!\"\n' Case-sensitive search for \"VBA\" starting from 1st char\nDebug.Print \"InStr(1, mainStr, \"\"VBA\"\", vbBinaryCompare): \" & InStr(1, mainStr, \"VBA\", vbBinaryCompare) ' Output: 1\n' Case-insensitive search for \"vba\" starting from 1st char\nDebug.Print \"InStr(1, mainStr, \"\"vba\"\", vbTextCompare): \" & InStr(1, mainStr, \"vba\", vbTextCompare) ' Output: 1\n' Case-sensitive search for \"VBA\" starting AFTER the first one (e.g., after char 5)\nDebug.Print \"InStr(5, mainStr, \"\"VBA\"\", vbBinaryCompare): \" & InStr(5, mainStr, \"VBA\", vbBinaryCompare) ' Output: 14\n' Search for a non-existent substring\nDebug.Print \"InStr(1, mainStr, \"\"Python\"\", vbTextCompare): \" & InStr(1, mainStr, \"Python\", vbTextCompare) ' Output: 0", "explanation": "演示 InStr 函數如何使用起始位置和不同的比較方法 (區分/不區分大小寫) 來尋找子字串。"}
    ],
    "keywords": ["instr start position", "instr compare method", "vbtextcompare", "vbbinarycompare", "字串查找進階"]
},
// Math
{
    "name": "WorksheetFunction.CountIfs (Excel)",
    "category": "數學、日期與時間",
    "syntax": "countResult = Application.WorksheetFunction.CountIfs(Criteria_Range1, Criteria1, [Criteria_Range2, Criteria2], ...)",
    "description": "使用 Excel 的 COUNTIFS 工作表函數，計算一組儲存格中符合所有指定多個條件的儲存格數量。",
    "parameters": [
        {"name": "Criteria_Range1", "description": "必需。第一個要評估條件的範圍。"},
        {"name": "Criteria1", "description": "必需。應用於 Criteria_Range1 的第一個條件。"},
        {"name": "Criteria_RangeN, CriteriaN", "description": "可選。額外的條件範圍和條件。"}
    ],
    "examples": [
        {"code": "' A=Region, B=Product, C=Status\n' Range(\"A1:C5\").Value = Application.Transpose(Array(Array(\"East\",\"Apple\",\"Shipped\"),Array(\"West\",\"Apple\",\"Pending\"),Array(\"East\",\"Banana\",\"Shipped\"),Array(\"East\",\"Apple\",\"Shipped\"),Array(\"West\",\"Banana\",\"Delivered\")))\nDim countEastAppleShipped As Long\ncountEastAppleShipped = Application.WorksheetFunction.CountIfs(Range(\"A1:A5\"), \"East\", Range(\"B1:B5\"), \"Apple\", Range(\"C1:C5\"), \"Shipped\")\nMsgBox \"東區Apple且狀態為Shipped的記錄數: \" & countEastAppleShipped ' Should be 2", "explanation": "計算同時滿足三個條件的記錄數量：A欄為 \"East\"，B欄為 \"Apple\"，且C欄為 \"Shipped\"。"}
    ],
    "keywords": ["countifs", "multiple criteria count", "excel countifs vba", "多條件計數"]
},
// Data Types
{
    "name": "Error Constants (vbObjectError)",
    "category": "資料類型、轉換與驗證",
    "description": "vbObjectError 是一個 VBA 常數 (值為 -2147221504 或 &H80040000)，用作使用者定義錯誤號碼的基數。當使用 `Err.Raise` 產生自訂錯誤時，建議將您的錯誤號碼設為 `vbObjectError + N` (其中 N 是大於等於 512 的數字)，以避免與 VBA 內建的錯誤號碼衝突。",
    "parameters": [],
    "examples": [
        {"code": "Sub GenerateCustomAppError()\n  Const MY_APP_ERROR_INVALID_INPUT As Long = vbObjectError + 1001\n  On Error GoTo HandleIt\n  Dim inputVal As String: inputVal = InputBox(\"Enter 'X':\")\n  If UCase(inputVal) <> \"X\" Then\n    Err.Raise MY_APP_ERROR_INVALID_INPUT, \"MyApp.Validation\", \"輸入的值不是 'X'。\"\n  End If\n  MsgBox \"輸入正確！\"\n  Exit Sub\nHandleIt:\n  If Err.Number = MY_APP_ERROR_INVALID_INPUT Then\n    MsgBox \"應用程式錯誤 \" & (Err.Number - vbObjectError) & \": \" & Err.Description & \" (來自: \" & Err.Source & \")\"\n  Else\n    MsgBox \"發生未處理的錯誤: \" & Err.Description\n  End If\nEnd Sub", "explanation": "定義一個基於 vbObjectError 的自訂錯誤號碼。如果使用者輸入的不是 \"X\"，則使用 Err.Raise 引發此自訂錯誤。錯誤處理程序會捕獲它並顯示相關信息。"}
    ],
    "keywords": ["vbojecterror", "user-defined error numbers", "custom error code", "err.raise custom", "自訂錯誤號碼"]
},
// Program Flow
{
    "name": "CallByName (Setting Properties)",
    "category": "程式流程與結構控制",
    "description": "CallByName 函數的 CallType 引數設為 vbLet (對於值類型屬性) 或 vbSet (對於物件類型屬性) 時，可以用於在執行階段動態設定物件的屬性值。",
    "syntax": "CallByName MyObject, \"PropertyName\", vbLet, NewValue ' For value type property\nCallByName MyObject, \"ObjectPropertyName\", vbSet, NewObjectValue ' For object type property",
    "parameters": [],
    "examples": [
        {"code": "Dim sh As Worksheet\nSet sh = ThisWorkbook.Sheets(1)\nDim propName As String: propName = \"Name\"\nDim newSheetName As String: newSheetName = \"MyRenamedSheet\"\n\n' Dynamically set the Name property (which is a value type - String)\nCallByName sh, propName, vbLet, newSheetName\nMsgBox \"工作表名稱已透過 CallByName 更新為: \" & sh.Name\n\n' Example for an object property (conceptual, Tab is read-only mostly for color)\n' Dim tabObj As Object ' Tab\n' Set tabObj = sh.Tab\n' CallByName tabObj, \"Color\", vbLet, RGB(255,0,0) ' Tab.Color needs RGB long value\n' If sh.Tab.Color = RGB(255,0,0) Then MsgBox \"工作表標籤顏色已設為紅色。\"", "explanation": "第一個範例使用 CallByName 和 vbLet 動態地將工作表的 Name 屬性設定為 \"MyRenamedSheet\"。第二個範例概念性地展示了如何設定物件的屬性 (例如 Tab.Color)，但實際中 Tab.Color 是直接賦值的。vbSet 主要用於設定物件參考。"}
    ],
    "keywords": ["callbyname set property", "vblet", "vbset", "dynamic property assignment", "動態設定屬性"]
},
// External API
{
    "name": "CreateObject(\"Msxml2.XMLHTTP.6.0\") - Methods and Properties",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "MSXML2.XMLHTTP.6.0 物件 (或其早期版本) 用於發送 HTTP/HTTPS 請求並接收回應。主要方法和屬性包括：\n.open(Method, URL, Async): 初始化請求。\n.send([Body]): 發送請求。Body 用於 POST/PUT 請求。\n.setRequestHeader(Header, Value): 設定請求標頭。\n.status: HTTP 狀態碼 (例如 200, 404)。\n.statusText: HTTP 狀態文字 (例如 \"OK\", \"Not Found\")。\n.responseText: 以字串形式傳回回應體。\n.responseXML: 如果回應是 XML，則傳回一個 DOMDocument 物件。\n.responseBody: 以位元組陣列形式傳回回應體 (可用於二進制數據)。\n.readyState: 請求狀態 (0-4，4表示完成)。\n.onreadystatechange: 事件處理程序，用於非同步操作。",
    "syntax": "Set http = CreateObject(\"Msxml2.XMLHTTP.6.0\")\nhttp.open \"GET\", \"url_here\", False\nhttp.send\nIf http.Status = 200 Then response = http.responseText",
    "parameters": [],
    "examples": [
        {"code": "Dim httpReq As Object, apiUrl As String, jsonData As String\nSet httpReq = CreateObject(\"MSXML2.XMLHTTP.6.0\")\napiUrl = \"https://jsonplaceholder.typicode.com/posts/1\" ' Example public API\n\nOn Error GoTo HttpError\nhttpReq.Open \"GET\", apiUrl, False ' False for synchronous\nhttpReq.SetRequestHeader \"Content-Type\", \"application/json\"\nhttpReq.SetRequestHeader \"Accept\", \"application/json\"\nhttpReq.Send\n\nIf httpReq.Status = 200 Then\n  jsonData = httpReq.responseText\n  Debug.Print \"API 回應 (JSON 字串):\"\n  Debug.Print jsonData\n  ' Here you would typically parse the jsonData if it's JSON\nElse\n  Debug.Print \"API 請求失敗。狀態: \" & httpReq.Status & \" - \" & httpReq.StatusText\nEnd If\nGoTo CleanUpHttp\nHttpError:\n  Debug.Print \"HTTP請求時發生錯誤: \" & Err.Description\nCleanUpHttp:\n  Set httpReq = Nothing", "explanation": "建立一個 MSXML2.XMLHTTP.6.0 物件，向一個公共的 JSON API 端點發送 GET 請求。它設定了 Content-Type 和 Accept 標頭。如果請求成功 (狀態碼 200)，則將回應的 JSON 字串列印到立即視窗。包含基本的錯誤處理。"}
    ],
    "keywords": ["msxml2.xmlhttp methods", "http request vba", "send http get", "setrequestheader", "http status response", "HTTP請求方法屬性"]
},
{
    "name": "ADODB.Connection (CursorLocation Property)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Connection 物件的 CursorLocation 屬性決定了資料指標引擎的位置。它可以是：\n`adUseClient` (3): 使用客戶端資料指標程式庫。這允許更豐富的功能，如離線操作、多表 Recordset、某些排序和篩選功能，但所有資料通常會先傳輸到客戶端。\n`adUseServer` (2): 使用資料提供者或驅動程式提供的伺服器端資料指標。這通常更快地開啟 Recordset，因為資料是按需提取的，但某些客戶端功能可能受限。\n預設值取決於提供者。對於某些操作 (如 Recordset 的某些 Filter 或 Sort 功能，或斷開連接的 Recordset)，可能需要 `adUseClient`。",
    "syntax": "conn.CursorLocation = adUseClient ' Or adUseServer",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object ' ADODB.Connection\nDim rs As Object   ' ADODB.Recordset\nDim connStr As String\n' connStr = \"Provider=Microsoft.ACE.OLEDB.12.0;Data Source=C:\\YourDB.accdb;\"\n\nSet conn = CreateObject(\"ADODB.Connection\")\n' Set cursor location to client-side before opening connection or recordset\nconn.CursorLocation = 3 ' adUseClient\n\n' On Error Resume Next\n' conn.Open connStr\n' If conn.State = 1 Then\n'   Set rs = CreateObject(\"ADODB.Recordset\")\n'   ' Client-side cursor allows for disconnected recordsets and more flexible sorting/filtering\n'   rs.Open \"SELECT * FROM Orders\", conn, 3, 3, 1 ' adOpenStatic, adLockOptimistic, adCmdText\n'   If Not rs.EOF Then\n'     Debug.Print \"第一筆訂單ID (客戶端資料指標): \" & rs.Fields(0).Value\n'     ' Example of a feature often better with client-side cursor: Filtering\n'     rs.Filter = \"ShipCity = 'London'\"\n'     If Not rs.EOF Then Debug.Print \"倫敦的第一筆訂單ID: \" & rs.Fields(0).Value Else Debug.Print \"倫敦無訂單。\"\n'   End If\n'   rs.Close\n'   conn.Close\n' Else\n'   Debug.Print \"資料庫連接失敗。\"\n' End If\n' On Error GoTo 0\n' Set rs = Nothing: Set conn = Nothing", "explanation": "在開啟 ADODB 連接之前，將 CursorLocation 設定為 adUseClient。這使得之後開啟的 Recordset 使用客戶端資料指標，從而支援更豐富的功能，例如在此範例中，對 Recordset 進行本地篩選。"}
    ],
    "keywords": ["adodb cursorlocation", "aduseclient", "aduseserver", "client-side cursor", "server-side cursor", "資料指標位置ADO"]
},
{
    "name": "MSXML2.DOMDocument (Load with Validation)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "MSXML2.DOMDocument 的 `validateOnParse` 屬性 (預設通常為 True，但依版本可能不同) 決定了在載入 XML 時是否根據 DTD 或 Schema 進行驗證。如果 `validateOnParse = True` 且文件包含 DTD/Schema 引用，則解析器會嘗試驗證。如果 `async = False` (同步載入)，則 `Load` 或 `LoadXML` 方法會傳回一個布林值指示成功與否，並且可以檢查 `xmlDoc.parseError` 物件以獲取詳細的驗證錯誤信息。",
    "syntax": "xmlDoc.async = False\nxmlDoc.validateOnParse = True\nsuccess = xmlDoc.Load(xmlSource)\nIf Not success Or xmlDoc.parseError.errorCode <> 0 Then ...",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object ' MSXML2.DOMDocument60\nDim validXml As String, invalidXmlAgainstSchema As String\nDim schemaContent As String, schemaCache As Object\nDim loadResult As Boolean\n\n' --- Create a simple XSD schema ---\nschemaContent = \"<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>\" & _\n                \"<xs:element name='note'><xs:complexType><xs:sequence>\" & _\n                \"<xs:element name='to' type='xs:string'/>\" & _\n                \"<xs:element name='from' type='xs:string'/>\" & _\n                \"<xs:element name='heading' type='xs:string'/>\" & _\n                \"<xs:element name='body' type='xs:string'/>\" & _\n                \"</xs:sequence></xs:complexType></xs:element></xs:schema>\"\n\nvalidXml = \"<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me!</body></note>\"\n' Invalid XML: 'sender' instead of 'from', 'subject' instead of 'heading'\ninvalidXmlAgainstSchema = \"<note><to>Tove</to><sender>Jani</sender><subject>Reminder</subject><body>Don't forget!</body></note>\"\n\n' --- Load schema into a SchemaCache ---\nSet schemaCache = CreateObject(\"MSXML2.SchemaCache.6.0\")\nOn Error Resume Next ' Adding an invalid schema string would error here\nschemaCache.Add \"urn:my-schema\", schemaContent ' Namespace and schema content/file\nIf Err.Number <> 0 Then Debug.Print \"SchemaCache.Add 失敗: \" & Err.Description: Exit Sub\nOn Error GoTo 0\n\n' --- Configure DOMDocument for validation ---\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\nxmlDoc.validateOnParse = True ' Enable validation during parsing\nSet xmlDoc.schemas = schemaCache ' Assign the schema cache\n\n' --- Attempt to load INVALID XML ---\nDebug.Print \"--- 嘗試載入無效XML (應觸發驗證錯誤) ---\"\nloadResult = xmlDoc.LoadXML(invalidXmlAgainstSchema)\nIf Not loadResult Or xmlDoc.parseError.errorCode <> 0 Then\n    Debug.Print \"XML 載入/驗證失敗 (預期中):\"\n    Debug.Print \"  錯誤碼: \" & xmlDoc.parseError.errorCode\n    Debug.Print \"  原因: \" & xmlDoc.parseError.reason\n    Debug.Print \"  行: \" & xmlDoc.parseError.Line & \", 位置: \" & xmlDoc.parseError.linepos\nElse\n    Debug.Print \"無效XML意外地通過驗證。\"\nEnd If\n\n' --- Attempt to load VALID XML ---\n' Re-assign schemas as LoadXML might clear it or state\nSet xmlDoc.schemas = schemaCache \nDebug.Print \"--- 嘗試載入有效XML (應通過驗證) ---\"\nloadResult = xmlDoc.LoadXML(validXml)\nIf Not loadResult Or xmlDoc.parseError.errorCode <> 0 Then\n    Debug.Print \"有效XML載入/驗證失敗:\"\n    Debug.Print \"  錯誤碼: \" & xmlDoc.parseError.errorCode & \", 原因: \" & xmlDoc.parseError.reason\nElse\n    Debug.Print \"有效XML已成功載入並驗證。根元素: \" & xmlDoc.documentElement.nodeName\nEnd If\n\nSet xmlDoc = Nothing: Set schemaCache = Nothing", "explanation": "此範例首先定義一個簡單的XSD Schema和兩個XML字串（一個符合Schema，一個不符合）。然後，它將Schema載入到一個MSXML2.SchemaCache物件中。接著，它配置一個DOMDocument物件，將`validateOnParse`設為True，並將SchemaCache指派給`schemas`屬性。然後，它分別嘗試載入無效和有效的XML字串。當載入無效XML時，由於`validateOnParse`為True，`LoadXML`方法應傳回False，並且`xmlDoc.parseError`物件會包含驗證錯誤的詳細信息。載入有效XML時則應成功。"}
    ],
    "keywords": ["msxml validateonparse", "xml schema validation vba", "xsd validation vba", "load xml with validation", "XML Schema驗證"]
},
// Excel 核心操作
{
    "name": "Range.Errors Property / Error Object (Excel Error Checking)",
    "category": "Excel 核心操作",
    "syntax": "Set errObj = rangeObject.Errors(Index)\nerrValue = errObj.Value ' XlErrorChecks constant\nignoreError = errObj.Ignore",
    "description": "Range.Errors 屬性傳回一個 Errors 集合，代表範圍中被 Excel 的錯誤檢查功能標記的所有錯誤。每個 Error 物件代表一個特定的錯誤。",
    "parameters": [
        {"name": "Errors(Index)", "description": "Errors 集合的 Item 方法，傳回單個 Error 物件。"},
        {"name": "Error.Value (Boolean)", "description": "如果儲存格中存在指定類型的錯誤檢查，則為 True。引數是 XlErrorChecks 常數 (例如 xlEvaluateToError, xlTextDate, xlNumberAsText, xlInconsistentFormula, xlUnlockedFormulaCells)。"},
        {"name": "Error.Ignore (Boolean)", "description": "True 表示忽略此錯誤檢查。設為 True 以隱藏綠色錯誤指示器。"}
    ],
    "examples": [
        {"code": "Dim cellWithError As Range, specificError As Error\nSet cellWithError = Range(\"A1\")\n' Create some errors for demonstration\ncellWithError.Formula = \"=1/0\" ' #DIV/0!\nRange(\"A2\").Value = \"'00123\" ' Number stored as text\nRange(\"A3\").Formula = \"=SUM(B1:B2)\" ' Inconsistent formula if B3 has =SUM(C1:C2)\n\nOn Error Resume Next ' Accessing .Errors or .Value on a cell with no specific error type can error\n' Check for #DIV/0! in A1 (xlEvaluateToError should be True)\nIf cellWithError.Errors.Item(xlEvaluateToError).Value = True Then\n    MsgBox \"A1 包含一個計算錯誤 (例如 #DIV/0!)。\"\n    ' cellWithError.Errors.Item(xlEvaluateToError).Ignore = True ' Ignore this error type\nEnd If\n\n' Check for number stored as text in A2\nIf Range(\"A2\").Errors.Item(xlNumberAsText).Value = True Then\n    MsgBox \"A2 包含儲存為文字的數字。\"\n    ' Range(\"A2\").Errors.Item(xlNumberAsText).Ignore = True\nEnd If\nOn Error GoTo 0", "explanation": "在儲存格 A1 中建立一個 #DIV/0! 錯誤，在 A2 中建立一個數字存儲為文本的錯誤。然後，程式碼檢查這些儲存格的 Errors 集合中是否存在對應類型的錯誤檢查 (xlEvaluateToError, xlNumberAsText)。註解部分顯示了如何忽略這些錯誤。"}
    ],
    "keywords": ["range.errors", "excel error checking vba", "xlEvaluateToError", "xlNumberAsText", "ignore error excel", "儲存格錯誤檢查"]
},
{
    "name": "Workbook.XmlMaps Property (Excel XML Maps)",
    "category": "Excel 核心操作",
    "syntax": "Set xmlMapsColl = workbookObject.XmlMaps",
    "description": "傳回一個 XmlMaps 集合，代表新增到指定活頁簿的 XML 對應。",
    "parameters": [
        {"name": "XmlMap.Name", "description": "XML 對應的名稱。"},
        {"name": "XmlMap.DataBinding.LoadSettings(Url)", "description": "從 XML 檔案或 URL 載入 XML 資料到對應。"},
        {"name": "XmlMap.DataBinding.Refresh()", "description": "重新整理 XML 對應的資料。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook, xmlMap As XmlMap\nSet wb = ThisWorkbook\nIf wb.XmlMaps.Count > 0 Then\n  MsgBox \"此活頁簿包含 \" & wb.XmlMaps.Count & \" 個 XML 對應。\"\n  For Each xmlMap In wb.XmlMaps\n    Debug.Print \"XML 對應名稱: \" & xmlMap.Name\n    If xmlMap.IsExportable Then Debug.Print \"  (可匯出)\"\n    ' Example: Refresh data for this map if it's linked to a source\n    ' On Error Resume Next\n    ' xmlMap.DataBinding.Refresh\n    ' If Err.Number <> 0 Then Debug.Print \"  刷新 \" & xmlMap.Name & \" 失敗: \" & Err.Description\n    ' Err.Clear; On Error GoTo 0\n  Next xmlMap\nElse\n  MsgBox \"此活頁簿沒有 XML 對應。\"\nEnd If", "explanation": "檢查目前活頁簿是否包含任何 XML 對應。如果包含，則列印每個 XML 對應的名稱，並概念性地展示如何刷新與 XML 對應關聯的數據 (如果適用)。"}
    ],
    "keywords": ["xml maps excel", "workbook xmlmaps", "xml data binding", "XML對應"]
},
{
    "name": "Worksheet.ListObjects.Add (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "Set newTable = worksheetObject.ListObjects.Add(SourceType As XlListObjectSourceType, Source, [LinkSource As Boolean], [XlListObjectHasHeaders As XlYesNoGuess = xlNo], [Destination], [TableStyleName As String])",
    "description": "在工作表上建立一個新的 Excel 表格 (ListObject)。",
    "parameters": [
        {"name": "SourceType", "description": "必需。XlListObjectSourceType 常數 (例如 xlSrcRange, xlSrcQuery)。"},
        {"name": "Source", "description": "必需。來源資料。對於 xlSrcRange，這是一個 Range 物件。"},
        {"name": "XlListObjectHasHeaders", "description": "可選。指定 Source 是否包含標頭。"},
        {"name": "Destination", "description": "可選。如果 SourceType 不是 xlSrcRange，則為放置表格的 Range。"},
        {"name": "TableStyleName", "description": "可選。要套用的表格樣式名稱。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet, tbl As ListObject, srcRange As Range\nSet ws = ActiveSheet\n' Define source data range (A1:C5 for example, with headers in row 1)\nSet srcRange = ws.Range(\"A1:C5\")\n' ws.Range(\"A1:C5\").Value = Application.Transpose(Array(Array(\"ID\",\"Product\",\"Sales\"),Array(1,\"A\",100),Array(2,\"B\",150),Array(3,\"C\",120),Array(4,\"D\",200))) ' Sample data\n\n' Delete existing table with the same name if it exists to avoid error\nOn Error Resume Next\nws.ListObjects(\"MyNewSalesTable\").Delete\nOn Error GoTo 0\n\nSet tbl = ws.ListObjects.Add(SourceType:=xlSrcRange, Source:=srcRange, XlListObjectHasHeaders:=xlYes, TableStyleName:=\"TableStyleMedium2\")\ntbl.Name = \"MyNewSalesTable\"\nMsgBox \"已從範圍 \" & srcRange.Address & \" 建立一個名為 '\" & tbl.Name & \"' 的新 Excel 表格。\"", "explanation": "從活動工作表上的 A1:C5 範圍 (假設包含標頭) 建立一個新的 Excel 表格，並套用中等樣式2，然後將其命名為 \"MyNewSalesTable\"。"}
    ],
    "keywords": ["listobjects.add", "create excel table vba", "new listobject", "建立Excel表格"]
},
// Word
{
    "name": "Selection.HomeKey / .EndKey (wdStory)",
    "category": "Word 文件處理",
    "syntax": "selectionObject.HomeKey Unit:=wdStory\nselectionObject.EndKey Unit:=wdStory",
    "description": "使用 wdStory 作為 Unit 引數，HomeKey 會將插入點移動到文件的最開頭，EndKey 會將其移動到文件的最末尾。",
    "parameters": [{"name": "Unit:=wdStory (Constant 6)", "description": "表示整個文件主要內容區域。"}],
    "examples": [
        {"code": "Dim sel As Object ' Word.Selection\n' Set sel = Application.Selection\n' sel.EndKey Unit:=wdStory ' Move to the very end of the document\n' sel.TypeParagraph\n' sel.TypeText \"--- 文件結束 (已透過EndKey跳轉) ---\"\n'\n' sel.HomeKey Unit:=wdStory ' Move to the very beginning\n' sel.InsertBefore \"[文件起始標記] \"", "explanation": "將插入點移動到文件的最末尾並輸入文字，然後再移動到文件的最開頭並插入文字。"}
    ],
    "keywords": ["word homekey wdstory", "word endkey wdstory", "goto document start end", "跳至文件頭尾"]
},
{
    "name": "Table.ConvertToText (Word)",
    "category": "Word 文件處理",
    "syntax": "Set textRange = tableObject.ConvertToText([Separator As WdCharacterSeparator = wdSeparateByParagraphs], [NestedTables As Boolean = True])",
    "description": "將表格轉換為純文字，並傳回代表該文字的 Range 物件。原始表格會被刪除。",
    "parameters": [
        {"name": "Separator", "description": "可選。WdCharacterSeparator 常數，指定用於分隔原儲存格內容的字元 (例如 wdSeparateByTabs, wdSeparateByCommas, wdSeparateByParagraphs)。"},
        {"name": "NestedTables", "description": "可選。True 表示也轉換巢狀表格。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, tblToConvert As Object ' Word.Table\n' Set wdDoc = ActiveDocument\n' If wdDoc.Tables.Count > 0 Then\n'   Set tblToConvert = wdDoc.Tables(1)\n'   If MsgBox(\"是否將第一個表格轉換為以Tab分隔的文字？\", vbYesNo) = vbYes Then\n'     tblToConvert.ConvertToText Separator:=0 ' 0 = wdSeparateByParagraphs (default); 1 = wdSeparateByTabs\n'     MsgBox \"第一個表格已轉換為文字。\"\n'   End If\n' End If", "explanation": "如果文件中有表格，則將第一個表格轉換為文字，使用Tab字元分隔原來的儲存格內容。"}
    ],
    "keywords": ["word table to text", "converttotext", "表格轉文字Word"]
},
{
    "name": "Range.ConvertToTable (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newTable = rangeObject.ConvertToTable([Separator As WdTableFieldSeparator = wdSeparateByParagraphs], [NumRows], [NumColumns], [InitialColumnWidth], [Format As WdTableFormat], [ApplyBands], ...)",
    "description": "將指定的文字範圍轉換為表格。",
    "parameters": [
        {"name": "Separator", "description": "可選。WdTableFieldSeparator 常數，指示文字中用於分隔儲存格內容的字元。"},
        {"name": "NumRows / NumColumns", "description": "可選。如果省略，Word 會根據內容自動決定。"}
    ],
    "examples": [
        {"code": "Dim textRange As Object ' Word.Range\nDim newTbl As Object ' Word.Table\n' ' Create some tab-separated text first\n' Selection.TypeText \"Name\" & vbTab & \"Age\" & vbTab & \"City\" & vbCrLf\n' Selection.TypeText \"John\" & vbTab & \"30\" & vbTab & \"New York\" & vbCrLf\n' Selection.TypeText \"Jane\" & vbTab & \"25\" & vbTab & \"London\" & vbCrLf\n' ' Select the text just inserted\n' Set textRange = ActiveDocument.Range(Start:=Selection.Start - (Len(\"Name...London\" & vbCrLf & vbCrLf) + Len(\"Name...City\" & vbCrLf)), End:=Selection.Start)\n' ' Convert the selected tab-separated text to a table\n' If Not textRange Is Nothing And Len(textRange.Text) > 5 Then ' Basic check\n'    Set newTbl = textRange.ConvertToTable(Separator:=wdSeparateByTabs, AutoFit:=True)\n'    newTbl.Style = \"淺色格線 - 強調色彩 1\" ' Apply a table style\n'    MsgBox \"選取的Tab分隔文字已轉換為表格。\"\n' End If", "explanation": "先創建一些以Tab分隔的文字，然後選取這些文字，並使用 ConvertToTable 將其轉換為一個表格。"}
    ],
    "keywords": ["word text to table", "converttotable", "文字轉表格Word"]
},
// Outlook
{
    "name": "Recipient.Resolved Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "isResolved = recipientObject.Resolved",
    "description": "如果收件者已對照 Outlook 通訊錄成功解析，則傳回 True。唯讀布林值。在新增收件者後，應呼叫 `Recipients.ResolveAll` 或 `Recipient.Resolve` 方法來嘗試解析。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object, recip As Object ' Outlook.Recipient\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nSet recip = olMail.Recipients.Add(\"nonexistent_user_xyz123\") ' An unresolved name\nrecip.Resolve ' Attempt to resolve\nIf recip.Resolved Then\n  MsgBox \"收件者 '\" & recip.Name & \"' 已成功解析。地址: \" & recip.Address\nElse\n  MsgBox \"收件者 '\" & recip.Name & \"' 未能解析。請檢查名稱或地址。\"\nolMail.Display ' Show the mail item, unresolved recipient will be underlined or prompted\nEnd If", "explanation": "新增一個可能無法解析的收件者，然後嘗試解析它，並檢查 Resolved 屬性以確定是否成功。"}
    ],
    "keywords": ["outlook recipient resolved", "resolve recipient address", "check email address validity", "解析收件者"]
},
{
    "name": "AppointmentItem.AllDayEvent Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "apptItemObject.AllDayEvent = True | False",
    "description": "如果約會是整天事件 (不佔用特定時間段)，則為 True。讀取/寫入布林值。設定為 True 時，Outlook 通常會忽略 Start 和 End 時間的時間部分。",
    "parameters": [{"name": "True | False", "description": "True 表示為整天事件。"}],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem\nSet olAppt = CreateObject(\"Outlook.Application\").CreateItem(1)\nolAppt.Subject = \"公司年度假期\"\nolAppt.AllDayEvent = True\nolAppt.Start = DateSerial(Year(Date), 12, 25) ' Set to December 25th\n' Duration is implicitly 1 day for AllDayEvent, End date might adjust accordingly\nolAppt.BusyStatus = olFree ' Mark as Free time for an all-day holiday\nolAppt.Display", "explanation": "建立一個新的整天事件，設定其主旨和開始日期 (結束日期會自動調整或被視為一整天)，並將忙碌狀態設為空閒。"}
    ],
    "keywords": ["outlook alldayevent", "create all-day appointment", "整天事件"]
},
// PowerPoint
{
    "name": "Slide.SlideShowTransition.AdvanceOnClick / .AdvanceOnTime",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideObject.SlideShowTransition.AdvanceOnClick = MsoTriStateConstant\nslideObject.SlideShowTransition.AdvanceOnTime = MsoTriStateConstant\nslideObject.SlideShowTransition.AdvanceTime = Seconds",
    "description": "AdvanceOnClick: 如果投影片在滑鼠點擊時換頁，則為 msoTrue。\nAdvanceOnTime: 如果投影片在指定時間後自動換頁，則為 msoTrue。\nAdvanceTime: 自動換頁的時間 (秒)。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object\n' Set pptSlide = ActivePresentation.Slides(1)\n' With pptSlide.SlideShowTransition\n'   .AdvanceOnClick = msoFalse ' Disable advance on click\n'   .AdvanceOnTime = msoTrue   ' Enable advance on time\n'   .AdvanceTime = 5         ' Advance after 5 seconds\n' End With\n' MsgBox \"第一張投影片已設定為5秒後自動換頁，且禁用滑鼠點擊換頁。\"", "explanation": "設定第一張投影片取消滑鼠點擊換頁，並在5秒後自動換到下一張投影片。"}
    ],
    "keywords": ["powerpoint slide advance settings", "advance on time", "advance on click", "投影片換頁設定"]
},
{
    "name": "ShapeRange.Align (RelativeToPage)",
    "category": "PowerPoint 簡報製作",
    "syntax": "shapeRangeObject.Align(AlignCmd As MsoAlignCmd, RelativeTo As MsoTriState)",
    "description": "Align 方法的 RelativeTo 引數設為 msoTrue 時，圖案會相對於整個投影片 (或頁面) 進行對齊，而不是相對於選取的圖案組。",
    "parameters": [{"name": "RelativeTo:=msoTrue", "description": "相對於投影片/頁面對齊。"}],
    "examples": [
        {"code": "Dim pptSlide As Object, shp1 As Object, shp2 As Object\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set shp1 = pptSlide.Shapes.AddShape(msoShapeRectangle, 50, 50, 100, 50)\n' Set shp2 = pptSlide.Shapes.AddShape(msoShapeOval, 200, 100, 80, 80)\n' ' Select both shapes\n' pptSlide.Shapes.Range(Array(shp1.Name, shp2.Name)).Select\n' ' Align selected shapes to the center of the slide\n' Selection.ShapeRange.Align msoAlignCenter, msoTrue ' Align horizontally to slide center\n' Selection.ShapeRange.Align msoAlignMiddle, msoTrue ' Align vertically to slide center\n' MsgBox \"兩個圖案已相對於投影片中央對齊。\"", "explanation": "建立兩個圖案，選取它們，然後使用 Align 方法將它們相對於整個投影片水平和垂直置中。"}
    ],
    "keywords": ["powerpoint align shapes to slide", "align relative to page", "圖案相對於投影片對齊"]
},
// FSO
{
    "name": "FileSystemObject.GetFile (Error Handling)",
    "category": "檔案與資料夾管理",
    "description": "如果使用 GetFile 方法嘗試獲取一個不存在的檔案，會產生執行階段錯誤 53「找不到檔案」。應使用錯誤處理來檢查檔案是否存在，或先用 FileExists 方法確認。",
    "syntax": "On Error Resume Next\nSet fileObj = fso.GetFile(NonExistentPath)\nIf Err.Number = 53 Then ...",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myFile As Object\nDim testPath As String: testPath = \"C:\\Path\\That\\DoesNotExist\\file.txt\"\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nOn Error Resume Next\nSet myFile = fso.GetFile(testPath)\nIf Err.Number = 53 Then\n  MsgBox \"使用 GetFile 找不到檔案: \" & testPath & vbCrLf & \"錯誤: \" & Err.Description\nElseIf Err.Number = 0 And Not myFile Is Nothing Then\n  MsgBox \"檔案 '\" & myFile.Name & \"' 存在 (這不應發生於此範例)。\"\nElseIf Err.Number <> 0 Then\n  MsgBox \"獲取檔案時發生其他錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\nSet fso = Nothing: Set myFile = Nothing", "explanation": "嘗試使用 GetFile 獲取一個不存在的檔案。透過 On Error Resume Next 捕獲錯誤 53，並顯示相應的訊息。"}
    ],
    "keywords": ["fso getfile error 53", "file not found fso", "handle getfile error", "GetFile錯誤處理"]
},
{
    "name": "TextStream.AtEndOfLine (vs AtEndOfStream)",
    "category": "檔案與資料lger管理",
    "description": "AtEndOfLine: 如果檔案指標緊接在行結束標記之前 (例如，在讀取了一行中的大部分字元但尚未讀取換行符時)，則傳回 True。主要用於逐字元讀取並想知道何時到達行尾。\nAtEndOfStream: 如果檔案指標位於檔案的結尾 (沒有更多字元可讀取)，則傳回 True。\n在逐行讀取 (例如使用 ReadLine) 的迴圈中，通常使用 AtEndOfStream 作為迴圈終止條件。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, ts As Object, tempFile As String, char As String, lineContent As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\ntempFile = fso.GetSpecialFolder(2).Path & \"\\\" & fso.GetTempName\n' Create a test file\nSet ts = fso.CreateTextFile(tempFile, True)\nts.WriteLine \"Line1-Part1 Line1-Part2\"\nts.WriteLine \"Line2\"\nts.Close\n\n' Read and demonstrate properties\nSet ts = fso.OpenTextFile(tempFile, 1) ' ForReading\nDebug.Print \"--- 讀取第一個字元 ---\"\nchar = ts.Read(1)\nDebug.Print \"字元: '\" & char & \"', AtEndOfLine: \" & ts.AtEndOfLine & \", AtEndOfStream: \" & ts.AtEndOfStream & \", Line: \" & ts.Line\n\nDebug.Print \"--- 讀取直到第一行結尾 ---\"\nDo While Not ts.AtEndOfLine And Not ts.AtEndOfStream\n  char = ts.Read(1)\n  Debug.Print \"字元: '\" & char & \"', AtEndOfLine: \" & ts.AtEndOfLine & \", Line: \" & ts.Line\nLoop\n' Now AtEndOfLine should be True (if not also AtEndOfStream)\nIf Not ts.AtEndOfStream Then Debug.Print \"(已在第一行結尾)\"\n\n' Read the newline character itself (ReadLine does this implicitly)\nIf Not ts.AtEndOfStream Then ts.Read(Len(vbCrLf)) ' Assuming Windows newline\n\nDebug.Print \"--- 讀取第二行 ---\"\nIf Not ts.AtEndOfStream Then\n  lineContent = ts.ReadLine\n  Debug.Print \"讀取的行: '\" & lineContent & \"', AtEndOfLine (after ReadLine): \" & ts.AtEndOfLine & \", AtEndOfStream: \" & ts.AtEndOfStream & \", Line: \" & ts.Line\nEnd If\nts.Close\nfso.DeleteFile tempFile, True\nSet fso = Nothing: Set ts = Nothing", "explanation": "建立一個臨時文字檔案，然後逐字元讀取第一行，演示 AtEndOfLine 在讀到行尾換行符前如何變為 True。然後使用 ReadLine 讀取第二行，並顯示 ReadLine 後 AtEndOfLine 的狀態 (通常會變為 False，因為指標已移到下一行開頭或檔案結尾)。"}
    ],
    "keywords": ["textstream atendofline", "textstream atendofstream", "read character by character", "逐字元讀取檔案"]
},
// String
{
    "name": "InStrRev (Compare Argument)",
    "category": "字串與文本操作",
    "description": "InStrRev 函數的 compare 引數與 InStr 的類似，允許指定比較方法：vbBinaryCompare (預設，區分大小寫) 或 vbTextCompare (不區分大小寫)。",
    "syntax": "InStrRev(StringCheck, StringMatch, [Start As Long = -1], [Compare As VbCompareMethod = vbBinaryCompare]) As Long",
    "parameters": [],
    "examples": [
        {"code": "Dim myText As String: myText = \"Report_Final_Report_Draft.xlsx\"\nDim lastOccurrence1 As Long, lastOccurrence2 As Long\n' Find last occurrence of \"Report\" (case-sensitive)\nlastOccurrence1 = InStrRev(myText, \"Report\", -1, vbBinaryCompare)\nDebug.Print \"vbBinaryCompare - 最後的 'Report' 在位置: \" & lastOccurrence1 ' Output: 14\n\n' Find last occurrence of \"report\" (case-insensitive)\nlastOccurrence2 = InStrRev(myText, \"report\", -1, vbTextCompare)\nDebug.Print \"vbTextCompare - 最後的 'report' 在位置: \" & lastOccurrence2 ' Output: 14", "explanation": "演示 InStrRev 如何使用 vbBinaryCompare (區分大小寫) 和 vbTextCompare (不區分大小寫) 來從字串尾部反向查找子字串。在此範例中，由於目標字串中的 \"Report\" 都是大寫開頭，所以兩種比較結果相同。如果 `myText` 包含 \"report\" (小寫)，則結果會不同。"}
    ],
    "keywords": ["instrrev compare method", "reverse find case insensitive", "vbtextcompare instrrev", "反向查找比較"]
},
// Math
{
    "name": "Fix Function (vs Int for Positive Numbers)",
    "category": "數學、日期與時間",
    "description": "對於非負數，Fix(number) 和 Int(number) 傳回相同的結果，即數字的整數部分 (直接截斷小數部分)。",
    "parameters": [],
    "examples": [
        {"code": "Dim num1 As Double: num1 = 123.45\nDim num2 As Double: num2 = 789.999\nDim num3 As Double: num3 = 50.0\n\nDebug.Print \"Fix(\" & num1 & \") = \" & Fix(num1) & \", Int(\" & num1 & \") = \" & Int(num1)\nDebug.Print \"Fix(\" & num2 & \") = \" & Fix(num2) & \", Int(\" & num2 & \") = \" & Int(num2)\nDebug.Print \"Fix(\" & num3 & \") = \" & Fix(num3) & \", Int(\" & num3 & \") = \" & Int(num3)", "explanation": "演示對於正數和小數，Fix 和 Int 函數都傳回數字的整數部分，行為一致。"}
    ],
    "keywords": ["fix vs int positive numbers", "truncate positive", "integer part positive", "正數取整Fix與Int"]
},
// Data Types
{
    "name": "vbObjectError (Constant Value)",
    "category": "資料類型、轉換與驗證",
    "description": "vbObjectError 是一個 VBA 錯誤處理常數，其值為 -2147221504 (或十六進制的 &H80040000)。當使用 `Err.Raise` 產生使用者定義的應用程式特定錯誤時，通常將此常數作為基數，然後加上一個大於等於 512 的數字來建立唯一的錯誤號碼，以避免與 VBA 內建的錯誤號碼 (0-1000 範圍內) 衝突。",
    "parameters": [],
    "examples": [
        {"code": "Debug.Print \"vbObjectError 的值是: \" & vbObjectError\nDebug.Print \"vbObjectError 的十六進制值是: \" & Hex(vbObjectError)\n\nDim customErrorNum1 As Long, customErrorNum2 As Long\ncustomErrorNum1 = vbObjectError + 512\ncustomErrorNum2 = vbObjectError + 1000\n\nDebug.Print \"第一個自訂錯誤號: \" & customErrorNum1\nDebug.Print \"第二個自訂錯誤號: \" & customErrorNum2\n\n' Example of raising such an error\n' On Error Resume Next\n' Err.Raise customErrorNum1, \"MySource\", \"This is a custom application error.\"\n' Debug.Print \"Raised Error: \" & Err.Number & \" - \" & Err.Description", "explanation": "顯示 vbObjectError 常數的十進制和十六進制值，並演示如何基於它建立兩個自訂錯誤號碼。"}
    ],
    "keywords": ["vbojecterror value", "user-defined error base", "custom error number range", "vbObjectError值"]
},
// Program Flow
{
    "name": "Declare PtrSafe Function (Conditional Compilation for 32/64 bit)",
    "category": "程式流程與結構控制",
    "description": "為了使包含 Windows API 呼叫的 VBA 程式碼能夠在32位元和64位元版本的 Office 中都能正確執行，需要使用條件式編譯。\n`#If VBA7 Then` 檢查 VBA 版本 (VBA7 對應 Office 2010 及更新版本)。\n`#If Win64 Then` 在 VBA7 環境下檢查 Office 是否為64位元版本。\n對於64位元 Office，Declare 語句必須包含 `PtrSafe` 關鍵字，並且任何指向記憶體位址的參數或函數傳回值 (例如控制代碼 HWND, 指標) 如果在32位元下是 Long，則在64位元下應使用 `LongPtr` 類型。",
    "syntax": "#If VBA7 Then\n  #If Win64 Then ' 64-bit Office\n    Private Declare PtrSafe Function MyApiFunc Lib \"kernel32\" (ByVal Arg1 As LongPtr) As Boolean\n  #Else ' 32-bit Office\n    Private Declare Function MyApiFunc Lib \"kernel32\" (ByVal Arg1 As Long) As Boolean\n  #End If\n#Else ' Office 2007 or earlier (always 32-bit VBA)\n  Private Declare Function MyApiFunc Lib \"kernel32\" (ByVal Arg1 As Long) As Boolean\n#End If",
    "parameters": [],
    "examples": [
        {"code": "' Example: GetCurrentProcessId API call\n#If VBA7 Then\n    Private Declare PtrSafe Function GetCurrentProcessId Lib \"kernel32\" () As Long\n#Else\n    Private Declare Function GetCurrentProcessId Lib \"kernel32\" () As Long\n#End If\n' Note: GetCurrentProcessId itself returns Long, not LongPtr, but PtrSafe is still needed for 64-bit declare.\n\nSub ShowProcessID()\n    Dim procID As Long\n    procID = GetCurrentProcessId()\n    MsgBox \"目前 Excel 程序的 Process ID 是: \" & procID\nEnd Sub", "explanation": "演示如何使用條件式編譯為 GetCurrentProcessId API 函數提供兼容32位元和64位元 Office 的 Declare 語句。即使此特定 API 的傳回值是 Long，在64位元下仍需 PtrSafe。如果參數或傳回值是指標或控制代碼，則還需將 Long 改為 LongPtr (對於64位元)。"}
    ],
    "keywords": ["declare ptrsafe longptr", "vba 64-bit api", "conditional compilation api", "win64 vba", "32位元64位元API宣告"]
},
// External API
{
    "name": "WScript.Shell.ExpandEnvironmentStrings (Error if Var Not Found)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "如果傳遞給 WScript.Shell 的 ExpandEnvironmentStrings 方法的字串包含一個無法解析的環境變數 (即系統中不存在該變數)，則該方法會將該部分 (例如 %NonExistentVar%) 原樣保留在傳回的字串中，而不會產生錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Dim wshShell As Object\nDim pathWithValidVar As String, pathWithInvalidVar As String\nDim expandedValid As String, expandedInvalid As String\nSet wshShell = CreateObject(\"WScript.Shell\")\n\npathWithValidVar = \"%SystemRoot%\\System32\"\nexpandedValid = wshShell.ExpandEnvironmentStrings(pathWithValidVar)\nDebug.Print \"有效變數展開: \" & expandedValid ' e.g., C:\\Windows\\System32\n\npathWithInvalidVar = \"%NON_EXISTENT_VAR%\\MyFolder\"\nexpandedInvalid = wshShell.ExpandEnvironmentStrings(pathWithInvalidVar)\nDebug.Print \"無效變數展開: \" & expandedInvalid ' Output: %NON_EXISTENT_VAR%\\MyFolder\n\nIf expandedInvalid = pathWithInvalidVar Then\n  Debug.Print \"環境變數 %NON_EXISTENT_VAR% 未被展開，可能不存在。\"\nEnd If\nSet wshShell = Nothing", "explanation": "演示當 ExpandEnvironmentStrings 方法遇到無法解析的環境變數時，它會將該變數原樣保留在結果字串中。"}
    ],
    "keywords": ["expandenvironmentstrings unknown variable", "wsh environment variable not found", "展開不存在的環境變數"]
},
{
    "name": "ADODB.Recordset (CursorLocation for Client-Side Operations)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "將 ADODB Connection 或 Recordset 物件的 CursorLocation 屬性設為 `adUseClient` (3) 會啟用客戶端資料指標服務。這對於執行某些在伺服器端資料指標下可能不受支援或效率低下的操作非常重要，例如：\n1. 創建斷開連接的 Recordset (將 Recordset 的 ActiveConnection 設為 Nothing 後仍可使用)。\n2. 對 Recordset 進行本地排序 (`Recordset.Sort = \"FieldName ASC\"`)。\n3. 對 Recordset 進行本地篩選 (`Recordset.Filter = \"FieldName > 10\"`)。\n4. 使用 Recordset 的某些屬性，如 `PageCount`, `AbsolutePage`, `AbsolutePosition`。\n5. 構建要綁定到某些控制項 (如 MS Hierarchical FlexGrid) 的 Recordset。",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object, rs As Object\nDim connStr As String, sqlStr As String\n' connStr = \"Provider=Microsoft.ACE.OLEDB.12.0;Data Source=C:\\Temp\\Northwind.mdb;\" ' Example for Access\nsqlStr = \"SELECT ProductName, UnitPrice, CategoryID FROM Products\"\n\nSet conn = CreateObject(\"ADODB.Connection\")\nSet rs = CreateObject(\"ADODB.Recordset\")\n\nconn.CursorLocation = 3 ' adUseClient (MUST be set before opening connection or recordset for some providers)\n' conn.Open connStr\n\n' rs.CursorLocation = 3 ' Can also be set on Recordset before opening if connection is not set first\n' rs.Open sqlStr, conn, 3, 1 ' adOpenStatic, adLockReadOnly\n\n' If Not rs.EOF Then\n'   ' Client-side sorting\n'   rs.Sort = \"UnitPrice DESC\" ' Sort by UnitPrice descending\n'   Debug.Print \"--- Sorted by UnitPrice DESC (Client-side) ---\"\n'   Do While Not rs.EOF\n'     Debug.Print rs!ProductName & \": \" & rs!UnitPrice\n'     rs.MoveNext\n'   Loop\n'   rs.MoveFirst ' Reset for next operation\n'\n'   ' Client-side filtering\n'   rs.Filter = \"CategoryID = 1 AND UnitPrice > 20\"\n'   Debug.Print \"--- Filtered: CategoryID=1 AND UnitPrice > 20 (Client-side) ---\"\n'   Do While Not rs.EOF\n'     Debug.Print rs!ProductName & \": \" & rs!UnitPrice\n'     rs.MoveNext\n'   Loop\n' End If\n' If rs.State = 1 Then rs.Close\n' If conn.State = 1 Then conn.Close\n' Set rs = Nothing: Set conn = Nothing\nMsgBox \"(概念性)演示了客戶端資料指標的排序和篩選。需有實際資料庫。\"", "explanation": "演示如何將 Connection 的 CursorLocation 設為 `adUseClient`，然後對從資料庫獲取的 Recordset 執行客戶端的排序和篩選操作。這對於不希望或無法在資料庫伺服器端執行這些操作的情況很有用。"}
    ],
    "keywords": ["adodb client-side cursor", "recordset.sort vba", "recordset.filter vba", "aduseclient features", "客戶端資料指標操作"]
},
// Excel 核心操作
{
    "name": "Range.FormatConditions.Count (Excel Conditional Formatting)",
    "category": "Excel 核心操作",
    "syntax": "numberOfConditions = rangeObject.FormatConditions.Count",
    "description": "傳回指定範圍上條件格式規則的數量。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").FormatConditions.Delete ' Clear first\nRange(\"A1\").FormatConditions.Add Type:=xlCellValue, Operator:=xlGreater, Formula1:=\"10\"\nRange(\"A1\").FormatConditions.Add Type:=xlCellValue, Operator:=xlLess, Formula1:=\"5\"\nMsgBox \"儲存格 A1 上有 \" & Range(\"A1\").FormatConditions.Count & \" 個條件格式規則。\"", "explanation": "為A1儲存格新增兩個條件格式規則，然後顯示該儲存格的條件格式規則總數。"}
    ],
    "keywords": ["formatconditions.count", "number of conditional formats", "條件格式數量"]
},
{
    "name": "Range.FormatConditions.Item(Index).Delete (Excel Conditional Formatting)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormatConditions.Item(Index).Delete",
    "description": "刪除指定範圍上特定索引的條件格式規則。",
    "parameters": [{"name": "Index", "description": "必需。要刪除的條件格式規則的索引號 (1-based)。"}],
    "examples": [
        {"code": "' Assume A1 has at least one conditional format rule\n' If Range(\"A1\").FormatConditions.Count > 0 Then\n'   Range(\"A1\").FormatConditions.Item(1).Delete\n'   MsgBox \"A1儲存格的第一個條件格式規則已被刪除。\"\n' Else\n'   MsgBox \"A1儲存格沒有條件格式可刪除。\"\n' End If", "explanation": "如果A1儲存格存在條件格式，則刪除其第一個條件格式規則。"}
    ],
    "keywords": ["delete specific conditional format", "remove formatcondition item", "刪除特定條件格式"]
},
// Word
{
    "name": "Document.Styles(WdBuiltinStyleConstant) (Word)",
    "category": "Word 文件處理",
    "syntax": "Set heading1Style = documentObject.Styles(wdStyleHeading1)",
    "description": "使用 WdBuiltinStyle 常數來存取文件中的內建樣式物件。",
    "parameters": [{"name": "WdBuiltinStyleConstant", "description": "例如 wdStyleNormal, wdStyleHeading1, wdStyleHyperlink。"}],
    "examples": [
        {"code": "Dim wdDoc As Object, h1Style As Object ' Word.Style\n' Set wdDoc = ActiveDocument\n' Set h1Style = wdDoc.Styles(wdStyleHeading1) ' -2 = wdStyleHeading1\n' MsgBox \"內建 'Heading 1' 樣式的基礎樣式是: \" & h1Style.BaseStyle & vbCrLf & _\n       \"字型: \" & h1Style.Font.Name & \", \" & h1Style.Font.Size & \"pt\"\n' h1Style.Font.Color = wdColorAutomatic ' Change a property of the style definition", "explanation": "獲取活動文件中內建的 \"Heading 1\" 樣式物件，並顯示其部分屬性。也可以修改這些屬性來改變整個文件中使用該樣式的所有文字的外觀。"}
    ],
    "keywords": ["word builtin styles", "wdstyleheading1", "access style object", "內建樣式Word"]
},
{
    "name": "Range.Style Property (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Style = styleNameOrObject",
    "description": "設定或傳回指定範圍的樣式。可以是樣式的名稱 (字串) 或 Style 物件。",
    "parameters": [{"name": "styleNameOrObject", "description": "樣式的名稱或 Style 物件。"}],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' selRange.Style = wdStyleNormal ' Apply Normal style\n' MsgBox \"選取範圍已套用 'Normal' 樣式。\"\n'\n' ' Create and apply a new style (if it doesn't exist)\n' Dim myParaStyle As Object ' Word.Style\n' On Error Resume Next\n' Set myParaStyle = ActiveDocument.Styles(\"MyEmphasis\")\n' If myParaStyle Is Nothing Then\n'   Set myParaStyle = ActiveDocument.Styles.Add(\"MyEmphasis\", wdStyleTypeParagraph)\n'   myParaStyle.Font.Italic = True\n'   myParaStyle.Font.ColorIndex = wdBlue\n' End If\n' On Error GoTo 0\n' If Not myParaStyle Is Nothing Then selRange.Style = myParaStyle", "explanation": "將目前選取範圍的樣式設為 \"Normal\" (標準)。並示範如何建立一個名為 \"MyEmphasis\" 的自訂段落樣式 (如果不存在)，然後將其套用於選取範圍。"}
    ],
    "keywords": ["word range style", "apply paragraph style word", "set text style word", "套用樣式Word"]
},
// Outlook
{
    "name": "MailItem.Categories (Clearing/Checking Multiple)",
    "category": "Outlook 郵件與項目管理",
    "description": "MailItem 的 Categories 屬性是一個字串，多個類別之間用逗號和/或分號分隔 (取決於Outlook版本和設定，通常是逗號後接空格)。要清除所有類別，將其設為空字串。要檢查是否包含特定類別，通常使用 InStr 函數。",
    "syntax": "mailItem.Categories = \"CategoryA, CategoryB\"\nIf InStr(1, mailItem.Categories, \"CategoryA\", vbTextCompare) > 0 Then ...\nmailItem.Categories = \"\" ' Clear all categories",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.CreateItem(olMailItem)\n' olMail.Categories = \"Project Alpha, Urgent, Review\"\n' Debug.Print \"初始類別: \" & olMail.Categories\n'\n' ' Check if a category exists\n' If InStr(1, olMail.Categories, \"Urgent\", vbTextCompare) > 0 Then\n'   Debug.Print \"郵件已標記為 Urgent。\"\n' End If\n'\n' ' Add a new category (append, ensuring no duplicates if needed)\n' Dim newCat As String: newCat = \"FollowUp\"\n' If InStr(1, olMail.Categories, newCat, vbTextCompare) = 0 Then\n'   If olMail.Categories <> \"\" Then\n'     olMail.Categories = olMail.Categories & \", \" & newCat\n'   Else\n'     olMail.Categories = newCat\n'   End If\n' End If\n' Debug.Print \"新增後類別: \" & olMail.Categories\n'\n' ' Remove a specific category (more complex, involves string manipulation)\n' Dim catToRemove As String: catToRemove = \"Urgent\"\n' Dim arrCats() As String, newCats As String, i As Long\n' If InStr(1, olMail.Categories, catToRemove, vbTextCompare) > 0 Then\n'    arrCats = Split(olMail.Categories, \",\")\n'    newCats = \"\"\n'    For i = LBound(arrCats) To UBound(arrCats)\n'        If Trim(arrCats(i)) <> catToRemove Then\n'            If newCats <> \"\" Then newCats = newCats & \", \"\n'            newCats = newCats & Trim(arrCats(i))\n'        End If\n'    Next i\n'    olMail.Categories = newCats\n' End If\n' Debug.Print \"移除 'Urgent' 後類別: \" & olMail.Categories\n'\n' olMail.Display ' For testing\n' ' olMail.Close olDiscard", "explanation": "演示如何設定多個類別、檢查特定類別是否存在、新增新類別到現有類別字串，以及從類別字串中移除特定類別。移除類別的邏輯需要更仔細的字串處理以應對逗號和空格。"}
    ],
    "keywords": ["outlook categories manipulation", "add multiple categories", "remove category vba", "check email category", "郵件類別管理"]
},
{
    "name": "TaskItem.StatusUpdateRecipients Property (Outlook Task)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "taskItemObject.StatusUpdateRecipients = recipientNamesString",
    "description": "設定或傳回一個以分號分隔的字串，其中包含在任務狀態更新時應收到狀態報告的收件者顯示名稱。僅當任務被指派後此屬性才相關。",
    "parameters": [{"name": "recipientNamesString", "description": "分號分隔的收件者名稱。"}],
    "examples": [
        {"code": "Dim olTask As Object ' Outlook.TaskItem\n' Set olTask = Application.CreateItem(olTaskItem)\n' olTask.Subject = \"需要狀態更新的任務\"\n' ' Assume task is assigned to someone else first using olTask.Assign\n' ' After assignment, if you are tracking it or are the delegator:\n' ' olTask.StatusUpdateRecipients = \"manager@example.com;supervisor@example.com\"\n' ' olTask.Save\n' If olTask.StatusUpdateRecipients <> \"\" Then\n'   MsgBox \"此任務的狀態更新將傳送給: \" & olTask.StatusUpdateRecipients\n' End If", "explanation": "如果一個任務已被指派，則可以設定 StatusUpdateRecipients 屬性，以便在被指派人更新任務狀態時，指定的收件者會收到通知。"}
    ],
    "keywords": ["outlook task status update recipients", "task progress notification", "任務狀態更新通知"]
},
// PowerPoint
{
    "name": "Slide.Shapes.Range(Array).Group / .Ungroup (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set groupedShape = slideObject.Shapes.Range(Array(\"ShapeName1\", \"ShapeName2\")).Group",
    "description": "與 Excel 類似，可以選取投影片上的一組圖案 (透過名稱或索引的陣列傳遞給 Shapes.Range)，然後使用 Group 方法將它們組合成單個 GroupShape。Ungroup 則反向操作。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim shp1 As Object, shp2 As Object, grp As Object ' PowerPoint.Shape, PowerPoint.GroupShape\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set shp1 = pptSlide.Shapes.AddShape(msoShapeRectangle, 50, 50, 100, 50)\n' shp1.Name = \"RectPPT1\"\n' Set shp2 = pptSlide.Shapes.AddShape(msoShapeOval, 70, 70, 100, 50)\n' shp2.Name = \"OvalPPT1\"\n'\n' If pptSlide.Shapes.Count >= 2 Then\n'   Set grp = pptSlide.Shapes.Range(Array(\"RectPPT1\", \"OvalPPT1\")).Group\n'   grp.Name = \"MyPPTGroup\"\n'   MsgBox \"已在PPT中將 'RectPPT1' 和 'OvalPPT1' 群組為 '\" & grp.Name & \"'.\"\n'   ' grp.Ungroup ' To ungroup\n' End If", "explanation": "在 PowerPoint 投影片上建立兩個圖案，為它們命名，然後使用 Shapes.Range 和名稱陣列來選取這兩個圖案，並將它們群組。"}
    ],
    "keywords": ["powerpoint group shapes", "powerpoint ungroup shapes", "shaperange group ppt", "群組PPT圖案"]
},
{
    "name": "TextRange.InsertDateTime (PowerPoint Shape Text)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set newTextRange = textRangeObject.InsertDateTime([DateTimeFormat As PpDateTimeFormat = ppDateTimeMdyy], [InsertAsField As MsoTriState = msoFalse], [InsertAsFullWidth As MsoTriState = msoFalse], [LanguageID As MsoLanguageID = msoLanguageIDNone])",
    "description": "在指定的文字範圍中插入日期和/或時間，並傳回代表新插入文字的 TextRange 物件。",
    "parameters": [
        {"name": "DateTimeFormat", "description": "PpDateTimeFormat 常數，指定日期/時間格式。"},
        {"name": "InsertAsField", "description": "msoTrue 表示插入為可自動更新的功能變數。"}
    ],
    "examples": [
        {"code": "Dim shpTextBox As Object ' PowerPoint.Shape\nDim tr As Object ' PowerPoint.TextRange\n' Set shpTextBox = ActivePresentation.Slides(1).Shapes.AddTextbox(msoTextOrientationHorizontal, 50, 200, 300, 30)\n' Set tr = shpTextBox.TextFrame.TextRange\n' tr.Text = \"報告日期: \"\n' tr.InsertAfter ' Move insertion point to end\n' Dim insertedDateRange As Object\n' Set insertedDateRange = tr.InsertDateTime(DateTimeFormat:=ppDateTimeMMMMdyyyy, InsertAsField:=msoTrue)\n' insertedDateRange.Font.Bold = True\n' MsgBox \"已在文字方塊中插入可更新的日期。\"", "explanation": "在投影片上的文字方塊中，先插入 \"報告日期: \"，然後在其後插入目前日期 (長格式)，並將其作為可更新的功能變數，同時將插入的日期文字設為粗體。"}
    ],
    "keywords": ["powerpoint insert datetime textrange", "add date to shape ppt", "textrange insertdatetime", "文字框插入日期PPT"]
},
// FSO
{
    "name": "FileSystemObject.File.Attributes (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "fileObject.Attributes = newAttributeConstant\ncurrentAttributes = fileObject.Attributes",
    "description": "設定或傳回檔案的屬性。可以使用 VbFileAttribute 常數 (例如 vbReadOnly, vbHidden, vbSystem, vbArchive, vbNormal) 的組合。要新增屬性而不影響其他屬性，使用 `file.Attributes = file.Attributes Or vbNewAttribute`。要移除屬性，使用 `file.Attributes = file.Attributes Xor vbAttributeToToggle` (如果已知目前狀態) 或 `file.Attributes = file.Attributes And (Not vbAttributeToRemove)`。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myFile As Object\nDim filePath As String: filePath = \"C:\\Temp\\TestAttribute.txt\"\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Create a dummy file if it doesn't exist\n' If Not fso.FileExists(filePath) Then fso.CreateTextFile filePath\nSet myFile = fso.GetFile(filePath)\n\nDebug.Print \"原始屬性: \" & myFile.Attributes\n' Set to ReadOnly and Hidden\nmyFile.Attributes = vbReadOnly Or vbHidden\nDebug.Print \"設定為唯讀和隱藏後: \" & myFile.Attributes\nIf (myFile.Attributes And vbReadOnly) = vbReadOnly Then Debug.Print \"  檔案是唯讀的。\"\nIf (myFile.Attributes And vbHidden) = vbHidden Then Debug.Print \"  檔案是隱藏的。\"\n\n' Add Archive attribute without affecting others\nmyFile.Attributes = myFile.Attributes Or vbArchive\nDebug.Print \"新增封存屬性後: \" & myFile.Attributes\n\n' Remove ReadOnly attribute\nmyFile.Attributes = myFile.Attributes And (Not vbReadOnly)\nDebug.Print \"移除唯讀屬性後: \" & myFile.Attributes\nIf Not ((myFile.Attributes And vbReadOnly) = vbReadOnly) Then Debug.Print \"  檔案不再是唯讀的。\"\n\nmyFile.Attributes = vbNormal ' Reset to Normal\nDebug.Print \"重設為正常後: \" & myFile.Attributes\nSet fso = Nothing: Set myFile = Nothing", "explanation": "演示如何讀取、設定和修改檔案的屬性，例如將檔案設為唯讀和隱藏，然後新增封存屬性，最後移除唯讀屬性並將其重設為正常。"}
    ],
    "keywords": ["fso file attributes", "set file readonly vba", "set file hidden vba", "vbfileattribute", "檔案屬性FSO"]
},
// String
{
    "name": "Replace (Count Argument = 0)",
    "category": "字串與文本操作",
    "description": "如果 Replace 函數的 count 引數設為 0，則不會執行任何取代，函數會傳回原始 expression 的副本。",
    "syntax": "Replace(expression, find, replace, [start], 0, [compare])",
    "parameters": [],
    "examples": [
        {"code": "Dim original As String: original = \"AABBAA\"\nDim result As String\nresult = Replace(original, \"A\", \"X\", 1, 0) ' Count = 0 means no replacements\nDebug.Print \"原始字串: '\" & original & \"'\"\nDebug.Print \"使用 Count=0 取代後: '\" & result & \"' (應與原始相同)\"\nIf result = original Then Debug.Print \"結果與原始字串相同。\"", "explanation": "演示當 Replace 函數的 count 引數為 0 時，即使 find 子字串存在，也不會執行任何取代操作。"}
    ],
    "keywords": ["replace count zero", "no replacement vba", "Replace零次數"]
},
// Math
{
    "name": "Sgn Function (Return Values)",
    "category": "數學、日期與時間",
    "description": "Sgn(number) 函數傳回一個整數，指示數字的符號：\n如果 number > 0, Sgn(number) 傳回 1。\n如果 number = 0, Sgn(number) 傳回 0。\n如果 number < 0, Sgn(number) 傳回 -1。",
    "syntax": "Sgn(Number)",
    "parameters": [],
    "examples": [
        {"code": "Debug.Print \"Sgn(123.45) = \" & Sgn(123.45) ' Output: 1\nDebug.Print \"Sgn(0) = \" & Sgn(0)         ' Output: 0\nDebug.Print \"Sgn(-0.001) = \" & Sgn(-0.001) ' Output: -1\nDebug.Print \"Sgn(-999) = \" & Sgn(-999)   ' Output: -1", "explanation": "演示 Sgn 函數對於正數、零和負數的傳回值。"}
    ],
    "keywords": ["sgn function", "sign of number", "positive negative zero", "取數字符號"]
},
// Data Types
{
    "name": "CByte (Range and Error)",
    "category": "資料類型、轉換與驗證",
    "description": "CByte 函數將運算式轉換為 Byte 資料類型 (0 到 255)。如果運算式的值超出此範圍，或者無法轉換為數字，則會產生執行階段錯誤 6「溢位」或錯誤 13「類型不符」。小數部分會被四捨五入。",
    "parameters": [],
    "examples": [
        {"code": "Dim b As Byte\nOn Error Resume Next\nb = CByte(120) ' Valid\nDebug.Print \"CByte(120) = \" & b & \", Error: \" & Err.Number\nErr.Clear\nb = CByte(255.4) ' Valid, rounds to 255\nDebug.Print \"CByte(255.4) = \" & b & \", Error: \" & Err.Number\nErr.Clear\nb = CByte(255.5) ' Valid, rounds to 256, then overflows for Byte\nDebug.Print \"CByte(255.5) (Value before assignment if no error): \" & CInt(255.5) & \", Assigned Byte: \" & b & \", Error: \" & Err.Number ' Error 6\nErr.Clear\nb = CByte(-1)    ' Error 6: Overflow\nDebug.Print \"CByte(-1), Assigned Byte: \" & b & \", Error: \" & Err.Number\nErr.Clear\nb = CByte(\"abc\") ' Error 13: Type mismatch\nDebug.Print \"CByte(\"\"abc\"\"), Assigned Byte: \" & b & \", Error: \" & Err.Number\nErr.Clear\nOn Error GoTo 0", "explanation": "演示 CByte 函數對於有效值、邊界值、超出範圍值和無效字串的轉換行為及其產生的錯誤。注意 255.5 會四捨五入到 256，這對於 Byte 類型會溢位。"}
    ],
    "keywords": ["cbyte range", "cbyte error", "byte overflow", "convert to byte error", "CByte範圍與錯誤"]
},
// Program Flow
{
    "name": "DoEvents (Loop with User Input)",
    "category": "程式流程與結構控制",
    "description": "如果在一個長時間執行的 Do...Loop 或 For...Next 迴圈中需要允許使用者與 Excel 互動 (例如，點擊一個「取消」按鈕บน UserForm 或工作表)，則必須在迴圈內部定期呼叫 DoEvents。否則，Excel 介面將會凍結，無法回應使用者輸入。",
    "parameters": [],
    "examples": [
        {"code": "Public StopLoopNow As Boolean ' Module-level flag, can be set by a UserForm button\nSub LongLoopWithCancelOption()\n  Dim i As Long\n  StopLoopNow = False ' Reset flag\n  ' ' Assume UserForm 'ufCancelLoop' has a button that sets StopLoopNow = True\n  ' ufCancelLoop.Show vbModeless ' Show form modelessly\n  Application.StatusBar = \"處理中... (可透過表單取消)\"\n  For i = 1 To 10000000 ' Very long loop\n    ' Your processing here\n    If i Mod 10000 = 0 Then ' Check periodically\n      DoEvents ' Crucial to process events, including UserForm button clicks\n      If StopLoopNow Then\n        MsgBox \"處理已被使用者取消於 i = \" & i\n        Exit For\n      End If\n    End If\n  Next i\n  Application.StatusBar = False\n  ' If Not ufCancelLoop Is Nothing Then Unload ufCancelLoop\n  If Not StopLoopNow Then MsgBox \"迴圈處理完成。\"\nEnd Sub", "explanation": "此範例概念性地展示了一個長迴圈，它會定期呼叫 DoEvents。假設有一個名為 `ufCancelLoop` 的非強制回應 UserForm，上面有一個按鈕，點擊該按鈕會將公共布林變數 `StopLoopNow` 設為 True。迴圈中的 DoEvents 允許 VBA 處理該按鈕的點擊事件，從而使 `StopLoopNow` 變數更新，進而讓迴圈可以被提前終止。"}
    ],
    "keywords": ["doevents user input", "cancel long loop vba", "modeless userform loop", "允許使用者輸入的迴圈"]
},
// Excel 核心操作
{
    "name": "Range.ListHeaderRows Property (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "numberOfHeaderRows = listObject.ListHeaderRows",
    "description": "傳回 Excel 表格 (ListObject) 中標頭列的數量。對於標準的 Excel 表格，這通常是 1 (如果顯示標頭) 或 0 (如果未顯示標頭)。讀取 Long。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As ListObject\n' Set tbl = ActiveSheet.ListObjects(1) ' Assume a table exists\n' If Not tbl Is Nothing Then\n'   If tbl.ShowHeaders Then\n'     MsgBox \"表格 '\" & tbl.Name & \"' 的標頭列數量是: \" & tbl.ListHeaderRows ' Should be 1\n'   Else\n'     MsgBox \"表格 '\" & tbl.Name & \"' 目前未顯示標頭列 (ListHeaderRows: \" & tbl.ListHeaderRows & \")\"\n'   End If\n' End If", "explanation": "獲取活動工作表上第一個表格的標頭列數量。如果表格顯示標頭，則通常為1。"}
    ],
    "keywords": ["listobject listheaderrows", "table header row count", "表格標頭行數"]
},
{
    "name": "ListColumn.DataBodyRange Property (Excel Table Column)",
    "category": "Excel 核心操作",
    "syntax": "Set columnDataRange = listColumnObject.DataBodyRange",
    "description": "傳回一個 Range 物件，代表 Excel 表格 (ListObject) 中特定欄 (ListColumn) 的數據區域 (不包括該欄的標頭或總計)。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As ListObject, lc As ListColumn, colData As Range\n' Set tbl = ActiveSheet.ListObjects(\"SalesData\")\n' Set lc = tbl.ListColumns(\"Revenue\") ' Get the 'Revenue' column\n' If Not lc Is Nothing Then\n'   Set colData = lc.DataBodyRange\n'   If Not colData Is Nothing Then\n'     colData.NumberFormat = \"#,##0.00 €\"\n'     MsgBox \"表格欄 'Revenue' 的數據區域 ('\" & colData.Address & \"') 已格式化為歐元。\"\n'     Debug.Print \"'Revenue' 欄的平均值: \" & Application.WorksheetFunction.Average(colData)\n'   End If\n' End If", "explanation": "獲取名為 \"SalesData\" 的表格中 \"Revenue\" 欄的數據主體範圍，將其數字格式設為歐元，並計算該欄的平均值。"}
    ],
    "keywords": ["listcolumn databodyrange", "table column data range", "excel table column values", "表格欄數據區域"]
},
{
    "name": "ListColumn.TotalsCalculation Property (Excel Table)",
    "category": "Excel 核心操作",
    "syntax": "listColumnObject.TotalsCalculation = XlTotalsCalculationConstant",
    "description": "設定或傳回 Excel 表格 (ListObject) 中特定欄 (ListColumn) 在總計列中使用的計算類型。",
    "parameters": [
        {"name": "XlTotalsCalculationConstant", "description": "例如 xlTotalsCalculationSum, xlTotalsCalculationAverage, xlTotalsCalculationCount, xlTotalsCalculationNone。"}
    ],
    "examples": [
        {"code": "Dim tbl As ListObject, salesCol As ListColumn\n' Set tbl = ActiveSheet.ListObjects(1)\n' If Not tbl Is Nothing Then\n'   tbl.ShowTotals = True ' Ensure total row is visible\n'   Set salesCol = tbl.ListColumns(\"SalesAmount\") ' Assuming a column named 'SalesAmount'\n'   If Not salesCol Is Nothing Then\n'     salesCol.TotalsCalculation = xlTotalsCalculationSum\n'     MsgBox \"表格 '\" & tbl.Name & \"' 的 'SalesAmount' 欄總計已設定為加總。\"\n'     Debug.Print \"'SalesAmount' 欄的總計值: \" & tbl.TotalsRowRange.Cells(1, salesCol.Index).Value\n'   End If\n' End If", "explanation": "顯示表格的總計列，然後將 \"SalesAmount\" 欄的總計計算方式設定為加總 (Sum)，並顯示計算出的總計值。"}
    ],
    "keywords": ["listcolumn totalscalculation", "excel table total row function", "表格總計列計算"]
},
{
    "name": "Worksheet.StandardFont Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "fontObject = worksheetObject.StandardFont",
    "description": "傳回一個代表工作表標準字型的 Font 物件。修改此 Font 物件的屬性會改變該工作表中未使用特定格式的儲存格的預設字型。此屬性是唯讀的 Font 物件，但其屬性可讀寫。",
    "parameters": [],
    "examples": [
        {"code": "Dim ws As Worksheet: Set ws = ActiveSheet\nMsgBox \"活動工作表的標準字型: \" & ws.StandardFont.Name & \", \" & ws.StandardFont.Size & \"pt\"\n' Change standard font for this sheet\n' ws.StandardFont.Name = \"Courier New\"\n' ws.StandardFont.Size = 9\n' MsgBox \"活動工作表的標準字型已更改。新輸入的未格式化文字將使用此設定。\"", "explanation": "顯示活動工作表的標準字型名稱和大小。註解部分演示了如何更改該工作表的標準字型。"}
    ],
    "keywords": ["worksheet standardfont", "default sheet font", "工作表標準字型"]
},
{
    "name": "Range.AddCommentThreaded (Excel Modern Comments)",
    "category": "Excel 核心操作",
    "syntax": "Set newThreadedComment = rangeObject.AddCommentThreaded(Text As String, [Author As String], [ProviderId As String])",
    "description": "在指定的儲存格新增一個新的執行緒式註解 (新式註解)，並傳回代表該註解的 CommentThreaded 物件。",
    "parameters": [
        {"name": "Text", "description": "必需。註解的初始文字。"},
        {"name": "Author", "description": "可選。Author 物件或作者姓名。如果省略，則使用目前使用者。"},
        {"name": "ProviderId", "description": "可選。用於外部提供者。"}
    ],
    "examples": [
        {"code": "Dim cmtThNew As CommentThreaded\nOn Error Resume Next ' In case cell already has a comment or other issue\nSet cmtThNew = Range(\"B5\").AddCommentThreaded(\"這是一個新的執行緒式註解。\")\nIf Err.Number = 0 And Not cmtThNew Is Nothing Then\n  cmtThNew.AddReply \"這是對新註解的第一個回覆。\"\n  MsgBox \"已在B5新增執行緒式註解及其回覆。\"\nElse\n  MsgBox \"無法新增執行緒式註解到B5。錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0", "explanation": "在B5儲存格新增一個新的執行緒式註解，然後為該註解新增一個回覆。"}
    ],
    "keywords": ["addcommentthreaded", "excel modern comment vba", "threaded reply", "新增執行緒式註解"]
},
{
    "name": "CommentThreaded.Replies Property (Excel Modern Comments)",
    "category": "Excel 核心操作",
    "syntax": "Set repliesCollection = commentThreadedObject.Replies",
    "description": "傳回一個 CommentThreaded 物件的 Replies 集合，代表對主執行緒註解的所有回覆。",
    "parameters": [
        {"name": "Replies.Count", "description": "屬性：回覆的數量。"},
        {"name": "Replies.Item(Index)", "description": "屬性：存取特定回覆 (CommentThreaded 物件)。"},
        {"name": "Replies.Add(Text, [Author])", "description": "方法：新增一個新回覆。"}
    ],
    "examples": [
        {"code": "Dim mainCmt As CommentThreaded, reply As CommentThreaded\n' Set mainCmt = Range(\"B5\").CommentThreaded ' Assume B5 has a threaded comment\n' If Not mainCmt Is Nothing Then\n'   Debug.Print \"主註解 ('\" & Left(mainCmt.Text,20) & \"...') 的回覆:\"\n'   If mainCmt.Replies.Count > 0 Then\n'     For Each reply In mainCmt.Replies\n'       Debug.Print \"  - \" & reply.Author.Name & \" 於 \" & reply.Date & \" 回覆: \" & reply.Text\n'     Next reply\n'   Else\n'     Debug.Print \"  (沒有回覆)\"\n'   End If\n' End If", "explanation": "如果B5儲存格有執行緒式註解，則遍歷其所有回覆，並列印每個回覆的作者、日期和內容。"}
    ],
    "keywords": ["commentthreaded replies", "get comment replies", "iterate threaded replies", "執行緒註解回覆"]
},
{
    "name": "Workbook.RemoveUser (Excel Shared Workbook - Legacy)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.RemoveUser(Index As Long)",
    "description": "從共用活頁簿的使用者清單中移除指定的使用者。此功能主要適用於舊版的「共用活頁簿」功能，該功能在新版Excel中已被共同編寫 (Co-authoring) 取代。",
    "parameters": [
        {"name": "Index", "description": "必需。要移除的使用者在 UserStatus 集合中的索引號 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook\n' Set wb = ActiveWorkbook\n' If wb.MultiUserEditing Then ' Check if it's a shared workbook (legacy)\n'   If wb.UserStatus.Count > 1 Then\n'     Dim userToRemove As String: userToRemove = wb.UserStatus(1).Name\n'     If MsgBox(\"是否要從共用清單中移除使用者 '\" & userToRemove & \"'？\", vbYesNo) = vbYes Then\n'       wb.RemoveUser 1 ' Remove the first user in the list\n'       MsgBox \"使用者 '\" & userToRemove & \"' 已被移除。\"\n'       wb.Save ' Save changes to shared workbook state\n'     End If\n'   Else\n'     MsgBox \"共用活頁簿中只有一位使用者或沒有其他使用者可移除。\"\n'   End If\n' Else\n'   MsgBox \"此活頁簿不是舊版共用活頁簿。\"\n' End If", "explanation": "如果活動活頁簿是舊版的「共用活頁簿」且有多個使用者，則嘗試移除使用者清單中的第一個使用者。"}
    ],
    "keywords": ["removeuser shared workbook", "excel shared workbook users", "移除共用使用者 (舊版)"]
},
// Word
{
    "name": "Document.BuiltInDocumentProperties(IndexOrName).Value (Word)",
    "category": "Word 文件處理",
    "syntax": "propValue = documentObject.BuiltInDocumentProperties(IndexOrName).Value",
    "description": "取得或設定指定的內建文件屬性的值。IndexOrName 可以是屬性的 WdBuiltInProperty 常數 (例如 wdPropertyTitle, wdPropertyAuthor) 或其字串名稱。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' On Error Resume Next ' Handle if property doesn't exist or is not set\n' wdDoc.BuiltInDocumentProperties(\"Title\").Value = \"我的年度報告\"\n' wdDoc.BuiltInDocumentProperties(wdPropertyKeywords).Value = \"報告, 年度, VBA\"\n' MsgBox \"文件標題: \" & wdDoc.BuiltInDocumentProperties(wdPropertyTitle).Value & vbCrLf & _\n'        \"關鍵詞: \" & wdDoc.BuiltInDocumentProperties(\"Keywords\").Value", "explanation": "設定活動文件的「標題」和「關鍵詞」內建屬性，然後顯示它們。"}
    ],
    "keywords": ["word document properties value", "set document author title", "wdproperty", "文件屬性值"]
},
{
    "name": "Paragraph.Range.Font Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set fontObj = paragraphObject.Range.Font",
    "description": "傳回一個 Font 物件，代表指定段落範圍的字元格式。修改此 Font 物件的屬性會影響整個段落的文字。",
    "parameters": [],
    "examples": [
        {"code": "Dim firstPara As Object ' Word.Paragraph\n' Set firstPara = ActiveDocument.Paragraphs(1)\n' With firstPara.Range.Font\n'   .Name = \"Consolas\"\n'   .Size = 10\n'   .ColorIndex = wdGray50\n' End With\n' MsgBox \"第一個段落的字型已變更。\"", "explanation": "將活動文件第一個段落的字型設為 Consolas，大小10，顏色為50%灰色。"}
    ],
    "keywords": ["word paragraph font", "format paragraph text", "段落字型格式"]
},
// Outlook
{
    "name": "MailItem.ReceivedByName Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "receivedByNameString = mailItemObject.ReceivedByName",
    "description": "傳回一個字串，表示郵件的實際接收者顯示名稱。這對於代理或代表傳送的郵件可能與 To 欄位不同。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem, assume it's a received email\n' ' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   Debug.Print \"郵件主旨: \" & olMail.Subject\n'   Debug.Print \"收件者 (To): \" & olMail.To\n'   Debug.Print \"實際接收者 (ReceivedByName): \" & olMail.ReceivedByName\n'   Debug.Print \"代表他人接收 (ReceivedOnBehalfOfName): \" & olMail.ReceivedOnBehalfOfName\n' End If", "explanation": "顯示所選郵件的 To 欄位、ReceivedByName (通常是郵箱擁有者) 和 ReceivedOnBehalfOfName (如果郵件是代表他人接收的)。"}
    ],
    "keywords": ["outlook receivedbyname", "actual recipient name", "on behalf of", "實際接收者"]
},
{
    "name": "NameSpace.GetDefaultFolder(olFolderDrafts) (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set draftsFolder = olNamespace.GetDefaultFolder(olFolderDrafts)",
    "description": "傳回一個 MAPIFolder 物件，代表預設的「草稿」資料夾。",
    "parameters": [{"name": "olFolderDrafts (Constant 16)", "description": "指定草稿資料夾。"}],
    "examples": [
        {"code": "Dim olNS As Object, olDrafts As Object, draftItem As Object\nSet olNS = Application.GetNamespace(\"MAPI\")\nSet olDrafts = olNS.GetDefaultFolder(16) ' olFolderDrafts\nMsgBox \"草稿資料夾 '\" & olDrafts.Name & \"' 中有 \" & olDrafts.Items.Count & \" 個項目。\"\nIf olDrafts.Items.Count > 0 Then\n  For Each draftItem In olDrafts.Items\n    Debug.Print \"草稿主旨: \" & draftItem.Subject\n    ' draftItem.Display ' Open a draft\n    ' draftItem.Send ' Send a draft\n  Next draftItem\nEnd If", "explanation": "獲取預設的草稿資料夾，顯示其中的項目數量，並遍歷所有草稿項目，列印其主旨。"}
    ],
    "keywords": ["outlook drafts folder", "olfolderdrafts", "access draft emails", "草稿資料夾"]
},
// PowerPoint
{
    "name": "Slide.TimeLine Property (PowerPoint Animation)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set tl = slideObject.TimeLine",
    "description": "傳回一個 TimeLine 物件，代表投影片的動畫時間軸。可以用於控制動畫序列和效果。",
    "parameters": [
        {"name": "TimeLine.MainSequence", "description": "屬性：傳回一個 Sequence 集合，代表主要的動畫序列。"},
        {"name": "Sequence.AddEffect(Shape, effectId, [Level], [trigger])", "description": "方法：新增動畫效果。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, shpToAnimate As Object ' PowerPoint.Shape\nDim mainAnimSeq As Object ' PowerPoint.Sequence\nDim newEffect As Object ' PowerPoint.Effect\n' Set pptSlide = ActivePresentation.Slides(1)\n' ' Assume a shape named \"TitleShape\" exists on the slide\n' On Error Resume Next\n' Set shpToAnimate = pptSlide.Shapes(\"TitleShape\")\n' If Not shpToAnimate Is Nothing Then\n'   Set mainAnimSeq = pptSlide.TimeLine.MainSequence\n'   ' Add a Fly In effect from Left\n'   Set newEffect = mainAnimSeq.AddEffect(Shape:=shpToAnimate, _\n'                                        effectId:=msoAnimEffectFlyIn, _\n'                                        trigger:=msoAnimTriggerAfterPrevious)\n'   newEffect.EffectParameters.Direction = msoAnimDirectionLeft\n'   newEffect.Timing.Duration = 1.5 ' Duration 1.5 seconds\n'   MsgBox \"已為 'TitleShape' 新增飛入動畫效果。\"\n' Else\n'   MsgBox \"未找到名為 'TitleShape' 的圖案可供動畫。\"\n' End If\n' On Error GoTo 0", "explanation": "為第一張投影片上名為 \"TitleShape\" 的圖案新增一個從左側飛入的動畫效果，並設定其持續時間。"}
    ],
    "keywords": ["powerpoint animation timeline", "add animation effect vba", "sequence.addeffect", "動畫時間軸"]
},
{
    "name": "Presentation.SlideShowSettings.AdvanceMode Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "presentationObject.SlideShowSettings.AdvanceMode = PpSlideShowAdvanceModeConstant",
    "description": "設定或傳回投影片放映的換頁模式。",
    "parameters": [
        {"name": "PpSlideShowAdvanceModeConstant", "description": "ppSlideShowManuallyAdvance (1, 手動換頁), ppSlideShowUseSlideTimings (2, 使用投影片計時), ppSlideShowRehearseNewTimings (3, 排練計時)。"}
    ],
    "examples": [
        {"code": "Dim pptPres As Object\n' Set pptPres = ActivePresentation\n' pptPres.SlideShowSettings.AdvanceMode = ppSlideShowUseSlideTimings\n' ' Ensure individual slides have timings set via SlideShowTransition.AdvanceOnTime = msoTrue\n' MsgBox \"簡報已設定為使用投影片計時進行換頁。\"", "explanation": "設定活動簡報的投影片放映使用每張投影片預設的計時來自動換頁。"}
    ],
    "keywords": ["powerpoint slideshow advancemode", "slide timings", "auto advance slides", "投影片放映換頁模式"]
},
// FSO
{
    "name": "FileSystemObject.GetDrive (Error if Drive Invalid)",
    "category": "檔案與資料夾管理",
    "description": "如果使用 GetDrive 方法嘗試獲取一個不存在的磁碟機規格 (例如 \"X:\" 如果 X 磁碟機不存在)，或無效的磁碟機規格，則會產生執行階段錯誤 '68' (裝置無法使用) 或 '76' (找不到路徑)。",
    "syntax": "On Error Resume Next\nSet drv = fso.GetDrive(InvalidDriveSpec)\nIf Err.Number <> 0 Then ...",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myDrive As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nDim testDriveSpec As String: testDriveSpec = \"X:\"\n\nOn Error Resume Next\nSet myDrive = fso.GetDrive(testDriveSpec)\nIf Err.Number <> 0 Then\n  MsgBox \"無法獲取磁碟機 '\" & testDriveSpec & \"' 的 Drive 物件。\" & vbCrLf & _\n         \"錯誤 \" & Err.Number & \": \" & Err.Description\nElseIf Not myDrive Is Nothing Then\n  MsgBox \"成功獲取磁碟機 '\" & myDrive.DriveLetter & \"' (這不應發生於此範例)。\"\nEnd If\nOn Error GoTo 0\nSet fso = Nothing: Set myDrive = Nothing", "explanation": "嘗試獲取一個假設不存在的 X: 磁碟機的 Drive 物件。使用 On Error Resume Next 來捕獲可能發生的錯誤，並向用戶顯示錯誤訊息。"}
    ],
    "keywords": ["fso getdrive error", "invalid drive specification", "drive not found fso", "GetDrive錯誤處理"]
},
// String
{
    "name": "Mid$ Statement (Replace Part of String - Typed)",
    "category": "字串與文本操作",
    "syntax": "Mid$(StringVariable As String, Start As Long, [Length As Long]) = NewStringExpression",
    "description": "用另一個字串取代字串變數中指定數量的字元。StringVariable 必須是一個已初始化的字串變數。NewStringExpression 取代的字元數不能超過 Length (如果指定) 或 StringVariable 中從 Start 開始的剩餘長度。",
    "parameters": [
        {"name": "StringVariable", "description": "必需。要修改的字串變數名稱。"},
        {"name": "Start", "description": "必需。取代開始的位置 (1-based)。"},
        {"name": "Length", "description": "可選。要取代的字元數。如果省略，則使用 NewStringExpression 的全部長度 (或直到 StringVariable 結尾)。"},
        {"name": "NewStringExpression", "description": "必需。用於取代的字串。"}
    ],
    "examples": [
        {"code": "Dim myPhrase As String: myPhrase = \"The quick brown fox\"\n' Replace \"quick\" with \"slow\"\nMid$(myPhrase, 5, 5) = \"slow \" ' Length 5 includes space to keep same length\nDebug.Print myPhrase ' Output: The slow  brown fox (Note the double space if replacement length is different and original string was fixed *before* this op)\n\nDim targetStr As String: targetStr = \"ABCDEFGHIJ\"\nMid$(targetStr, 4, 3) = \"***\" ' Replace DEF with ***\nDebug.Print targetStr ' Output: ABC***GHIJ\n\nMid$(targetStr, 8) = \"XYZ\" ' Replace HIJ with XYZ (and potential further chars if targetStr was longer)\nDebug.Print targetStr ' Output: ABC***GXYZ\n\nDim fixedLengthExample As String * 20\nfixedLengthExample = \"Original Content Here\"\nMid$(fixedLengthExample, 1, 8) = \"Replaced\"\nDebug.Print \"'\" & fixedLengthExample & \"'\" ' Output: 'Replaced Content Here'", "explanation": "第一個範例將 \"quick\" 取代為 \"slow \"。第二和第三個範例演示在字串中間和末尾進行取代。第四個範例演示在固定長度字串上使用 Mid$。"}
    ],
    "keywords": ["mid$ statement", "replace substring statement", "string modification", "字串部分取代"]
},
// Math
{
    "name": "Log (Natural Logarithm)",
    "category": "數學、日期與時間",
    "description": "Log(number) 函數傳回指定數字的自然對數 (以 e 為底)。number 引數必須是正實數。",
    "syntax": "Log(Number As Double) As Double",
    "parameters": [{"name": "Number", "description": "必需。任何大於 0 的有效數值表達式。"}],
    "examples": [
        {"code": "Debug.Print \"Log(1) = \" & Log(1) ' Output: 0 (e^0 = 1)\nDebug.Print \"Log(10) = \" & Log(10) ' Output: approx 2.302585\nDebug.Print \"Log(Exp(3)) = \" & Log(Exp(3)) ' Output: 3\n\n' To calculate logarithm to base N: LogN(X) = Log(X) / Log(N)\nDim logBase10_of_100 As Double\nlogBase10_of_100 = Log(100) / Log(10)\nDebug.Print \"Log base 10 of 100 = \" & logBase10_of_100 ' Output: 2", "explanation": "演示 Log 函數計算自然對數，以及如何使用換底公式計算常用對數 (以10為底)。"}
    ],
    "keywords": ["log function vba", "natural logarithm", "log base e", "自然對數"]
},
// Data Types
{
    "name": "DefType Statements (Scope and Priority)",
    "category": "資料類型、轉換與驗證",
    "description": "DefType 語句 (DefInt, DefStr, 等) 僅在定義它們的模組中有效。它們的優先級低於明確的 `Dim ... As Type` 宣告。如果同時存在 DefType 宣告和明確的 Dim 宣告，則以 Dim 宣告的類型為準。如果沒有 DefType 且沒有明確的 As Type，則變數預設為 Variant (除非使用了 `Option Explicit`，這會強制所有變數都必須明確宣告)。",
    "parameters": [],
    "examples": [
        {"code": "' --- Module Level ---\n' Option Explicit ' Recommended\n' DefStr A ' Variables starting with A default to String in this module\n' DefInt I  ' Variables starting with I default to Integer in this module\n'\n' Sub DefTypeScopeTest()\n'   Dim Alpha As String ' Explicitly String, overrides DefStr A if it were just 'Dim Alpha'\n'   Dim Beta          ' If Option Explicit is OFF, this is String due to DefStr A-Z rule from example\n'                     ' If Option Explicit is ON, this line causes error 'Variable not defined'\n'                     ' If Option Explicit is ON & 'DefStr B' existed, it would be String.\n'   Dim Index         ' If Option Explicit is OFF, this is Integer due to DefInt I\n'   Dim Value As Double ' Explicitly Double, overrides any DefDbl V or DefInt V\n'\n'   Alpha = \"Test\"\n'   ' Beta = \"Another Test\" ' This would error with Option Explicit ON unless Dim'd\n'   ' Index = 100         ' This would error with Option Explicit ON unless Dim'd\n'   Value = 123.45\n'\n'   Debug.Print \"TypeName(Alpha): \" & TypeName(Alpha)\n'   ' Debug.Print \"TypeName(Beta): \" & TypeName(Beta)\n'   ' Debug.Print \"TypeName(Index): \" & TypeName(Index)\n'   Debug.Print \"TypeName(Value): \" & TypeName(Value)\n' End Sub", "explanation": "演示 DefType 語句的作用範圍和優先級。當 `Option Explicit` 生效時，所有變數都必須使用 `Dim` (或 Public/Private/Static) 進行宣告，DefType 的影響僅在於如果 `Dim` 語句省略了 `As Type` 子句時提供預設類型。然而，最佳實踐是始終為每個變數明確指定類型。"}
    ],
    "keywords": ["deftype scope", "deftype priority", "variable declaration precedence", "DefType作用域優先級"]
},
// Program Flow
{
    "name": "Declare Statement (Calling Convention - ByVal/ByRef for API)",
    "category": "程式流程與結構控制",
    "description": "在 Declare 語句中定義 API 函數參數時，使用 ByVal 或 ByRef 關鍵字非常重要，它決定了參數如何傳遞給 DLL 中的函數：\nByVal：將參數的值複製一份傳遞給 DLL 函數。DLL 內對該值的任何修改都不會影響 VBA 中的原始變數。大多數簡單資料類型參數 (如 Long, Integer, String 指標) 通常使用 ByVal。\nByRef：將參數的記憶體位址 (指標) 傳遞給 DLL 函數。DLL 內對該記憶體位置的修改會直接改變 VBA 中的原始變數的值。通常用於需要 DLL 函數回填資料的參數 (例如，字串緩衝區、結構)。\n如果省略，VBA 預設使用 ByRef，這對於許多 API 函數來說是不正確的，可能導致錯誤或崩潰。",
    "parameters": [],
    "examples": [
        {"code": "' Example: GetWindowText API (gets window title)\n' For GetWindowText, lpString (the buffer) is ByRef because API writes into it.\n' But often, string parameters that are *input only* to API are passed ByVal As String (VBA passes a pointer to string).\n\n' #If VBA7 Then ' For GetWindowTextLength\n'   Private Declare PtrSafe Function GetWindowTextLength Lib \"user32\" Alias \"GetWindowTextLengthA\" (ByVal hwnd As LongPtr) As Long\n'   Private Declare PtrSafe Function GetWindowText Lib \"user32\" Alias \"GetWindowTextA\" (ByVal hwnd As LongPtr, ByVal lpString As String, ByVal cchMax As Long) As Long\n' #Else\n'   Private Declare Function GetWindowTextLength Lib \"user32\" Alias \"GetWindowTextLengthA\" (ByVal hwnd As Long) As Long\n'   Private Declare Function GetWindowText Lib \"user32\" Alias \"GetWindowTextA\" (ByVal hwnd As Long, ByVal lpString As String, ByVal cchMax As Long) As Long\n' #End If\n'\n' Sub GetActiveWindowTitleExample()\n'   Dim hwnd As LongPtr ' Or Long for 32-bit\n'   Dim windowTitle As String, titleLen As Long\n'\n'   hwnd = Application.hWnd ' Get Excel main window handle\n'   titleLen = GetWindowTextLength(hwnd) ' hwnd passed ByVal\n'\n'   If titleLen > 0 Then\n'     windowTitle = String(titleLen + 1, vbNullChar) ' Create buffer\n'     GetWindowText hwnd, windowTitle, titleLen + 1 ' hwnd and cchMax passed ByVal, windowTitle (lpString) passed ByVal as String (VBA handles pointer)\n'     windowTitle = Left(windowTitle, titleLen) ' Trim null terminator\n'     MsgBox \"活動視窗標題 (GetWindowText): \" & windowTitle\n'   Else\n'     MsgBox \"無法獲取活動視窗標題長度。\"\n'   End If\n' End Sub", "explanation": "演示 GetWindowTextLength 和 GetWindowText API 函數的 Declare 語句。hwnd (視窗控制代碼) 和 cchMax (緩衝區大小) 通常使用 ByVal 傳遞。對於 lpString (接收標題的字串緩衝區)，當在 VBA Declare 中宣告為 `ByVal lpString As String` 時，VBA 實際上會傳遞字串數據的指標，API 函數可以寫入此緩衝區 (直到 cchMax 指定的長度)。這是 VBA 中處理 API 字串參數的一種常見方式。如果 API 需要修改一個 Long 或 Integer，則該參數應宣告為 ByRef。"}
    ],
    "keywords": ["declare byval byref api", "api parameter passing", "windows api string buffer", "API參數傳遞方式"]
},
// External API
{
    "name": "WScript.Shell RegRead (Default Value of Key)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "使用 WScript.Shell 的 RegRead 方法讀取登錄檔機碼的預設值時，機碼名稱應以反斜線 `\\` 結尾。",
    "syntax": "defaultValue = wshShell.RegRead(\"HKCU\\MyKey\\\")",
    "parameters": [],
    "examples": [
        {"code": "Dim wshShell As Object, defaultVal As String\nSet wshShell = CreateObject(\"WScript.Shell\")\n' Example: Try to read default value of a common key (Shell Folders)\n' This key usually has a default value, but it might be empty or not set as expected.\nDim keyPathWithSlash As String: keyPathWithSlash = \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\\"\nOn Error Resume Next ' In case key or default value doesn't exist\ndefaultVal = wshShell.RegRead(keyPathWithSlash)\nIf Err.Number = 0 Then\n  Debug.Print \"機碼 '\" & keyPathWithSlash & \"' 的預設值是: '\" & defaultVal & \"'\"\nElse\n  Debug.Print \"讀取機碼 '\" & keyPathWithSlash & \"' 的預設值失敗。錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\nSet wshShell = Nothing", "explanation": "演示如何讀取登錄檔機碼 `HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\` 的預設值。注意機碼路徑以反斜線結尾。"}
    ],
    "keywords": ["regread default key value", "registry key default value", "wsh read registry default", "讀取登錄檔預設值"]
},
{
    "name": "MSXML2.DOMDocument (preserveWhiteSpace Property)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "MSXML2.DOMDocument 物件的 `preserveWhiteSpace` 屬性 (布林值) 決定了在解析 XML 時是否保留元素之間的空白字元 (包括空格、定位字元、換行符)。預設通常為 False (不保留，即會移除元素間的無意義空白)。如果設為 True，則所有空白都會被視為 XML 文檔的一部分並保留在 DOM 樹中 (例如，作為文字節點)。",
    "syntax": "xmlDoc.preserveWhiteSpace = True ' Or False",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object\nDim xmlWithSpaces As String\nxmlWithSpaces = \"<root>  <item>  Value1  </item>   <item>Value2</item> </root>\"\n\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\n\n' Case 1: preserveWhiteSpace = False (Default or explicitly set)\nxmlDoc.preserveWhiteSpace = False\nxmlDoc.LoadXML xmlWithSpaces\nDebug.Print \"--- preserveWhiteSpace = False ---\"\nDebug.Print xmlDoc.XML ' Whitespace between elements might be stripped or normalized\nDebug.Print \"root childNodes.length: \" & xmlDoc.documentElement.childNodes.Length\n' The text nodes consisting only of whitespace might be removed.\n\n' Case 2: preserveWhiteSpace = True\nxmlDoc.preserveWhiteSpace = True\nxmlDoc.LoadXML xmlWithSpaces\nDebug.Print \"--- preserveWhiteSpace = True ---\"\nDebug.Print xmlDoc.XML ' All whitespace should be preserved\nDebug.Print \"root childNodes.length: \" & xmlDoc.documentElement.childNodes.Length\n' Whitespace nodes will be present in childNodes.\n\nSet xmlDoc = Nothing", "explanation": "演示 `preserveWhiteSpace` 屬性對 XML 解析的影響。當設為 False 時，元素之間純粹由空白組成的文字節點可能會被解析器移除或忽略。當設為 True 時，這些空白節點會被保留在 DOM 樹中。這會影響 `childNodes` 的數量和 `Text` 屬性的內容。"}
    ],
    "keywords": ["msxml preservewhitespace", "xml whitespace handling", "dom preserve space", "保留XML空白"]
},
{
    "name": "ADODB.Recordset (AbsolutePosition Property)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 AbsolutePosition 屬性設定或傳回目前記錄在 Recordset 中的序數位置 (1-based)。要使用此屬性，資料提供者必須支援它，並且 Recordset 的 CursorType 通常需要是 `adOpenKeyset` (1) 或 `adOpenStatic` (3)。對於 `adOpenForwardOnly` 資料指標，AbsolutePosition 可能總是傳回 `adPosUnknown` (-1), `adPosBOF` (-2), 或 `adPosEOF` (-3)。",
    "syntax": "currentPosition = rs.AbsolutePosition\nrs.AbsolutePosition = newPosition",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object, rs As Object\n' ' Assume conn is an open ADODB.Connection\n' ' Set conn = CreateObject(\"ADODB.Connection\")\n' ' conn.Open \"YourConnectionString\"\n' Set rs = CreateObject(\"ADODB.Recordset\")\n' rs.CursorLocation = 3 ' adUseClient or a server-side cursor that supports AbsolutePosition\n' rs.CursorType = 3     ' adOpenStatic\n' On Error Resume Next ' Open might fail if table doesn't exist or no records\n' rs.Open \"SELECT TOP 5 ProductID, ProductName FROM Products ORDER BY ProductID\", conn, , , 1 ' adCmdText\n' If Err.Number = 0 And Not rs.EOF Then\n'   Debug.Print \"Total Records (if static/keyset): \" & rs.RecordCount\n'   rs.AbsolutePosition = 3 ' Move to the 3rd record\n'   If rs.AbsolutePosition > 0 And rs.AbsolutePosition <= rs.RecordCount Then\n'     Debug.Print \"目前在第 \" & rs.AbsolutePosition & \" 筆記錄: \" & rs!ProductName\n'   Else\n'     Debug.Print \"無法定位到第3筆記錄，或 AbsolutePosition 不受支援。目前位置: \" & rs.AbsolutePosition\n'   End If\n'   rs.AbsolutePosition = 1 ' Move back to the 1st record\n'   Debug.Print \"移回第 \" & rs.AbsolutePosition & \" 筆記錄: \" & rs!ProductName\n'   rs.Close\n' Else\n'   Debug.Print \"查詢無結果或開啟資料錄集失敗。錯誤: \" & Err.Description\n' End If\n' On Error GoTo 0\n' ' If conn.State = 1 Then conn.Close\n' ' Set rs = Nothing: Set conn = Nothing\nMsgBox \"(概念性) 演示了 AbsolutePosition。需有實際資料庫。\"", "explanation": "演示如何使用 Recordset 的 AbsolutePosition 屬性來讀取目前記錄的位置或將記錄指標移動到特定的序數位置。這需要資料指標類型 (如 adOpenStatic) 支援此功能。"}
    ],
    "keywords": ["adodb absoluteposition", "recordset current record number", "move to record number ado", "記錄集絕對位置"]
},
// Excel 核心操作
{
    "name": "Range.ClearHyperlinks (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ClearHyperlinks",
    "description": "移除指定範圍內所有儲存格的超連結，但保留儲存格的內容和格式 (包括看起來像超連結的藍色底線文字)。要同時移除格式，可以使用 `Range.ClearFormats` 或 `Range.Clear`。",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Hyperlinks.Add Anchor:=Range(\"A1\"), Address:=\"http://www.example.com\", TextToDisplay:=\"Example Link\"\nRange(\"A1\").Font.Color = vbBlue\nRange(\"A1\").Font.Underline = xlUnderlineStyleSingle\nRange(\"A1\").ClearHyperlinks\nMsgBox \"A1儲存格的超連結已被移除，但文字和格式 ('Example Link' 藍色底線) 仍保留。\"", "explanation": "在A1新增一個超連結，然後使用 ClearHyperlinks 移除該超連結的連結功能，但儲存格的文字內容和其視覺格式 (例如藍色底線) 會被保留。"}
    ],
    "keywords": ["clearhyperlinks", "remove hyperlink keep text", "excel delete link only", "清除超連結保留文字"]
},
{
    "name": "Worksheet.Hyperlinks.Delete (Excel - All on Sheet)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Hyperlinks.Delete",
    "description": "刪除指定工作表上的所有超連結。這會移除連結功能和通常的超連結格式 (藍色底線文字會變回普通文字)。",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Hyperlinks.Add Anchor:=Range(\"A1\"), Address:=\"http://example.com\", TextToDisplay:=\"Link1\"\nActiveSheet.Hyperlinks.Add Anchor:=Range(\"B5\"), Address:=\"http://bing.com\", TextToDisplay:=\"Link2\"\nIf MsgBox(\"是否刪除活動工作表上的所有超連結 (包括格式)？\", vbYesNo) = vbYes Then\n  ActiveSheet.Hyperlinks.Delete\n  MsgBox \"活動工作表上的所有超連結已被刪除。\"\nEnd If", "explanation": "在活動工作表上新增兩個超連結，然後提示使用者是否刪除工作表上的所有超連結。如果選擇是，則所有超連結及其預設格式都會被移除。"}
    ],
    "keywords": ["delete all hyperlinks sheet", "remove all links worksheet", "worksheet.hyperlinks.delete", "刪除工作表所有超連結"]
},
// Word
{
    "name": "Document.ActiveWindow.Selection (Word - Current Selection)",
    "category": "Word 文件處理",
    "syntax": "Set sel = documentObject.ActiveWindow.Selection",
    "description": "傳回一個 Selection 物件，代表指定文件視窗 (通常是活動文件視窗) 中的目前選取範圍或插入點。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object, currentSelection As Object ' Word.Selection\n' Set wdDoc = ActiveDocument\n' Set currentSelection = wdDoc.ActiveWindow.Selection\n' If currentSelection.Type = wdSelectionIP Then\n'   currentSelection.TypeText \"在目前插入點輸入。 \"\n' ElseIf currentSelection.Type = wdSelectionNormal Then\n'   currentSelection.Font.Bold = Not currentSelection.Font.Bold ' Toggle bold\n'   MsgBox \"選取文字的粗體狀態已切換。\"\n' End If", "explanation": "獲取活動文件的目前選取範圍。如果是一個插入點，則輸入文字；如果選取了內容，則切換其粗體狀態。"}
    ],
    "keywords": ["word document selection", "get active selection word", "目前選取範圍Word"]
},
{
    "name": "Table.Uniform Property (Word)",
    "category": "Word 文件處理",
    "syntax": "isUniform = tableObject.Uniform",
    "description": "如果指定表格中的所有列都具有相同數量的欄，則傳回 True。唯讀布林值。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\n' If ActiveDocument.Tables.Count > 0 Then\n'   Set tbl = ActiveDocument.Tables(1)\n'   If tbl.Uniform Then\n'     MsgBox \"第一個表格的所有列具有相同的欄數。\"\n'   Else\n'     MsgBox \"第一個表格的列具有不同的欄數 (可能包含合併/分割的儲存格)。\"\n'   End If\n' End If", "explanation": "檢查活動文件中的第一個表格是否每列都具有相同數量的欄。"}
    ],
    "keywords": ["word table uniform columns", "check table structure word", "表格結構是否一致"]
},
// Outlook
{
    "name": "MailItem.MarkAsTask (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.MarkAsTask(MarkInterval As OlMarkInterval)",
    "description": "將 MailItem 標記為一個任務，並為其指派一個提醒間隔。",
    "parameters": [
        {"name": "MarkInterval", "description": "必需。OlMarkInterval 常數，指定任務的提醒標記 (例如 olMarkToday, olMarkTomorrow, olMarkNextWeek, olMarkNoDate)。"}
    ],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   olMail.MarkAsTask olMarkTomorrow ' Mark for follow-up tomorrow\n'   olMail.TaskSubject = \"跟進郵件: \" & olMail.Subject ' Set task subject\n'   olMail.TaskDueDate = Date + 1 ' Set due date for the task\n'   olMail.Save\n'   MsgBox \"郵件 '\" & olMail.Subject & \"' 已標記為明天跟進的任務。\"\n' End If", "explanation": "將選取的郵件標記為一個任務，設定提醒為明天，並自訂任務的主旨和到期日。"}
    ],
    "keywords": ["outlook mark as task", "email to task", "flag for follow-up task", "標記為任務"]
},
{
    "name": "NameSpace.GetItemFromID (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set olItem = olNamespace.GetItemFromID(EntryIDItem As String, [EntryIDStore As String])",
    "description": "傳回一個 Outlook 項目物件 (例如 MailItem, AppointmentItem)，由其唯一的 EntryID 標識。",
    "parameters": [
        {"name": "EntryIDItem", "description": "必需。Outlook 項目的 EntryID。"},
        {"name": "EntryIDStore", "description": "可選。項目所在儲存區的 StoreID。如果省略，則在預設儲存區中尋找。"}
    ],
    "examples": [
        {"code": "Dim olNS As Object, firstMail As Object, retrievedMail As Object\nDim mailEntryID As String\nSet olNS = Application.GetNamespace(\"MAPI\")\n' Get EntryID of the first mail in Inbox for testing\nOn Error Resume Next\nSet firstMail = olNS.GetDefaultFolder(olFolderInbox).Items(1)\nIf firstMail Is Nothing Or Err.Number <> 0 Then MsgBox \"收件匣沒有郵件可供測試。\": Exit Sub\nOn Error GoTo 0\nmailEntryID = firstMail.EntryID\n' Retrieve the same mail item using its EntryID\nSet retrievedMail = olNS.GetItemFromID(mailEntryID)\nIf Not retrievedMail Is Nothing Then\n  MsgBox \"透過 EntryID 成功獲取郵件: \" & retrievedMail.Subject\nElse\n  MsgBox \"無法透過 EntryID 獲取郵件。\"\nEnd If", "explanation": "獲取收件匣中第一封郵件的 EntryID，然後使用 GetItemFromID 方法透過該 EntryID 重新獲取該郵件物件。"}
    ],
    "keywords": ["outlook getitemfromid", "entryid item", "access item by id", "依ID獲取項目"]
},
// PowerPoint
{
    "name": "SlideRange.Export (PowerPoint - Selected Slides)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideRangeObject.Export(FileName As String, FilterName As String, [ScaleWidth As Long], [ScaleHeight As Long])",
    "description": "將 SlideRange 物件 (代表一個或多個選取的投影片) 中的所有投影片匯出為指定格式的圖形檔案。如果 SlideRange 只包含一個投影片，則與 Slide.Export 類似。",
    "parameters": [
        {"name": "FileName", "description": "必需。目標檔案的路徑和名稱。如果匯出多張投影片到某些格式 (如 JPG, PNG)，PowerPoint 可能會自動在檔名後附加序號並為每張投影片建立單獨檔案，或將其儲存在一個以此檔名命名的資料夾中。"},
        {"name": "FilterName", "description": "必需。圖形篩選器的副檔名 (例如 \"JPG\", \"PNG\")。"}
    ],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\nDim selectedSlides As Object ' PowerPoint.SlideRange\n' Set pptPres = ActivePresentation\n' ' Assume user has selected slides 2 and 4 in the slide sorter view or navigation pane\n' ' For programmatic selection:\n' ' Set selectedSlides = pptPres.Slides.Range(Array(2, 4)) ' Selects slides 2 and 4\n' ' For this example, let's use current selection if any\n' On Error Resume Next ' If no slides selected or selection is not a SlideRange\n' Set selectedSlides = ActiveWindow.Selection.SlideRange\n' If selectedSlides Is Nothing Or selectedSlides.Count = 0 Then\n'   MsgBox \"沒有選取投影片可供匯出。請先選取一或多張投影片。\"\n'   Exit Sub\n' End If\n' On Error GoTo 0\n'\n' Dim exportPath As String: exportPath = \"C:\\PPT_Exports\\SelectedSlidesOutput\"\n' ' PowerPoint will typically create files like SelectedSlidesOutput1.JPG, SelectedSlidesOutput2.JPG etc.\n' ' or a folder named SelectedSlidesOutput containing Slide1.JPG, Slide2.JPG etc.\n' On Error Resume Next\n' selectedSlides.Export FileName:=exportPath, FilterName:=\"JPG\", ScaleWidth:=800\n' If Err.Number = 0 Then\n'   MsgBox selectedSlides.Count & \" 張選取的投影片已嘗試匯出為 JPG 圖片到 '\" & exportPath & \"' (或其子資料夾)。\"\n' Else\n'   MsgBox \"匯出選取的投影片失敗: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "如果使用者在 PowerPoint 中選取了投影片 (或程式碼選取了 SlideRange)，則此範例會將所有選取的投影片匯出為 JPG 格式的圖片。`FileName` 引數在這裡用作基礎名稱或資料夾名稱。"}
    ],
    "keywords": ["powerpoint export selected slides", "sliderange export", "save multiple slides as images", "匯出選定投影片"]
},
// FSO
{
    "name": "FileSystemObject.GetStandardStream (StdIn Example - Conceptual)",
    "category": "檔案與資料夾管理",
    "description": "GetStandardStream(StdIn) 獲取標準輸入流。這在 VBA Office 應用中不常用，因為它們是 GUI 應用。但在 VBScript (cscript.exe) 環境中，可以從命令列讀取輸入。在 Office VBA 中，可以透過 Shell 執行一個命令並嘗試捕獲其輸出，但直接讀取 Office VBA 的 StdIn 不適用。",
    "parameters": [{"name": "StdIn (Constant 0)", "description": "指定標準輸入流。"}],
    "examples": [
        {"code": "' This example is more suited for VBScript run with CScript.\n' In Office VBA, direct StdIn is not typical.\n' Sub ReadFromStdIn_Conceptual()\n'   Dim fso As Object, tsIn As Object, inputLine As String\n'   Set fso = CreateObject(\"Scripting.FileSystemObject\")\n'   Set tsIn = fso.GetStandardStream(0) ' StdIn\n'   If Not tsIn.AtEndOfStream Then\n'     Debug.Print \"請在執行此腳本的命令提示符中輸入一行文字然後按Enter:\"\n'     inputLine = tsIn.ReadLine\n'     Debug.Print \"從 StdIn 讀取到: \" & inputLine\n'   Else\n'     Debug.Print \"StdIn 中沒有可讀取的輸入。\"\n'   End If\n'   Set fso = Nothing: Set tsIn = Nothing\n' End Sub\nMsgBox \"GetStandardStream(StdIn) 主要用於命令列腳本環境。\"", "explanation": "概念性地演示如何嘗試從標準輸入流讀取一行。在 Office VBA 中，這通常沒有意義，因為沒有直接的控制台輸入。此功能在 VBScript/WSH 環境中更有用。"}
    ],
    "keywords": ["fso stdin", "read console input script", "standard input stream", "標準輸入流FSO"]
},
// String
{
    "name": "LCase$ / UCase$ (Typed String Functions)",
    "category": "字串與文本操作",
    "syntax": "lowerCaseString$ = LCase$(SourceString$)\nupperCaseString$ = UCase$(SourceString$)",
    "description": "LCase$ 和 UCase$ 是 VBA 中將字串轉換為全小寫或全大寫的強型別版本函數。它們明確傳回 String 資料類型，而 LCase 和 UCase 傳回 Variant (String)。在現代VBA中，效能差異通常可以忽略，但使用 `$` 版本可以更明確地指示字串操作。",
    "parameters": [{"name": "SourceString$", "description": "必需。要轉換的字串表達式。"}],
    "examples": [
        {"code": "Dim mixedCase As String: mixedCase = \"Hello World 123!\"\nDim lowerResult As String, upperResult As String\n\nlowerResult = LCase$(mixedCase)\nDebug.Print \"LCase$(\"\"\" & mixedCase & \"\"\") = \" & lowerResult ' Output: hello world 123!\n\nupperResult = UCase$(mixedCase)\nDebug.Print \"UCase$(\"\"\" & mixedCase & \"\"\") = \" & upperResult ' Output: HELLO WORLD 123!\n\nDebug.Print \"TypeName of LCase$ result: \" & TypeName(lowerResult) ' String\nDebug.Print \"TypeName of LCase result (Variant/String): \" & TypeName(LCase(mixedCase))", "explanation": "演示 LCase$ 和 UCase$ 函數將字串轉換為小寫和大寫，並顯示其傳回類型為 String。"}
    ],
    "keywords": ["lcase$", "ucase$", "typed string case conversion", "字串大小寫轉換 (強型別)"]
},
// Math
{
    "name": "WorksheetFunction.CountBlank (Excel)",
    "category": "數學、日期與時間",
    "syntax": "blankCount = Application.WorksheetFunction.CountBlank(Range As Range)",
    "description": "使用 Excel 的 COUNTBLANK 工作表函數，計算指定儲存格範圍中空白儲存格的數量。",
    "parameters": [{"name": "Range", "description": "必需。要計數其中空白儲存格的範圍。"}],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Text\"\nRange(\"A2\").Value = Empty ' Blank\nRange(\"A3\").Value = \"\"\nRange(\"A4\").Value = 123\nRange(\"A5\").ClearContents ' Blank\nDim numBlanks As Long\nnumBlanks = Application.WorksheetFunction.CountBlank(Range(\"A1:A5\"))\nMsgBox \"範圍 A1:A5 中空白儲存格的數量是: \" & numBlanks ' Expected: 2 (A2, A5). A3 with \"\" is not blank for COUNTBLANK.", "explanation": "計算A1:A5範圍內空白儲存格的數量。注意，對於 COUNTBLANK，值為 Empty 或由 ClearContents 清除的儲存格被視為空白，但包含零長度字串 `\"\"` 的儲存格不被視為空白。"}
    ],
    "keywords": ["countblank", "excel countblank vba", "count empty cells", "計數空白儲存格"]
},
// Data Types
{
    "name": "TypeName (Return Values for Arrays)",
    "category": "資料類型、轉換與驗證",
    "description": "當 TypeName 函數的參數是一個陣列時，它會傳回 \"Variant()\" 或 \"SpecificType()\" (例如 \"Integer()\", \"String()\", \"MyClass()\")。這取決於陣列是如何宣告的。",
    "parameters": [],
    "examples": [
        {"code": "Dim intArray(5) As Integer\nDim strDynArray() As String\nDim varArray As Variant\nDim objArray(2) As Object\nDim myClassArray(1) As Collection ' Array of Collection objects\n\nDebug.Print \"Integer Array: \" & TypeName(intArray) ' Output: Integer()\nReDim strDynArray(3)\nDebug.Print \"String Dynamic Array: \" & TypeName(strDynArray) ' Output: String()\nvarArray = Array(1, 2, 3)\nDebug.Print \"Variant Array (from Array()): \" & TypeName(varArray) ' Output: Variant()\n' Debug.Print \"Object Array: \" & TypeName(objArray) ' Output: Object()\nSet myClassArray(0) = New Collection\nDebug.Print \"Collection Object Array: \" & TypeName(myClassArray) ' Output: Collection() (or specific class if strongly typed array of class)", "explanation": "顯示不同類型陣列 (固定大小的整數陣列、動態的字串陣列、由 Array() 函數建立的 Variant 陣列、物件陣列) 的 TypeName 傳回值。它清楚地指出了陣列的元素類型。"}
    ],
    "keywords": ["typename array", "array type name", "get array element type", "陣列類型名稱"]
},
// Program Flow
{
    "name": "Static Variable (Module Level vs Procedure Level)",
    "category": "程式流程與結構控制",
    "description": "Static 關鍵字可以用於宣告模組層級的變數 (與 Private 類似，但強調其值在程式執行期間持續存在且僅在該模組內可見)，或用於宣告程序內部的區域變數。\n模組層級 Static 變數：其值在整個應用程式執行期間保留，並且僅限於該模組訪問。\n程序層級 Static 變數：其值在程序的不同呼叫之間保留，但該變數僅在該程序內部可見。",
    "parameters": [],
    "examples": [
        {"code": "' --- Module Level Static Variable (Module1) ---\n' Option Explicit\n' Static ModuleLevelCounter As Long ' Value persists across calls to any Sub/Function in this module\n'\n' Sub IncrementModuleCounter()\n'   ModuleLevelCounter = ModuleLevelCounter + 1\n'   Debug.Print \"ModuleLevelCounter: \" & ModuleLevelCounter\n' End Sub\n'\n' Sub ProcedureWithStaticVar()\n'   Static ProcLevelCounter As Long ' Value persists across calls to THIS Sub only\n'   Dim RegularVar As Long ' Reinitialized each call\n'   ProcLevelCounter = ProcLevelCounter + 1\n'   RegularVar = RegularVar + 1\n'   Debug.Print \"  ProcLevelCounter: \" & ProcLevelCounter & \", RegularVar: \" & RegularVar\n' End Sub\n'\n' Sub TestCounters()\n'   IncrementModuleCounter ' MLC = 1\n'   IncrementModuleCounter ' MLC = 2\n'\n'   ProcedureWithStaticVar ' PLC = 1, RV = 1\n'   ProcedureWithStaticVar ' PLC = 2, RV = 1\n'   ProcedureWithStaticVar ' PLC = 3, RV = 1\n'\n'   Debug.Print \"Final ModuleLevelCounter (accessible here): \" & ModuleLevelCounter\n'   ' Debug.Print ProcLevelCounter ' Error: Not accessible outside its procedure\n' End Sub", "explanation": "演示模組層級 Static 變數 (ModuleLevelCounter) 和程序層級 Static 變數 (ProcLevelCounter) 的行為。ModuleLevelCounter 在對 IncrementModuleCounter 的多次呼叫之間以及對 TestCounters 的呼叫期間都保留其值。ProcLevelCounter 僅在對 ProcedureWithStaticVar 的多次呼叫之間保留其值，而 RegularVar 每次都會重新初始化。"}
    ],
    "keywords": ["static variable scope", "module level static", "procedure level static", "preserve variable value", "靜態變數範圍"]
},
// External API
{
    "name": "WScript.Shell.Environment Property (System/User/Process Env Vars)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "WScript.Shell 物件的 Environment 屬性傳回一個 WshEnvironment 物件，允許存取特定類型的環境變數 (System, User, Process, Volatile)。這比 VBA 的 Environ 函數提供了更細緻的控制和對不同環境變數集的存取。",
    "syntax": "Set envVars = wshShell.Environment(VarType As String) ' VarType: \"System\", \"User\", \"Process\", \"Volatile\"\nvalue = envVars.Item(\"VarName\") ' Or envVars(\"VarName\")\nFor Each envVar In envVars: Debug.Print envVar : Next ' Prints VarName=Value",
    "parameters": [],
    "examples": [
        {"code": "Dim wshShell As Object, systemEnv As Object, userEnv As Object, envItem As Object\nSet wshShell = CreateObject(\"WScript.Shell\")\n\nDebug.Print \"--- System Environment Variables (First 5) ---\"\nSet systemEnv = wshShell.Environment(\"System\")\nDim countSys As Integer: countSys = 0\nFor Each envItem In systemEnv\n    Debug.Print envItem ' Prints as NAME=VALUE\n    countSys = countSys + 1\n    If countSys >= 5 Then Exit For\nNext\n\nDebug.Print \"--- User Environment Variables (First 5) ---\"\nSet userEnv = wshShell.Environment(\"User\")\nDim countUser As Integer: countUser = 0\nFor Each envItem In userEnv\n    Debug.Print envItem\n    countUser = countUser + 1\n    If countUser >= 5 Then Exit For\nNext\n\n' Get a specific User environment variable\nDim myPath As String\nmyPath = userEnv(\"Path\") ' Get User's Path variable\nDebug.Print \"User's Path variable (first 100 chars): \" & Left(myPath, 100) & \"...\"\n\n' Get a specific System environment variable\nDim windir As String\nwindir = systemEnv(\"WINDIR\")\nDebug.Print \"System's WINDIR: \" & windir\n\nSet wshShell = Nothing: Set systemEnv = Nothing: Set userEnv = Nothing", "explanation": "演示如何使用 WScript.Shell 的 Environment 屬性分別獲取系統級 (System) 和用戶級 (User) 的環境變數集合。然後遍歷這些集合以列印前幾個變數，並示範如何獲取特定環境變數 (如 Path 和 WINDIR) 的值。"}
    ],
    "keywords": ["wscript.shell.environment", "system environment variables", "user environment variables", "access specific env vars", "系統環境變數", "用戶環境變數"]
},
{
    "name": "ADODB.Recordset (AddNew and Update Methods)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 AddNew 方法用於在可更新的 Recordset 中建立一個新的空白記錄，以便填入資料。填完新記錄的欄位值後，必須呼叫 Update 方法才能將新記錄永久儲存到資料庫 (或 Recordset 的本地副本，取決於 CursorLocation 和 LockType)。",
    "syntax": "rs.AddNew\nrs.Fields(\"FieldName1\").Value = Value1\nrs.Fields(\"FieldName2\").Value = Value2\nrs.Update",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object, rs As Object\nDim connStr As String, sqlProducts As String\n' connStr = \"Provider=Microsoft.ACE.OLEDB.12.0;Data Source=C:\\Temp\\Northwind.mdb;\"\nsqlProducts = \"SELECT ProductName, UnitPrice, UnitsInStock FROM Products\"\n\nSet conn = CreateObject(\"ADODB.Connection\")\nSet rs = CreateObject(\"ADODB.Recordset\")\n\n' conn.Open connStr\n' ' Open recordset with client-side cursor and optimistic locking to allow updates\n' rs.CursorLocation = 3 ' adUseClient\n' rs.Open sqlProducts, conn, 2, 3, 1 ' adOpenKeyset/Dynamic, adLockOptimistic, adCmdText\n\n' If Not rs.EOF Then ' Ensure recordset is not empty, though AddNew works on empty one too\n'   ' Add a new product\n'   rs.AddNew\n'   rs.Fields(\"ProductName\").Value = \"VBA Super Widget\"\n'   rs.Fields(\"UnitPrice\").Value = 199.99\n'   rs.Fields(\"UnitsInStock\").Value = 50\n'   On Error Resume Next ' Update might fail due to DB constraints or permissions\n'   rs.Update\n'   If Err.Number = 0 Then\n'     MsgBox \"新產品 'VBA Super Widget' 已成功新增並更新到資料庫 (或本地快取)。\"\n'     rs.Requery ' To see the new record if DB auto-generates ID or if others might have added\n'   Else\n'     MsgBox \"新增產品失敗: \" & Err.Description\n'     If rs.EditMode <> 0 Then rs.CancelUpdate ' adEditNone = 0\n'   End If\n'   On Error GoTo 0\n' Else\n'   Debug.Print \"無法開啟產品資料錄集或為空。\"\n' End If\n'\n' If rs.State = 1 Then rs.Close\n' If conn.State = 1 Then conn.Close\n' Set rs = Nothing: Set conn = Nothing\nMsgBox \"(概念性) 演示了 AddNew 和 Update。需有實際可寫資料庫。\"", "explanation": "演示如何使用 ADODB Recordset 的 AddNew 方法來準備一條新記錄，為其欄位賦值，然後使用 Update 方法將新記錄儲存。需要一個可更新的資料指標類型 (如 adOpenKeyset 或 adOpenDynamic) 和鎖定類型 (如 adLockOptimistic)。"}
    ],
    "keywords": ["adodb recordset addnew", "recordset update method", "insert record ado", "add data to database vba", "新增記錄ADO", "更新記錄ADO"]
},
{
    "name": "MSXML2.DOMDocument (selectNodes with Namespaces - setProperty \"SelectionNamespaces\")",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "當 XML 文件使用命名空間時，標準的 XPath 查詢 (例如 `//book/title`) 可能無法正確選取節點，因為節點名稱實際上是 `prefix:localname`。要正確使用 XPath 查詢帶命名空間的 XML，需要使用 DOMDocument 的 `setProperty` 方法設定 `SelectionNamespaces` 屬性，定義命名空間前綴和其對應的 URI。",
    "syntax": "xmlDoc.setProperty \"SelectionNamespaces\", \"xmlns:prefix='namespaceURI' xmlns:anotherprefix='anotherURI'\"",
    "parameters": [{"name": "SelectionNamespaces String", "description": "一個包含一或多個 `xmlns:prefix='namespaceURI'` 定義的字串，用空格分隔。"}],
    "examples": [
        {"code": "Dim xmlDoc As Object ' MSXML2.DOMDocument60\nDim books As Object ' IXMLDOMNodeList\nDim xmlContentWithNS As String\nxmlContentWithNS = \"<lib:library xmlns:lib='http://www.example.com/library' xmlns:bk='http://www.example.com/bookschema'>\" & _\n                   \"  <lib:book bk:genre='Fiction'>\" & _\n                   \"    <bk:title>The Martian</bk:title>\" & _\n                   \"    <bk:author>Andy Weir</bk:author>\" & _\n                   \"  </lib:book>\" & _\n                   \"  <lib:book bk:genre='Science'>\" & _\n                   \"    <bk:title>Cosmos</bk:title>\" & _\n                   \"    <bk:author>Carl Sagan</bk:author>\" & _\n                   \"  </lib:book>\" & _\n                   \"</lib:library>\"\n\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\nxmlDoc.LoadXML xmlContentWithNS\n\nIf xmlDoc.parseError.errorCode <> 0 Then\n    MsgBox \"XML 載入錯誤: \" & xmlDoc.parseError.reason\n    Exit Sub\nEnd If\n\n' Define namespaces to be used in XPath queries\nDim nsDecl As String\nnsDecl = \"xmlns:lib='http://www.example.com/library' \" & _\n         \"xmlns:bk='http://www.example.com/bookschema'\"\nxmlDoc.setProperty \"SelectionNamespaces\", nsDecl\n\n' Query using the defined prefixes\nSet books = xmlDoc.selectNodes(\"//lib:book/bk:title\")\nIf Not books Is Nothing Then\n    Debug.Print \"找到 \" & books.Length & \" 本書的標題 (使用命名空間):\"\n    Dim titleNode As Object\n    For Each titleNode In books\n        Debug.Print \"  - \" & titleNode.Text\n    Next titleNode\nElse\n    Debug.Print \"使用命名空間的 selectNodes 未傳回有效物件。\"\nEnd If\n\n' Query without namespace prefix (will likely fail or return 0 if elements are namespaced)\nSet books = xmlDoc.selectNodes(\"//book/title\") ' This might not work as expected\nDebug.Print \"找到 \" & books.Length & \" 本書的標題 (不使用命名空間前綴，可能失敗)。\"\n\nSet xmlDoc = Nothing: Set books = Nothing", "explanation": "此範例載入一個包含命名空間的 XML 字串。然後，它使用 `setProperty \"SelectionNamespaces\"` 來定義 XPath 查詢中將使用的命名空間前綴 (`lib` 和 `bk`) 及其對應的 URI。接著，它使用帶前綴的 XPath 查詢 (`//lib:book/bk:title`) 來成功選取節點。最後，它演示了一個不帶前綴的查詢，這在有命名空間的文檔中通常會失敗。"}
    ],
    "keywords": ["msxml selectionnamespaces", "xpath with namespaces", "query namespaced xml", "xml prefix uri", "XPath命名空間查詢"]
},
{
    "name": "Range.Name Property (Excel Cell/Range Name)",
    "category": "Excel 核心操作",
    "syntax": "Set nameObj = rangeObject.Name",
    "description": "如果指定的 Range 物件對應於一個已定義的名稱 (Named Range)，則此屬性傳回代表該名稱的 Name 物件。如果該儲存格或範圍沒有被賦予名稱，或者它是多個名稱的一部分，則存取此屬性可能會產生錯誤或傳回非預期結果。通常用於檢查單一儲存格是否為某個已命名範圍的左上角，或整個範圍是否完全對應某個已命名範圍。",
    "parameters": [],
    "examples": [
        {"code": "Dim myNamedCell As Name, myNamedArea As Name\n' Define some names first\nOn Error Resume Next ' Clear previous if any\nThisWorkbook.Names(\"TestCell\").Delete\nThisWorkbook.Names(\"TestArea\").Delete\nOn Error GoTo 0\nThisWorkbook.Names.Add Name:=\"TestCell\", RefersTo:=\"=Sheet1!$A$1\"\nThisWorkbook.Names.Add Name:=\"TestArea\", RefersTo:=\"=Sheet1!$B$1:$D$5\"\n\nOn Error Resume Next ' If cell is not a named range, .Name property access errors\nSet myNamedCell = Range(\"A1\").Name ' For cell A1\nIf Err.Number = 0 And Not myNamedCell Is Nothing Then\n  MsgBox \"儲存格A1對應的名稱是: '\" & myNamedCell.Name & \"'，它參照: \" & myNamedCell.RefersTo\nElse\n  MsgBox \"儲存格A1沒有直接對應的單一已定義名稱，或讀取名稱屬性失敗。\"\nEnd If\nErr.Clear\n\nSet myNamedArea = Range(\"B1:D5\").Name ' For range B1:D5\nIf Err.Number = 0 And Not myNamedArea Is Nothing Then\n  MsgBox \"範圍B1:D5對應的名稱是: '\" & myNamedArea.Name & \"'，它參照: \" & myNamedArea.RefersTo\nElse\n  MsgBox \"範圍B1:D5沒有直接且完全匹配的單一已定義名稱。\"\nEnd If\nOn Error GoTo 0", "explanation": "建立兩個已定義名稱 (\"TestCell\" 指向 A1，\"TestArea\" 指向 B1:D5)。然後，程式碼嘗試獲取儲存格 A1 的 Name 物件和範圍 B1:D5 的 Name 物件。如果儲存格或範圍完全對應於一個已定義的名稱，則可以成功獲取 Name 物件並顯示其屬性。如果範圍僅是某個更大已命名範圍的一部分，或根本沒有名稱，則存取 `.Name` 屬性可能會失敗或行為不確定。"}
    ],
    "keywords": ["range.name property", "get named range from cell", "excel cell name object", "範圍名稱屬性"]
},
{
    "name": "Worksheet.Protect (DrawingObjects, Contents, Scenarios Arguments)",
    "category": "Excel 核心操作",
    "description": "Worksheet.Protect 方法的多個布林引數允許精細控制工作表受保護時哪些元素也被保護：\n`DrawingObjects` (預設 True): 保護繪圖物件 (圖案、圖表)。\n`Contents` (預設 True): 保護儲存格內容 (對於未解除鎖定的儲存格)。\n`Scenarios` (預設 True): 保護分析藍本。\n還有許多其他引數，如 `AllowFormattingCells`, `AllowFiltering`, `AllowUsingPivotTables` 等，用於在保護工作表時允許特定的使用者操作。",
    "syntax": "worksheetObject.Protect([Password], [DrawingObjects], [Contents], [Scenarios], ...)",
    "parameters": [],
    "examples": [
        {"code": "Dim ws As Worksheet: Set ws = ActiveSheet\n' Protect contents and scenarios, but allow drawing objects to be modified\nws.Protect Password:=\"MyPass\", DrawingObjects:=False, Contents:=True, Scenarios:=True, _\n           AllowFormattingCells:=True, AllowFiltering:=True\nMsgBox \"工作表 '\" & ws.Name & \"' 已受保護。\" & vbCrLf & _\n       \"儲存格內容和分析藍本受保護。\" & vbCrLf & _\n       \"繪圖物件可以修改。\" & vbCrLf & _\n       \"允許格式化儲存格和使用篩選。\"\n' ws.Unprotect \"MyPass\"", "explanation": "保護活動工作表，設定密碼，指定保護儲存格內容和分析藍本，但不保護繪圖物件。同時，允許使用者在受保護的工作表上進行儲存格格式化和使用自動篩選功能。"}
    ],
    "keywords": ["worksheet.protect arguments", "protect drawingobjects", "protect contents", "protect scenarios", "allow filtering protected sheet", "保護工作表選項"]
},
{
    "name": "Range.Show (Outline - Collapse)",
    "category": "Excel 核心操作",
    "syntax": "' To collapse, you usually select a cell within the expanded detail range\n' and then use an Outline method, or set the .ShowDetail property of the summary row/column to False.\n' Range.Show itself only expands.",
    "description": "Range.Show 方法用於展開大綱的詳細資料。要摺疊大綱的詳細資料，通常需要設定摘要列或摘要欄的 `.ShowDetail = False` 屬性，或者在UI中點擊摺疊按鈕。沒有直接的 `Range.HideDetail` 或 `Range.CollapseOutline` 方法。",
    "parameters": [],
    "examples": [
        {"code": "' Assume Rows 2-5 are grouped under Row 1 (Row 1 is summary row)\n' Rows(\"2:5\").EntireRow.Hidden = False ' Ensure details are potentially visible\n' Rows(1).Show ' This might expand it if it's a summary row and details are hidden by outline level.\n'\n' ' To collapse details for row 1 (assuming it's a summary row for an outline group):\n' If Rows(1).ShowDetail Then ' If details are shown\n'   Rows(1).ShowDetail = False ' This will collapse the details under it.\n'   MsgBox \"第1列下方的大綱詳細資料已摺疊。\"\n' Else\n'   Rows(1).ShowDetail = True ' This will expand them.\n'   MsgBox \"第1列下方的大綱詳細資料已展開。\"\n' End If", "explanation": "演示如何使用摘要列的 ShowDetail 屬性來摺疊或展開其下方的大綱級別。Range.Show 本身通常用於顯示選取範圍 (例如，如果它被隱藏或在篩選中)。"}
    ],
    "keywords": ["collapse outline excel vba", "hide outline detail", "range.showdetail false", "摺疊大綱"]
},
{
    "name": "Range.ColumnDifferences (Multiple Comparison Cells)",
    "category": "Excel 核心操作",
    "description": "Range.ColumnDifferences(Comparison As Range) 方法的 Comparison 引數可以是一個包含多個儲存格的範圍。在這種情況下，rangeObject 中的每一欄都會與 Comparison 範圍中對應欄的儲存格進行比較。如果 Comparison 範圍的欄數少於 rangeObject，則 rangeObject 中超出部分的欄會與 Comparison 中的最後一欄比較。如果 Comparison 的欄數更多，則多餘的欄被忽略。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1:C1\").Value = Array(\"X\", \"Y\", \"Z\") ' Comparison row\nRange(\"A2:C5\").Value = Application.Transpose(Array(Array(\"X\", \"Y\", \"Z\"), Array(\"X\", \"B\", \"Z\"), Array(\"A\", \"Y\", \"C\"), Array(\"X\",\"Y\",\"Z\"))) ' Data\nDim dataToCheck As Range: Set dataToCheck = Range(\"A2:C5\")\nDim comparisonRow As Range: Set comparisonRow = Range(\"A1:C1\")\nDim diffs As Range\nOn Error Resume Next\nSet diffs = dataToCheck.ColumnDifferences(Comparison:=comparisonRow)\nOn Error GoTo 0\nIf Not diffs Is Nothing Then\n  MsgBox \"與第一列對應比較儲存格不同的儲存格有: \" & diffs.Address\n  diffs.Interior.ColorIndex = 3 ' Red\nElse\n  MsgBox \"所有檢查的儲存格都與其欄的比較儲存格相同。\"\nEnd If", "explanation": "將 A2:C5 範圍的數據與 A1:C1 範圍的數據按欄進行比較。A2:A5 中的每一欄 (A, B, C) 分別與比較列 A1, B1, C1 中的值比較。在此範例中，A3(A), B2(B), C3(C) 應被標記。"}
    ],
    "keywords": ["columndifferences multiple compare", "compare columns against template row", "欄差異多儲存格比較"]
},
{
    "name": "Range.RowDifferences (Multiple Comparison Cells)",
    "category": "Excel 核心操作",
    "description": "與 ColumnDifferences 類似，Range.RowDifferences(Comparison As Range) 的 Comparison 引數也可以是一個多儲存格範圍。rangeObject 中的每一列會與 Comparison 範圍中對應列的儲存格進行比較。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1:A3\").Value = Application.Transpose(Array(\"X\", \"Y\", \"Z\")) ' Comparison column\nRange(\"B1:E3\").Value = Array(Array(\"X\", \"B\", \"X\", \"X\"), Array(\"A\", \"Y\", \"C\", \"Y\"), Array(\"Z\", \"Z\", \"Z\", \"D\")) ' Data\nDim dataToCheck As Range: Set dataToCheck = Range(\"B1:E3\")\nDim comparisonCol As Range: Set comparisonCol = Range(\"A1:A3\")\nDim diffs As Range\nOn Error Resume Next\nSet diffs = dataToCheck.RowDifferences(Comparison:=comparisonCol)\nOn Error GoTo 0\nIf Not diffs Is Nothing Then\n  MsgBox \"與第一欄對應比較儲存格不同的儲存格有: \" & diffs.Address\n  diffs.Font.Bold = True\nElse\n  MsgBox \"所有檢查的儲存格都與其列的比較儲存格相同。\"\nEnd If", "explanation": "將 B1:E3 範圍的數據與 A1:A3 範圍的數據按列進行比較。B1:E3 中的每一列 (1, 2, 3) 分別與比較欄 A1, A2, A3 中的值比較。在此範例中，B2(A), C1(B), C2(C), D2(C), E1(B), E3(D) 應被標記。"}
    ],
    "keywords": ["rowdifferences multiple compare", "compare rows against template column", "列差異多儲存格比較"]
},
{
    "name": "Range.Replace (SearchFormat and What Argument)",
    "category": "Excel 核心操作",
    "description": "當 Range.Replace 的 `SearchFormat` 引數為 True 時，`What` 引數仍然是必需的，但其值可以設為萬用字元 `*` (以匹配任何內容)，這樣取代操作就主要基於 `Application.FindFormat` 設定的格式。如果 `What` 設為特定文字，則只會取代同時符合文字和格式條件的儲存格。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Important Text\": Range(\"A1\").Font.Bold = True\nRange(\"A2\").Value = \"Other Text\": Range(\"A2\").Font.Bold = False\nRange(\"A3\").Value = \"Important Too\": Range(\"A3\").Font.Bold = True\n\nApplication.FindFormat.Clear\nApplication.FindFormat.Font.Bold = True\nApplication.ReplaceFormat.Clear\nApplication.ReplaceFormat.Interior.Color = vbYellow\n\n' Replace based only on format (Bold)\nRange(\"A1:A3\").Replace What:=\"*\", Replacement:=\"\", SearchFormat:=True, ReplaceFormat:=True\n' Result: A1 and A3 background become yellow. Their text content remains.\nMsgBox \"所有粗體儲存格的背景已變更 (內容不變)。\"", "explanation": "尋找 A1:A3 中所有粗體儲存格，並將其背景色改為黃色，而不改變儲存格的文字內容。`Replacement:=\"\"` 與 `ReplaceFormat:=True` 結合使用時，表示只更改格式而不更改值。"}
    ],
    "keywords": ["replace format only", "excel replace based on cell format", "僅取代格式"]
},
{
    "name": "Range.PrintOut (Collate Argument)",
    "category": "Excel 核心操作",
    "description": "Range.PrintOut (以及 Worksheet.PrintOut, Workbook.PrintOut) 的 Collate 引數是一個布林值，指定在列印多份副本時是否逐份整理。True 表示逐份整理 (例如，先印完第一份的第1,2,3頁，再印第二份的第1,2,3頁)。False 表示不整理 (例如，先印所有份數的第1頁，再印所有份數的第2頁)。預設通常為 True。",
    "syntax": "object.PrintOut Copies:=2, Collate:=True",
    "parameters": [],
    "examples": [
        {"code": "' ActiveSheet.PrintOut Copies:=3, Collate:=True\n' MsgBox \"已傳送3份整理好的活動工作表到印表機。\"\n'\n' ActiveSheet.PrintOut Copies:=3, Collate:=False\n' MsgBox \"已傳送3份未整理的活動工作表到印表機 (會先印完3張第一頁，再印3張第二頁等)。\"", "explanation": "演示如何使用 Collate 引數控制列印多份副本時的整理方式。"}
    ],
    "keywords": ["printout collate", "excel print multiple copies sorted", "列印整理"]
},
{
    "name": "Dialogs(xlDialogSaveAs).Show (Return Value and Arguments)",
    "category": "Excel 核心操作",
    "description": "Application.Dialogs(xlDialogSaveAs).Show 方法顯示「另存新檔」對話框。如果使用者點擊「儲存」，則傳回 True，並且檔案會被儲存。如果點擊「取消」，則傳回 False。可以透過在 Show 方法前設定對話框的引數來預填檔名、檔案類型等，例如 `Application.Dialogs(xlDialogSaveAs).Show Arg1:=\"MyNewFileName.xlsx\", Arg2:=51` (Arg2 for FileFormat, 51=xlOpenXMLWorkbook)。",
    "syntax": "Application.Dialogs(xlDialogSaveAs).Show([Arg1 As String_FileName], [Arg2 As Long_FileFormatIndex], ...)",
    "parameters": [],
    "examples": [
        {"code": "Dim suggestedName As String\nsuggestedName = \"Report_\" & Format(Date, \"yyyymmdd\") & \".xlsx\"\nDim fileFormatXLSX As Long: fileFormatXLSX = 51 ' xlOpenXMLWorkbook for .xlsx\n\nIf Application.Dialogs(xlDialogSaveAs).Show(Arg1:=suggestedName, Arg2:=fileFormatXLSX) Then\n    MsgBox \"檔案已儲存 (或使用者點擊了儲存)。目前活頁簿名稱: \" & ActiveWorkbook.Name\nElse\n    MsgBox \"另存新檔操作已取消。\"\nEnd If", "explanation": "顯示「另存新檔」對話框，預設檔案名稱為包含日期的字串，預設檔案類型為 .xlsx。然後根據使用者操作顯示訊息。"}
    ],
    "keywords": ["xldialogsaveas arguments", "excel save as dialog vba", "另存新檔對話框參數"]
},

{
    "name": "Table.Cell(Row,Col).Range.Font (Word)",
    "category": "Word 文件處理",
    "syntax": "tableObject.Cell(Row, Column).Range.Font.Bold = True",
    "description": "存取 Word 表格中特定儲存格內容的 Font 物件，以修改其字元格式。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\n' Set tbl = ActiveDocument.Tables(1)\n' If tbl.Rows.Count >= 2 And tbl.Columns.Count >= 2 Then\n'   With tbl.Cell(2, 2).Range.Font\n'     .Name = \"Verdana\"\n'     .Size = 9\n'     .Italic = True\n'     .ColorIndex = wdBlue\n'   End With\n'   MsgBox \"表格(2,2)儲存格的字型已格式化。\"\n' End If", "explanation": "如果活動文件的第一個表格至少有2列2欄，則獲取其 (2,2) 儲存格的範圍，並設定該儲存格文字的字型為 Verdana、大小9、斜體且藍色。"}
    ],
    "keywords": ["word table cell font", "format table text word", "表格儲存格字型Word"]
},
{
    "name": "Table.Cell(Row,Col).Range.ParagraphFormat (Word)",
    "category": "Word 文件處理",
    "syntax": "tableObject.Cell(Row, Column).Range.ParagraphFormat.Alignment = WdParagraphAlignmentConstant",
    "description": "存取 Word 表格中特定儲存格內容的 ParagraphFormat 物件，以修改其段落格式 (例如對齊方式)。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\n' Set tbl = ActiveDocument.Tables(1)\n' If tbl.Rows.Count >= 1 And tbl.Columns.Count >= 1 Then\n'   tbl.Cell(1, 1).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter\n'   MsgBox \"表格(1,1)儲存格的內容已置中對齊。\"\n' End If", "explanation": "將活動文件第一個表格的 (1,1) 儲存格的內容設定為置中對齊。"}
    ],
    "keywords": ["word table cell paragraph format", "align text in table cell word", "表格儲存格段落格式Word"]
},
{
    "name": "InlineShape.ScaleHeight / .ScaleWidth (Word)",
    "category": "Word 文件處理",
    "syntax": "inlineShapeObject.ScaleHeight = ScaleFactor\ninlineShapeObject.ScaleWidth = ScaleFactor",
    "description": "設定或傳回內嵌圖形相對於其原始大小的高度或寬度縮放比例。ScaleFactor 是一個 Single 值，100 代表原始大小的 100%。",
    "parameters": [{"name": "ScaleFactor", "description": "百分比值 (例如，50 表示 50%)。"}],
    "examples": [
        {"code": "Dim ils As Object ' Word.InlineShape\n' If ActiveDocument.InlineShapes.Count > 0 Then\n'   Set ils = ActiveDocument.InlineShapes(1)\n'   ils.ScaleHeight = 50 ' Scale height to 50% of original\n'   ils.ScaleWidth = 75  ' Scale width to 75% of original\n'   MsgBox \"第一個內嵌圖形的高度已縮放為50%，寬度縮放為75%。\"\n' End If", "explanation": "如果文件中有內嵌圖形，則將第一個內嵌圖形的高度縮放為其原始大小的50%，寬度縮放為75%。"}
    ],
    "keywords": ["word inlineshape scale", "resize inline image percentage", "縮放內嵌圖形"]
},
{
    "name": "HeaderFooter.PageNumbers.Add (Word)",
    "category": "Word 文件處理",
    "syntax": "Set pgNum = headerFooterObject.PageNumbers.Add([PageNumberAlignment As WdPageNumberAlignment = wdAlignPageNumberCenter], [FirstPage As Boolean = True])",
    "description": "將頁碼新增到指定的頁首或頁尾。",
    "parameters": [
        {"name": "PageNumberAlignment", "description": "可選。WdPageNumberAlignment 常數，指定頁碼的對齊方式。"},
        {"name": "FirstPage", "description": "可選。True (預設) 表示在第一頁也顯示頁碼。"}
    ],
    "examples": [
        {"code": "Dim mainFooter As Object ' Word.HeaderFooter\n' Set mainFooter = ActiveDocument.Sections(1).Footers(wdHeaderFooterPrimary)\n' ' Add page number aligned to the right, visible on first page\n' mainFooter.PageNumbers.Add PageNumberAlignment:=wdAlignPageNumberRight, FirstPage:=True\n' ' Optional: Add text like \"Page X of Y\"\n' ' mainFooter.Range.Text = \"Page \" ' Clear existing if any\n' ' mainFooter.Range.Fields.Add Range:=mainFooter.Range.Characters.Last, Type:=wdFieldPage\n' ' mainFooter.Range.InsertAfter \" of \"\n' ' mainFooter.Range.Fields.Add Range:=mainFooter.Range.Characters.Last, Type:=wdFieldNumPages\n' MsgBox \"主要頁尾已新增右對齊的頁碼。\"", "explanation": "在活動文件第一節的主要頁尾新增一個右對齊的頁碼。註解部分展示了如何建立更複雜的「第 X 頁，共 Y 頁」格式。"}
    ],
    "keywords": ["word add page numbers to footer", "insert page field", "頁尾新增頁碼"]
},
{
    "name": "Document.TrackFormatting Property (Word Track Changes)",
    "category": "Word 文件處理",
    "syntax": "documentObject.TrackFormatting = True | False",
    "description": "如果啟用追蹤修訂時，Word 會追蹤格式的變更，則為 True。讀取/寫入布林值。預設通常為 False。",
    "parameters": [{"name": "True | False", "description": "True 表示追蹤格式變更。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.TrackRevisions = True ' Ensure track revisions is on\n' wdDoc.TrackFormatting = True\n' MsgBox \"文件 '\" & wdDoc.Name & \"' 現在會追蹤格式變更 (如果追蹤修訂已啟用)。\"", "explanation": "設定活動文件在啟用追蹤修訂時，同時追蹤格式的變更。"}
    ],
    "keywords": ["word track formatting", "track changes formatting", "追蹤格式變更"]
},
// Outlook
{
    "name": "NameSpace.GetRecipientFromID (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set recip = olNamespace.GetRecipientFromID(EntryID As String)",
    "description": "傳回一個 Recipient 物件，代表具有指定 EntryID 的收件者。EntryID 是來自通訊錄的收件者的唯一識別碼。",
    "parameters": [{"name": "EntryID", "description": "必需。收件者的 EntryID。"}],
    "examples": [
        {"code": "Dim olNS As Object, someUser As Object ' Outlook.Recipient, could be from Address Book\nDim userID As String, retrievedUser As Object\n' Set olNS = Application.GetNamespace(\"MAPI\")\n' ' Example: Get EntryID of the current user (for testing)\n' ' Set someUser = olNS.CurrentUser\n' ' If Not someUser Is Nothing And someUser.Resolved Then\n' '   userID = someUser.AddressEntry.ID\n' '   Set retrievedUser = olNS.GetRecipientFromID(userID)\n' '   If Not retrievedUser Is Nothing And retrievedUser.Resolved Then\n' '     MsgBox \"透過 EntryID 成功獲取收件者: \" & retrievedUser.Name\n' '   Else\n' '     MsgBox \"無法透過 EntryID 獲取或解析收件者。\"\n' '   End If\n' ' Else\n' '   MsgBox \"無法獲取目前使用者的EntryID進行測試。\"\n' ' End If\nMsgBox \"(概念性) GetRecipientFromID 用於從EntryID獲取Recipient物件。\"", "explanation": "概念性地演示如何獲取一個收件者 (例如目前使用者) 的 EntryID，然後使用 GetRecipientFromID 方法透過該 EntryID 重新獲取該 Recipient 物件。"}
    ],
    "keywords": ["outlook getrecipientfromid", "entryid recipient", "access recipient by id", "依ID獲取收件者"]
},
{
    "name": "Explorer.Display (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "explorerObject.Display",
    "description": "顯示指定的 Explorer 物件 (Outlook 主視窗或其副本)。如果該瀏覽器已可見，則此方法會將其帶到前景。",
    "parameters": [],
    "examples": [
        {"code": "Dim olApp As Object, exp As Object ' Outlook.Explorer\n' Set olApp = CreateObject(\"Outlook.Application\")\n' ' Get the active explorer, or create one if none (though usually one exists)\n' Set exp = olApp.ActiveExplorer\n' If exp Is Nothing And olApp.Explorers.Count > 0 Then\n'   Set exp = olApp.Explorers(1)\n' ElseIf exp Is Nothing Then\n'   ' This is less common, usually an explorer opens with app\n'   ' Set exp = olApp.Explorers.Add(olApp.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderInbox))\n' End If\n'\n' If Not exp Is Nothing Then\n'   exp.Display\n'   exp.WindowState = olMaximized ' olMaximized = 1\n'   MsgBox \"Outlook 瀏覽器視窗已顯示並嘗試最大化。\"\n' Else\n'   MsgBox \"沒有可用的 Outlook 瀏覽器視窗。\"\n' End If", "explanation": "獲取活動的 Outlook 瀏覽器視窗 (主視窗)，然後使用 Display 方法確保其可見並嘗試將其帶到前景，並將其最大化。"}
    ],
    "keywords": ["outlook explorer display", "show outlook window", "bring outlook to front", "顯示Outlook視窗"]
},
{
    "name": "Inspector.Display (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "inspectorObject.Display([Modal As Boolean])",
    "description": "顯示指定的 Inspector 物件 (例如，開啟的郵件、約會、連絡人視窗)。如果檢閱器已可見，則此方法會將其帶到前景。",
    "parameters": [{"name": "Modal", "description": "可選。True 表示以強制回應模式顯示 (不常用於檢閱器)。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\nDim olInspector As Object ' Outlook.Inspector\n' Set olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\n' olMail.Subject = \"檢閱器顯示測試\"\n' Set olInspector = olMail.GetInspector ' Get the inspector for this new item\n' olInspector.Display ' Display the new email window\n' MsgBox \"新郵件的檢閱器視窗已顯示。\"", "explanation": "建立一個新的郵件項目，獲取其 Inspector 物件，然後使用 Display 方法將該郵件視窗顯示出來。"}
    ],
    "keywords": ["outlook inspector display", "show item window", "display email window", "顯示項目視窗"]
},
// PowerPoint
{
    "name": "Slide.Shapes.Count (Check before Accessing)",
    "category": "PowerPoint 簡報製作",
    "description": "在嘗試透過索引 (例如 `Shapes(1)`) 或名稱存取投影片上的圖案之前，檢查 `Slide.Shapes.Count` 是否大於0是一個好習慣，以避免在投影片沒有圖案時產生錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\n' Set pptSlide = ActivePresentation.Slides(1)\n' If pptSlide.Shapes.Count > 0 Then\n'   Dim firstShape As Object: Set firstShape = pptSlide.Shapes(1)\n'   MsgBox \"第一個圖案的名稱是: \" & firstShape.Name\n' Else\n'   MsgBox \"第一張投影片上沒有圖案。\"\n' End If", "explanation": "先檢查第一張投影片上是否有圖案，如果有的話，再嘗試存取第一個圖案並顯示其名稱。"}
    ],
    "keywords": ["powerpoint shapes count check", "safe shape access ppt", "檢查圖案數量PPT"]
},
{
    "name": "SlideRange.Tags Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideRangeObject.Tags.Add Name As String, Value As String\nvalueString = slideRangeObject.Tags(Name As String)",
    "description": "Tags 屬性傳回一個 Tags 集合，允許您為投影片範圍 (或單個投影片) 儲存自訂的字串資訊 (鍵值對)。這對於儲存與投影片相關的元數據非常有用。",
    "parameters": [
        {"name": ".Add(Name, Value)", "description": "方法：新增一個標籤。"},
        {"name": ".Item(NameOrIndex) / (NameOrIndex)", "description": "屬性：依名稱或索引獲取標籤的值。"},
        {"name": ".Delete(NameOrIndex)", "description": "方法：刪除標籤。"}
    ],
    "examples": [
        {"code": "Dim sld As Object ' PowerPoint.Slide\n' Set sld = ActivePresentation.Slides(1)\n' ' Add a custom tag\n' On Error Resume Next ' Delete if already exists for re-run\n' sld.Tags.Delete \"ReviewStatus\"\n' On Error GoTo 0\n' sld.Tags.Add \"ReviewStatus\", \"PendingApproval\"\n' sld.Tags.Add \"Version\", \"1.2\"\n'\n' ' Retrieve the tag value\n' Dim status As String: status = sld.Tags(\"ReviewStatus\")\n' MsgBox \"投影片1的 ReviewStatus 標籤是: \" & status\n'\n' ' Iterate through all tags\n' Dim tg As Object ' PowerPoint.Tag\n' Debug.Print \"投影片1的所有標籤:\"\n' For Each tg In sld.Tags\n'   Debug.Print \"  \" & tg.Name & \" = \" & tg.Value\n' Next tg", "explanation": "為第一張投影片新增兩個自訂標籤 (\"ReviewStatus\" 和 \"Version\")，然後讀取其中一個標籤的值，並遍歷所有標籤列印其名稱和值。"}
    ],
    "keywords": ["powerpoint slide tags", "custom slide metadata", "store data in slide ppt", "投影片標籤", "自訂投影片資訊"]
},
// FSO
{
    "name": "FileSystemObject.BuildPath (Multiple Components)",
    "category": "檔案與資料夾管理",
    "description": "FileSystemObject 的 BuildPath 方法會正確處理路徑組件是否已包含路徑分隔符號的情況，確保最終路徑格式正確。它可以將多個組件串聯起來。",
    "syntax": "fullPath = fso.BuildPath(Path1, Path2)",
    "parameters": [{"name": "Path1, Path2", "description": "要組合的路徑組件。"}],
    "examples": [
        {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nDim p1 As String, p2 As String, p3 As String, resultPath As String\np1 = \"C:\\Users\\Public\"\np2 = \"Documents\"\np3 = \"Report.docx\"\nresultPath = fso.BuildPath(fso.BuildPath(p1, p2), p3)\nDebug.Print \"組合路徑1: \" & resultPath ' C:\\Users\\Public\\Documents\\Report.docx\n\np1 = \"C:\\TempFolder\\\" ' Path with trailing slash\np2 = \"SubFolder1\"\nresultPath = fso.BuildPath(p1, p2)\nDebug.Print \"組合路徑2: \" & resultPath ' C:\\TempFolder\\SubFolder1\nSet fso = Nothing", "explanation": "第一個範例演示如何使用兩次 BuildPath 來組合三個路徑組件。第二個範例顯示即使第一個路徑組件以反斜線結尾，BuildPath 也能正確處理，不會產生雙反斜線。"}
    ],
    "keywords": ["fso buildpath multiple", "join path components", "construct file path fso", "組合多個路徑"]
},
// String
{
    "name": "Mid Function (Return Remainder of String)",
    "category": "字串與文本操作",
    "description": "如果 Mid(string, start, [length]) 函數的 length 引數被省略，或者 length 大於從 start 位置開始的字串剩餘長度，則 Mid 函數會傳回從 start 位置開始到字串結尾的所有字元。",
    "syntax": "Mid(StringExpression, StartPosition, [Length])",
    "parameters": [],
    "examples": [
        {"code": "Dim myString As String: myString = \"Hello VBA World!\"\nDim sub1 As String, sub2 As String\n' Get substring from 6th character to the end\nsub1 = Mid(myString, 7) ' Note: Space is 6th, V is 7th\nDebug.Print \"Mid(myString, 7) = '\" & sub1 & \"'\" ' Output: 'VBA World!'\n\n' Length argument (100) is greater than remaining length\nsub2 = Mid(myString, 7, 100)\nDebug.Print \"Mid(myString, 7, 100) = '\" & sub2 & \"'\" ' Output: 'VBA World!' (same as above)", "explanation": "演示當 Mid 函數的 length 引數省略或超出實際剩餘長度時，它如何傳回從起始位置到字串末尾的所有字元。"}
    ],
    "keywords": ["mid function omit length", "substring to end", "get rest of string", "Mid函數省略長度"]
},
// Math
{
    "name": "WorksheetFunction.Mdeterm (Excel - Matrix Determinant)",
    "category": "數學、日期與時間",
    "syntax": "determinant = Application.WorksheetFunction.Mdeterm(Array As Object)",
    "description": "使用 Excel 的 MDETERM 工作表函數，傳回一個方陣 (儲存格範圍或VBA陣列) 的矩陣行列式值。",
    "parameters": [{"name": "Array", "description": "必需。一個包含數字的方陣 (相同列數和欄數) 的 Range 物件或 VBA 陣列。"}],
    "examples": [
        {"code": "Dim myMatrix(1 To 2, 1 To 2) As Double\nDim detValue As Double\nmyMatrix(1, 1) = 4: myMatrix(1, 2) = 2\nmyMatrix(2, 1) = 3: myMatrix(2, 2) = 5\n' Determinant = (4*5) - (2*3) = 20 - 6 = 14\nOn Error Resume Next ' Mdeterm requires a square matrix of numbers\ndetValue = Application.WorksheetFunction.Mdeterm(myMatrix)\nIf Err.Number = 0 Then\n  MsgBox \"2x2 矩陣 [[4,2],[3,5]] 的行列式值是: \" & detValue\nElse\n  MsgBox \"計算行列式失敗: \" & Err.Description\nEnd If\nOn Error GoTo 0\n\n' Using a range\n' Range(\"A1:B2\").Value = myMatrix\n' detValue = Application.WorksheetFunction.Mdeterm(Range(\"A1:B2\"))\n' MsgBox \"範圍 A1:B2 的行列式值是: \" & detValue", "explanation": "定義一個2x2的VBA雙精度陣列作為矩陣，然後使用 MDETERM 函數計算其行列式值。同時顯示了如何對儲存格範圍使用此函數 (註解中)。"}
    ],
    "keywords": ["mdeterm", "matrix determinant", "excel mdeterm vba", "矩陣行列式"]
},
{
    "name": "WorksheetFunction.MInverse (Excel - Matrix Inverse)",
    "category": "數學、日期與時間",
    "syntax": "inverseMatrixArray = Application.WorksheetFunction.MInverse(Array As Object)",
    "description": "使用 Excel 的 MINVERSE 工作表函數，傳回一個方陣的逆矩陣。傳回的結果是一個與原始矩陣大小相同的陣列。",
    "parameters": [{"name": "Array", "description": "必需。一個包含數字的方陣的 Range 物件或 VBA 陣列。"}],
    "examples": [
        {"code": "Dim myMatrix(1 To 2, 1 To 2) As Double\nDim invMatrix As Variant ' Will be a 2D array\nmyMatrix(1, 1) = 4: myMatrix(1, 2) = 7\nmyMatrix(2, 1) = 2: myMatrix(2, 2) = 6\n' For matrix [[a,b],[c,d]], inverse is (1/(ad-bc))*[[d,-b],[-c,a]]\n' Determinant = (4*6) - (7*2) = 24 - 14 = 10\n' Inverse = (1/10) * [[6,-7],[-2,4]] = [[0.6, -0.7],[-0.2, 0.4]]\nOn Error Resume Next\ninvMatrix = Application.WorksheetFunction.MInverse(myMatrix)\nIf Err.Number = 0 And IsArray(invMatrix) Then\n  MsgBox \"矩陣 [[4,7],[2,6]] 的逆矩陣是: \" & vbCrLf & _\n         \"[\" & invMatrix(1, 1) & \", \" & invMatrix(1, 2) & \"]\" & vbCrLf & _\n         \"[\" & invMatrix(2, 1) & \", \" & invMatrix(2, 2) & \"]\"\nElse\n  MsgBox \"計算逆矩陣失敗 (可能矩陣不可逆): \" & Err.Description\nEnd If\nOn Error GoTo 0", "explanation": "定義一個2x2的VBA雙精度陣列，然後使用 MINVERSE 函數計算其逆矩陣。結果會是一個包含逆矩陣元素的新陣列。"}
    ],
    "keywords": ["minverse", "matrix inverse", "excel minverse vba", "逆矩陣"]
},
{
    "name": "WorksheetFunction.MMult (Excel - Matrix Multiplication)",
    "category": "數學、日期與時間",
    "syntax": "resultMatrixArray = Application.WorksheetFunction.MMult(Array1 As Object, Array2 As Object)",
    "description": "使用 Excel 的 MMULT 工作表函數，傳回兩個陣列的矩陣乘積。結果陣列的列數與 Array1 相同，欄數與 Array2 相同。Array1 的欄數必須與 Array2 的列數相同。",
    "parameters": [
        {"name": "Array1", "description": "必需。第一個要相乘的矩陣 (Range 或 VBA Array)。"},
        {"name": "Array2", "description": "必需。第二個要相乘的矩陣 (Range 或 VBA Array)。"}
    ],
    "examples": [
        {"code": "Dim matrixA(1 To 2, 1 To 3) As Double ' 2x3\nDim matrixB(1 To 3, 1 To 2) As Double ' 3x2\nDim resultC As Variant ' Will be 2x2\n' Populate matrixA and matrixB\nmatrixA(1,1)=1: matrixA(1,2)=2: matrixA(1,3)=3\nmatrixA(2,1)=4: matrixA(2,2)=5: matrixA(2,3)=6\n\nmatrixB(1,1)=7: matrixB(1,2)=8\nmatrixB(2,1)=9: matrixB(2,2)=10\nmatrixB(3,1)=11: matrixB(3,2)=12\n\nOn Error Resume Next\nresultC = Application.WorksheetFunction.MMult(matrixA, matrixB)\nIf Err.Number = 0 And IsArray(resultC) Then\n  MsgBox \"2x3 矩陣 A 與 3x2 矩陣 B 的乘積 (2x2 結果): \" & vbCrLf & _\n         \"[\" & resultC(1, 1) & \", \" & resultC(1, 2) & \"]\" & vbCrLf & _\n         \"[\" & resultC(2, 1) & \", \" & resultC(2, 2) & \"]\"\n  ' Expected C(1,1) = 1*7 + 2*9 + 3*11 = 7 + 18 + 33 = 58\n  ' Expected C(1,2) = 1*8 + 2*10 + 3*12 = 8 + 20 + 36 = 64\n  ' Expected C(2,1) = 4*7 + 5*9 + 6*11 = 28 + 45 + 66 = 139\n  ' Expected C(2,2) = 4*8 + 5*10 + 6*12 = 32 + 50 + 72 = 154\nElse\n  MsgBox \"矩陣相乘失敗 (檢查維度是否匹配): \" & Err.Description\nEnd If\nOn Error GoTo 0", "explanation": "定義一個2x3的矩陣A和一個3x2的矩陣B，然後使用 MMULT 函數計算它們的乘積，結果將是一個2x2的矩陣。"}
    ],
    "keywords": ["mmult", "matrix multiplication", "excel mmult vba", "矩陣相乘"]
},
// Data Types
{
    "name": "vbBoolean Constant (VarType)",
    "category": "資料類型、轉換與驗證",
    "syntax": "vbBoolean",
    "description": "VbVarType 列舉中的一個常數，其值為 11。VarType 函數在檢查 Boolean 資料類型變數時會傳回此值。",
    "parameters": [],
    "examples": [
        {"code": "Dim myFlag As Boolean: myFlag = True\nIf VarType(myFlag) = vbBoolean Then\n  Debug.Print \"myFlag 的 VarType 是 vbBoolean (\" & vbBoolean & \").\"\nElse\n  Debug.Print \"myFlag 的 VarType 不是 vbBoolean: \" & VarType(myFlag)\nEnd If", "explanation": "檢查一個 Boolean 變數的 VarType 是否等於 vbBoolean 常數。"}
    ],
    "keywords": ["vbboolean", "vartype boolean", "boolean data type code", "布林類型代碼"]
},
{
    "name": "vbDataObject Constant (VarType)",
    "category": "資料類型、轉換與驗證",
    "syntax": "vbDataObject",
    "description": "VbVarType 列舉中的一個常數，其值為 13。VarType 函數在檢查非 OLE 自動化物件 (例如，由 VBA 內部建立的某些物件，或某些非 COM 的外部物件) 時可能會傳回此值。與 vbObject (9) 相區分，vbObject 通常指 OLE 自動化物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim dataObj As Object\n' On Error Resume Next ' MSForms.DataObject might not be available\n' Set dataObj = CreateObject(\"Forms.DataObject.1\") ' This is an OLE Automation object\n' If Not dataObj Is Nothing Then\n'   Debug.Print \"MSForms.DataObject - VarType: \" & VarType(dataObj) & \" (vbObject = \" & vbObject & \")\"\n' Else\n'   Debug.Print \"無法建立 Forms.DataObject。\"\n' End If\n' On Error GoTo 0\n' ' It's hard to create a simple vbDataObject example without specific non-OLE object context.\n' ' Most objects created with CreateObject or New are vbObject.\nDebug.Print \"vbDataObject 常數值: \" & vbDataObject & \". 此類型在一般VBA中較少直接遇到。\"", "explanation": "顯示 vbDataObject 常數的值。實際中，VBA程式設計師更常遇到 vbObject。MSForms.DataObject 通常被識別為 vbObject。vbDataObject 更多地與 Visual Basic (非VBA) 或特定內部資料物件相關。"}
    ],
    "keywords": ["vbdataobject", "vartype dataobject", "non-ole object", "資料物件類型代碼"]
},
// Program Flow
{
    "name": "Declare Statement (Optional Parameters in API)",
    "category": "程式流程與結構控制",
    "description": "當宣告的 Windows API 函數包含可選參數時，可以在 Declare 語句中使用 Optional 關鍵字。然而，並非所有 API 的「可選」參數都適合直接在 VBA Declare 中標記為 Optional。通常，如果 API 函數的可選參數是透過傳遞 Null 指標 (0& 或 vbNullPtr) 來表示省略，則在 VBA Declare 中該參數仍需宣告為 ByVal As LongPtr (或 Long)，然後在呼叫時傳遞 0&。只有當 API 確實設計為可以完全不傳遞某個參數 (這在 C/C++ 風格的 DLL 中不常見) 時，VBA 的 Optional 才直接適用。",
    "syntax": "' Declare PtrSafe Function MyApi Lib \"...\" (Optional ByVal optParam As Long = 0) As Long",
    "parameters": [],
    "examples": [
        {"code": "' Example: SleepEx API (dwMilliseconds is required, bAlertable is optional-like but typically passed)\n' #If VBA7 Then\n' Private Declare PtrSafe Function SleepEx Lib \"kernel32\" (\n'     ByVal dwMilliseconds As Long, ByVal bAlertable As Boolean) As Long\n' #Else\n' Private Declare Function SleepEx Lib \"kernel32\" (\n'     ByVal dwMilliseconds As Long, ByVal bAlertable As Boolean) As Long\n' #End If\n'\n' Sub TestSleepEx()\n'   Debug.Print \"開始 SleepEx (2秒，不可警告)... \" & Time\n'   SleepEx 2000, False ' bAlertable is passed as False\n'   Debug.Print \"SleepEx 結束。 \" & Time\n'\n'   ' If bAlertable was truly optional in VBA sense (it's not for SleepEx, it's a required boolean):\n'   ' You would define it with Optional and a default in Declare if API allowed omitting it.\n'   ' But for most WinAPIs, even if conceptually optional, they expect a value (like 0 or False).\n'   MsgBox \"SleepEx 的 bAlertable 參數在C中不是傳統意義上的可選，VBA中需傳值。\"\n' End Sub", "explanation": "演示 SleepEx API，其 `bAlertable` 參數雖然在功能上是「可選的行為修飾」，但在 Declare 語句中仍需作為必需參數傳遞。VBA 的 Optional 關鍵字在 Declare 中用於 DLL 函數的參數時，需要非常小心，確保 DLL 函數的設計確實支援完全省略該參數的呼叫方式。"}
    ],
    "keywords": ["declare optional api parameter", "api optional argument", "windows api optional", "API可選參數宣告"]
},
// External API
{
    "name": "WScript.Shell.LogEvent (Write to Event Log - Admin Rights)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "WScript.Shell 物件的 LogEvent 方法可以將一個項目寫入 Windows 事件日誌 (應用程式日誌)。Type 可以是 0 (SUCCESS), 1 (ERROR), 2 (WARNING), 4 (INFORMATION), 8 (AUDIT_SUCCESS), 16 (AUDIT_FAILURE)。要成功寫入事件日誌，執行 VBA 的使用者通常需要足夠的權限 (可能是管理員權限，取決於事件來源是否已註冊)。",
    "syntax": "wshShell.LogEvent(Type As Long, Message As String, [Target As String = SystemName])",
    "parameters": [
        {"name": "Type", "description": "事件類型 (0, 1, 2, 4, 8, 16)。"},
        {"name": "Message", "description": "要記錄的訊息字串。"},
        {"name": "Target", "description": "可選。記錄事件的目標電腦名稱。預設為本機。"}
    ],
    "examples": [
        {"code": "Dim wsh As Object\nSet wsh = CreateObject(\"WScript.Shell\")\nDim success As Boolean\nOn Error Resume Next ' Logging can fail due to permissions\nsuccess = wsh.LogEvent(4, \"VBA Script 'MyProcess' completed successfully at \" & Now) ' 4 = Information\nIf Err.Number = 0 And success Then ' LogEvent returns True on success\n  MsgBox \"一條資訊事件已嘗試寫入應用程式事件日誌。\"\nElseIf Not success And Err.Number = 0 Then\n  MsgBox \"LogEvent 報告失敗 (可能權限不足或事件來源未註冊)。\"\nElse\n  MsgBox \"寫入事件日誌時發生錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\nSet wsh = Nothing", "explanation": "嘗試將一條資訊類型的事件寫入本機電腦的應用程式事件日誌。執行此操作可能需要管理員權限，或者應用程式需要預先註冊為事件來源。"}
    ],
    "keywords": ["wscript.shell logevent", "write to windows event log", "vba event logging", "system event log", "寫入事件日誌"]
},
{
    "name": "MSXML2.DOMDocument (parseError Properties)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "當 MSXML2.DOMDocument 的 Load 或 LoadXML 方法失敗時 (例如，XML 格式錯誤或驗證失敗)，其 parseError 物件會被填充，提供有關錯誤的詳細資訊。主要屬性包括：\n.errorCode (Long): 錯誤碼 (0表示無錯誤)。\n.reason (String): 對錯誤的可讀描述。\n.line (Long): 錯誤發生的行號 (1-based)。\n.linepos (Long): 錯誤在行中的字元位置 (1-based)。\n.srcText (String): 包含錯誤的原始 XML 行的文本。\n.url (String): 包含錯誤的 XML 文件的 URL (如果從檔案或 URL 載入)。",
    "syntax": "If xmlDoc.parseError.errorCode <> 0 Then\n  errorDetails = \"Code: \" & xmlDoc.parseError.errorCode & _\n                 \"Reason: \" & xmlDoc.parseError.reason & _\n                 \"Line: \" & xmlDoc.parseError.line\nEnd If",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object ' MSXML2.DOMDocument60\nDim xmlMalformed As String: xmlMalformed = \"<root><item>Value1</item><anotherItem>Value2</rootBAD_CLOSING_TAG>\"\nDim errObj As Object ' IXMLDOMParseError\n\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\nxmlDoc.LoadXML xmlMalformed\n\nSet errObj = xmlDoc.parseError\nIf errObj.errorCode <> 0 Then\n  Debug.Print \"--- XML 解析錯誤詳情 ---\"\n  Debug.Print \"錯誤碼 (ErrorCode): \" & errObj.errorCode\n  Debug.Print \"原因 (Reason): \" & errObj.reason\n  Debug.Print \"URL: \" & errObj.URL ' Empty if loaded from string\n  Debug.Print \"行號 (Line): \" & errObj.Line\n  Debug.Print \"行中位置 (Linepos): \" & errObj.linepos\n  Debug.Print \"來源文本 (SrcText): \" & errObj.srcText\n  MsgBox \"XML 解析失敗。請檢查立即視窗獲取詳細錯誤信息。\"\nElse\n  MsgBox \"XML 已成功解析 (此訊息不應出現於此範例)。\"\nEnd If\nSet xmlDoc = Nothing: Set errObj = Nothing", "explanation": "載入一個格式錯誤的 XML 字串。然後，如果 parseError.errorCode 不是0，則列印 parseError 物件的各個屬性，以顯示有關解析失敗的詳細信息，包括錯誤原因、行號、行內位置和包含錯誤的源文本。"}
    ],
    "keywords": ["msxml parseerror", "xml validation error details", "ixmldomparseerror", "debug xml parsing", "XML解析錯誤詳情"]
},
{
    "name": "ADODB.Recordset (BOF and EOF Properties)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 BOF (Beginning Of File) 和 EOF (End Of File) 屬性用於判斷記錄指標的目前位置：\nBOF: 如果目前記錄位置在第一筆記錄之前，則為 True。\nEOF: 如果目前記錄位置在最後一筆記錄之後，則為 True。\n如果 Recordset 為空 (沒有記錄)，則 BOF 和 EOF 都會是 True。\n在遍歷 Recordset (例如使用 MoveNext) 之前，通常先檢查 Not rs.EOF。在向後遍歷 (例如使用 MovePrevious) 之前，檢查 Not rs.BOF。",
    "parameters": [],
    "examples": [
        {"code": "Dim rs As Object ' ADODB.Recordset\n' ' Assume rs is opened with some records, or it might be empty\n' Set rs = CreateObject(\"ADODB.Recordset\")\n' ' rs.Open \"SELECT * FROM SomeTable WHERE 1=0\", conn ' Example of an empty recordset query\n'\n' ' Check for empty recordset\n' If rs.BOF And rs.EOF Then\n'   Debug.Print \"資料錄集為空。\"\n' ElseIf Not rs.EOF Then ' Has records, MoveFirst to ensure starting correctly\n'   rs.MoveFirst\n'   Debug.Print \"--- 遍歷記錄 (向前) ---\"\n'   Do While Not rs.EOF\n'     Debug.Print rs.Fields(0).Value ' Print first field\n'     rs.MoveNext\n'   Loop\n' Else\n'   Debug.Print \"資料錄集已在EOF (可能是空的或已遍歷完畢)。\"\n' End If\n'\n' ' Example of moving backwards (requires cursor that supports it, e.g., adOpenStatic or adOpenKeyset)\n' ' If Not (rs.BOF And rs.EOF) And (rs.CursorType = adOpenStatic Or rs.CursorType = adOpenKeyset) Then\n' '   rs.MoveLast\n' '   Debug.Print \"--- 遍歷記錄 (向後) ---\"\n' '   Do While Not rs.BOF\n' '     Debug.Print rs.Fields(0).Value\n' '     rs.MovePrevious\n' '   Loop\n' ' End If\n' If Not rs Is Nothing Then If rs.State = 1 Then rs.Close\n' Set rs = Nothing\nMsgBox \"(概念性) 演示了BOF和EOF屬性。需有實際資料錄集。\"", "explanation": "演示如何使用 BOF 和 EOF 屬性來檢查 Recordset 是否為空，以及在向前遍歷記錄時作為迴圈的條件。同時概念性地展示了在向後遍歷時如何使用 BOF。"}
    ],
    "keywords": ["adodb bof eof", "recordset empty check", "beginning of file", "end of file", "loop through recordset", "記錄集開頭結尾"]
},
{
    "name": "Command.CreateParameter (Full Argument List)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Command 物件的 CreateParameter 方法用於建立並傳回一個新的 Parameter 物件。其完整引數列表為：\n`CreateParameter([Name As String], [Type As DataTypeEnum], [Direction As ParameterDirectionEnum = adParamInput], [Size As Long], [Value As Variant])`\nName: 參數名稱 (例如，在 SQL Server 中是 \"@ParamName\")。\nType: 參數的資料類型 (DataTypeEnum 常數，如 adVarChar, adInteger, adDate)。\nDirection: 參數的方向 (ParameterDirectionEnum，如 adParamInput, adParamOutput, adParamReturnValue)。\nSize: 對於可變長度類型 (如 adVarChar, adBinary)，指定最大大小。\nValue: 參數的初始值。",
    "syntax": "Set param = cmd.CreateParameter(Name, Type, Direction, Size, Value)",
    "parameters": [],
    "examples": [
        {"code": "Dim cmd As Object, paramCustomerName As Object, paramOrderID_Output As Object\n' Set cmd = CreateObject(\"ADODB.Command\")\n' ' ... (Set cmd.ActiveConnection, cmd.CommandType = adCmdStoredProc, cmd.CommandText = \"sp_ProcessOrder\") ...\n'\n' ' Input Parameter: Customer Name (VARCHAR, size 50)\n' Set paramCustomerName = cmd.CreateParameter(\"@CustomerName\", adVarChar, adParamInput, 50, \"John Doe\")\n' cmd.Parameters.Append paramCustomerName\n'\n' ' Output Parameter: New Order ID (INTEGER)\n' Set paramOrderID_Output = cmd.CreateParameter(\"@NewOrderID\", adInteger, adParamOutput)\n' cmd.Parameters.Append paramOrderID_Output\n'\n' ' cmd.Execute ' Execute the stored procedure\n'\n' ' After execution, retrieve the output parameter value\n' ' Dim newGeneratedOrderID As Long\n' ' newGeneratedOrderID = cmd.Parameters(\"@NewOrderID\").Value\n' ' Debug.Print \"新產生的訂單ID: \" & newGeneratedOrderID\nMsgBox \"(概念性) 演示了CreateParameter的完整引數。需有預存程序。\"", "explanation": "演示如何使用 CreateParameter 方法為預存程序建立一個輸入參數 (`@CustomerName`) 和一個輸出參數 (`@NewOrderID`)，指定它們的名稱、資料類型、方向、大小 (對於字串) 和初始值 (對於輸入參數)。"}
    ],
    "keywords": ["adodb createparameter", "ado command parameter details", "parameterdirectionenum", "datatypeenum", "建立參數ADO"]
},
{
    "name": "ADODB.Connection (Errors Collection)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Connection 物件有一個 Errors 集合，其中包含在上次資料提供者操作期間發生的所有錯誤。每個錯誤都是一個 Error 物件 (ADODB.Error)。如果操作成功，Errors 集合為空。這對於獲取比 VBA 的 `Err` 物件更詳細的資料庫特定錯誤資訊非常有用。",
    "syntax": "For Each errItem In adoConnectionObject.Errors\n  Debug.Print errItem.Number, errItem.Description, errItem.Source\nNext errItem",
    "parameters": [
        {"name": "Error.Number", "description": "提供者特定的錯誤號碼。"},
        {"name": "Error.Description", "description": "錯誤的文字描述。"},
        {"name": "Error.Source", "description": "產生錯誤的物件或應用程式的名稱。"},
        {"name": "Error.SQLState", "description": "SQL 狀態錯誤碼 (5個字元)。"},
        {"name": "Error.NativeError", "description": "資料來源特定的原生錯誤碼。"}
    ],
    "examples": [
        {"code": "Dim conn As Object ' ADODB.Connection\nDim errADO As Object ' ADODB.Error\nDim connStrInvalid As String: connStrInvalid = \"Provider=SQLOLEDB;Data Source=NonExistentServer;Initial Catalog=NonExistentDB;User ID=sa;Password=pwd;Connect Timeout=5\"\n\nSet conn = CreateObject(\"ADODB.Connection\")\nOn Error Resume Next ' Let ADO handle the error and populate its Errors collection\nconn.Open connStrInvalid\n\nIf conn.Errors.Count > 0 Then\n    Debug.Print \"--- ADO 連接錯誤詳情 ---\"\n    For Each errADO In conn.Errors\n        Debug.Print \"  錯誤號 (Number): \" & errADO.Number\n        Debug.Print \"  描述 (Description): \" & errADO.Description\n        Debug.Print \"  來源 (Source): \" & errADO.Source\n        Debug.Print \"  SQL狀態 (SQLState): \" & errADO.SQLState\n        Debug.Print \"  原生錯誤 (NativeError): \" & errADO.NativeError\n        Debug.Print \"  -------------------\"\n    Next errADO\n    MsgBox conn.Errors.Count & \" 個ADO錯誤發生。請檢查立即視窗。\"\nElseIf conn.State <> 1 Then ' adStateOpen\n    MsgBox \"連接失敗，但ADO Errors集合為空。VBA錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\nIf conn.State = 1 Then conn.Close\nSet conn = Nothing: Set errADO = Nothing", "explanation": "嘗試使用一個無效的連接字串打開 ADODB 連接。然後，遍歷 Connection 物件的 Errors 集合，以列印由資料提供者產生的所有錯誤的詳細信息，包括錯誤號、描述、來源、SQLState 和原生錯誤碼。這提供了比 VBA `Err` 物件更豐富的資料庫錯誤上下文。"}
    ],
    "keywords": ["adodb errors collection", "ado error object", "database provider errors", "sqlstate", "nativeerror", "ADO錯誤集合"]
},
// Excel 核心操作
{
    "name": "Range.AddressLocal",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AddressLocal([RowAbsolute], [ColumnAbsolute], [ReferenceStyle], [External], [RelativeTo])",
    "description": "以使用者語言傳回代表儲存格範圍參照的字串。",
    "parameters": [
        {"name": "RowAbsolute", "description": "可選。True 表示傳回絕對列參照。預設為 True。"},
        {"name": "ColumnAbsolute", "description": "可選。True 表示傳回絕對欄參照。預設為 True。"},
        {"name": "ReferenceStyle", "description": "可選。XlReferenceStyle 常數 (xlA1 或 xlR1C1)。預設為 xlA1。"},
        {"name": "External", "description": "可選。True 表示傳回包含工作簿和工作表名稱的外部參照。預設為 False。"},
        {"name": "RelativeTo", "description": "可選。如果 ReferenceStyle 是 xlA1，則此引數是一個 Range 物件，指定傳回相對位址的左上角儲存格。"}
    ],
    "examples": [
        {"code": "MsgBox Range(\"A1\").AddressLocal ' 在中文Excel中可能傳回 \"$A$1\" (取決於設定)", "explanation": "取得儲存格 A1 的本地化絕對位址。"}
    ],
    "keywords": ["位址本地化", "儲存格參照", "excel", "cell address local", "localized reference"]
},
{
    "name": "Range.AdvancedFilter",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AdvancedFilter(Action As XlFilterAction, [CriteriaRange], [CopyToRange], [Unique As Boolean = False])",
    "description": "根據準則範圍篩選清單。可以將結果複製到其他位置或就地篩選。",
    "parameters": [
        {"name": "Action", "description": "必需。XlFilterAction 常數 (xlFilterInPlace 或 xlFilterCopy)。"},
        {"name": "CriteriaRange", "description": "可選。包含篩選準則的範圍。"},
        {"name": "CopyToRange", "description": "可選。如果 Action 是 xlFilterCopy，則為複製篩選結果的目標範圍。"},
        {"name": "Unique", "description": "可選。True 表示僅篩選唯一記錄。"}
    ],
    "examples": [
        {"code": "' 假設 A1:D100 是資料範圍，F1:F2 是準則範圍，結果複製到 H1\n' Range(\"A1:D100\").AdvancedFilter Action:=xlFilterCopy, CriteriaRange:=Range(\"F1:F2\"), CopyToRange:=Range(\"H1\"), Unique:=False", "explanation": "對 A1:D100 範圍執行進階篩選，使用 F1:F2 的準則，並將結果複製到 H1 開始的區域。"}
    ],
    "keywords": ["進階篩選", "複雜篩選", "excel", "advanced filter", "criteria filter"]
},
{
    "name": "Worksheet.Cells.SpecialCells",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Cells.SpecialCells(Type As XlCellType, [Value])",
    "description": "傳回一個 Range 物件，代表工作表上所有符合指定類型和值的儲存格。與 Range.SpecialCells 類似，但通常應用於整個工作表的儲存格。",
    "parameters": [
        {"name": "Type", "description": "必需。XlCellType 常數。"},
        {"name": "Value", "description": "可選。如果 Type 是 xlCellTypeConstants 或 xlCellTypeFormulas，則此引數用於確定結果中包含哪些類型的儲存格。"}
    ],
    "examples": [
        {"code": "Dim constantsOnly As Range\nOn Error Resume Next\nSet constantsOnly = ActiveSheet.Cells.SpecialCells(xlCellTypeConstants)\nOn Error GoTo 0\nIf Not constantsOnly Is Nothing Then constantsOnly.Interior.Color = vbYellow", "explanation": "高亮顯示活動工作表上所有包含常數的儲存格。"}
    ],
    "keywords": ["全表特殊儲存格", "篩選工作表儲存格", "excel", "worksheet special cells", "all cells filter"]
},
{
    "name": "Range.ShowDetail",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ShowDetail [= True | False]",
    "description": "如果範圍是分級顯示 (大綱) 中可展開或摺疊的摘要列或摘要欄的左上角儲存格，則此屬性設定或傳回該摘要的詳細資料是否顯示。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示詳細資料 (展開)，False 表示隱藏詳細資料 (摺疊)。"}],
    "examples": [
        {"code": "' 假設第5列是一個已分組/大綱的摘要列\n' If Rows(5).ShowDetail = False Then Rows(5).ShowDetail = True ' 展開第5列的詳細資料", "explanation": "如果第5列的詳細資料是摺疊的，則將其展開。"}
    ],
    "keywords": ["顯示詳細資料", "展開大綱", "摺疊大綱", "excel", "show detail", "outline expand", "outline collapse"]
},
{
    "name": "Workbook.Names.Add",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.Names.Add(Name As String, RefersTo As String, [Visible As Boolean = True], [MacroType], [ShortcutKey], [Category], [NameLocal], [RefersToLocal], [CategoryLocal], [RefersToR1C1], [RefersToR1C1Local])",
    "description": "在活頁簿中定義一個新的名稱 (已命名範圍或常數)。",
    "parameters": [
        {"name": "Name", "description": "必需。新名稱的文字。"},
        {"name": "RefersTo", "description": "必需。名稱所參照的公式或值 (A1 樣式或 R1C1 樣式，取決於 RefersToR1C1/Local 引數)。"}
    ],
    "examples": [
        {"code": "ThisWorkbook.Names.Add Name:=\"SalesTaxRate\", RefersTo:=\"=0.05\"\nMsgBox \"SalesTaxRate 的值: \" & [SalesTaxRate]", "explanation": "定義一個名為 \"SalesTaxRate\" 的活頁簿級別常數，其值為 0.05。"},
        {"code": "ActiveSheet.Names.Add Name:=\"MyDataArea\", RefersTo:=\"=Sheet1!$A$1:$C$10\"\nRange(\"MyDataArea\").Font.Bold = True", "explanation": "定義一個名為 \"MyDataArea\" 的工作表級別已命名範圍，參照 Sheet1 上的 A1:C10。"}
    ],
    "keywords": ["新增名稱", "已命名範圍", "定義名稱", "excel", "add named range", "define name", "named constant"]
},
{
    "name": "Worksheet.Evaluate (Short Bracket Form)",
    "category": "Excel 核心操作",
    "syntax": "result = [SheetName!Expression]",
    "description": "Worksheet.Evaluate 方法的簡寫形式，用於在特定工作表的上下文中計算運算式。",
    "parameters": [{"name": "SheetName!Expression", "description": "工作表名稱後接驚嘆號，再加上要計算的運算式（如儲存格參照、已命名範圍或公式）。"}],
    "examples": [
        {"code": "Worksheets(\"Sheet1\").Range(\"A1\").Value = 100\nDim val As Variant\nval = [Sheet1!A1*2]\nMsgBox \"Sheet1!A1 * 2 = \" & val", "explanation": "計算 Sheet1 上 A1 儲存格的值乘以 2。"}
    ],
    "keywords": ["工作表計算", "簡寫evaluate", "excel", "worksheet evaluate shortcut", "sheet specific calculation"]
},
// Word Document Processing
{
    "name": "Document.Paragraphs.First / .Last (Word)",
    "category": "Word 文件處理",
    "syntax": "Set firstPara = documentObject.Paragraphs.First\nSet lastPara = documentObject.Paragraphs.Last",
    "description": "Paragraphs 集合的 First 和 Last 屬性分別傳回文件中的第一個和最後一個段落物件。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Paragraphs.Count > 0 Then\n'   wdDoc.Paragraphs.First.Range.Font.Size = 16\n'   wdDoc.Paragraphs.Last.Range.InsertAfter vbCrLf & \"--- 文件結束 ---\"\n'   MsgBox \"已修改第一個和最後一個段落。\"\n' End If", "explanation": "將文件第一個段落的字型大小設為16，並在最後一個段落後新增文字。"}
    ],
    "keywords": ["word first paragraph", "word last paragraph", "document start end paragraph", "第一個段落", "最後一個段落"]
},
{
    "name": "Range.Characters (Word)",
    "category": "Word 文件處理",
    "syntax": "Set charsCollection = rangeObject.Characters",
    "description": "傳回一個 Characters 集合，代表範圍中的字元。可以逐字元存取和格式化。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdRange As Object ' Word.Range\nDim firstChar As Object ' Word.Range (representing a character)\n' Set wdRange = ActiveDocument.Paragraphs(1).Range\n' If wdRange.Characters.Count > 0 Then\n'   Set firstChar = wdRange.Characters(1)\n'   firstChar.Font.ColorIndex = wdRed ' Make the first character red\n'   MsgBox \"第一個段落的第一個字元已設為紅色。\"\n' End If", "explanation": "獲取第一個段落的範圍，然後將其第一個字元的顏色設為紅色。"}
    ],
    "keywords": ["word characters collection", "format individual characters", "字元集合", "格式化單個字元"]
},
{
    "name": "Document.Sections (Word)",
    "category": "Word 文件處理",
    "syntax": "Set sectionsColl = documentObject.Sections",
    "description": "傳回一個 Sections 集合，代表指定文件中的所有節。節是用於設定不同頁面格式 (如頁首頁尾、欄數、頁面方向) 的區域。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim sec As Object ' Word.Section\n' Set wdDoc = ActiveDocument\n' MsgBox \"文件共有 \" & wdDoc.Sections.Count & \" 個節。\"\n' For Each sec In wdDoc.Sections\n'   Debug.Print \"節 \" & sec.Index & \" 的頁面方向: \" & sec.PageSetup.Orientation\n'   ' sec.PageSetup.Orientation = wdOrientLandscape ' Example: Change to landscape\n' Next sec", "explanation": "顯示文件中的節數量，並遍歷每個節以列印其頁面方向。"}
    ],
    "keywords": ["word sections", "document sections", "page formatting sections", "節集合", "頁面格式節"]
},
// Outlook Mail & Item Management
{
    "name": "MailItem.SenderEmailAddress (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "emailAddr = mailItemObject.SenderEmailAddress",
    "description": "傳回一個字串，表示 Outlook 郵件項目的寄件者電子郵件地址。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem, assume it points to a received email\n' ' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   MsgBox \"寄件者郵箱: \" & olMail.SenderEmailAddress\n' End If", "explanation": "獲取所選郵件的寄件者實際電子郵件地址。"}
    ],
    "keywords": ["outlook sender email", "get sender address", "寄件者郵箱地址"]
},
{
    "name": "MailItem.Recipients (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set recipientsColl = mailItemObject.Recipients",
    "description": "傳回一個 Recipients 集合，代表 Outlook 項目的所有收件者 (包括 To, CC, BCC)。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\nDim recip As Object ' Outlook.Recipient\n' Set olMail = Application.CreateItem(0) ' olMailItem\n' olMail.Recipients.Add \"user1@example.com\"\n' olMail.Recipients.Add \"user2@example.com\" \n' olMail.Recipients.Item(2).Type = 2 ' olCC (2)\n' olMail.Recipients.ResolveAll\n' For Each recip In olMail.Recipients\n'   Debug.Print recip.Name & \" (\" & recip.Address & \") - Type: \" & recip.Type\n' Next recip", "explanation": "建立新郵件，新增兩個收件者，將第二個設為CC，然後解析並遍歷所有收件者，列印其名稱、地址和類型。"}
    ],
    "keywords": ["outlook recipients", "email recipients collection", "to cc bcc", "收件者集合"]
},
// PowerPoint Presentation Creation
{
    "name": "Slide.Shapes.AddTextbox (PowerPoint - Details)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set shp = slideObject.Shapes.AddTextbox(Orientation, Left, Top, Width, Height)",
    "description": "在投影片上建立一個文字方塊。Orientation 指定文字方向 (例如 msoTextOrientationHorizontal)。Left, Top, Width, Height 以點為單位定義文字方塊的位置和大小。",
    "parameters": [
        {"name": "Orientation", "description": "MsoTextOrientation 常數。"},
        {"name": "Left, Top, Width, Height", "description": "以點為單位的 Single 值。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim newTextbox As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set newTextbox = pptSlide.Shapes.AddTextbox(msoTextOrientationHorizontal, 72, 72, 288, 50) ' 1 inch from top/left, 4in wide, 0.7in high\n' newTextbox.TextFrame.TextRange.Text = \"這是文字方塊中的內容。\"\n' newTextbox.TextFrame.TextRange.Font.Color.RGB = RGB(0, 0, 128)", "explanation": "在第一張投影片的指定位置新增一個水平文字方塊，並設定其文字內容和字型顏色。"}
    ],
    "keywords": ["powerpoint add textbox", "insert text box", "ppt shape text", "新增文字方塊"]
},
// File & Folder Management
{
    "name": "FileSystemObject.GetDriveName",
    "category": "檔案與資料夾管理",
    "syntax": "driveNameString = fso.GetDriveName(Path)",
    "description": "從指定的路徑傳回磁碟機的名稱 (例如 \"C:\")。",
    "parameters": [{"name": "Path", "description": "必需。路徑規格。"}],
    "examples": [
        {"code": "Dim fso As Object, drive As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\ndrive = fso.GetDriveName(\"C:\\Windows\\System32\\notepad.exe\")\nMsgBox \"磁碟機名稱是: \" & drive ' 傳回 \"C:\"", "explanation": "從完整檔案路徑中提取磁碟機名稱。"}
    ],
    "keywords": ["fso", "獲取磁碟機名", "磁碟機字母", "get drive letter", "drive name"]
},
{
    "name": "TextStream.Write (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "textStreamObject.Write(String)",
    "description": "將指定的字串寫入 TextStream 檔案。不自動新增換行符。",
    "parameters": [{"name": "String", "description": "必需。要寫入檔案的文字。"}],
    "examples": [
        {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.CreateTextFile(\"C:\\Temp\\MyData.txt\", True)\nts.Write \"第一部分,\"\nts.Write \"第二部分.\"\nts.WriteBlankLines 1 ' Add a newline\nts.Write \"新的一行。\"\nts.Close", "explanation": "使用 Write 方法將多個字串片段寫入檔案的同一行，然後使用 WriteBlankLines 換行。"}
    ],
    "keywords": ["fso", "寫入文字", "文字檔案", "textstream write", "write string to file"]
},
// Math
{
    "name": "WorksheetFunction.Pi",
    "category": "數學、日期與時間",
    "syntax": "piValue = Application.WorksheetFunction.Pi()",
    "description": "傳回圓周率 PI (π) 的值，約為 3.14159265358979。",
    "parameters": [],
    "examples": [
        {"code": "Dim circleArea As Double, radius As Double\nradius = 5\ncircleArea = Application.WorksheetFunction.Pi() * radius ^ 2\nMsgBox \"半徑為 \" & radius & \" 的圓面積約為: \" & Format(circleArea, \"0.00\")", "explanation": "使用 Pi 函數計算圓的面積。"}
    ],
    "keywords": ["pi", "圓周率", "數學常數", "math constant", "circle"]
},
{
    "name": "WorksheetFunction.Degrees",
    "category": "數學、日期與時間",
    "syntax": "degreeValue = Application.WorksheetFunction.Degrees(Radians)",
    "description": "將弧度轉換為度。",
    "parameters": [{"name": "Radians", "description": "必需。要轉換為度的弧度值。"}],
    "examples": [
        {"code": "Dim radiansAngle As Double: radiansAngle = 1.5708 ' Approx Pi/2\nDim degreesAngle As Double\ndegreesAngle = Application.WorksheetFunction.Degrees(radiansAngle)\nMsgBox radiansAngle & \" 弧度約等於 \" & Format(degreesAngle, \"0.00\") & \" 度。\"", "explanation": "將弧度值 (約 Pi/2) 轉換為度 (約 90 度)。"}
    ],
    "keywords": ["弧度轉度", "角度轉換", "degrees conversion", "radians to degrees"]
},
{
    "name": "WorksheetFunction.Radians",
    "category": "數學、日期與時間",
    "syntax": "radianValue = Application.WorksheetFunction.Radians(Degrees)",
    "description": "將度轉換為弧度。",
    "parameters": [{"name": "Degrees", "description": "必需。要轉換為弧度的度數值。"}],
    "examples": [
        {"code": "Dim degreesAngle As Double: degreesAngle = 180\nDim radiansAngle As Double\nradiansAngle = Application.WorksheetFunction.Radians(degreesAngle)\nMsgBox degreesAngle & \" 度等於 \" & Format(radiansAngle, \"0.0000\") & \" 弧度 (約 Pi)。\"", "explanation": "將 180 度轉換為弧度 (約 Pi)。"}
    ],
    "keywords": ["度轉弧度", "角度轉換", "radians conversion", "degrees to radians"]
},
// Array
{
    "name": "IsArray Empty Check",
    "category": "陣列、集合與字典",
    "syntax": "If Not IsArray(arrName) Or UBound(arrName) < LBound(arrName) Then ...",
    "description": "檢查一個 Variant 變數是否為已宣告但未初始化 (即未 ReDim) 或空的陣列。對於未初始化的動態陣列，UBound 會產生錯誤，所以需要先 IsArray。",
    "parameters": [{"name": "arrName", "description": "要檢查的陣列變數名 (通常是 Variant 或動態陣列)。"}],
    "examples": [
        {"code": "Dim dynArray() As String ' Declared but not initialized\nDim initArray(1 To 5) As Integer\nDim emptyArray() As String: ReDim emptyArray(1 To 0) ' Initialized but UBound < LBound\n\nIf Not IsArrayInitialized(dynArray) Then Debug.Print \"dynArray 未初始化或為空。\"\nIf IsArrayInitialized(initArray) Then Debug.Print \"initArray 已初始化且非空。\"\nIf Not IsArrayInitialized(emptyArray) Then Debug.Print \"emptyArray (ReDim 1 To 0) 被視為空。\"\n\nFunction IsArrayInitialized(arr As Variant) As Boolean\n  IsArrayInitialized = False\n  If Not IsArray(arr) Then Exit Function ' Not even an array\n  On Error Resume Next ' To handle UBound on uninitialized array\n  IsArrayInitialized = (UBound(arr) >= LBound(arr))\n  On Error GoTo 0\nEnd Function", "explanation": "IsArrayInitialized 函數檢查傳入的 Variant 是否為一個已初始化且至少包含一個元素的陣列。對於剛宣告的動態陣列，UBound 會觸發錯誤，此函數會處理該情況。"}
    ],
    "keywords": ["檢查陣列空", "陣列初始化", "is array empty", "array initialized check", "ubound error"]
},
// More Excel Core
{
    "name": "Range.FormulaHidden",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaHidden [= True | False]",
    "description": "如果當工作表受保護時公式是隱藏的，則為 True。讀取/寫入。",
    "parameters": [{"name": "True | False", "description": "True 表示隱藏公式，False 表示顯示。"}],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=SUM(B1:B5)\"\nRange(\"A1\").FormulaHidden = True\nActiveSheet.Protect Password:=\"pass\"\n' Now, if Sheet1 is protected, the formula in A1 will not be visible in the formula bar.", "explanation": "設定A1儲存格的公式，將其FormulaHidden屬性設為True，然後保護工作表。"}
    ],
    "keywords": ["隱藏公式", "保護公式", "excel", "hide formula", "protect formula"]
},
{
    "name": "Range.Locked",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Locked [= True | False]",
    "description": "如果物件被鎖定，則為 True。當工作表受保護時，鎖定的儲存格無法修改。預設所有儲存格都是鎖定的。",
    "parameters": [{"name": "True | False", "description": "True 表示鎖定，False 表示解除鎖定。"}],
    "examples": [
        {"code": "Range(\"A1:A5\").Locked = False ' Unlock cells A1:A5\nRange(\"B1\").Locked = True ' Ensure B1 is locked (default)\nActiveSheet.Protect Password:=\"123\"\n' Now A1:A5 can be edited, but B1 cannot (if sheet is protected).", "explanation": "解除A1:A5儲存格的鎖定，然後保護工作表。這樣，A1:A5儲存格在工作表受保護時仍可編輯。"}
    ],
    "keywords": ["鎖定儲存格", "解除鎖定儲存格", "保護工作表", "excel", "lock cells", "unlock cells"]
},
{
    "name": "Range.Text",
    "category": "Excel 核心操作",
    "syntax": "stringResult = rangeObject.Text",
    "description": "傳回一個字串，代表儲存格中顯示的格式化文字。與 .Value 不同，.Text 傳回儲存格所顯示的內容，包括數字格式、日期格式等。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = 1234.5\nRange(\"A1\").NumberFormat = \"$#,##0.00\"\nMsgBox \"Value: \" & Range(\"A1\").Value ' Displays 1234.5\nMsgBox \"Text: \" & Range(\"A1\").Text   ' Displays \"$1,234.50\"", "explanation": "演示 .Value 和 .Text 屬性之間的差異，.Text 會反映儲存格的數字格式。"}
    ],
    "keywords": ["儲存格文字", "格式化值", "顯示文字", "excel", "cell text", "formatted value", "display text"]
},
{
    "name": "Application.DisplayFormulaBar",
    "category": "Excel 核心操作",
    "syntax": "Application.DisplayFormulaBar [= True | False]",
    "description": "如果顯示資料編輯列，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示顯示，False 表示隱藏。"}],
    "examples": [
        {"code": "If Application.DisplayFormulaBar Then\n  MsgBox \"資料編輯列目前是可見的。\"\n  ' Application.DisplayFormulaBar = False ' To hide it\nElse\n  MsgBox \"資料編輯列目前是隱藏的。\"\n  ' Application.DisplayFormulaBar = True ' To show it\nEnd If", "explanation": "檢查資料編輯列的目前可見狀態，並示範如何切換它。"}
    ],
    "keywords": ["資料編輯列", "公式列", "excel", "formula bar", "show formula bar", "hide formula bar"]
},
{
    "name": "Application.Cursor",
    "category": "Excel 核心操作",
    "syntax": "Application.Cursor = XlMousePointerConstant",
    "description": "設定滑鼠游標的形狀。",
    "parameters": [{"name": "XlMousePointerConstant", "description": "例如 xlDefault (預設指標), xlWait (沙漏/忙碌指標), xlIBeam (I 型指標), xlNorthwestArrow (標準箭頭)。"}],
    "examples": [
        {"code": "Application.Cursor = xlWait ' Change cursor to hourglass\n' Perform a long operation...\nApplication.Wait Now + TimeValue(\"00:00:03\")\nApplication.Cursor = xlDefault ' Reset cursor to default", "explanation": "在執行耗時操作前將滑鼠游標變更為沙漏形狀，完成後再恢復預設。"}
    ],
    "keywords": ["滑鼠游標", "指標形狀", "excel", "mouse cursor", "pointer shape", "wait cursor", "hourglass"]
},
{
    "name": "Worksheet.StandardWidth",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.StandardWidth [= widthInChars]",
    "description": "設定或傳回工作表中所有欄的標準 (預設) 寬度，以字元為單位。",
    "parameters": [{"name": "widthInChars", "description": "標準欄寬。"}],
    "examples": [
        {"code": "MsgBox \"目前工作表的標準欄寬是: \" & ActiveSheet.StandardWidth\nActiveSheet.StandardWidth = 10 ' Set default column width to 10 characters", "explanation": "獲取並設定活動工作表的標準欄寬。"}
    ],
    "keywords": ["標準欄寬", "預設欄寬", "excel", "standard column width", "default column width"]
},
{
    "name": "TypeName (VBA Intrinsic)",
    "category": "資料類型、轉換與驗證",
    "syntax": "TypeName(varname)",
    "description": "傳回一個字串，提供有關變數的資料類型資訊。",
    "parameters": [{"name": "varname", "description": "必需。任何變數。"}],
    "examples": [
        {"code": "Dim myInteger As Integer: MsgBox TypeName(myInteger) ' 傳回 \"Integer\"", "explanation": "顯示整數變數的類型名稱。"},
        {"code": "Dim mySheet As Worksheet: Set mySheet = ThisWorkbook.Sheets(1): MsgBox TypeName(mySheet) ' 傳回 \"Worksheet\"", "explanation": "顯示 Worksheet 物件變數的類型名稱。"}
    ],
    "keywords": ["資料類型名稱", "變數類型", "vba", "data type name", "variable type"]
},
{
    "name": "CallByName Function",
    "category": "程式流程與結構控制",
    "syntax": "CallByName(Object, ProcName As String, CallType As VbCallType, [Args() As Variant])",
    "description": "在執行階段執行物件的方法、設定或取得物件的屬性。",
    "parameters": [
        {"name": "Object", "description": "必需。物件變數名稱。"},
        {"name": "ProcName", "description": "必需。包含要呼叫的屬性或方法名稱的字串。"},
        {"name": "CallType", "description": "必需。VbCallType 常數，表示程序類型 (vbMethod, vbGet, vbLet, vbSet)。"},
        {"name": "Args", "description": "可選。包含要傳遞給程序的參數的 Variant 陣列。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet\nSet ws = ThisWorkbook.Sheets(1)\n' Call a method\nCallByName ws, \"Activate\", vbMethod\n' Get a property\nMsgBox CallByName(ws, \"Name\", vbGet)\n' Set a property (if not read-only)\n' CallByName ws, \"Name\", vbLet, \"NewSheetName\"", "explanation": "演示如何使用 CallByName 來動態呼叫工作表物件的 Activate 方法，並獲取其 Name 屬性。"}
    ],
    "keywords": ["動態呼叫", "執行階段呼叫", "callbyname", "dynamic dispatch", "late binding"]
},
{
    "name": "Input # Statement",
    "category": "檔案與資料夾管理",
    "syntax": "Input #FileNumber, VarList",
    "description": "從以 Input 或 Binary 模式開啟的循序檔案中讀取資料，並將其指派給變數。",
    "parameters": [
        {"name": "FileNumber", "description": "必需。用於開啟檔案的檔案號碼。"},
        {"name": "VarList", "description": "必需。以逗號分隔的變數列表，用於儲存從檔案讀取的資料。"}
    ],
    "examples": [
        {"code": "Dim fileNum As Integer, myName As String, myAge As Integer\nfileNum = FreeFile\n' Assume \"C:\\Temp\\data.txt\" contains: \"John Doe\",30 (on one line)\n' Open \"C:\\Temp\\data.txt\" For Input As #fileNum\n' If Not EOF(fileNum) Then\n'   Input #fileNum, myName, myAge\n'   MsgBox \"姓名: \" & myName & \", 年齡: \" & myAge\n' End If\n' Close #fileNum", "explanation": "從文字檔案中讀取以逗號分隔的資料到不同的變數中。"}
    ],
    "keywords": ["讀取檔案", "循序檔", "檔案輸入", "fso", "file input", "sequential file", "read data"]
},
{
    "name": "Line Input # Statement",
    "category": "檔案與資料夾管理",
    "syntax": "Line Input #FileNumber, VariableName",
    "description": "從以 Input 模式開啟的循序檔案中讀取一整行文字 (直到但不包括換行符號)，並將其指派給字串變數。",
    "parameters": [
        {"name": "FileNumber", "description": "必需。用於開啟檔案的檔案號碼。"},
        {"name": "VariableName", "description": "必需。用於儲存讀取行的字串變數。"}
    ],
    "examples": [
        {"code": "Dim fileNum As Integer, textLine As String\nfileNum = FreeFile\n' Open \"C:\\Temp\\MyLog.txt\" For Input As #fileNum\n' Do While Not EOF(fileNum)\n'   Line Input #fileNum, textLine\n'   Debug.Print textLine\n' Loop\n' Close #fileNum", "explanation": "逐行讀取文字檔案的內容並將其列印到立即視窗。"}
    ],
    "keywords": ["讀取行", "檔案逐行讀取", "fso", "line input", "read line by line"]
},
{
    "name": "Option Compare Statement",
    "category": "程式流程與結構控制",
    "syntax": "Option Compare {Binary | Text | Database}",
    "description": "在模組層級宣告字串比較時使用的預設比較方法。",
    "parameters": [
        {"name": "Binary", "description": "字串比較基於內部二進制表示法 (區分大小寫，預設)。"},
        {"name": "Text", "description": "字串比較基於不區分大小寫的文字排序順序 (由系統地區設定決定)。"},
        {"name": "Database", "description": "(僅用於 Microsoft Access) 字串比較基於資料庫的排序順序。"}
    ],
    "examples": [
        {"code": "Option Compare Text ' Module level statement\nSub CompareStrings()\n  Dim str1 As String: str1 = \"Apple\"\n  Dim str2 As String: str2 = \"apple\"\n  If str1 = str2 Then\n    MsgBox \"'\" & str1 & \"' 和 '\" & str2 & \"' 相等 (不區分大小寫)。\"\n  End If\nEnd Sub", "explanation": "在模組頂部設定 Option Compare Text 後，該模組中的字串比較 (如使用 = 運算子) 將不區分大小寫。"}
    ],
    "keywords": ["字串比較模式", "區分大小寫", "option compare", "string comparison", "case sensitive"]
},
{
    "name": "DoEvents (Purpose and Caution)",
    "category": "綜合應用案例與技巧",
    "syntax": "DoEvents",
    "description": "暫時將控制權交給作業系統，以允許處理其他事件，如使用者介面更新或鍵盤/滑鼠輸入。在長時間執行的迴圈中使用 DoEvents 可以防止應用程式看起來『凍結』或無回應。但是，過度使用或在不当情況下使用 (例如，在事件處理程序中可能導致遞迴) 可能會產生非預期行為或效能問題。",
    "parameters": [],
    "examples": [
        {"code": "Sub LongProcessWithDoEvents()\n    Dim i As Long\n    Application.StatusBar = \"正在處理進度: 0%\"\n    For i = 1 To 50000 ' 模擬一個耗時的操作\n        If i Mod 1000 = 0 Then\n            Sheet1.Cells(1, 1).Value = i ' 更新UI (如果ScreenUpdating為True)\n            Application.StatusBar = \"正在處理進度: \" & Round((i / 50000) * 100, 0) & \"%\"\n            DoEvents ' 允許UI更新和處理其他系統事件\n        End If\n    Next i\n    Application.StatusBar = False\n    MsgBox \"處理完成！\"\nEnd Sub", "explanation": "在一個模擬的長迴圈中，每處理1000次迭代就呼叫 DoEvents 一次，以便更新狀態列和Excel介面，並允許應用程式回應其他事件。"}
    ],
    "keywords": ["doevents", "ui responsiveness", "prevent freezing", "yield control", "application not responding", "處理事件", "防止卡死", "程式回應"]
},
{
    "name": "Collection.Remove",
    "category": "陣列、集合與字典",
    "syntax": "collectionObject.Remove(IndexOrKey)",
    "description": "從 Collection 物件中移除一個項目。可以透過項目的索引 (1-based) 或其唯一的鍵 (如果新增時已提供) 來指定要移除的項目。",
    "parameters": [
        {"name": "IndexOrKey", "description": "必需。數值表達式 (1 到 Count) 或字串表達式 (鍵名)。"}
    ],
    "examples": [
        {"code": "Dim myColl As New Collection\nmyColl.Add \"Apple\", \"Fruit1\"\nmyColl.Add \"Banana\"\nmyColl.Add \"Cherry\", \"Fruit3\"\n\nDebug.Print \"移除前數量: \" & myColl.Count ' Output: 3\nmyColl.Remove \"Fruit1\" ' Remove by key\nDebug.Print \"移除 'Fruit1' 後數量: \" & myColl.Count ' Output: 2\nDebug.Print \"索引1的項目: \" & myColl(1) ' Was Banana, now maybe Cherry or error if key was 1st numerically\nmyColl.Remove 1 ' Remove by index (now removes 'Banana')\nDebug.Print \"再次移除後數量: \" & myColl.Count ' Output: 1 (Cherry remains)\nSet myColl = Nothing", "explanation": "演示如何使用索引和鍵從 Collection 中移除項目。注意，按索引移除後，後續項目的索引會改變。"}
    ],
    "keywords": ["collection remove", "delete from collection", "remove item vba", "集合移除", "刪除集合項目"]
},
{
    "name": "Worksheet.Evaluate Method",
    "category": "Excel 核心操作",
    "syntax": "result = worksheetObject.Evaluate(Name)",
    "description": "將 Microsoft Excel 名稱轉換為物件或值。此方法與方括號快捷方式類似 (例如，[A1] 或 [MyNamedRange])，但可以用於動態构造的名稱。",
    "parameters": [
        {"name": "Name", "description": "必需。物件的名稱 (字串)，使用 Excel 的命名約定 (例如，\"A1\", \"Sheet2!B5\", \"MyNamedRange\", \"SUM(C1:C10)\")。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet\nSet ws = ThisWorkbook.Sheets(1)\nws.Range(\"A1\").Value = 10\nws.Range(\"A2\").Value = 20\nws.Names.Add Name:=\"MyCellA1\", RefersToR1C1:=\"=Sheet1!R1C1\"\n\nDim valA1 As Variant\nvalA1 = ws.Evaluate(\"A1\") ' Equivalent to ws.Range(\"A1\").Value\nMsgBox \"A1 (via Evaluate): \" & valA1\n\nDim sumResult As Double\nsumResult = ws.Evaluate(\"SUM(A1:A2)\")\nMsgBox \"SUM(A1:A2) (via Evaluate): \" & sumResult\n\nDim namedRangeVal As Variant\nnamedRangeVal = ws.Evaluate(\"MyCellA1\")\nMsgBox \"MyCellA1 (via Evaluate): \" & namedRangeVal", "explanation": "演示如何使用 Evaluate 方法獲取儲存格的值、計算公式的結果以及獲取已命名範圍的值。"}
    ],
    "keywords": ["evaluate excel name", "string to range", "calculate formula vba", "excel indirect vba", "計算名稱", "字串轉物件"]
},
{
    "name": "Application.Evaluate Method (ShortForm Brackets)",
    "category": "Excel 核心操作",
    "syntax": "result = [ExcelNameString]",
    "description": "Evaluate 方法的簡寫形式。方括號內的字串會被 Excel 嘗試解析為名稱、範圍或公式。",
    "parameters": [
        {"name": "ExcelNameString", "description": "必需。物件的名稱 (字串)，使用 Excel 的命名約定，括在方括號中。"}
    ],
    "examples": [
        {"code": "Sheet1.Range(\"B1\").Value = 50\nSheet1.Range(\"B2\").Value = 75\nDim res As Variant\nres = [SUM(Sheet1!B1:B2)] ' Evaluates the SUM formula\nMsgBox \"[SUM(Sheet1!B1:B2)] = \" & res\n\nDim cellVal As Variant\ncellVal = [Sheet1!B1] ' Gets the value of Sheet1!B1\nMsgBox \"[Sheet1!B1] = \" & cellVal\n\n' ThisWorkbook.Names.Add Name:=\"TestRate\", RefersTo:=\"=0.05\"\n' Dim rateVal As Double\n' rateVal = [TestRate]\n' MsgBox \"[TestRate] = \" & rateVal", "explanation": "演示如何使用方括號簡寫形式來計算公式、獲取儲存格值以及獲取已命名範圍的值。"}
    ],
    "keywords": ["evaluate shortcut", "excel square brackets", "short form evaluate", "計算快捷方式", "方括號評估"]
},
{
    "name": "Range.Value2 Property",
    "category": "Excel 核心操作",
    "syntax": "value = rangeObject.Value2",
    "description": "傳回或設定儲存格的值。與 .Value 屬性類似，但 Value2 不使用 Currency 和 Date 資料類型。它會將這些類型的值傳回為浮點數 (Double)。使用 Value2 通常可以提高效能。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = Now ' Store current date and time\nRange(\"A1\").NumberFormat = \"m/d/yyyy h:mm:ss AM/PM\"\n\nDim val1 As Variant, val2 As Variant\nval1 = Range(\"A1\").Value  ' val1 will be of Date type\nval2 = Range(\"A1\").Value2 ' val2 will be of Double type (serial date-time number)\n\nMsgBox \"Using .Value: TypeName=\" & TypeName(val1) & \", Value=\" & val1\nMsgBox \"Using .Value2: TypeName=\" & TypeName(val2) & \", Value=\" & val2", "explanation": "比較 .Value 和 .Value2 在讀取包含日期時間的儲存格時的差異。Value2 將日期作為序列號（Double）傳回。"}
    ],
    "keywords": ["range value2", "cell value performance", "excel date as number", "儲存格值2", "效能值讀取"]
},
{
    "name": "Workbook.Saved Property",
    "category": "Excel 核心操作",
    "syntax": "booleanResult = workbookObject.Saved",
    "description": "如果自上次儲存活頁簿以來沒有對其進行任何變更，則為 True。您可以將此屬性設為 True 以指示活頁簿已儲存 (即使未實際儲存)，這樣在關閉時不會提示使用者。讀取/寫入布林值。",
    "parameters": [],
    "examples": [
        {"code": "Dim wb As Workbook\nSet wb = ActiveWorkbook\nIf Not wb.Saved Then\n  MsgBox wb.Name & \" 有未儲存的變更。\"\n  ' wb.Save ' Optionally save it\nElse\n  MsgBox wb.Name & \" 目前沒有未儲存的變更。\"\nEnd If\n' Example of setting it to avoid prompt on close (use with caution)\n' If some minor changes were made by code that don't need saving:\n' wb.Saved = True ' Excel will now think it's saved\n' wb.Close SaveChanges:=False ' Can now close without prompt", "explanation": "檢查活動活頁簿是否有未儲存的變更，並示範如何將 Saved 屬性設為 True 以在關閉時避免儲存提示（應謹慎使用）。"}
    ],
    "keywords": ["workbook saved status", "check if saved", "excel save state", "活頁簿儲存狀態", "是否已儲存"]
},
{
    "name": "Worksheet.Shapes.AddShape",
    "category": "Excel 核心操作",
    "syntax": "Set shp = worksheetObject.Shapes.AddShape(Type As MsoAutoShapeType, Left As Single, Top As Single, Width As Single, Height As Single)",
    "description": "在工作表上建立一個新的 AutoShape，並傳回代表該圖案的 Shape 物件。",
    "parameters": [
        {"name": "Type", "description": "必需。MsoAutoShapeType 常數，指定要建立的圖案類型 (例如，msoShapeRectangle, msoShapeOval, msoShapeFlowchartProcess)。"},
        {"name": "Left, Top", "description": "必需。圖案左上角的水平和垂直位置 (以點為單位)，相對於工作表。"},
        {"name": "Width, Height", "description": "必需。圖案的寬度和高度 (以點為單位)。"}
    ],
    "examples": [
        {"code": "Dim myOval As Shape\nSet myOval = ActiveSheet.Shapes.AddShape(msoShapeOval, 100, 50, 120, 60)\nmyOval.Fill.ForeColor.RGB = RGB(100, 150, 200)\nmyOval.TextFrame.Characters.Text = \"橢圓形\"\nmyOval.TextFrame.HorizontalAlignment = xlHAlignCenter\nmyOval.TextFrame.VerticalAlignment = xlVAlignCenter", "explanation": "在活動工作表上新增一個橢圓形 AutoShape，設定其填充顏色和文字。"}
    ],
    "keywords": ["add autoshape", "insert shape excel", "drawing object", "新增自選圖案", "插入圖形"]
},
{
    "name": "Worksheet.ChartObjects Method / Collection",
    "category": "Excel 核心操作",
    "syntax": "Set chtObj = worksheetObject.ChartObjects([IndexOrName])\nSet newChtObj = worksheetObject.ChartObjects.Add(Left, Top, Width, Height)",
    "description": "ChartObjects 方法 (帶參數) 傳回工作表上單個嵌入式圖表物件 (ChartObject)。ChartObjects 屬性 (不帶參數) 傳回代表工作表上所有嵌入式圖表物件的 ChartObjects 集合。Add 方法用於新增新的嵌入式圖表容器。",
    "parameters": [
        {"name": "IndexOrName (Method)", "description": "可選。圖表物件的名稱或索引號。"},
        {"name": "Left, Top, Width, Height (Add Method)", "description": "必需。新圖表物件容器的位置和尺寸。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet: Set ws = ActiveSheet\nDim newChartObj As ChartObject\n' Add a new chart object container\nSet newChartObj = ws.ChartObjects.Add(Left:=100, Top:=75, Width:=300, Height:=200)\n' Now, define the chart within this container\nWith newChartObj.Chart\n  .ChartType = xlXYScatterSmooth\n  ' .SetSourceData Source:=ws.Range(\"A1:B10\") ' Example source data\n  .HasTitle = True\n  .ChartTitle.Text = \"我的XY散佈圖\"\nEnd With\nMsgBox \"已新增嵌入式圖表: \" & newChartObj.Name", "explanation": "在活動工作表上新增一個新的嵌入式圖表容器，然後設定其內部圖表的類型和標題。"}
    ],
    "keywords": ["embedded chart excel", "add chartobject", "chartobjects collection", "嵌入式圖表", "新增圖表容器"]
},
{
    "name": "Application.FileDialogProperty (msoFileDialogFolderPicker)",
    "category": "Excel 核心操作",
    "syntax": "Set fd = Application.FileDialog(msoFileDialogFolderPicker)\nfd.Title = \"Select a Folder\"\nfd.InitialFileName = \"C:\\Users\\\"\nIf fd.Show = -1 Then selectedPath = fd.SelectedItems(1)",
    "description": "使用 FileDialog 物件的 msoFileDialogFolderPicker 類型來顯示一個對話框，允許使用者選擇一個資料夾。",
    "parameters": [
        {"name": "msoFileDialogFolderPicker (Constant)", "description": "FileDialog 類型，用於選擇資料夾。"},
        {"name": ".Title", "description": "屬性：設定對話框的標題。"},
        {"name": ".InitialFileName", "description": "屬性：設定對話框開啟時的初始路徑。"},
        {"name": ".Show()", "description": "方法：顯示對話框。如果使用者選擇資料夾並點擊確定，則傳回 -1。"},
        {"name": ".SelectedItems(1)", "description": "屬性：傳回包含使用者選擇的資料夾完整路徑的字串。"}
    ],
    "examples": [
        {"code": "Dim folderPath As String\nWith Application.FileDialog(msoFileDialogFolderPicker)\n  .Title = \"請選擇一個專案資料夾\"\n  .AllowMultiSelect = False\n  If .Show = -1 Then ' User clicked OK\n    folderPath = .SelectedItems(1)\n    MsgBox \"您選擇的資料夾是: \" & folderPath\n  Else\n    MsgBox \"使用者取消了選擇。\"\n  End If\nEnd With", "explanation": "顯示一個資料夾選擇對話框，讓使用者選擇一個資料夾，然後顯示所選的路徑。"}
    ],
    "keywords": ["folder picker", "select folder dialog", "choose directory", "filedialog", "資料夾選擇器", "選擇目錄"]
},
{
    "name": "Collection.Count",
    "category": "陣列、集合與字典",
    "syntax": "numberOfItems = collectionObject.Count",
    "description": "傳回 Collection 物件中包含的項目數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim myStrings As New Collection\nmyStrings.Add \"Apple\"\nmyStrings.Add \"Banana\"\nmyStrings.Add \"Cherry\"\nMsgBox \"集合中有 \" & myStrings.Count & \" 個項目。\"", "explanation": "建立一個集合，新增三個項目，然後顯示集合中的項目數量。"}
    ],
    "keywords": ["collection count", "number of items in collection", "集合計數", "項目數量"]
},
{
    "name": "Collection.Item",
    "category": "陣列、集合與字典",
    "syntax": "itemValue = collectionObject.Item(IndexOrKey)",
    "description": "從 Collection 物件中依其索引 (1-based) 或唯一的鍵 (如果新增時已提供) 傳回特定項目。",
    "parameters": [
        {"name": "IndexOrKey", "description": "必需。數值表達式 (1 到 Count) 或字串表達式 (鍵名)。"}
    ],
    "examples": [
        {"code": "Dim fruits As New Collection\nfruits.Add \"Red Apple\", \"F1\"\nfruits.Add \"Yellow Banana\", \"F2\"\nMsgBox \"依索引 2 取得: \" & fruits.Item(2) ' 傳回 \"Yellow Banana\"\nMsgBox \"依鍵 'F1' 取得: \" & fruits.Item(\"F1\") ' 傳回 \"Red Apple\"", "explanation": "演示如何使用索引和鍵從 Collection 中檢索項目。"}
    ],
    "keywords": ["collection item", "get item from collection", "access collection element", "集合項目", "讀取集合元素"]
},
// --- More String ---
{
    "name": "Replace Function (Detailed Example)",
    "category": "字串與文本操作",
    "syntax": "Replace(expression, find, replace, [start As Long = 1], [count As Long = -1], [compare As VbCompareMethod = vbBinaryCompare])",
    "description": "傳回一個字串，其中指定的子字串已被另一個子字串取代指定次數。詳細參數說明：start (開始取代的位置，1-based)，count (要取代的次數，-1 表示全部取代)，compare (vbBinaryCompare 區分大小寫，vbTextCompare 不區分)。",
    "parameters": [
        {"name": "expression", "description": "必需。包含要搜尋的子字串的原始字串。"},
        {"name": "find", "description": "必需。要被取代的子字串。"},
        {"name": "replace", "description": "必需。用於取代的字串。"},
        {"name": "start", "description": "可選。搜尋的起始位置。預設為 1。"},
        {"name": "count", "description": "可選。要執行的取代次數。預設為 -1 (全部取代)。"},
        {"name": "compare", "description": "可選。指定比較類型 (vbBinaryCompare 或 vbTextCompare)。預設為 vbBinaryCompare。"}
    ],
    "examples": [
        {"code": "Dim originalText As String: originalText = \"The quick brown fox jumps over the lazy dog. The dog was quick.\"\nDim newText1 As String, newText2 As String, newText3 As String\n' 1. Replace all 'quick' with 'fast' (case-sensitive)\nnewText1 = Replace(originalText, \"quick\", \"fast\")\nDebug.Print \"1: \" & newText1\n\n' 2. Replace all 'the' with 'a' (case-insensitive)\nnewText2 = Replace(originalText, \"the\", \"a\", compare:=vbTextCompare)\nDebug.Print \"2: \" & newText2\n\n' 3. Replace first two occurrences of 'dog' with 'cat' starting from character 1\nnewText3 = Replace(originalText, \"dog\", \"cat\", 1, 2, vbTextCompare)\nDebug.Print \"3: \" & newText3", "explanation": "第一個範例區分大小寫地將所有 \"quick\" 取代為 \"fast\"。第二個範例不區分大小寫地將所有 \"the\" 取代為 \"a\"。第三個範例不區分大小寫地將前兩次出現的 \"dog\" 取代為 \"cat\"。"}
    ],
    "keywords": ["replace string", "find and replace", "text manipulation", "substitute text", "字串取代", "尋找並取代"]
},
// --- More File/Folder ---
{
    "name": "FileSystemObject.GetAbsolutePathName (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "absolutePathString = fso.GetAbsolutePathName(PathSpec)",
    "description": "從提供的路徑規格傳回完整且明確的路徑。如果 PathSpec 是相對路徑，則會基於目前磁碟機和目錄來解析它。",
    "parameters": [
        {"name": "PathSpec", "description": "必需。檔案或資料夾的路徑規格 (可以是相對的或絕對的)。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, absPath As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Assuming current directory is C:\\Users\\YourName\nabsPath = fso.GetAbsolutePathName(\"Documents\\MyFile.txt\")\nMsgBox \"絕對路徑: \" & absPath ' 可能傳回 C:\\Users\\YourName\\Documents\\MyFile.txt\n\nabsPath = fso.GetAbsolutePathName(\"..\\Desktop\")\nMsgBox \"上層的桌面路徑: \" & absPath ' 可能傳回 C:\\Users\\Desktop", "explanation": "演示如何使用 GetAbsolutePathName 將相對路徑轉換為絕對路徑。實際結果取決於執行時的目前目錄。"}
    ],
    "keywords": ["fso", "absolute path", "full path", "resolve path", "filesystemobject", "絕對路徑", "完整路徑"]
},
{
    "name": "Drive Object Properties (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "driveObject.AvailableSpace | .TotalSize | .FreeSpace | .VolumeName | .DriveLetter | .FileSystem | .IsReady | .Path | .RootFolder | .SerialNumber | .ShareName | .DriveType",
    "description": "FileSystemObject 的 Drive 物件提供有關磁碟機的各種資訊。",
    "parameters": [
        {"name": ".AvailableSpace", "description": "傳回指定磁碟機或網路共用上使用者可用的空間量 (位元組)。"},
        {"name": ".TotalSize", "description": "傳回磁碟機或網路共用的總空間 (位元組)。"},
        {"name": ".FreeSpace", "description": "與 AvailableSpace 類似，通常指總可用空間。"},
        {"name": ".VolumeName", "description": "設定或傳回指定磁碟機的磁碟區名稱。"},
        {"name": ".DriveLetter", "description": "傳回磁碟機的字母。"},
        {"name": ".FileSystem", "description": "傳回指定磁碟機使用的檔案系統類型 (例如 \"NTFS\", \"FAT32\")。"},
        {"name": ".IsReady", "description": "如果磁碟機已就緒，則為 True (例如，已插入媒體)。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, drv As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet drv = fso.GetDrive(fso.GetDriveName(Application.Path)) ' Get drive of Excel installation\nMsgBox \"Excel 所在磁碟機: \" & drv.DriveLetter & vbCrLf & _\n       \"磁碟區名稱: \" & drv.VolumeName & vbCrLf & _\n       \"檔案系統: \" & drv.FileSystem & vbCrLf & _\n       \"總空間: \" & Format(drv.TotalSize / (1024^3), \"0.00\") & \" GB\" & vbCrLf & _\n       \"可用空間: \" & Format(drv.AvailableSpace / (1024^3), \"0.00\") & \" GB\"", "explanation": "獲取 Excel 應用程式安裝所在磁碟機的 Drive 物件，並顯示其磁碟機代號、磁碟區名稱、檔案系統、總大小和可用空間。"}
    ],
    "keywords": ["fso drive object", "disk information", "drive space", "volume name", "filesystem", "磁碟機資訊", "磁碟空間"]
},
{
    "name": "Folder Object Properties (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "folderObject.Attributes | .DateCreated | .DateLastAccessed | .DateLastModified | .Drive | .IsRootFolder | .Name | .ParentFolder | .Path | .ShortName | .ShortPath | .Size | .Type | .Files | .SubFolders",
    "description": "FileSystemObject 的 Folder 物件提供有關資料夾的各種屬性以及存取其內容的方法。",
    "parameters": [
        {"name": ".Attributes", "description": "資料夾的屬性 (例如，唯讀、隱藏、系統、目錄)。"},
        {"name": ".DateCreated / .DateLastAccessed / .DateLastModified", "description": "日期/時間戳記。"},
        {"name": ".Name", "description": "資料夾的名稱。"},
        {"name": ".Path", "description": "資料夾的完整路徑。"},
        {"name": ".Size", "description": "資料夾中所有檔案和子資料夾的總大小 (位元組)。"},
        {"name": ".Files", "description": "傳回一個 Files 集合，包含資料夾中的所有檔案。"},
        {"name": ".SubFolders", "description": "傳回一個 Folders 集合，包含資料夾中的所有子資料夾。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, myFolder As Object, aFile As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFolder = fso.GetFolder(\"C:\\Windows\") ' Example folder\nMsgBox \"資料夾名稱: \" & myFolder.Name & vbCrLf & _\n       \"路徑: \" & myFolder.Path & vbCrLf & _\n       \"檔案數: \" & myFolder.Files.Count & vbCrLf & _\n       \"子資料夾數: \" & myFolder.SubFolders.Count & vbCrLf & _\n       \"大小 (Bytes): \" & myFolder.Size\n' List first 5 files\nDim count As Integer: count = 0\nFor Each aFile In myFolder.Files\n    Debug.Print \"  File: \" & aFile.Name\n    count = count + 1\n    If count >= 5 Then Exit For\nNext aFile", "explanation": "獲取 C:\\Windows 資料夾的 Folder 物件，顯示其名稱、路徑、檔案數、子資料夾數和總大小，並列印前5個檔案的名稱。"}
    ],
    "keywords": ["fso folder object", "directory information", "folder properties", "list files in folder", "資料夾資訊", "列出檔案"]
},
{
    "name": "File Object Properties (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "fileObject.Attributes | .DateCreated | .DateLastAccessed | .DateLastModified | .Drive | .Name | .ParentFolder | .Path | .ShortName | .ShortPath | .Size | .Type",
    "description": "FileSystemObject 的 File 物件提供有關檔案的各種屬性以及操作檔案的方法。",
    "parameters": [
        {"name": ".Attributes", "description": "檔案的屬性 (例如，唯讀、隱藏、系統、封存)。"},
        {"name": ".DateCreated / .DateLastAccessed / .DateLastModified", "description": "日期/時間戳記。"},
        {"name": ".Name", "description": "檔案的名稱 (不含路徑)。"},
        {"name": ".Path", "description": "檔案的完整路徑。"},
        {"name": ".Size", "description": "檔案的大小 (位元組)。"},
        {"name": ".Type", "description": "描述檔案類型的字串 (例如 \"文字文件\", \"Microsoft Excel 工作表\")。"},
        {"name": ".ParentFolder", "description": "傳回包含此檔案的 Folder 物件。"},
        {"name": ".Drive", "description": "傳回檔案所在磁碟機的 Drive 物件。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, myFile As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFile = fso.GetFile(\"C:\\Windows\\notepad.exe\") ' Example file\nMsgBox \"檔案名稱: \" & myFile.Name & vbCrLf & _\n       \"類型: \" & myFile.Type & vbCrLf & _\n       \"大小: \" & myFile.Size & \" bytes\" & vbCrLf & _\n       \"上次修改: \" & myFile.DateLastModified", "explanation": "獲取 C:\\Windows\\notepad.exe 檔案的 File 物件，並顯示其名稱、類型、大小和上次修改日期。"}
    ],
    "keywords": ["fso file object", "file information", "file properties", "filesystemobject", "檔案資訊", "檔案屬性"]
},
{
    "name": "File.OpenAsTextStream (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "Set ts = fileObject.OpenAsTextStream([IOMode As IOMode = ForReading], [Format As Tristate = TristateFalse])",
    "description": "開啟指定的檔案並傳回一個 TextStream 物件，可用於讀取或附加到檔案。",
    "parameters": [
        {"name": "IOMode", "description": "可選。IOMode 常數：ForReading (1, 預設), ForWriting (2), ForAppending (8)。"},
        {"name": "Format", "description": "可選。Tristate 常數，指示開啟檔案的格式：TristateUseDefault (-2), TristateTrue (-1, Unicode), TristateFalse (0, ASCII, 預設)。"}
    ],
    "examples": [
        {"code": "Dim fso As Object, myFile As Object, textStream As Object, fileContent As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet myFile = fso.GetFile(\"C:\\Temp\\MyDocument.txt\") ' Assume this file exists\nIf myFile.Size > 0 Then\n  Set textStream = myFile.OpenAsTextStream(1) ' 1 = ForReading\n  fileContent = textStream.ReadAll\n  textStream.Close\n  MsgBox \"檔案內容:\\n\" & fileContent\nElse\n  MsgBox \"檔案為空或不存在。\"\nEnd If\nSet fso = Nothing: Set myFile = Nothing: Set textStream = Nothing", "explanation": "獲取檔案物件，然後使用 OpenAsTextStream 方法以讀取模式打開它，讀取全部內容並顯示。"}
    ],
    "keywords": ["fso opentextstream", "read text file fso", "textstream from file", "開啟文字流"]
},
{
    "name": "Static Array Declaration",
    "category": "陣列、集合與字典",
    "syntax": "Dim ArrayName(LowerBound To UpperBound) As DataType\nDim ArrayName(Size) As DataType ' If Option Base 0, index from 0 to Size. If Option Base 1, index from 1 to Size.",
    "description": "宣告一個固定大小的陣列。一旦宣告，其大小不能改變。",
    "parameters": [
        {"name": "ArrayName", "description": "陣列的名稱。"},
        {"name": "LowerBound To UpperBound", "description": "指定陣列每個維度的索引範圍。"},
        {"name": "Size", "description": "如果只提供一個數字，它代表上限，下限取決於 Option Base 設定。"},
        {"name": "DataType", "description": "陣列元素儲存的資料類型。"}
    ],
    "examples": [
        {"code": "Dim studentNames(1 To 3) As String\nstudentNames(1) = \"Alice\"\nstudentNames(2) = \"Bob\"\nstudentNames(3) = \"Charlie\"\nMsgBox studentNames(2) ' Displays \"Bob\"", "explanation": "宣告一個可以儲存3個學生姓名的固定大小字串陣列。"},
        {"code": "Dim monthlySales(11) As Double ' If Option Base 0, this is 0 to 11 (12 elements)\nmonthlySales(0) = 1500.50 ' January sales (index 0)\n' ...\nmonthlySales(11) = 2100.75 ' December sales (index 11)", "explanation": "宣告一個儲存12個月銷售額的雙精度浮點數陣列 (假設 Option Base 0)。"}
    ],
    "keywords": ["static array", "fixed-size array", "declare array", "array bounds", "固定大小陣列", "靜態陣列"]
},
{
    "name": "Dynamic Array Declaration and ReDim",
    "category": "陣列、集合與字典",
    "syntax": "Dim DynamicArrayName() As DataType\nReDim [Preserve] DynamicArrayName(NewUpperBound) ' Or (NewLowerBound To NewUpperBound)",
    "description": "宣告一個動態陣列 (不指定初始大小)，然後使用 ReDim 語句在執行階段設定或變更其大小。使用 Preserve 關鍵字可以在調整大小時保留陣列現有內容 (通常僅限於調整最後一個維度的大小，或在增加維度數時)。",
    "parameters": [
        {"name": "DynamicArrayName()", "description": "宣告時使用空括號表示為動態陣列。"},
        {"name": "ReDim", "description": "用於在執行階段設定或改變動態陣列大小的關鍵字。"},
        {"name": "Preserve", "description": "可選。在改變陣列最後一個維度的大小時保留陣列中的現有資料。"}
    ],
    "examples": [
        {"code": "Dim customerIDs() As Long\nDim numCustomers As Integer: numCustomers = CInt(InputBox(\"輸入客戶數量:\"))\nIf numCustomers > 0 Then\n  ReDim customerIDs(1 To numCustomers)\n  Dim i As Integer\n  For i = 1 To numCustomers\n    customerIDs(i) = 1000 + i\n  Next i\n  MsgBox \"最後一個客戶ID: \" & customerIDs(numCustomers)\nElse\n  MsgBox \"未指定客戶數量。\"\nEnd If", "explanation": "根據使用者輸入決定動態陣列 customerIDs 的大小，然後填充值。"},
        {"code": "Dim dataPoints() As Double\nReDim dataPoints(0 To 2)\ndataPoints(0) = 1.1: dataPoints(1) = 2.2: dataPoints(2) = 3.3\n' Add more space while preserving existing data\nReDim Preserve dataPoints(0 To 4)\ndataPoints(3) = 4.4\ndataPoints(4) = 5.5\nDebug.Print \"Data at index 1 (preserved): \" & dataPoints(1)", "explanation": "先定義一個包含3個元素的動態陣列，然後使用 ReDim Preserve 將其擴展到5個元素，同時保留原始數據。"}
    ],
    "keywords": ["dynamic array", "redim array", "resize array", "preserve array data", "動態陣列", "重定義陣列", "陣列大小調整"]
},
{
    "name": "Multi-dimensional Array",
    "category": "陣列、集合與字典",
    "syntax": "Dim MultiArray(Dim1_Upper, Dim2_Upper, ...) As DataType\nDim MultiArray(L1 To U1, L2 To U2, ...) As DataType",
    "description": "宣告多維陣列以表格或更複雜的結構儲存資料。最多可以有60個維度，但通常使用2維或3維。",
    "parameters": [
        {"name": "DimN_Upper", "description": "每個維度的上限 (如果 Option Base 為0或1)。"},
        {"name": "LN To UN", "description": "每個維度的明確下限和上限。"}
    ],
    "examples": [
        {"code": "Dim matrix(1 To 3, 1 To 4) As Integer ' A 3x4 matrix\nDim r As Integer, c As Integer\nFor r = 1 To 3\n  For c = 1 To 4\n    matrix(r, c) = r * 10 + c\n    Debug.Print \"matrix(\" & r & \",\" & c & \") = \" & matrix(r, c)\n  Next c\nNext r", "explanation": "宣告一個3列4欄的二維整數陣列 (矩陣)，並填充值。"},
        {"code": "Dim salesData(1 To 2, 1 To 12, 1 To 3) As Currency ' Product, Month, Region\nsalesData(1, 1, 1) = 5000 ' Sales for Product 1, Month 1, Region 1\nMsgBox \"示例數據: \" & salesData(1, 1, 1)", "explanation": "宣告一個三維貨幣陣列來儲存按產品、月份和區域劃分的銷售數據。"}
    ],
    "keywords": ["multidimensional array", "2d array", "3d array", "matrix array", "table array", "多維陣列", "二維陣列", "三維陣列", "矩陣"]
},
{
    "name": "Worksheet.UsedRange Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set ur = worksheetObject.UsedRange",
    "description": "傳回一個 Range 物件，代表指定工作表上已使用的儲存格範圍。這是包含任何資料的最小矩形區域。",
    "parameters": [],
    "examples": [
        {"code": "Dim dataRange As Range\nSet dataRange = ActiveSheet.UsedRange\nMsgBox \"已使用範圍的位址: \" & dataRange.Address & vbCrLf & _\n       \"包含 \" & dataRange.Rows.Count & \" 列和 \" & dataRange.Columns.Count & \" 欄。\"\ndataRange.Select ' Selects the entire used area", "explanation": "獲取活動工作表上的已使用範圍，顯示其位址、大小，然後選取該範圍。"}
    ],
    "keywords": ["used range", "data area", "actual data range", "excel", "已使用範圍", "資料區域"]
},
{
    "name": "Range.ClearOutline (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.ClearOutline",
    "description": "清除指定範圍的大綱 (移除所有分組)。",
    "parameters": [],
    "examples": [
        {"code": "' Assume rows 2-5 are grouped\n' Rows(\"2:5\").Group\n' Range(\"A1\").CurrentRegion.ClearOutline ' Clears any outline in the current region of A1\n' MsgBox \"範圍的大綱已清除。\"", "explanation": "如果A1儲存格所在的目前區域有設定大綱 (分組)，則此程式碼會清除該大綱。"}
    ],
    "keywords": ["clear outline", "remove grouping", "ungroup excel", "清除大綱", "取消分組"]
},
{
    "name": "Range.Group (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Group([Start], [End], [By], [Periods])",
    "description": "建立範圍的大綱 (分組)。通常用於對列或欄進行分組。對於日期，可以用於按日、月、年等分組。",
    "parameters": [
        {"name": "Start", "description": "可選。對於日期分組，為 True 表示按指定日期開始分組。"},
        {"name": "End", "description": "可選。對於日期分組，為 True 表示按指定日期結束分組。"},
        {"name": "By", "description": "可選。對於數值分組，為間隔。對於日期分組，為包含週期的陣列。"},
        {"name": "Periods", "description": "可選 (日期分組)。布林值陣列，指定分組週期 (年、季、月、週、日、時、分)。"}
    ],
    "examples": [
        {"code": "Rows(\"5:10\").Group ' Group rows 5 to 10\nColumns(\"C:E\").Group ' Group columns C to E\nMsgBox \"列和欄已分組。\"", "explanation": "將第5到第10列分組，並將C到E欄分組。"},
        {"code": "Range(\"A1:A20\").Group Start:=True, End:=True, By:=7, Periods:=Array(False, False, False, True, False, False, False) ' Group by week (if A1:A20 contains dates)", "explanation": "如果A1:A20包含日期，則嘗試按週對這些日期進行分組 (此範例更適用於樞紐分析表中的日期欄位分組，直接對Range使用日期分組參數較少見，除非是特定操作)。更常見的是直接分組列或欄。"}
    ],
    "keywords": ["group rows", "group columns", "outline excel", "data grouping", "分組列", "分組欄", "建立大綱"]
},
{
    "name": "Range.Subtotal (Excel)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Subtotal(GroupBy As Long, FunctionNum As XlConsolidationFunction, TotalList, [Replace As Boolean = True], [PageBreaks As Boolean = False], [SummaryBelowData As XlSummaryRow = xlSummaryBelow])",
    "description": "為範圍建立小計。範圍必須是已排序的清單。",
    "parameters": [
        {"name": "GroupBy", "description": "必需。進行小計的欄位 (1-based index within the range)。"},
        {"name": "FunctionNum", "description": "必需。XlConsolidationFunction 常數 (例如 xlSum, xlCount, xlAverage)。"},
        {"name": "TotalList", "description": "必需。一個 1-based 的整數陣列，指示要加入小計的欄位。"},
        {"name": "SummaryBelowData", "description": "可選。XlSummaryRow 常數，指定摘要資訊是否顯示在資料下方。"}
    ],
    "examples": [
        {"code": "Dim dataRange As Range\nSet dataRange = Range(\"A1\").CurrentRegion ' Assume A1 is top-left of a sorted list\n' Sort by the GroupBy column first if not already sorted\n' dataRange.Sort Key1:=dataRange.Columns(1), Order1:=xlAscending, Header:=xlYes\n\n' Subtotal by first column (GroupBy:=1), sum values in third column (TotalList:=Array(3))\ndataRange.Subtotal GroupBy:=1, FunctionNum:=xlSum, TotalList:=Array(3), _\n                   Replace:=True, PageBreaks:=False, SummaryBelowData:=xlSummaryBelow\nMsgBox \"已為第一欄新增小計 (加總第三欄)。\"", "explanation": "在以A1為起點的目前資料區域，按第一欄的變化進行分類匯總，對第三欄的數值進行加總。假設第一欄已排序。"}
    ],
    "keywords": ["subtotal", "summary data", "group and sum", "excel data analysis", "小計", "分類匯總"]
},
{
    "name": "Debug.Print",
    "category": "錯誤處理與調試",
    "syntax": "Debug.Print [OutputList]",
    "description": "在VBA編輯器的「即時運算」視窗 (Immediate Window) 中顯示文字或變數的值。這是一個非常有用的調試工具。",
    "parameters": [
        {"name": "OutputList", "description": "可選。要列印的一個或多個以逗號或分號分隔的表達式。"}
    ],
    "examples": [
        {"code": "Dim myVar As String: myVar = \"Test Value\"\nDim counter As Integer: counter = 10\nDebug.Print \"變數 myVar 的值是: \" & myVar\nDebug.Print \"計數器:\"; counter; \"時間:\"; Time", "explanation": "在即時運算視窗中輸出變數的值和一些文字。使用分號 (;) 會緊密連接輸出，使用逗號 (,) 會在標準定位點位置輸出。"}
    ],
    "keywords": ["debug print", "immediate window", "vba debugging", "output variable", "調試輸出", "即時運算視窗"]
},
{
    "name": "Debug.Assert",
    "category": "錯誤處理與調試",
    "syntax": "Debug.Assert BooleanExpression",
    "description": "當指定的 BooleanExpression 評估為 False 時，在VBA編輯器中暫停執行 (進入中斷模式)。如果表達式為 True，則不執行任何操作。此語句僅在開發環境中有效，在編譯後的執行檔中會被忽略。",
    "parameters": [
        {"name": "BooleanExpression", "description": "必需。一個評估為 True 或 False 的表達式。"}
    ],
    "examples": [
        {"code": "Function CalculateDiscount(price As Double, quantity As Integer) As Double\n  Debug.Assert price > 0 And quantity > 0 ' Assert that price and quantity are positive\n  If quantity >= 10 Then\n    CalculateDiscount = price * quantity * 0.9 ' 10% discount\n  Else\n    CalculateDiscount = price * quantity\n  End If\nEnd Function\n\nSub TestDiscount()\n  Dim finalPrice As Double\n  finalPrice = CalculateDiscount(50, 5) ' This is fine\n  Debug.Print finalPrice\n  ' finalPrice = CalculateDiscount(-10, 2) ' This will trigger Debug.Assert and break execution\nEnd Sub", "explanation": "在 CalculateDiscount 函數的開頭，使用 Debug.Assert 確保傳入的 price 和 quantity 都是正數。如果任一為非正數，執行將在中斷模式下暫停於 Debug.Assert 行。"}
    ],
    "keywords": ["debug assert", "assertion vba", "test condition", "debugging tool", "判斷提示", "條件測試"]
},
{
    "name": "Application.GetPhonetic (Excel)",
    "category": "Excel 核心操作",
    "syntax": "phoneticString = Application.GetPhonetic(Text)",
    "description": "傳回儲存格中文字的日文注音假名 (拼音指南) 字串。如果儲存格沒有注音假名資訊，則傳回空字串。主要用於日文版 Excel。",
    "parameters": [
        {"name": "Text", "description": "必需。可以是一個字串，或包含要提取注音假名的儲存格 (Range 物件)。"}
    ],
    "examples": [
        {"code": "Dim ph As String\n' Range(\"A1\").Value = \"東京\" ' Assuming Japanese text with phonetic info in A1\n' Range(\"A1\").Phonetic.Visible = True ' Make phonetic visible in cell (if not already)\n' ph = Application.GetPhonetic(Range(\"A1\"))\n' If ph <> \"\" Then\n'   MsgBox \"A1儲存格的注音假名是: \" & ph\n' Else\n'   MsgBox \"A1儲存格沒有注音假名資訊，或者此功能在此Excel版本/語言中不可用。\"\n' End If", "explanation": "嘗試獲取儲存格A1中文字的日文注音假名。此功能的效果取決於Excel的語言版本和儲存格內容是否包含注音資訊。"}
    ],
    "keywords": ["phonetic", "furigana", "japanese excel", "get phonetic text", "注音假名", "日文拼音指南"]
},
{
    "name": "Environ Function (More Examples)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "Environ({envstring | number})",
    "description": "傳回與作業系統環境變數相關聯的 String。下面是更多常見的環境變數範例。",
    "parameters": [
        {"name": "envstring", "description": "環境變數的名稱 (例如 \"COMPUTERNAME\", \"OS\", \"PROCESSOR_ARCHITECTURE\")。"}
    ],
    "examples": [
        {"code": "Debug.Print \"Computer Name: \" & Environ(\"COMPUTERNAME\")\nDebug.Print \"Operating System: \" & Environ(\"OS\")\nDebug.Print \"User Domain: \" & Environ(\"USERDOMAIN\")\nDebug.Print \"Processor Architecture: \" & Environ(\"PROCESSOR_ARCHITECTURE\")\nDebug.Print \"Number of Processors: \" & Environ(\"NUMBER_OF_PROCESSORS\")\nDebug.Print \"Program Files Path: \" & Environ(\"ProgramFiles\")\nDebug.Print \"System Root: \" & Environ(\"SystemRoot\")", "explanation": "列印多個常見的 Windows 環境變數的值到立即視窗。"}
    ],
    "keywords": ["environment variables", "system information", "os details", "computer info", "環境變數", "系統資訊"]
},
{
    "name": "Collection Object (More Usage)",
    "category": "陣列、集合與字典",
    "description": "Collection 物件是儲存和管理相關項目群組的便捷方式。項目可以是任何資料類型，包括其他物件。可以使用索引 (1-based) 或唯一的字串鍵來存取項目。",
    "parameters": [
        {"name": "Before / After (Add method)", "description": "在 Add 方法中，可以使用 Before 或 After 引數將新項目插入到集合中的特定位置 (相對於現有項目)。"}
    ],
    "examples": [
        {"code": "Dim myTasks As New Collection\nDim taskObj1 As Object, taskObj2 As Object, taskObj3 As Object\n\n' Simulate task objects (could be class instances or dictionaries)\nSet taskObj1 = CreateObject(\"Scripting.Dictionary\"): taskObj1(\"Name\") = \"Task A\": taskObj1(\"Priority\") = 1\nSet taskObj2 = CreateObject(\"Scripting.Dictionary\"): taskObj2(\"Name\") = \"Task B\": taskObj2(\"Priority\") = 3\nSet taskObj3 = CreateObject(\"Scripting.Dictionary\"): taskObj3(\"Name\") = \"Task C\": taskObj3(\"Priority\") = 2\n\nmyTasks.Add taskObj1, \"T1\"\nmyTasks.Add taskObj3, \"T3\", Before:=\"T1\" ' Add T3 before T1\nmyTasks.Add taskObj2, \"T2\", After:=myTasks.Count ' Add T2 at the end (After last existing item's index)\n\nDim task As Object\nDim i As Long\nFor i = 1 To myTasks.Count\n    Set task = myTasks(i)\n    Debug.Print \"Task \" & i & \" Name: \" & task(\"Name\") & \", Priority: \" & task(\"Priority\")\nNext i\n' Expected order: Task C, Task A, Task B", "explanation": "演示如何使用 Collection 的 Add 方法中的 Before 和 After 引數來控制新增項目的位置，並儲存複雜物件 (此處為 Dictionary)。"}
    ],
    "keywords": ["collection object advanced", "vba collection order", "insert into collection", "object collection", "集合物件進階", "排序集合項目"]
},
{
    "name": "Application.International Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "settingValue = Application.International(Index As XlApplicationInternational)",
    "description": "傳回有關目前國家/地區和國際設定的資訊。",
    "parameters": [
        {"name": "Index", "description": "必需。XlApplicationInternational 常數，指定要傳回的設定 (例如，xlCountryCode, xlCountrySetting, xlCurrencyDigits, xlDateSeparator, xlDecimalSeparator, xlThousandsSeparator, xlTimeSeparator)。"}
    ],
    "examples": [
        {"code": "Debug.Print \"國家/地區代碼: \" & Application.International(xlCountryCode)\nDebug.Print \"國家/地區設定: \" & Application.International(xlCountrySetting)\nDebug.Print \"日期分隔符號: \" & Application.International(xlDateSeparator)\nDebug.Print \"小數分隔符號: \" & Application.International(xlDecimalSeparator)\nDebug.Print \"千位分隔符號: \" & Application.International(xlThousandsSeparator)\nDebug.Print \"貨幣符號: \" & Application.International(xlCurrencySymbol)\nDebug.Print \"通用貨幣格式: \" & Application.International(xlGeneralFormatName)", "explanation": "顯示 Excel 目前使用的各種國際和地區設定，如日期分隔符號、小數點符號等。"}
    ],
    "keywords": ["international settings", "regional settings", "excel localization", "date format", "number format", "國際設定", "地區設定"]
},
{
    "name": "Parameter Object Properties (ADODB.Command)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Parameter 物件具有多個屬性，用於定義如何將參數傳遞給資料庫命令。",
    "parameters": [
        {"name": ".Name", "description": "參數的名稱 (例如，\"@ParamName\")。"},
        {"name": ".Type", "description": "參數的資料類型 (DataTypeEnum 常數，例如 adInteger, adVarChar, adDate)。"},
        {"name": "Direction", "description": "參數的方向 (ParameterDirectionEnum，例如 adParamInput, adParamOutput, adParamInputOutput, adParamReturnValue)。"},
        {"name": ".Size", "description": "對於字串或二進制參數，為最大大小。"},
        {"name": ".Value", "description": "參數的值。"},
        {"name": ".Precision", "description": "對於數值參數，為最大總位數。"},
        {"name": ".NumericScale", "description": "對於數值參數，為小數點右邊的位數。"},
        {"name": ".Attributes", "description": "ParameterAttributesEnum，描述參數的特性 (例如 adParamNullable, adParamSigned)。"}
    ],
    "examples": [
        {"code": "Dim cmd As Object, param As Object ' ADODB.Command, ADODB.Parameter\n' Set cmd = CreateObject(\"ADODB.Command\")\n' ' ... set cmd.ActiveConnection and cmd.CommandText ...\n' ' Example: Creating an input parameter for a stored procedure\n' Set param = cmd.CreateParameter(\"InputCustID\", adVarChar, adParamInput, 10) ' Name, Type, Direction, Size\n' param.Value = \"ALFKI\"\n' cmd.Parameters.Append param\n'\n' ' Example: Creating an output parameter\n' Dim paramOut As Object\n' Set paramOut = cmd.CreateParameter(\"RowCount\", adInteger, adParamOutput)\n' cmd.Parameters.Append paramOut\n'\n' ' cmd.Execute\n' ' MsgBox \"Output RowCount: \" & cmd.Parameters(\"RowCount\").Value", "explanation": "演示如何建立輸入參數 (adVarChar) 和輸出參數 (adInteger)，設定其屬性，並將它們附加到 Command 物件的 Parameters 集合中。"}
    ],
    "keywords": ["adodb parameter properties", "parameter type", "parameter direction", "parameter value", "參數屬性", "ADO參數"]
},
// Word specific objects
{
    "name": "Document.ActiveWindow Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set wdWindow = documentObject.ActiveWindow",
    "description": "傳回一個代表指定文件視窗的 Window 物件。如果文件未在視窗中開啟，則此屬性不可用。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object, activeWin As Object ' Word.Window\n' Set wdDoc = ActiveDocument\n' If Not wdDoc Is Nothing Then\n'   Set activeWin = wdDoc.ActiveWindow\n'   If Not activeWin Is Nothing Then\n'     MsgBox \"活動文件視窗標題: \" & activeWin.Caption\n'     activeWin.WindowState = wdWindowStateMaximize ' Maximize the document window\n'   End If\n' End If", "explanation": "獲取活動文件的活動視窗，顯示其標題，並將該文件視窗最大化。"}
    ],
    "keywords": ["word active window", "document window object", "word ui", "活動文件視窗"]
},
{
    "name": "Document.Range Method (Word)",
    "category": "Word 文件處理",
    "syntax": "Set rng = documentObject.Range([Start As Long], [End As Long])",
    "description": "傳回一個 Range 物件，代表文件中指定的區域。Start 和 End 引數是字元位置。",
    "parameters": [
        {"name": "Start", "description": "可選。範圍的起始字元位置。如果省略，則從文件開頭開始。"},
        {"name": "End", "description": "可選。範圍的結束字元位置。如果省略，則到文件結尾。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, myRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' ' Get a range for the first 100 characters of the document\n' Set myRange = wdDoc.Range(Start:=0, End:=100)\n' myRange.Font.ColorIndex = wdBrightGreen\n' myRange.Select\n' MsgBox \"已選取並格式化文件的前100個字元。\"", "explanation": "選取並格式化文件的前100個字元。"}
    ],
    "keywords": ["word document range", "select text range", "character position", "文件範圍", "字元範圍"]
},
{
    "name": "Range.InsertBefore / .InsertAfter (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.InsertBefore(Text As String)\nrangeObject.InsertAfter(Text As String)",
    "description": "在指定的 Range 物件之前或之後插入指定的文字。原始範圍會擴展以包含新文字。",
    "parameters": [
        {"name": "Text", "description": "必需。要插入的文字。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range ' Get current selection\n' selRange.InsertBefore \"[前綴文字] \"\n' selRange.InsertAfter \" [後綴文字]\"\n' selRange.Font.Bold = True ' The original range now includes the new text", "explanation": "在目前選取的文字前後分別插入前綴和後綴文字，並將整個新範圍設為粗體。"}
    ],
    "keywords": ["word insert text before", "word insert text after", "add text to range", "插入文字前後"]
},
{
    "name": "Range.GoTo Method (Word)",
    "category": "Word 文件處理",
    "syntax": "Set newRange = rangeObject.GoTo(What As WdGoToItem, [Which As WdGoToDirection], [Count As Long], [Name As String])",
    "description": "將範圍移動到指定項目，並傳回一個代表該新位置的 Range 物件。這與 Selection.GoTo 類似，但操作於 Range 物件。",
    "parameters": [
        {"name": "What", "description": "必需。WdGoToItem 常數 (例如，wdGoToPage, wdGoToLine, wdGoToHeading)。"},
        {"name": "Which", "description": "可選。WdGoToDirection 常數 (例如，wdGoToNext, wdGoToPrevious)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, currentRange As Object, nextHeadingRange As Object\n' Set wdDoc = ActiveDocument\n' Set currentRange = wdDoc.Range(0, 0) ' Start of document\n' ' Go to the next heading from the current range\n' Set nextHeadingRange = currentRange.GoTo(What:=wdGoToHeading, Which:=wdGoToNext)\n' If Not nextHeadingRange Is Nothing Then\n'   nextHeadingRange.Select\n'   MsgBox \"已跳至下一個標題: \" & Left(nextHeadingRange.Paragraphs(1).Range.Text, 50)\n' End If", "explanation": "從文件開頭開始，使用 Range.GoTo 方法跳至下一個標題並選取它。"}
    ],
    "keywords": ["word range goto", "navigate with range", "find item range", "範圍跳轉"]
},
// PowerPoint specific objects
{
    "name": "Presentation.Slides Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set slds = presentationObject.Slides",
    "description": "傳回一個 Slides 集合，代表指定簡報中的所有投影片。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\nDim sld As Object ' PowerPoint.Slide\n' Set pptPres = ActivePresentation\n' MsgBox \"此簡報共有 \" & pptPres.Slides.Count & \" 張投影片。\"\n' For Each sld In pptPres.Slides\n'   Debug.Print \"投影片 \" & sld.SlideIndex & \": \" & sld.Name\n' Next sld", "explanation": "顯示活動簡報中的投影片總數，並遍歷所有投影片，列印其索引和名稱。"}
    ],
    "keywords": ["powerpoint slides collection", "all slides", "iterate slides", "投影片集合"]
},
{
    "name": "Slide.Shapes.AddTable (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set tblShape = slideObject.Shapes.AddTable(NumRows As Long, NumColumns As Long, Left As Single, Top As Single, Width As Single, Height As Single)",
    "description": "在投影片上新增一個表格圖案，並傳回代表該表格的 Shape 物件。",
    "parameters": [
        {"name": "NumRows, NumColumns", "description": "必需。表格的列數和欄數。"},
        {"name": "Left, Top, Width, Height", "description": "必需。表格的位置和大小 (以點為單位)。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, newTable As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set newTable = pptSlide.Shapes.AddTable(NumRows:=3, NumColumns:=4, Left:=50, Top:=100, Width:=400, Height:=150)\n' ' Populate the table\n' newTable.Table.Cell(1, 1).Shape.TextFrame.TextRange.Text = \"標題1\"\n' newTable.Table.Cell(2, 1).Shape.TextFrame.TextRange.Text = \"資料A\"\n' MsgBox \"已在第一張投影片新增表格。\"", "explanation": "在第一張投影片上新增一個3列4欄的表格，並填充一些儲存格。"}
    ],
    "keywords": ["powerpoint add table", "insert table ppt", "ppt table shape", "新增表格PPT"]
},
{
    "name": "Table.Cell (PowerPoint Shape)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set cel = tableShapeObject.Table.Cell(Row As Long, Column As Long)",
    "description": "傳回一個 Cell 物件，代表表格圖案 (Shape 物件的 Table 屬性) 中的特定儲存格。",
    "parameters": [
        {"name": "Row", "description": "必需。儲存格所在的列號 (1-based)。"},
        {"name": "Column", "description": "必需。儲存格所在的欄號 (1-based)。"}
    ],
    "examples": [
        {"code": "Dim tblShape As Object ' PowerPoint.Shape (a table)\nDim targetCell As Object ' PowerPoint.Cell\n' Set tblShape = ActivePresentation.Slides(1).Shapes(\"MyTableShape\") ' Assume table shape exists\n' Set targetCell = tblShape.Table.Cell(2, 3) ' Row 2, Column 3\n' targetCell.Shape.TextFrame.TextRange.Text = \"已更新的值\"\n' targetCell.Shape.Fill.ForeColor.RGB = RGB(255, 255, 150) ' Light yellow fill", "explanation": "獲取名為 \"MyTableShape\" 的表格圖案中第2列第3欄的儲存格，並更新其文字和背景色。"}
    ],
    "keywords": ["powerpoint table cell", "access ppt table cell", "format table cell ppt", "PPT表格儲存格"]
},
{
    "name": "Slide.Design Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set des = slideObject.Design",
    "description": "傳回一個 Design 物件，代表指定投影片所使用的設計範本。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object, currentDesign As Object ' PowerPoint.Design\n' Set pptSlide = ActivePresentation.Slides(1)\n' Set currentDesign = pptSlide.Design\n' If Not currentDesign Is Nothing Then\n'   MsgBox \"第一張投影片使用的設計範本名稱: \" & currentDesign.Name\n'   ' You can apply a different design template:\n'   ' ActivePresentation.ApplyTemplate \"C:\\Path\\To\\NewTemplate.potx\"\n' End If", "explanation": "獲取第一張投影片的設計範本物件，並顯示其名稱。同時示範了如何套用新範本 (註解中)。"}
    ],
    "keywords": ["powerpoint slide design", "presentation template", "design template", "投影片設計範本"]
},
{
    "name": "Application.OperatingSystem (Excel/Word/PowerPoint)",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "osString = Application.OperatingSystem",
    "description": "傳回目前作業系統的名稱和版本號 (字串)。",
    "parameters": [],
    "examples": [
        {"code": "MsgBox \"作業系統: \" & Application.OperatingSystem", "explanation": "顯示執行 Office 應用程式的作業系統資訊。"}
    ],
    "keywords": ["operating system", "os version", "system info", "作業系統資訊", "通用"]
},
{
    "name": "Application.PathSeparator (Excel/Word/PowerPoint)",
    "category": "檔案與資料夾管理",
    "syntax": "separatorChar = Application.PathSeparator",
    "description": "傳回作業系統使用的路徑分隔符號 (例如，在 Windows 上是 \"\\\")。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim myPath As String, fileName As String\nfileName = \"report.xlsx\"\nmyPath = \"C:\" & Application.PathSeparator & \"MyDocs\" & Application.PathSeparator & fileName\nMsgBox \"完整路徑: \" & myPath", "explanation": "使用 PathSeparator 屬性來建構平台獨立的檔案路徑 (儘管 VBA 主要在 Windows 上使用，但這是良好實踐)。"}
    ],
    "keywords": ["path separator", "directory separator", "file path construction", "路徑分隔符號", "通用"]
},
// --- Additional Error Handling & Debugging ---
{
    "name": "Error Statement",
    "category": "錯誤處理與調試",
    "syntax": "Error errornumber",
    "description": "模擬發生一個指定編號的錯誤。可用於測試錯誤處理常式。",
    "parameters": [
        {"name": "errornumber", "description": "必需。任何有效的錯誤編號 (0-65535)。"}
    ],
    "examples": [
        {"code": "Sub TestCustomErrorHandler()\n  On Error GoTo HandleMyError\n  Dim x As Integer\n  x = CInt(InputBox(\"輸入一個數字 (輸入0來觸發錯誤):\"))\n  If x = 0 Then\n    Error 11 ' Simulate Division by zero error\n  Else\n    MsgBox \"100 / \" & x & \" = \" & 100 / x\n  End If\nExit Sub\nHandleMyError:\n  MsgBox \"發生錯誤! 編號: \" & Err.Number & \", 描述: \" & Err.Description\nEnd Sub", "explanation": "如果使用者輸入0，則使用 Error 11 語句模擬一個「除以零」的錯誤，以測試 HandleMyError 錯誤處理程序。"}
    ],
    "keywords": ["simulate error", "raise error vba", "test error handler", "模擬錯誤", "觸發錯誤"]
},
// --- More Math/Date ---
{
    "name": "DatePart Function",
    "category": "數學、日期與時間",
    "syntax": "DatePart(interval As String, dateValue, [firstdayofweek As VbDayOfWeek = vbSunday], [firstweekofyear As VbFirstWeekOfYear = vbFirstJan1])",
    "description": "傳回包含日期特定部分的 Variant (Integer)。",
    "parameters": [
        {"name": "interval", "description": "必需。字串表達式，表示要傳回的時間間隔 (例如 \"yyyy\"-年, \"q\"-季, \"m\"-月, \"y\"-年中日, \"d\"-日, \"w\"-周中日, \"ww\"-年中週, \"h\"-時, \"n\"-分, \"s\"-秒)。"},
        {"name": "dateValue", "description": "必需。要評估的 Date 值。"}
    ],
    "examples": [
        {"code": "Dim myDate As Date: myDate = Now\nMsgBox \"目前年份: \" & DatePart(\"yyyy\", myDate)\nMsgBox \"目前季度: \" & DatePart(\"q\", myDate)\nMsgBox \"目前月份: \" & DatePart(\"m\", myDate)\nMsgBox \"今天是今年的第 \" & DatePart(\"y\", myDate) & \" 天。\"\nMsgBox \"今天是本週的第 \" & DatePart(\"w\", myDate, vbMonday) & \" 天 (週一為第一天)。\"\nMsgBox \"今天是今年的第 \" & DatePart(\"ww\", myDate, vbMonday, vbFirstFourDays) & \" 週。\"", "explanation": "使用 DatePart 函數從目前日期和時間中提取各種不同的時間部分，如年、季、月、年中日、周中日和年中週。"}
    ],
    "keywords": ["datepart", "extract date part", "get year", "get month", "get quarter", "date components", "日期部分", "提取日期資訊"]
},
// Excel 核心操作
{
    "name": "Worksheet.QueryTables Property (Excel)",
    "category": "Excel 核心操作",
    "syntax": "Set qts = worksheetObject.QueryTables",
    "description": "傳回一個 QueryTables 集合，代表工作表上的所有查詢表 (Web 查詢或資料庫查詢的結果)。",
    "parameters": [
        {"name": "QueryTable.Refresh([BackgroundQuery As Boolean = True])", "description": "方法：更新查詢表。"},
        {"name": "QueryTable.Delete()", "description": "方法：刪除查詢表。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet, qt As QueryTable\nSet ws = ActiveSheet\nIf ws.QueryTables.Count > 0 Then\n  MsgBox \"此工作表包含 \" & ws.QueryTables.Count & \" 個查詢表。\"\n  For Each qt In ws.QueryTables\n    Debug.Print \"查詢表名稱: \" & qt.Name & \", 連接: \" & qt.Connection\n    ' qt.Refresh BackgroundQuery:=False ' Example: Refresh one query synchronously\n  Next qt\nElse\n  MsgBox \"此工作表沒有查詢表。\"\nEnd If", "explanation": "檢查活動工作表是否包含查詢表，如果包含，則列印其名稱和連接信息，並示範如何刷新查詢。"}
    ],
    "keywords": ["querytables", "excel data query", "web query", "database query", "查詢表"]
},
{
    "name": "Workbook.Queries Property (Excel Power Query)",
    "category": "Excel 核心操作",
    "syntax": "Set queriesColl = workbookObject.Queries",
    "description": "傳回一個 WorkbookQueries 集合，代表活頁簿中的所有 Power Query 查詢 (在新版 Excel 中也稱為「取得與轉換資料」)。此屬性及相關物件在較新版本的 Excel (約 2016+) 中可用。",
    "parameters": [
        {"name": "WorkbookQuery.Name", "description": "查詢的名稱。"},
        {"name": "WorkbookQuery.Formula", "description": "查詢的 M 公式。"},
        {"name": "WorkbookQuery.Refresh()", "description": "方法：刷新查詢。"}
    ],
    "examples": [
        {"code": "Dim wb As Workbook, pq As WorkbookQuery\nSet wb = ThisWorkbook\nOn Error Resume Next ' Queries property might not exist in older Excel versions\nIf wb.Queries.Count > 0 Then\n  MsgBox \"此活頁簿包含 \" & wb.Queries.Count & \" 個 Power Query 查詢。\"\n  For Each pq In wb.Queries\n    Debug.Print \"Power Query 名稱: \" & pq.Name\n    ' Debug.Print \"  公式 (M): \" & Left(pq.Formula, 100) & \"...\"\n    ' pq.Refresh ' Refresh the query\n  Next pq\nElseIf Err.Number <> 0 Then\n  MsgBox \"此 Excel 版本不支援 Queries 屬性。\"\nElse\n  MsgBox \"此活頁簿沒有 Power Query 查詢。\"\nEnd If\nOn Error GoTo 0", "explanation": "檢查活頁簿是否包含 Power Query 查詢，如果包含，則列印其名稱。同時包含對舊版 Excel 的錯誤處理。"}
    ],
    "keywords": ["power query vba", "workbook queries", "excel get and transform", "m formula", "Power Query查詢"]
},
// Word Document Processing
{
    "name": "Range.Font.Hidden (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.Hidden = True | False",
    "description": "如果指定範圍的文字被格式化為隱藏文字，則為 True。讀取/寫入布林值。",
    "parameters": [{"name": "True | False", "description": "True 表示隱藏文字。"}],
    "examples": [
        {"code": "Dim secretRange As Object ' Word.Range\n' Set secretRange = Selection.Range\n' secretRange.Font.Hidden = True\n' MsgBox \"選取的文字已被設為隱藏。若要查看，請在Word選項中啟用顯示隱藏文字。\"", "explanation": "將目前選取的文字格式化為隱藏文字。"}
    ],
    "keywords": ["word hidden text", "font hidden", "hide text word", "隱藏文字"]
},
{
    "name": "Document.FormattingShowFilter Property (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.FormattingShowFilter = WdShowFilterConstant",
    "description": "設定或傳回一個 WdShowFilter 常數，指定在「樣式與格式」工作窗格中顯示哪些格式。",
    "parameters": [
        {"name": "WdShowFilterConstant", "description": "例如 wdShowFilterFormattingInUse, wdShowFilterFormattingAvailable, wdShowFilterStylesAvailable。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.FormattingShowFilter = wdShowFilterFormattingInUse\n' MsgBox \"樣式與格式窗格已設定為僅顯示使用中的格式。\"", "explanation": "將活動文件的「樣式與格式」工作窗格設定為僅顯示文件中實際使用到的格式。"}
    ],
    "keywords": ["word formatting show filter", "styles and formatting pane", "樣式與格式篩選"]
},
// Outlook Mail & Item Management
{
    "name": "MailItem.DownloadState Property (Outlook Cached Mode)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "downloadStateConstant = mailItemObject.DownloadState",
    "description": "在快取 Exchange 模式下，傳回一個 OlDownloadState 常數，指出項目的下載狀態 (例如，olHeaderOnly, olFullItem)。唯讀。",
    "parameters": [
        {"name": "olHeaderOnly (0)", "description": "僅下載標頭。"},
        {"name": "olFullItem (1)", "description": "已下載完整項目。"}
    ],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem, assume it's an item in cached mode folder\n' ' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   Select Case olMail.DownloadState\n'     Case 0: Debug.Print \"郵件 '\" & olMail.Subject & \"' 目前僅下載了標頭。\"\n'     Case 1: Debug.Print \"郵件 '\" & olMail.Subject & \"' 已完整下載。\"\n'     Case Else: Debug.Print \"郵件 '\" & olMail.Subject & \"' 的下載狀態未知或不適用。\"\n'   End Select\n'   ' To download the full item if only header exists:\n'   ' If olMail.DownloadState = olHeaderOnly Then olMail.MarkAsTask olMarkNoDate ' A trick to force download\n' End If", "explanation": "檢查所選郵件在快取 Exchange 模式下的下載狀態 (僅標頭或完整項目)。註解中提供了一個強制下載完整項目技巧 (將其標記為無到期日的任務通常會觸發下載)。"}
    ],
    "keywords": ["outlook downloadstate", "cached mode email status", "olheaderonly", "olfullitem", "快取模式下載狀態"]
},
{
    "name": "AppointmentItem.IsRecurring Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "isRecurringBoolean = appointmentItemObject.IsRecurring",
    "description": "如果約會是週期性約會系列的一部分，則傳回 True。唯讀布林值。",
    "parameters": [],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem\n' ' Set olAppt = Application.ActiveExplorer.Selection.Item(1) ' If an appointment is selected\n' If TypeName(olAppt) = \"AppointmentItem\" Then\n'   If olAppt.IsRecurring Then\n'     Dim recPattern As Object ' Outlook.RecurrencePattern\n'     Set recPattern = olAppt.GetRecurrencePattern\n'     MsgBox \"約會 '\" & olAppt.Subject & \"' 是一個週期性約會。週期模式: \" & recPattern.RecurrenceType\n'     ' recPattern.RecurrenceType: 0=Daily, 1=Weekly, 2=Monthly, 3=MonthNth, 5=Yearly, 6=YearNth\n'   Else\n'     MsgBox \"約會 '\" & olAppt.Subject & \"' 不是週期性約會。\"\n'   End If\n' End If", "explanation": "檢查選取的 Outlook 約會項目是否為週期性約會。如果是，則獲取其週期模式並顯示週期類型。"}
    ],
    "keywords": ["outlook isrecurring appointment", "recurring meeting", "get recurrence pattern", "週期性約會"]
},
// PowerPoint Presentation Creation
{
    "name": "Slide.Shapes.AddMediaObject2 (PowerPoint 2010+)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set mediaShape = slideObject.Shapes.AddMediaObject2(FileName As String, [LinkToFile As MsoTriState = msoFalse], [SaveWithDocument As MsoTriState = msoTrue], [Left As Single = 0], [Top As Single = 0], [Width As Single = -1], [Height As Single = -1])",
    "description": "將音訊或視訊檔案嵌入或連結到投影片。這是較新的新增媒體物件方法。",
    "parameters": [
        {"name": "FileName", "description": "必需。媒體檔案的路徑。"},
        {"name": "LinkToFile", "description": "可選。msoTrue 表示連結到檔案，msoFalse (預設) 表示嵌入。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, videoShp As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, ppLayoutBlank)\n' On Error Resume Next ' File might not exist or format not supported\n' Set videoShp = pptSlide.Shapes.AddMediaObject2(FileName:=\"C:\\Videos\\MyDemo.mp4\", _\n'                                             LinkToFile:=msoFalse, SaveWithDocument:=msoTrue, _\n'                                             Left:=50, Top:=50, Width:=320, Height:=240)\n' If Not videoShp Is Nothing And Err.Number = 0 Then\n'   MsgBox \"視訊 'MyDemo.mp4' 已嵌入到新投影片。\"\n'   ' videoShp.AnimationSettings.PlaySettings.PlayOnEntry = msoTrue ' Auto play\n' Else\n'   MsgBox \"嵌入視訊失敗: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "在新投影片上嵌入一個名為 \"MyDemo.mp4\" 的視訊檔案，並設定其位置和大小。"}
    ],
    "keywords": ["powerpoint addmediaobject2", "embed video ppt", "insert audio ppt", "嵌入視訊PPT", "插入音訊PPT"]
},
{
    "name": "Presentation.RemovePersonalInformation Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "presentationObject.RemovePersonalInformation = True | False",
    "description": "如果個人資訊在儲存簡報時從簡報中移除，則為 True。讀取/寫入布林值。這對應於「文件檢查器」中的某些選項。",
    "parameters": [{"name": "True | False", "description": "True 表示儲存時移除個人資訊。"}],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\n' Set pptPres = ActivePresentation\n' pptPres.RemovePersonalInformation = True\n' ' When the presentation is saved next, personal information will be removed.\n' MsgBox \"簡報 '\" & pptPres.Name & \"' 將在儲存時移除個人資訊。\"", "explanation": "設定活動簡報在下次儲存時移除作者姓名、備註中的個人資訊等。"}
    ],
    "keywords": ["powerpoint remove personal information", "document inspector ppt", "anonymize presentation", "移除個人資訊PPT"]
},
// FSO
{
    "name": "TextStream.WriteBlankLines (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "textStreamObject.WriteBlankLines(Lines As Long)",
    "description": "向 TextStream 檔案寫入指定數量的換行字元。",
    "parameters": [{"name": "Lines", "description": "必需。要寫入的空白行 (換行符號) 數量。"}],
    "examples": [
        {"code": "Dim fso As Object, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet ts = fso.CreateTextFile(\"C:\\Temp\\SpacedOutput.txt\", True)\nts.WriteLine \"第一行。\"\nts.WriteBlankLines 2 ' Writes two newline characters\nts.WriteLine \"這是第四行 (因為中間有兩空行)。\"\nts.Close\nMsgBox \"已寫入帶有空行的檔案到 C:\\Temp\\SpacedOutput.txt\"", "explanation": "建立一個文字檔案，寫入第一行，然後使用 WriteBlankLines 寫入兩個空行，接著寫入另一行文字。"}
    ],
    "keywords": ["fso writeblanklines", "textstream newline", "insert empty lines file", "寫入空行FSO"]
},
// String
{
    "name": "MidB / LenB / LeftB / RightB / AscB / ChrB (Byte-Oriented String Functions)",
    "category": "字串與文本操作",
    "description": "這些是 Mid, Len, Left, Right, Asc, Chr 函數的位元組導向版本。它們處理字串時以位元組為單位，而不是以字元為單位。這在處理包含雙位元組字元 (如某些東亞語言字元) 的字串並需要基於位元組進行操作時，或者在處理二進制數據作為字串傳遞時可能有用。在現代 Unicode 環境中，它們的使用已大大減少，應謹慎使用，因為直接操作位元組可能會破壞多位元組字元的完整性。",
    "syntax": "MidB(String, StartByte, [LengthBytes])\nLenB(String)\nLeftB(String, LengthBytes)\nRightB(String, LengthBytes)\nAscB(String) ' Returns byte value of first byte of first character\nChrB(ByteValue) ' Creates character from byte value",
    "parameters": [],
    "examples": [
        {"code": "Dim s As String: s = \"AB\" & ChrW(258) & \"CD\" ' ChrW(258) is Ā (2 bytes in UTF-16 for VBA string)\n' VBA strings are internally Unicode (UTF-16), so LenB reflects byte length of that internal representation.\nDebug.Print \"字串: '\" & s & \"'\"\nDebug.Print \"Len(s) = \" & Len(s) ' Character length (A, B, Ā, C, D = 5 chars)\nDebug.Print \"LenB(s) = \" & LenB(s) ' Byte length (2*5 = 10 bytes for UTF-16)\n\nDebug.Print \"AscB(\"\"A\"\") = \" & AscB(\"A\") ' Byte value of 'A'\nDebug.Print \"ChrB(65) = \" & ChrB(65)  ' Character for byte 65 ('A')\n\n' Using LeftB to get first 4 bytes (might cut a multi-byte character)\nDim firstFourBytesRepr As String\n' If s is UTF-16, first 4 bytes are 'A' and 'B'.\n' firstFourBytesRepr = LeftB(s, 4)\n' For this to be meaningful, you'd usually convert the string to a specific byte encoding first\n' (e.g., Shift-JIS, UTF-8) then use byte functions, which VBA doesn't do natively for these funcs.\n' These functions operate on VBA's internal string representation.\nMsgBox \"位元組字串函數主要用於特定低階操作或與舊系統交互。現代VBA中應謹慎使用。\"", "explanation": "演示 LenB 與 Len 的區別。LenB 傳回字串在記憶體中佔用的位元組數 (VBA內部字串是UTF-16，所以通常是字元數的兩倍)。AscB 傳回字串第一個字元的第一個位元組的值。ChrB 從單個位元組值建立字元。MidB, LeftB, RightB 按位元組操作，如果用於多位元組字元環境，可能會切斷字元。"}
    ],
    "keywords": ["midb", "lenb", "leftb", "rightb", "ascb", "chrb", "byte string functions", "位元組字串函數"]
},
// Math
{
    "name": "WorksheetFunction.Median (Excel)",
    "category": "數學、日期與時間",
    "syntax": "medianValue = Application.WorksheetFunction.Median(Arg1, [Arg2], ...)",
    "description": "使用 Excel 的 MEDIAN 工作表函數，傳回給定數字集的中位數。",
    "parameters": [{"name": "Arg1, Arg2, ...", "description": "必需/可選。要計算中位數的一個或多個數字、儲存格範圍或陣列。"}],
    "examples": [
        {"code": "Dim scores As Variant\nscores = Array(80, 92, 75, 88, 95, 70)\nMsgBox \"分數的中位數是: \" & Application.WorksheetFunction.Median(scores) ' (70,75,80,88,92,95) -> (80+88)/2 = 84\n\n' Range(\"A1:A5\").Value = Application.Transpose(Array(10,20,5,25,15))\n' MsgBox \"A1:A5的中位數是: \" & Application.WorksheetFunction.Median(Range(\"A1:A5\")) ' (5,10,15,20,25) -> 15", "explanation": "計算一個VBA陣列和一個儲存格範圍中數字的中位數。"}
    ],
    "keywords": ["median", "excel median vba", "find middle value", "中位數"]
},
{
    "name": "WorksheetFunction.Mode_Sngl (Excel 2010+)",
    "category": "數學、日期與時間",
    "syntax": "modeValue = Application.WorksheetFunction.Mode_Sngl(Arg1, [Arg2], ...)",
    "description": "使用 Excel 的 MODE.SNGL 工作表函數 (Excel 2010及更新版本)，傳回資料集中出現頻率最高的值 (眾數)。如果有多個眾數，則傳回找到的第一個。",
    "parameters": [{"name": "Arg1, Arg2, ...", "description": "必需/可選。要計算眾數的一個或多個數字、儲存格範圍或陣列。"}],
    "examples": [
        {"code": "' Range(\"B1:B7\").Value = Application.Transpose(Array(1,2,2,3,4,4,4))\nDim mostFrequent As Double\nOn Error Resume Next ' Mode functions can error if no mode or all unique\nmostFrequent = Application.WorksheetFunction.Mode_Sngl(Range(\"B1:B7\"))\nIf Err.Number = 0 Then\n  MsgBox \"B1:B7 中的眾數是: \" & mostFrequent ' Expected: 4\nElse\n  MsgBox \"無法計算眾數 (可能沒有重複值或值不適用)。錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0", "explanation": "計算B1:B7範圍內數位的眾數。如果所有值都是唯一的，MODE.SNGL會產生錯誤。"}
    ],
    "keywords": ["mode.sngl", "excel mode function vba", "most frequent value", "眾數"]
},
// Data Types
{
    "name": "vbString Constant (VarType)",
    "category": "資料類型、轉換與驗證",
    "syntax": "vbString",
    "description": "VbVarType 列舉中的一個常數，其值為 8。VarType 函數在檢查 String 資料類型變數時會傳回此值。",
    "parameters": [],
    "examples": [
        {"code": "Dim myName As String: myName = \"Test\"\nIf VarType(myName) = vbString Then\n  Debug.Print \"myName 的 VarType 是 vbString (\" & vbString & \").\"\nElse\n  Debug.Print \"myName 的 VarType 不是 vbString: \" & VarType(myName)\nEnd If", "explanation": "檢查一個 String 變數的 VarType 是否等於 vbString 常數。"}
    ],
    "keywords": ["vbstring", "vartype string", "string data type code", "字串類型代碼"]
},
{
    "name": "DefType (Interaction with Dim As Variant)",
    "category": "資料類型、轉換與驗證",
    "description": "如果在模組層級使用了 DefType 語句 (例如 `DefInt A-Z`)，然後在過程中明確地將一個變數宣告為 `Dim MyVar As Variant`，則 MyVar 仍然是 Variant 類型。明確的 `As Variant` 宣告會覆寫 DefType 的預設設定。",
    "parameters": [],
    "examples": [
        {"code": "' --- Module Level ---\n' Option Explicit\n' DefInt A-Z ' Default all undeclared (or Dim without As Type) to Integer\n'\n' Sub DefTypeVsVariant()\n'   Dim Counter ' Due to DefInt A-Z, if Option Explicit OFF, Counter is Integer\n'               ' If Option Explicit ON, this line errors without 'As Type'\n'   Dim DataValue As Variant ' Explicitly Variant, overrides DefInt\n'   Dim Amount As Integer    ' Explicitly Integer, consistent with DefInt (but explicit is better)\n'\n'   Counter = 10 ' Assuming this is Integer\n'   DataValue = \"Some Text\" ' Can hold a string\n'   DataValue = 123.45      ' Can hold a double\n'   Amount = 500\n'\n'   Debug.Print \"TypeName(Counter if Integer): \" & TypeName(Counter) ' Assuming it became Integer\n'   Debug.Print \"TypeName(DataValue): \" & TypeName(DataValue) ' Should be Double now\n'   Debug.Print \"TypeName(Amount): \" & TypeName(Amount)   ' Integer\n' End Sub", "explanation": "演示即使在模組中設定了 DefInt A-Z，明確宣告為 As Variant 的變數 (DataValue) 仍然是 Variant 類型，可以儲存不同類型的數據。"}
    ],
    "keywords": ["deftype as variant", "variant overrides deftype", "explicit variant declaration", "DefType與Variant"]
},
// Program Flow
{
    "name": "Resume Next (Error Handling - Use with Extreme Caution)",
    "category": "錯誤處理與調試",
    "description": "`On Error Resume Next` 語句會使 VBA 在遇到執行階段錯誤時忽略該錯誤，並繼續執行緊隨錯誤發生行之後的下一行程式碼。這可能非常危險，因為它會隱藏問題，可能導致後續程式碼基於不正確的數據或狀態執行，產生更難以追蹤的邏輯錯誤或非預期結果。只應在完全理解錯誤的性質且確定可以安全地忽略它，或者在之後立即檢查 `Err` 物件以進行特定處理時才謹慎使用。",
    "parameters": [],
    "examples": [
        {"code": "Sub RiskyResumeNextExample()\n  Dim x As Integer, y As Integer, z As Variant\n  y = 0\n  On Error Resume Next ' DANGER: Error will be ignored\n  x = 10 / y         ' This causes a division by zero error, x will not get a new value (remains 0 or uninitialized)\n  If Err.Number <> 0 Then\n    Debug.Print \"發生錯誤 (已透過Resume Next忽略): \" & Err.Description & \" (錯誤號: \" & Err.Number & \")\"\n    Debug.Print \"  變數 x 的值可能不正確: \" & x\n    Err.Clear ' Important to clear error if you handle it and continue\n  End If\n  z = x + 5          ' z will be 5 if x remained 0 (or uninitialized value + 5)\n  On Error GoTo 0    ' Always good to turn off Resume Next as soon as possible\n  MsgBox \"x = \" & x & \", z = \" & z & \" (注意x的值)\"\nEnd Sub", "explanation": "演示了 `On Error Resume Next` 的行為。當 `x = 10 / y` 發生除零錯誤時，程式不會停止，而是繼續執行。變數 `x` 可能保持其初始值 (0 或 Empty)，導致後續計算 (`z = x + 5`) 的結果不符合預期。雖然範例中檢查了 `Err.Number`，但在許多情況下，開發者可能會忘記檢查，從而導致潛在問題。"}
    ],
    "keywords": ["on error resume next caution", "ignore runtime errors vba", "dangers of resume next", "Resume Next的風險"]
},
// External API
{
    "name": "ADODB.Connection (ConnectionString without Provider)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "對於某些資料來源，特別是 ODBC 資料來源名稱 (DSN)，ADODB Connection 的 ConnectionString 可能不需要明確指定 Provider。如果 DSN 已正確設定了驅動程式資訊，則可以直接使用 `DSN=MyDsnName;UID=user;PWD=pass;` 這樣的連接字串。",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object ' ADODB.Connection\nDim dsnConnStr As String\n' Assume an ODBC DSN named \"MyOracleDSN\" has been configured on the system\n' that points to an Oracle database and has driver info.\ndsnConnStr = \"DSN=MyOracleDSN;Uid=MyUsername;Pwd=MyPassword;\"\n\nSet conn = CreateObject(\"ADODB.Connection\")\n' On Error Resume Next\n' conn.Open dsnConnStr\n' If conn.State = 1 Then\n'   MsgBox \"成功透過DSN 'MyOracleDSN' 連接到資料庫。\"\n'   conn.Close\n' Else\n'   MsgBox \"透過DSN連接失敗: \" & Err.Description\n' End If\n' On Error GoTo 0\n' Set conn = Nothing\nMsgBox \"(概念性) 演示了使用DSN且不指定Provider的連接字串。需有實際DSN。\"", "explanation": "演示一個概念性的連接字串，它使用系統上已配置的 ODBC DSN (\"MyOracleDSN\")，而沒有明確指定 Provider。DSN 本身應包含驅動程式信息。"}
    ],
    "keywords": ["adodb connectionstring dsn", "odbc dsn connection vba", "connect without provider", "DSN連接字串"]
},
{
    "name": "ADODB.Recordset (Fields.Count Property)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 Fields 集合有一個 Count 屬性，它傳回 Recordset 中的欄位 (欄) 數量。",
    "syntax": "numberOfFields = rs.Fields.Count",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object, rs As Object\n' ' Assume conn is an open ADODB.Connection to Northwind or similar database\n' ' Set conn = ... conn.Open ...\n' Set rs = CreateObject(\"ADODB.Recordset\")\n' On Error Resume Next\n' rs.Open \"SELECT CustomerID, CompanyName, ContactName FROM Customers\", conn\n' If Err.Number = 0 And Not rs.EOF Then\n'   MsgBox \"Customers 資料錄集包含 \" & rs.Fields.Count & \" 個欄位。\"\n'   Dim i As Long\n'   Debug.Print \"欄位名稱:\"\n'   For i = 0 To rs.Fields.Count - 1 ' Fields collection is 0-based\n'     Debug.Print \"  \" & i & \": \" & rs.Fields(i).Name\n'   Next i\n'   rs.Close\n' Else\n'   Debug.Print \"無法開啟資料錄集或為空。錯誤: \" & Err.Description\n' End If\n' On Error GoTo 0\n' ' If conn.State = 1 Then conn.Close\n' ' Set rs = Nothing: Set conn = Nothing\nMsgBox \"(概念性) 演示了 Fields.Count 和遍歷欄位。需有實際資料庫。\"", "explanation": "打開一個包含客戶資料的 Recordset，然後使用 `rs.Fields.Count` 獲取欄位數量，並遍歷 Fields 集合以列印每個欄位的索引和名稱。"}
    ],
    "keywords": ["adodb fields.count", "recordset number of columns", "get field names ado", "欄位數量ADO"]
},
{
    "name": "MSXML2.DOMDocument (Load Options and Properties for External Schemas)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "當 XML 文件引用外部 DTD 或 XSD Schema (例如，透過 `xsi:schemaLocation` 或 `xsi:noNamespaceSchemaLocation` 屬性) 時，MSXML2.DOMDocument 物件在載入和驗證時的行為會受到某些屬性影響：\n`resolveExternals` (Boolean): 如果為 True (預設通常是 True，但某些版本可能不同或受安全性設定影響)，解析器會嘗試下載和處理外部 DTD、實體或 Schema。設為 False 可以阻止外部網路請求。\n`validateOnParse` (Boolean): 如前述，控制是否進行驗證。\n`schemas` (Object): 可以將一個 MSXML2.SchemaCache 物件指派給此屬性，以提供用於驗證的本地 Schema，而不是依賴文件中的引用。",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object ' MSXML2.DOMDocument60\nDim xmlWithExternalSchemaRef As String\n' Example XML referencing an external schema (conceptual - schemaLocation might be online)\nxmlWithExternalSchemaRef = \"<?xml version='1.0'?>\" & _\n  \"<root xmlns='urn:my-namespace' \" & _\n  \"xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \" & _\n  \"xsi:schemaLocation='urn:my-namespace http://www.example.com/schemas/mySchema.xsd'>\" & _\n  \"  <element>Some data</element></root>\"\n\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\n\n' Option 1: Attempt to resolve external schema (default, but may be blocked by security)\nxmlDoc.validateOnParse = True ' Enable validation\nxmlDoc.setProperty \"ResolveExternals\", True ' Explicitly allow (or try to allow)\n' Dim loadSuccess As Boolean\n' On Error Resume Next ' Network access might fail or be blocked\n' loadSuccess = xmlDoc.LoadXML(xmlWithExternalSchemaRef)\n' If loadSuccess And xmlDoc.parseError.errorCode = 0 Then\n'   Debug.Print \"XML (with external schema ref) 載入並驗證成功 (外部解析已嘗試)。\"\n' Else\n'   Debug.Print \"XML 載入或驗證失敗 (外部解析)。錯誤: \" & xmlDoc.parseError.reason\n' End If\n' Err.Clear; On Error GoTo 0\n\n' Option 2: Prohibit resolving external schemas (more secure if source is untrusted)\nxmlDoc.setProperty \"ResolveExternals\", False\nxmlDoc.validateOnParse = False ' If externals are off, validation against them might fail or be skipped\n' loadSuccess = xmlDoc.LoadXML(xmlWithExternalSchemaRef)\n' If loadSuccess And xmlDoc.parseError.errorCode = 0 Then\n'   Debug.Print \"XML (with external schema ref) 載入成功 (外部解析已禁止)。\"\n' Else\n'   Debug.Print \"XML 載入失敗 (外部解析禁止)。錯誤: \" & xmlDoc.parseError.reason\n' End If\nMsgBox \"(概念性) 演示了 ResolveExternals 屬性。實際行為受限於網路和安全設定。\"", "explanation": "演示 `resolveExternals` 屬性如何影響載入包含外部 Schema 引用的 XML 文件。當 `resolveExternals` 為 True 時，解析器會嘗試獲取外部 Schema 進行驗證 (可能受網路/安全限制)。當為 False 時，則不會嘗試解析外部引用，這在處理不受信任的 XML 或離線環境中可能更安全。同時，`validateOnParse` 屬性控制是否實際執行驗證。"}
    ],
    "keywords": ["msxml resolveexternals", "xml external schema vba", "load xml with dtd schema", "xml security resolve", "解析外部Schema"]
},
// Excel 核心操作
{
    "name": "Range.SortSpecial (Excel - Sort by Cell Attributes)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.SortSpecial(SortMethod As XlSortMethod, Key1, [Order1], [Type], [Key2], [Order2], [Key3], [Order3], [Header As XlYesNoGuess], [OrderCustom], [MatchCase], [Orientation As XlSortOrientation], [DataOption1], [DataOption2], [DataOption3])",
    "description": "提供更進階的排序選項，包括按儲存格格式 (例如，儲存格顏色、字型顏色) 進行排序。`SortMethod` 通常設為 `xlSortValues` (如果按值排序) 或 `xlPinYin` (預設，處理中文等)。要按格式排序，需要與 `SortFields.Add` 方法 (Excel 2007+) 結合使用，SortSpecial 本身不直接暴露按格式排序的參數。",
    "parameters": [
        {"name": "SortMethod", "description": "XlSortMethod 常數。"},
        {"name": "Key1, Order1, etc.", "description": "與 Range.Sort 類似的鍵和順序參數。"}
    ],
    "examples": [
        {"code": "' Sorting by cell color or font color is done via the SortFields collection in modern Excel.\n' Range.SortSpecial is more for legacy compatibility or specific sort methods like PinYin.\n' Example of standard sort using SortFields which allows sorting by format:\nSub SortByCellColorExample()\n    Dim dataRange As Range\n    Set dataRange = Range(\"A1:A10\") ' Assume A1:A10 has data with different cell colors\n    ' Apply some colors for demo\n    ' Range(\"A2\").Interior.Color = vbRed\n    ' Range(\"A5\").Interior.Color = vbGreen\n    ' Range(\"A8\").Interior.Color = vbBlue\n\n    ' With ActiveWorkbook.Worksheets(dataRange.Worksheet.Name).Sort\n    '   .SortFields.Clear\n    '   ' Add sort field for cell interior color\n    '   .SortFields.Add(Key:=dataRange, _\n    '                     SortOn:=xlSortOnCellColor, _\n    '                     Order:=xlAscending).SortOnValue.Color = vbRed ' Sort Red to top\n    '   ' Can add more SortFields for other colors or criteria\n    '   .SetRange dataRange\n    '   .Header = xlNo ' Assuming no header in this specific range for sorting\n    '   .MatchCase = False\n    '   .Orientation = xlTopToBottom\n    '   .SortMethod = xlPinYin ' Or xlStroke for some East Asian languages\n    '   .Apply\n    ' End With\n    MsgBox \"(概念性) SortSpecial 通常不直接用於按格式排序。現代Excel使用SortFields。\"\nEnd Sub", "explanation": "Range.SortSpecial 本身不直接提供按儲存格顏色等格式排序的簡單參數。在現代 Excel (2007+) 中，按格式排序是通過 `Worksheet.Sort.SortFields` 集合來實現的，可以新增基於 `xlSortOnCellColor`, `xlSortOnFontColor`, 或 `xlSortOnIcon` 的排序欄位。此處的範例概念性地指出了這一點，並給出了使用 SortFields 的框架。"}
    ],
    "keywords": ["excel sortspecial", "sort by cell color vba", "sort by font color", "advanced sorting excel", "按儲存格顏色排序"]
},
{
    "name": "Range.Validation.ErrorMessage / .ErrorTitle (Get/Set)",
    "category": "Excel 核心操作",
    "description": "Validation 物件的 ErrorMessage 屬性設定或傳回當使用者輸入無效資料時顯示的錯誤訊息文字。ErrorTitle 屬性設定或傳回該錯誤訊息對話框的標題。",
    "syntax": "rangeObject.Validation.ErrorMessage = \"Your custom error message.\"\nrangeObject.Validation.ErrorTitle = \"Invalid Input Detected\"",
    "parameters": [],
    "examples": [
        {"code": "With Range(\"A1\").Validation\n  .Delete\n  .Add Type:=xlValidateDecimal, Operator:=xlBetween, Formula1:=\"1.0\", Formula2:=\"10.0\"\n  .InputMessage = \"請輸入1.0到10.0之間的小數。\"\n  .ErrorTitle = \"輸入值錯誤\"\n  .ErrorMessage = \"您輸入的數字必須介於1.0和10.0之間。請重新輸入。\"\n  .ShowInput = True\n  .ShowError = True ' Must be True for ErrorMessage to show\nEnd With\nMsgBox \"A1已設定自訂的資料驗證錯誤標題和訊息。試著輸入無效值 (例如 11)。\"", "explanation": "為儲存格A1設定一個資料驗證規則 (允許1.0到10.0的小數)，並為其定義了自訂的錯誤標題和錯誤訊息，當使用者輸入不符合規則的數據時會顯示這些訊息。"}
    ],
    "keywords": ["validation errormessage", "validation errortitle", "custom data validation error", "自訂驗證錯誤訊息"]
},
// Word
{
    "name": "Document.TablesOfContents.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "numberOfTocs = documentObject.TablesOfContents.Count",
    "description": "傳回文件中 TableOfContents 物件的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.TablesOfContents.Count > 0 Then\n'   MsgBox \"此文件包含 \" & wdDoc.TablesOfContents.Count & \" 個目錄。\"\n' Else\n'   MsgBox \"此文件沒有目錄。\"\n' End If", "explanation": "計算並顯示活動文件中的目錄數量。"}
    ],
    "keywords": ["word tableofcontents count", "number of tocs", "目錄數量Word"]
},
{
    "name": "Range.ListFormat.ListTemplate Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set lt = rangeObject.ListFormat.ListTemplate",
    "description": "傳回一個 ListTemplate 物件，代表指定範圍中第一個段落的清單格式所使用的清單範本。如果範圍未格式化為清單，則可能傳回 Nothing 或產生錯誤。",
    "parameters": [],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\nDim currentListTemplate As Object ' Word.ListTemplate\n' Set selRange = Selection.Range\n' On Error Resume Next ' In case no list format is applied\n' Set currentListTemplate = selRange.ListFormat.ListTemplate\n' If Not currentListTemplate Is Nothing Then\n'   MsgBox \"選取範圍使用的清單範本名稱 (如果有的話): \" & currentListTemplate.Name\n'   Debug.Print \"清單範本的類型: \" & currentListTemplate.ListLevels(1).NumberStyle ' Example property\n' Else\n'   MsgBox \"選取範圍未使用特定的ListTemplate物件，或沒有清單格式。\"\n' End If\n' On Error GoTo 0", "explanation": "獲取目前選取範圍第一個段落的清單範本物件 (如果已套用清單格式)，並顯示其名稱和第一級的數字樣式。"}
    ],
    "keywords": ["word listformat listtemplate", "get list template word", "清單範本屬性"]
},
// Outlook
{
    "name": "MailItem.PermissionService / .PermissionTemplateGuid (Details)",
    "category": "Outlook 郵件與項目管理",
    "description": "若要使用資訊版權管理 (IRM) 保護郵件，通常需要設定：\n1. `MailItem.Permission = olPermissionTemplate` (表示使用範本)。\n2. `MailItem.PermissionTemplateGuid` = 範本的 GUID 字串。\n3. (可選) `MailItem.PermissionService` (例如 `olWindowsRMS` 或 `olAzureRMS`) 可能會根據範本或系統設定自動確定，但有時可能需要明確設定。\n權限範本由 IRM 伺服器 (例如 Azure Information Protection 或 Active Directory Rights Management Services) 管理和提供。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object\n' Set olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\n' olMail.To = \"user@example.com\"\n' olMail.Subject = \"受IRM保護的專案更新 (範本 GUID 範例)\"\n' olMail.Body = \"此郵件內容受IRM保護。\"\n'\n' ' These values are illustrative. Replace with actual Template GUID and verify Service if needed.\n' Const IRM_TEMPLATE_GUID As String = \"{YOUR-SPECIFIC-IRM-TEMPLATE-GUID-HERE}\"\n' Const IRM_SERVICE As Long = 1 ' olWindows (1) or olADS (2) - depends on your org's RMS\n'\n' On Error GoTo IRM_Error\n' olMail.Permission = 2 ' olPermissionTemplate\n' olMail.PermissionTemplateGuid = IRM_TEMPLATE_GUID\n' ' olMail.PermissionService = IRM_SERVICE ' Often not needed if template GUID is correct\n' olMail.Save ' Save to apply IRM. Or .Send\n' MsgBox \"郵件已嘗試套用IRM範本。\"\n' GoTo IRM_End\n'IRM_Error:\n'  MsgBox \"套用IRM時發生錯誤: \" & Err.Description & vbCrLf & \"請確認IRM已設定且範本GUID有效。\"\n'IRM_End:\n' ' olMail.Display ' To see the result (e.g., permission banner)\n' Set olMail = Nothing", "explanation": "建立一封郵件，並嘗試使用指定的範本 GUID 來套用 IRM 保護。此操作成功與否取決於使用者環境中是否已正確設定和部署 IRM 服務及範本。"}
    ],
    "keywords": ["outlook irm by template guid", "set irm policy vba", "email protection irm", "IRM範本GUID"]
},
{
    "name": "AppointmentItem.GetRecurrencePattern (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set recPattern = appointmentItemObject.GetRecurrencePattern()",
    "description": "傳回一個 RecurrencePattern 物件，代表約會的週期性設定。如果約會不是週期性的 (IsRecurring = False)，則使用此方法會產生錯誤。",
    "parameters": [
        {"name": "RecurrencePattern.RecurrenceType", "description": "OlRecurrenceType 常數 (olRecursDaily, olRecursWeekly, etc.)。"},
        {"name": "RecurrencePattern.PatternStartDate / .PatternEndDate", "description": "週期模式的開始/結束日期。"},
        {"name": "RecurrencePattern.Interval", "description": "週期間隔 (例如，每2週)。"},
        {"name": "RecurrencePattern.DayOfWeekMask", "description": "對於每週週期，指定星期幾 (OlDaysOfWeek 常數的組合)。"},
        {"name": "RecurrencePattern.StartTime / .EndTime", "description": "週期性約會的開始/結束時間。"},
        {"name": "RecurrencePattern.Duration", "description": "約會的持續時間 (分鐘)。"},
        {"name": "RecurrencePattern.Occurrences", "description": "總共的發生次數 (如果適用)。"}
    ],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem\nDim rp As Object   ' Outlook.RecurrencePattern\n' ' Assume olAppt is a recurring appointment item\n' Set olAppt = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olAppt) = \"AppointmentItem\" And olAppt.IsRecurring Then\n'   Set rp = olAppt.GetRecurrencePattern\n'   Debug.Print \"--- 週期性約會模式 ('\" & olAppt.Subject & \"') ---\"\n'   Debug.Print \"類型: \" & rp.RecurrenceType\n'   Debug.Print \"開始日期: \" & rp.PatternStartDate\n'   Debug.Print \"開始時間: \" & Format(rp.StartTime, \"hh:mm AM/PM\")\n'   Debug.Print \"持續時間 (分鐘): \" & rp.Duration\n'   If rp.PatternEndDate > #1/1/4501# Then Debug.Print \"結束日期: \" & rp.PatternEndDate\n'   If rp.Occurrences > 0 Then Debug.Print \"發生次數: \" & rp.Occurrences\n'   If rp.RecurrenceType = olRecursWeekly Then Debug.Print \"週遮罩: \" & rp.DayOfWeekMask\n' ElseIf TypeName(olAppt) = \"AppointmentItem\" Then\n'   MsgBox \"選取的約會不是週期性的。\"\n' End If\n' Set rp = Nothing: Set olAppt = Nothing", "explanation": "如果選取的 Outlook 項目是一個週期性約會，則獲取其 RecurrencePattern 物件，並列印其週期類型、開始日期/時間、持續時間以及其他相關的週期設定。"}
    ],
    "keywords": ["outlook getrecurrencepattern", "recurring appointment details", "recurrencetype", "dayofweekmask", "獲取週期模式"]
},
// PowerPoint
{
    "name": "Slide.HeadersFooters.Clear (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideObject.HeadersFooters.Clear",
    "description": "清除投影片上由 HeadersFooters 集合控制的所有頁首和頁尾資訊 (日期時間、頁尾文字、投影片編號)，並將其可見性設為 False。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptSlide As Object\n' Set pptSlide = ActivePresentation.Slides(1)\n' ' First, set some footer info\n' With pptSlide.HeadersFooters\n'   .Footer.Visible = msoTrue: .Footer.Text = \"My Footer Text\"\n'   .SlideNumber.Visible = msoTrue\n' End With\n' MsgBox \"投影片1的頁尾資訊已設定。點擊確定以清除。\"\n' pptSlide.HeadersFooters.Clear\n' MsgBox \"投影片1的所有頁首/頁尾資訊 (日期、頁尾、編號) 已被清除。\"", "explanation": "首先為第一張投影片設定一些頁尾和投影片編號資訊，然後使用 Clear 方法將它們全部清除。"}
    ],
    "keywords": ["powerpoint clear headersfooters", "remove slide footer", "清除投影片頁首頁尾"]
},
{
    "name": "TextRange.Paragraphs.Count (PowerPoint Shape Text)",
    "category": "PowerPoint 簡報製作",
    "syntax": "numberOfParagraphs = shapeObject.TextFrame.TextRange.Paragraphs.Count",
    "description": "傳回指定圖案文字框的 TextRange 中段落的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim shp As Object ' PowerPoint.Shape\n' Set shp = ActiveWindow.Selection.ShapeRange(1) ' Assume a shape with text is selected\n' If shp.HasTextFrame And shp.TextFrame.HasText Then\n'   Dim paraCount As Long\n'   paraCount = shp.TextFrame.TextRange.Paragraphs.Count\n'   MsgBox \"選取圖案的文字框中包含 \" & paraCount & \" 個段落。\"\n'   If paraCount > 0 Then\n'     Debug.Print \"第一個段落的文字: \" & shp.TextFrame.TextRange.Paragraphs(1).Text\n'   End If\n' End If", "explanation": "獲取選取圖案文字框中的段落數量，並列印第一個段落的內容。"}
    ],
    "keywords": ["powerpoint textrange paragraphs count", "count paragraphs in shape", "PPT圖案段落數"]
},
// FSO
{
    "name": "FileSystemObject.GetTempName (Usage for Temporary Files)",
    "category": "檔案與資料夾管理",
    "description": "GetTempName 方法用於產生一個唯一的暫存檔案名稱，但不實際建立檔案。在需要臨時儲存資料時，可以先用此方法取得檔名，然後用 CreateTextFile 或其他方式建立並使用該檔案，最後記得刪除它。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, tempFilePath As String, ts As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Get a temporary file name in the system's temp folder\ntempFilePath = fso.GetSpecialFolder(2).Path & \"\\\" & fso.GetTempName\nDebug.Print \"將使用的暫存檔案路徑: \" & tempFilePath\n\n' Create and use the temporary file\nSet ts = fso.CreateTextFile(tempFilePath, True) ' True to overwrite if (highly unlikely) exists\nts.WriteLine \"這是一些臨時數據。\"\nts.WriteLine \"處理完畢後將被刪除。\"\nts.Close\n\nMsgBox \"臨時數據已寫入: \" & tempFilePath & \". 點擊確定後將刪除此檔案。\"\n\n' Delete the temporary file after use\nIf fso.FileExists(tempFilePath) Then\n  fso.DeleteFile tempFilePath, True ' True to force delete\n  Debug.Print \"暫存檔案 '\" & tempFilePath & \"' 已刪除。\"\nEnd If\nSet fso = Nothing: Set ts = Nothing", "explanation": "產生一個暫存檔案的完整路徑，建立該檔案並寫入一些數據，然後在使用者確認後刪除該臨時檔案。"}
    ],
    "keywords": ["fso create temporary file", "gettempname usage", "temp file management", "建立並刪除暫存檔"]
},
// String
{
    "name": "MidB Statement (Byte-Level String Replacement)",
    "category": "字串與文本操作",
    "description": "MidB 陳述式用於在位元組層級取代字串變數的一部分。它將一個字串中的指定位元組數用另一個字串的位元組取代。這對於處理二進制數據的字串表示或某些特定編碼的字串可能有用，但必須非常小心，以避免破壞多位元組字元的邊界。",
    "syntax": "MidB(ByteStringVariable, StartBytePosition, [LengthBytes]) = NewByteStringExpression",
    "parameters": [],
    "examples": [
        {"code": "Dim myByteStr As String\nDim replacementBytes As String\n' Assume myByteStr is representing some byte data, e.g., read from a binary file into a string\n' For demonstration, let's create a string where each char is one byte effectively (using ChrB for ASCII)\nmyByteStr = ChrB(65) & ChrB(66) & ChrB(67) & ChrB(68) & ChrB(69) ' \"ABCDE\"\nDebug.Print \"原始位元組字串 (表示): \" & myByteStr\n\nreplacementBytes = ChrB(88) & ChrB(89) ' \"XY\"\n\n' Replace 2 bytes starting from byte position 3 (C)\n' MidB myByteStr, 3, 2 -> Will be replaced by \"XY\"\n' So, ABCDE becomes ABXYE\n' Note: VBA strings are Unicode internally. MidB operates on this internal byte representation.\n' For pure byte arrays, this is different. This example is conceptual for VBA strings.\n' If used with actual multi-byte character strings, results can be unpredictable if char boundaries are not respected.\n' On Error Resume Next ' MidB might behave differently or error with Unicode strings vs byte arrays\n' MidB(myByteStr, 3, 2) = replacementBytes\n' If Err.Number = 0 Then\n'   Debug.Print \"MidB 取代後: \" & myByteStr\n' Else\n'   Debug.Print \"MidB 操作時發生錯誤或行為與預期不符，因VBA字串為Unicode。\"\n' End If\n' On Error GoTo 0\nMsgBox \"MidB 陳述式應謹慎用於VBA字串，因其Unicode內部表示。更適用於Byte陣列的直接操作。\"", "explanation": "概念性地演示 MidB 陳述式。在現代 VBA 中，字串是 Unicode (UTF-16)，每個字元通常佔用2個位元組。MidB 直接操作這些位元組。如果源字串和取代字串都只包含單一位元組字元 (例如，標準 ASCII 0-127)，則行為可能如預期。但如果涉及多位元組字元，MidB 可能會破壞字元邊界，導致亂碼。對於真正的位元組級操作，通常建議使用 Byte 陣列而不是 String。"}
    ],
    "keywords": ["midb statement", "byte string replacement", "replace bytes in string", "位元組級字串取代"]
},
// Math
{
    "name": "WorksheetFunction.Large (Excel)",
    "category": "數學、日期與時間",
    "syntax": "kthLargestValue = Application.WorksheetFunction.Large(ArrayOrRange, K As Double)",
    "description": "使用 Excel 的 LARGE 工作表函數，傳回資料集中第 k 個最大值。",
    "parameters": [
        {"name": "ArrayOrRange", "description": "必需。包含要從中找出第 k 個最大值的數據的陣列或儲存格範圍。"},
        {"name": "K", "description": "必需。指示要傳回的值在數據集中的排名 (從最大開始)。"}
    ],
    "examples": [
        {"code": "Dim scores As Variant\nscores = Array(70, 85, 92, 100, 85, 95)\nDim secondHighest As Double\nsecondHighest = Application.WorksheetFunction.Large(scores, 2) ' 2nd largest\nMsgBox \"分數中第二高的值是: \" & secondHighest ' Expected: 95\n\n' Range(\"C1:C6\").Value = Application.Transpose(scores)\n' Dim thirdHighestFromRange As Double\n' thirdHighestFromRange = Application.WorksheetFunction.Large(Range(\"C1:C6\"), 3) ' 3rd largest\n' MsgBox \"範圍 C1:C6 中第三高的值是: \" & thirdHighestFromRange ' Expected: 92", "explanation": "演示如何使用 LARGE 函數從一個 VBA 陣列中找出第二大的值，以及從一個儲存格範圍中找出第三大的值。"}
    ],
    "keywords": ["large function", "excel large vba", "kth largest value", "第k大值"]
},
{
    "name": "WorksheetFunction.Small (Excel)",
    "category": "數學、日期與時間",
    "syntax": "kthSmallestValue = Application.WorksheetFunction.Small(ArrayOrRange, K As Double)",
    "description": "使用 Excel 的 SMALL 工作表函數，傳回資料集中第 k 個最小值。",
    "parameters": [
        {"name": "ArrayOrRange", "description": "必需。包含要從中找出第 k 個最小值的數據的陣列或儲存格範圍。"},
        {"name": "K", "description": "必需。指示要傳回的值在數據集中的排名 (從最小開始)。"}
    ],
    "examples": [
        {"code": "Dim dataSet As Variant\ndataSet = Array(10, 5, 25, 2, 18, 5)\nDim secondSmallest As Double\nsecondSmallest = Application.WorksheetFunction.Small(dataSet, 2) ' 2nd smallest\nMsgBox \"數據集中第二小的值是: \" & secondSmallest ' Data: (2,5,5,10,18,25), 2nd smallest is 5", "explanation": "從一個 VBA 陣列中找出第二小的值。"}
    ],
    "keywords": ["small function", "excel small vba", "kth smallest value", "第k小值"]
},
// Data Types
{
    "name": "VarType (Return Value for Objects - vbObject)",
    "category": "資料類型、轉換與驗證",
    "description": "當 VarType 函數的參數是一個指向 OLE 自動化物件 (例如，Excel.Worksheet, Word.Document, Scripting.Dictionary, UserForm 實例等) 的物件變數時，其傳回值是 `vbObject` (常數值 9)。",
    "parameters": [],
    "examples": [
        {"code": "Dim ws As Worksheet\nDim dict As Object\nDim myForm As Object ' Assume UserForm1 is a UserForm in the project\n\nSet ws = ThisWorkbook.Sheets(1)\nSet dict = CreateObject(\"Scripting.Dictionary\")\n' On Error Resume Next ' UserForm may not be loaded or exist in context for late bind example\n' Set myForm = UserForm1 ' This would need UserForm1 to be a known class, or use Load UserForm1\n' On Error GoTo 0\n\nDebug.Print \"VarType of Worksheet object: \" & VarType(ws) & \" (vbObject = \" & vbObject & \")\"\nDebug.Print \"VarType of Dictionary object: \" & VarType(dict) & \" (vbObject = \" & vbObject & \")\"\n' If Not myForm Is Nothing Then\n'   Debug.Print \"VarType of UserForm object: \" & VarType(myForm) & \" (vbObject = \" & vbObject & \")\"\n' End If\nSet ws = Nothing: Set dict = Nothing: Set myForm = Nothing", "explanation": "演示對於 Worksheet 物件和 Scripting.Dictionary 物件，VarType 函數傳回 vbObject (9)。同時概念性地顯示 UserForm 實例也會傳回 vbObject。"}
    ],
    "keywords": ["vartype object", "vbobject constant", "object data type code", "物件類型代碼"]
},
// Program Flow
{
    "name": "GoSub...Return (Nesting and Limitations - Legacy)",
    "category": "程式流程與結構控制",
    "description": "GoSub...Return 結構允許跳轉到一個本地子常式並在完成後返回。可以進行巢狀 GoSub 呼叫 (一個 GoSub 子常式內部再呼叫另一個 GoSub)。然而，VBA 不會像堆疊般管理 Return 位址，如果從巢狀 GoSub 中直接使用 GoTo 跳出，或者 Return 的次數與 GoSub 不匹配，可能會導致程式流程混亂或錯誤 (例如，錯誤 20「Resume zonder error」如果 Return 沒有對應的 GoSub)。這是它不如結構化程序呼叫 (Call SubName) 穩健的原因之一。",
    "parameters": [],
    "examples": [
        {"code": "Sub MainGoSubDemo()\n    Debug.Print \"Main: Calling GoSub Level1\"\n    GoSub Level1\n    Debug.Print \"Main: Returned from Level1. Value: \" & sharedValue\n    Exit Sub ' Ensure exit before labels\nLevel1:\n    Debug.Print \"  Level1: Entered. Setting value to 10.\"\n    sharedValue = 10\n    Debug.Print \"  Level1: Calling GoSub Level2\"\n    GoSub Level2\n    Debug.Print \"  Level1: Returned from Level2. Value now: \" & sharedValue\n    sharedValue = sharedValue + 5 ' Modify after Level2 returns\n    Return\nLevel2:\n    Debug.Print \"    Level2: Entered. Value from Level1: \" & sharedValue\n    sharedValue = sharedValue * 2 ' Modify shared value\n    Return\nEnd Sub\nPublic sharedValue As Long ' Module level for demo, not good practice", "explanation": "演示巢狀的 GoSub 呼叫。MainGoSubDemo 呼叫 Level1，Level1 內部再呼叫 Level2。Return 會將控制權返回到最近的 GoSub 之後的語句。此範例使用一個模組級變數 sharedValue 來觀察值的變化，這不是良好的程式設計實踐，僅為演示。"}
    ],
    "keywords": ["gosub return nesting", "legacy subroutine call", "vba local subroutine", "巢狀GoSub"]
},
// Excel 核心操作
{
    "name": "Range.NumberFormat (General Number, Text, Date, Time)",
    "category": "Excel 核心操作",
    "description": "Range.NumberFormat 屬性設定儲存格的數字/日期/時間/文字顯示格式。\n通用數字: \"General\"\n數字 (0小數位): \"0\"\n數字 (2小數位): \"0.00\"\n數字 (千分位, 2小數位): \"#,##0.00\"\n百分比 (2小數位): \"0.00%\"\n科學記號: \"0.00E+00\"\n文字: \"@\"\n日期 (短): \"yyyy/m/d\" (或系統短日期)\n日期 (長): \"yyyy\"\"年\"\"m\"\"月\"\"d\"\"日\"\" (或系統長日期)\n時間 (時:分): \"h:mm AM/PM\"\n時間 (時:分:秒): \"h:mm:ss\"",
    "syntax": "rangeObject.NumberFormat = FormatString",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = 12345.6789: Range(\"A1\").NumberFormat = \"#,##0.00\" ' $12,345.68 (if currency symbol is $)\nRange(\"A2\").Value = 0.75: Range(\"A2\").NumberFormat = \"0.0%\"   ' 75.0%\nRange(\"A3\").Value = Now: Range(\"A3\").NumberFormat = \"yyyy-mm-dd hh:mm:ss\"\nRange(\"A4\").Value = \"00123\": Range(\"A4\").NumberFormat = \"@\" ' Treat as text", "explanation": "為不同類型的數據設定不同的數字和日期時間格式。"}
    ],
    "keywords": ["numberformat examples", "excel cell formatting codes", "date format codes", "text format code", "數字格式代碼", "日期格式代碼"]
},
{
    "name": "Worksheet.UsedRange.Address",
    "category": "Excel 核心操作",
    "syntax": "addressString = worksheetObject.UsedRange.Address([RowAbsolute], [ColumnAbsolute], [ReferenceStyle], [External], [RelativeTo])",
    "description": "傳回代表工作表上已使用範圍的位址字串。",
    "parameters": [],
    "examples": [
        {"code": "Dim urAddr As String\nurAddr = ActiveSheet.UsedRange.Address\nMsgBox \"活動工作表的已使用範圍位址是: \" & urAddr\n\nDim urAddrExternal As String\nurAddrExternal = ActiveSheet.UsedRange.Address(External:=True)\nMsgBox \"活動工作表的已使用範圍外部位址是: \" & urAddrExternal", "explanation": "獲取活動工作表已使用範圍的標準位址和包含工作簿/工作表名稱的外部位址。"}
    ],
    "keywords": ["usedrange address", "get data range address", "已使用範圍位址"]
},
{
    "name": "Range.Areas (Working with Non-Contiguous Ranges)",
    "category": "Excel 核心操作",
    "syntax": "Set areasCollection = rangeObject.Areas",
    "description": "如果 Range 物件代表一個多重選取範圍 (非連續範圍)，則 Areas 屬性會傳回一個 Areas 集合，其中每個 Area 物件代表一個連續的子範圍。如果 Range 物件是單一連續範圍，則 Areas 集合只包含一個代表該原始範圍的 Area。",
    "parameters": [
        {"name": "Areas.Count", "description": "傳回 Areas 集合中的子範圍數量。"},
        {"name": "Areas.Item(Index)", "description": "傳回指定索引的 Area (Range 物件)。"}
    ],
    "examples": [
        {"code": "' Select non-contiguous ranges first (e.g., A1:B2 and D4:E5 by holding Ctrl in Excel)\n' Then run this macro:\nDim multiRange As Range, areaItem As Range, i As Integer\nOn Error Resume Next ' Selection might not be a range or might be single area\nSet multiRange = Selection\nIf Err.Number <> 0 Or multiRange Is Nothing Then\n  MsgBox \"請先選取一個或多個範圍。\": Exit Sub\nEnd If\nOn Error GoTo 0\n\nMsgBox \"選取的範圍包含 \" & multiRange.Areas.Count & \" 個子區域。\"\ni = 1\nFor Each areaItem In multiRange.Areas\n  Debug.Print \"子區域 \" & i & \" 位址: \" & areaItem.Address\n  areaItem.Interior.ColorIndex = i + 3 ' Apply different color to each area\n  i = i + 1\nNext areaItem", "explanation": "如果使用者在工作表上選取了多個非連續的儲存格區域，此程式碼會遍歷每個選取的子區域，列印其位址並為其設定不同的背景色。"}
    ],
    "keywords": ["range.areas", "non-contiguous range", "multiple selection vba", "多重選取範圍", "非連續區域"]
},
{
    "name": "Range.Offset (Entire Row/Column)",
    "category": "Excel 核心操作",
    "syntax": "Set offsetRow = rangeObject.EntireRow.Offset(RowOffset)\nSet offsetCol = rangeObject.EntireColumn.Offset(, ColumnOffset)",
    "description": "對整個列或整個欄執行偏移操作。例如，獲取某列下方第N列，或某欄右方第N欄。",
    "parameters": [],
    "examples": [
        {"code": "Dim startCell As Range: Set startCell = Range(\"B2\")\n' Get the row 2 rows below B2's row (i.e., entire row 4)\nDim rowBelow As Range: Set rowBelow = startCell.EntireRow.Offset(2)\nrowBelow.Select\nMsgBox \"已選取 \" & startCell.Address & \" 所在列的下方第2列: \" & rowBelow.Address(False,False,xlA1,True)\n\n' Get the column 3 columns to the right of B2's column (i.e., entire column E)\nDim colToRight As Range: Set colToRight = startCell.EntireColumn.Offset(0, 3)\n' colToRight.Select ' This would select entire column E\nMsgBox \"已取得 \" & startCell.Address & \" 所在欄的右方第3欄: \" & colToRight.Cells(1,1).Address(False,False) & \" (整欄)\"", "explanation": "演示如何獲取相對於某個儲存格所在列的下方某整列，以及相對於某個儲存格所在欄的右方某整欄。"}
    ],
    "keywords": ["offset entirerow", "offset entirecolumn", "get relative row column", "整列偏移", "整欄偏移"]
},
// Word Document Processing
{
    "name": "Document.Tables(Index).Rows.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "numberOfRows = documentObject.Tables(Index).Rows.Count",
    "description": "傳回指定 Word 表格中的列數。",
    "parameters": [{"name": "Index", "description": "必需。表格在 Tables 集合中的索引 (1-based)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Tables.Count > 0 Then\n'   MsgBox \"第一個表格共有 \" & wdDoc.Tables(1).Rows.Count & \" 列。\"\n' Else\n'   MsgBox \"文件中沒有表格。\"\n' End If", "explanation": "計算並顯示活動文件中第一個表格的總列數。"}
    ],
    "keywords": ["word table rows count", "number of rows in table word", "表格列數Word"]
},
{
    "name": "Document.Tables(Index).Columns.Count (Word)",
    "category": "Word 文件處理",
    "syntax": "numberOfColumns = documentObject.Tables(Index).Columns.Count",
    "description": "傳回指定 Word 表格中的欄數。",
    "parameters": [{"name": "Index", "description": "必需。表格在 Tables 集合中的索引 (1-based)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Tables.Count > 0 Then\n'   MsgBox \"第一個表格共有 \" & wdDoc.Tables(1).Columns.Count & \" 欄。\"\n' End If", "explanation": "計算並顯示活動文件中第一個表格的總欄數。"}
    ],
    "keywords": ["word table columns count", "number of columns in table word", "表格欄數Word"]
},
{
    "name": "Range.Bold / .Italic / .Underline (Word Font Properties)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Font.Bold = True | False | wdToggle\nrangeObject.Font.Italic = True | False | wdToggle\nrangeObject.Font.Underline = WdUnderlineConstant",
    "description": "設定或傳回指定範圍文字的粗體、斜體或底線格式。對於 Bold 和 Italic，可以設為 wdToggle 來切換目前狀態。Underline 使用 WdUnderline 常數 (例如 wdUnderlineSingle, wdUnderlineNone, wdUnderlineDotted)。",
    "parameters": [],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' If selRange.Type <> wdSelectionIP Then ' If text is selected\n'   selRange.Font.Bold = True\n'   selRange.Font.Italic = wdToggle ' Toggle Italic state\n'   selRange.Font.Underline = wdUnderlineDash\n'   MsgBox \"選取文字已設為粗體，斜體狀態已切換，並加上虛線底線。\"\n' End If", "explanation": "如果使用者選取了文字，則將其設為粗體，切換其斜體狀態，並設定為虛線底線。"}
    ],
    "keywords": ["word font bold italic underline", "toggle bold word", "wdunderline", "文字格式Word"]
},
{
    "name": "Table.AutoFitBehavior (Word Table)",
    "category": "Word 文件處理",
    "syntax": "tableObject.AutoFitBehavior(Behavior As WdAutoFitBehavior)",
    "description": "變更表格的自動調整行為，以適應其內容或視窗寬度。",
    "parameters": [
        {"name": "Behavior", "description": "必需。WdAutoFitBehavior 常數 (wdAutoFitContent, wdAutoFitWindow, wdAutoFitFixed)。"}
    ],
    "examples": [
        {"code": "Dim tbl As Object ' Word.Table\n' If ActiveDocument.Tables.Count > 0 Then\n'   Set tbl = ActiveDocument.Tables(1)\n'   tbl.AutoFitBehavior wdAutoFitContent ' AutoFit to content\n'   MsgBox \"第一個表格已設定為根據內容自動調整欄寬。\"\n'   ' tbl.AutoFitBehavior wdAutoFitWindow ' AutoFit to window\n' End If", "explanation": "將活動文件中第一個表格的自動調整行為設定為根據內容調整欄寬。"}
    ],
    "keywords": ["word table autofit", "autofitbehavior", "表格自動調整Word"]
},
// Outlook Mail & Item Management
{
    "name": "MailItem.Attachments(Index).DisplayName (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "displayNameString = mailItemObject.Attachments(Index).DisplayName",
    "description": "傳回郵件項目中指定附件的顯示名稱 (通常是檔案名稱)。唯讀。",
    "parameters": [{"name": "Index", "description": "必需。附件在 Attachments 集合中的索引 (1-based)。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" And olMail.Attachments.Count > 0 Then\n'   MsgBox \"第一個附件的顯示名稱是: \" & olMail.Attachments(1).DisplayName\n' End If", "explanation": "如果選取的郵件有附件，則顯示第一個附件的顯示名稱。"}
    ],
    "keywords": ["outlook attachment displayname", "get attachment name", "附件顯示名稱"]
},
{
    "name": "ContactItem.CompanyName / .JobTitle (Outlook Contact)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "contactItemObject.CompanyName = \"Company Name\"\ncontactItemObject.JobTitle = \"Job Title\"",
    "description": "設定或傳回 Outlook 連絡人的公司名稱和職稱。",
    "parameters": [],
    "examples": [
        {"code": "Dim olContact As Object ' Outlook.ContactItem\n' Set olContact = Application.CreateItem(olContactItem)\n' olContact.FirstName = \"Alex\"\n' olContact.LastName = \"Chen\"\n' olContact.CompanyName = \"Contoso Ltd.\"\n' olContact.JobTitle = \"Senior Analyst\"\n' olContact.Save\n' MsgBox \"連絡人 'Alex Chen' 的公司和職稱已設定。\"", "explanation": "建立一個新連絡人並設定其公司名稱和職稱。"}
    ],
    "keywords": ["outlook contact company", "contact job title", "連絡人公司職稱"]
},
// PowerPoint Presentation Creation
{
    "name": "Slide.Shapes.BuildFreeform (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set freeformBuilder = slideObject.Shapes.BuildFreeform(EditingType As MsoEditingType, X1 As Single, Y1 As Single)\nfreeformBuilder.AddNodes SegmentType:=msoSegmentLine, EditingType:=msoEditingAuto, X2, Y2, [X3, Y3]\nSet newShape = freeformBuilder.ConvertToShape()",
    "description": "建立一個 FreeformBuilder 物件，用於逐步建構任意多邊形或手繪圖案。",
    "parameters": [
        {"name": "EditingType (BuildFreeform)", "description": "MsoEditingType 常數 (msoEditingAuto, msoEditingCorner)。"},
        {"name": "X1, Y1 (BuildFreeform)", "description": "第一個頂點的座標。"},
        {"name": "AddNodes", "description": "方法：新增節點到任意多邊形。SegmentType (msoSegmentLine, msoSegmentCurve)。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, ffBuild As Object ' PowerPoint.FreeformBuilder\nDim finalShape As Object ' PowerPoint.Shape\n' Set pptSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, ppLayoutBlank)\n' Set ffBuild = pptSlide.Shapes.BuildFreeform(msoEditingCorner, 100, 100)\n' ffBuild.AddNodes SegmentType:=msoSegmentLine, EditingType:=msoEditingCorner, X1:=200, Y1:=100\n' ffBuild.AddNodes SegmentType:=msoSegmentLine, EditingType:=msoEditingCorner, X1:=150, Y1:=200\n' ffBuild.AddNodes SegmentType:=msoSegmentLine, EditingType:=msoEditingCorner, X1:=100, Y1:=100 ' Close the shape (back to start)\n' Set finalShape = ffBuild.ConvertToShape()\n' finalShape.Fill.ForeColor.RGB = RGB(100, 200, 100) ' Light green\n' MsgBox \"已建立一個任意多邊形。\"", "explanation": "在新投影片上使用 FreeformBuilder 建立一個三角形，並填充顏色。"}
    ],
    "keywords": ["powerpoint buildfreeform", "draw custom shape ppt", "addnodes", "繪製任意多邊形PPT"]
},
{
    "name": "Presentation.Path Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "pathString = presentationObject.Path",
    "description": "傳回指定簡報的儲存路徑 (不含檔案名稱和最後的分隔符號)。如果簡報未儲存，則傳回空字串。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\n' Set pptPres = ActivePresentation\n' If pptPres.Path <> \"\" Then\n'   MsgBox \"目前簡報的路徑是: \" & pptPres.Path\n' Else\n'   MsgBox \"目前簡報尚未儲存，沒有路徑。\"\n' End If", "explanation": "顯示活動簡報的儲存路徑 (如果已儲存)。"}
    ],
    "keywords": ["powerpoint presentation path", "get ppt file directory", "簡報檔案路徑"]
},
// FSO
{
    "name": "FileSystemObject.GetFolder (Error Handling)",
    "category": "檔案與資料夾管理",
    "description": "如果使用 GetFolder 方法嘗試獲取一個不存在的資料夾，會產生執行階段錯誤 76「找不到路徑」。應使用錯誤處理來檢查，或先用 FolderExists 方法確認。",
    "syntax": "On Error Resume Next\nSet folderObj = fso.GetFolder(NonExistentPath)\nIf Err.Number = 76 Then ...",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myFolder As Object\nDim testPath As String: testPath = \"C:\\Path\\That\\Definitely\\DoesNotExist_Folder\"\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nOn Error Resume Next\nSet myFolder = fso.GetFolder(testPath)\nIf Err.Number = 76 Then\n  MsgBox \"使用 GetFolder 找不到資料夾: \" & testPath & vbCrLf & \"錯誤: \" & Err.Description\nElseIf Err.Number = 0 And Not myFolder Is Nothing Then\n  MsgBox \"資料夾 '\" & myFolder.Name & \"' 存在 (這不應發生於此範例)。\"\nElseIf Err.Number <> 0 Then\n  MsgBox \"獲取資料夾時發生其他錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\nSet fso = Nothing: Set myFolder = Nothing", "explanation": "嘗試使用 GetFolder 獲取一個不存在的資料夾。透過 On Error Resume Next 捕獲錯誤 76，並顯示相應的訊息。"}
    ],
    "keywords": ["fso getfolder error 76", "folder not found fso", "handle getfolder error", "GetFolder錯誤處理"]
},
// String
{
    "name": "vbCr (vs vbCrLf in Text Files)",
    "category": "字串與文本操作",
    "description": "寫入文字檔案時：\nvbCrLf: 在 Windows 上產生標準的換行 (回車+換行)。\nvbLf: 在 Unix/Linux 系統上產生換行。在 Windows 的某些文字編輯器 (如記事本) 中可能顯示為方塊或不換行，但在程式設計編輯器或 WordPad 中通常能正確顯示為換行。\nvbCr: 在舊版 Mac OS (OS 9及更早) 上表示換行。在 Windows 上單獨使用 vbCr 通常不會產生使用者期望的換行效果，可能會導致文字在同一行覆寫。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, ts As Object, filePath As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nfilePath = fso.GetSpecialFolder(2).Path & \"\\NewlineTest.txt\"\nSet ts = fso.CreateTextFile(filePath, True)\nts.Write \"Line 1 (CRLF)\" & vbCrLf\nts.Write \"Line 2 (LF)\" & vbLf\nts.Write \"Line 3 (CR)\" & vbCr\nts.Write \"Line 4 (After CR)\"\nts.Close\nMsgBox \"已建立 NewlineTest.txt 檔案於暫存資料夾。請用不同編輯器開啟查看效果。\"\n' Shell \"notepad.exe \" & filePath, vbNormalFocus ' Open with Notepad to see\nSet fso = Nothing: Set ts = Nothing", "explanation": "建立一個文字檔案，分別使用 vbCrLf, vbLf, 和 vbCr 寫入不同的行結束符。然後提示使用者用文字編輯器開啟查看它們的顯示差異。"}
    ],
    "keywords": ["vbcr text file", "vblf text file", "newline character differences", "文字檔案換行符"]
},
// Math
{
    "name": "WorksheetFunction.Percentile_Inc (Excel)",
    "category": "數學、日期與時間",
    "syntax": "percentileValue = Application.WorksheetFunction.Percentile_Inc(ArrayOrRange, K As Double)",
    "description": "使用 Excel 的 PERCENTILE.INC 工作表函數 (Excel 2010 及更新版本，舊版為 PERCENTILE)，傳回資料集中第 k 個百分位數的值 (k 介於 0 和 1 之間，包含0和1)。",
    "parameters": [
        {"name": "ArrayOrRange", "description": "必需。定義相對位置的數據陣列或儲存格範圍。"},
        {"name": "K", "description": "必需。0 到 1 之間的百分位數值。"}
    ],
    "examples": [
        {"code": "Dim scores As Variant: scores = Array(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)\nDim p25 As Double, p50 As Double, p90 As Double\np25 = Application.WorksheetFunction.Percentile_Inc(scores, 0.25) ' 25th percentile (1st quartile)\np50 = Application.WorksheetFunction.Percentile_Inc(scores, 0.5)  ' 50th percentile (median)\np90 = Application.WorksheetFunction.Percentile_Inc(scores, 0.9)  ' 90th percentile\nMsgBox \"25百分位數: \" & p25 & vbCrLf & _\n       \"50百分位數 (中位數): \" & p50 & vbCrLf & _\n       \"90百分位數: \" & p90", "explanation": "計算一組數字的第25、50（中位數）和90百分位數。"}
    ],
    "keywords": ["percentile.inc", "excel percentile vba", "kth percentile", "百分位數"]
},
{
    "name": "WorksheetFunction.Quartile_Inc (Excel)",
    "category": "數學、日期與時間",
    "syntax": "quartileValue = Application.WorksheetFunction.Quartile_Inc(ArrayOrRange, Quart As Long)",
    "description": "使用 Excel 的 QUARTILE.INC 工作表函數 (Excel 2010 及更新版本，舊版為 QUARTILE)，傳回資料集的四分位數 (基於0到1包含端點的百分位數值)。",
    "parameters": [
        {"name": "ArrayOrRange", "description": "必需。要計算四分位數的數據陣列或儲存格範圍。"},
        {"name": "Quart", "description": "必需。指示要傳回哪個四分位數的值 (0=最小值, 1=第一四分位數(25%), 2=中位數(50%), 3=第三四分位數(75%), 4=最大值)。"}
    ],
    "examples": [
        {"code": "Dim dataSet As Variant: dataSet = Array(1, 2, 5, 7, 9, 10, 12, 15, 18, 20)\nDim q1 As Double, medianQ As Double, q3 As Double\nq1 = Application.WorksheetFunction.Quartile_Inc(dataSet, 1) ' First Quartile\nmedianQ = Application.WorksheetFunction.Quartile_Inc(dataSet, 2) ' Median\nq3 = Application.WorksheetFunction.Quartile_Inc(dataSet, 3) ' Third Quartile\nMsgBox \"第一四分位數 (Q1): \" & q1 & vbCrLf & _\n       \"中位數 (Q2): \" & medianQ & vbCrLf & _\n       \"第三四分位數 (Q3): \" & q3", "explanation": "計算一組數字的第一四分位數、中位數和第三四分位數。"}
    ],
    "keywords": ["quartile.inc", "excel quartile vba", "first quartile", "third quartile", "四分位數"]
},
// Data Types
{
    "name": "vbArray Constant (VarType for Arrays)",
    "category": "資料類型、轉換與驗證",
    "description": "vbArray 是一個 VbVarType 列舉常數，其值為 8192。當 VarType 函數的參數是一個陣列時，傳回值中會包含此常數 (與陣列元素的 VarType 值進行 OR 運算或相加)。要檢查一個 Variant 變數是否為陣列，除了使用 `IsArray(var)`，也可以檢查 `(VarType(var) And vbArray) = vbArray`。",
    "parameters": [],
    "examples": [
        {"code": "Dim myIntArray(3) As Integer\nDim myVarArray As Variant: myVarArray = Array(\"A\", \"B\")\nDim mySingleVar As Integer\n\nIf (VarType(myIntArray) And vbArray) = vbArray Then\n  Debug.Print \"myIntArray 是一個陣列。其 VarType 值: \" & VarType(myIntArray)\nEnd If\nIf (VarType(myVarArray) And vbArray) = vbArray Then\n  Debug.Print \"myVarArray 是一個陣列。其 VarType 值: \" & VarType(myVarArray)\nEnd If\nIf Not ((VarType(mySingleVar) And vbArray) = vbArray) Then\n  Debug.Print \"mySingleVar 不是一個陣列。其 VarType 值: \" & VarType(mySingleVar)\nEnd If", "explanation": "演示如何使用位元 AND 運算符結合 vbArray 常數來判斷一個變數是否為陣列。"}
    ],
    "keywords": ["vbarray", "vartype check array", "isarray alternative", "檢查是否為陣列"]
},
// Program Flow
{
    "name": "Declare Statement (lpstr Alias for String Parameters)",
    "category": "程式流程與結構控制",
    "description": "在為 Windows API 函數編寫 Declare 語句時，如果 API 文件指出一個參數是 `LPSTR` (指向ANSI字串的長指標) 或 `LPCSTR` (指向常數ANSI字串的長指標)，在 VBA Declare 中通常將該參數宣告為 `ByVal ParameterName As String`。VBA 會自動處理字串到 ANSI 指標的轉換。有時，為了更明確或與舊程式碼兼容，可能會看到使用 `Alias` 關鍵字將參數名稱或整個函數名稱映射到其在 DLL 中的真實名稱，並可能包含類型資訊提示 (但 `ByVal As String` 是關鍵)。",
    "parameters": [],
    "examples": [
        {"code": "' Example: GetShortPathName API (takes an input path string and returns short path in a buffer)\n' #If VBA7 Then\n'   Private Declare PtrSafe Function GetShortPathName Lib \"kernel32\" Alias \"GetShortPathNameA\" (\n'     ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal cchBuffer As Long) As Long\n' #Else\n'   Private Declare Function GetShortPathName Lib \"kernel32\" Alias \"GetShortPathNameA\" (\n'     ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal cchBuffer As Long) As Long\n' #End If\n'\n' Sub ShowShortPath()\n'   Dim longPath As String: longPath = \"C:\\Program Files\\Microsoft Office\\Office16\\EXCEL.EXE\" ' Example\n'   Dim shortPathBuffer As String, bufferLen As Long, pathLen As Long\n'   bufferLen = 260 ' MAX_PATH often used for buffer size\n'   shortPathBuffer = String(bufferLen, vbNullChar)\n'\n'   pathLen = GetShortPathName(longPath, shortPathBuffer, bufferLen)\n'\n'   If pathLen > 0 And pathLen < bufferLen Then\n'     MsgBox \"長路徑: \" & longPath & vbCrLf & \"短路徑 (8.3): \" & Left(shortPathBuffer, pathLen)\n'   ElseIf pathLen >= bufferLen Then\n'     MsgBox \"緩衝區太小以容納短路徑。\"\n'   Else\n'     MsgBox \"無法獲取短路徑。錯誤碼: \" & Err.LastDllError\n'   End If\n' End Sub", "explanation": "演示 GetShortPathName API 的 Declare 語句。`lpszLongPath` 和 `lpszShortPath` (作為緩衝區) 都被宣告為 `ByVal As String`。VBA 在傳遞 `lpszLongPath` 時會傳遞字串內容的指標，在傳遞 `shortPathBuffer` 時也會傳遞一個可寫入的字串緩衝區的指標。"}
    ],
    "keywords": ["declare lpstr", "api string parameter", "byval as string api", "API字串參數宣告"]
},
// External API
{
    "name": "WScript.Shell.AppActivate (Application Title or Process ID)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "WScript.Shell 物件的 AppActivate 方法可以啟動一個應用程式視窗，使其獲得焦點。它可以接受視窗的完整標題、標題的一部分，或者由 Shell 函數或 WScript.Shell.Run 方法傳回的程序ID (Process ID)。使用程序ID通常更可靠，因為視窗標題可能改變或不唯一。",
    "parameters": [
        {"name": "AppTitleOrProcessID", "description": "必需。視窗標題 (字串) 或程序ID (長整數)。"},
        {"name": "Wait (Optional)", "description": "布林值，如果為 True，則呼叫 AppActivate 的腳本會等待直到被啟動的應用程式取得焦點。"}
    ],
    "examples": [
        {"code": "Dim wshShell As Object\nDim procID As Long\nSet wshShell = CreateObject(\"WScript.Shell\")\n\n' Start Notepad and get its process ID using WScript.Shell.Run\nOn Error Resume Next\nprocID = wshShell.Run(\"notepad.exe\", 1, False) ' Run normal, don't wait for it to close\nIf Err.Number = 0 And procID <> 0 Then\n    MsgBox \"記事本已啟動 (Process ID: \" & procID & \"). 嘗試使用Process ID啟動它。\"\n    Application.Wait Now + TimeValue(\"00:00:01\") ' Wait for window to appear\n    If wshShell.AppActivate(procID) Then\n        Debug.Print \"記事本視窗 (透過 Process ID) 已成功啟動。\"\n    Else\n        Debug.Print \"使用 Process ID 啟動記事本視窗失敗。嘗試使用標題...\"\n        If wshShell.AppActivate(\"無標題 - 記事本\") Or wshShell.AppActivate(\"Untitled - Notepad\") Then ' Title depends on locale\n            Debug.Print \"記事本視窗 (透過標題) 已成功啟動。\"\n        Else\n            Debug.Print \"使用標題啟動記事本視窗也失敗。\"\n        End If\n    End If\nElse\n    MsgBox \"啟動記事本或獲取Process ID失敗。錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\nSet wshShell = Nothing", "explanation": "使用 WScript.Shell.Run 啟動記事本並獲取其程序ID。然後，嘗試使用該程序ID透過 AppActivate 方法將記事本視窗帶到前景。如果失敗，則嘗試使用視窗標題來啟動它。"}
    ],
    "keywords": ["wscript.shell appactivate", "activate window by process id", "focus application pid", "AppActivate程序ID"]
},
{
    "name": "ADODB.Recordset (EditMode Property)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 EditMode 屬性傳回一個 EditModeEnum 常數，指示目前記錄的編輯狀態。\n`adEditNone` (0): 沒有編輯操作正在進行。\n`adEditInProgress` (1): 目前記錄中的數據已被修改但尚未儲存。\n`adEditAdd` (2): AddNew 方法已被呼叫，目前記錄是緩衝區中的新記錄，尚未儲存到資料庫。\n在呼叫 Update 或 CancelUpdate 之前檢查此屬性很有用。",
    "parameters": [],
    "examples": [
        {"code": "Dim rs As Object ' ADODB.Recordset\n' ' Assume rs is an open, updatable recordset\n' ' Set rs = ... rs.Open ...\n'\n' ' If Not rs.EOF Then\n' '   rs.MoveFirst\n' '   Debug.Print \"初始 EditMode: \" & rs.EditMode ' Should be 0 (adEditNone)\n'\n' '   rs.Fields(\"SomeField\").Value = \"New Value\"\n' '   Debug.Print \"修改欄位後 EditMode: \" & rs.EditMode ' Should be 1 (adEditInProgress)\n'\n' '   rs.Update ' Save changes\n' '   Debug.Print \"更新後 EditMode: \" & rs.EditMode ' Should be 0 again\n'\n' '   rs.AddNew\n' '   Debug.Print \"AddNew 之後 EditMode: \" & rs.EditMode ' Should be 2 (adEditAdd)\n' '   rs.Fields(\"SomeField\").Value = \"Another New Record\"\n' '   rs.Update\n' '   Debug.Print \"新增並更新後 EditMode: \" & rs.EditMode ' Should be 0\n' ' End If\n' ' If rs.State = 1 Then rs.Close\n' ' Set rs = Nothing\nMsgBox \"(概念性) 演示了 EditMode 屬性。需有實際可寫資料錄集。\"", "explanation": "演示 Recordset 的 EditMode 屬性在不同操作 (修改現有記錄、呼叫 AddNew) 後的變化。"}
    ],
    "keywords": ["adodb recordset editmode", "adeditnone", "adeditinprogress", "adeditadd", "recordset editing status", "記錄集編輯狀態"]
},
// Excel 核心操作
{
    "name": "Window.SplitColumn / .SplitRow Properties (Excel)",
    "category": "Excel 核心操作",
    "syntax": "windowObject.SplitColumn = pointsOrZero\nwindowObject.SplitRow = pointsOrZero",
    "description": "設定或傳回視窗分割的水平 (SplitColumn) 或垂直 (SplitRow) 位置 (以點為單位)。將這些屬性設為 0 可以移除相應的分割線。將 `Window.Split = False` 會同時移除所有分割。",
    "parameters": [{"name": "pointsOrZero", "description": "分割線的位置 (點)，或 0 以移除該方向的分割。"}],
    "examples": [
        {"code": "ActiveWindow.SplitColumn = 250 ' Create a vertical split at 250 points from left\nActiveWindow.SplitRow = 150   ' Create a horizontal split at 150 points from top\nMsgBox \"視窗已在水平和垂直方向上分割。\"\nApplication.Wait Now + TimeValue(\"00:00:02\")\nActiveWindow.SplitColumn = 0 ' Remove vertical split\nMsgBox \"垂直分割已移除。\"\nApplication.Wait Now + TimeValue(\"00:00:02\")\nActiveWindow.Split = False   ' Remove all splits\nMsgBox \"所有分割已移除。\"", "explanation": "先在活動視窗中建立一個垂直和一個水平的分割線，然後分別移除垂直分割，最後移除所有分割。"}
    ],
    "keywords": ["splitcolumn", "splitrow", "excel window split position", "分割視窗位置"]
},
{
    "name": "Range.ColumnWidth (Set to AutoFit)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Columns.AutoFit ' Or rangeObject.EntireColumn.AutoFit",
    "description": "要將欄寬設定為自動調整以適應內容，應使用 Range.Columns.AutoFit 或 Range.EntireColumn.AutoFit 方法，而不是嘗試將 ColumnWidth 屬性設定為某個特殊值。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = \"這是一段非常非常長的文字，需要自動調整欄寬。\"\nRange(\"B1\").Value = \"短文字\"\n' Autofit column A based on content of A1\nRange(\"A1\").EntireColumn.AutoFit\n' Autofit columns A through C\nRange(\"A:C\").Columns.AutoFit\nMsgBox \"A欄和A到C欄已嘗試自動調整寬度。\"", "explanation": "演示如何使用 EntireColumn.AutoFit 和 Columns.AutoFit 來自動調整欄寬以適應其內容。"}
    ],
    "keywords": ["autofit column width vba", "excel set column autofit", "自動調整欄寬VBA"]
},
// Word
{
    "name": "Document.ActiveWindow.View.Type (Word View Mode)",
    "category": "Word 文件處理",
    "syntax": "currentViewType = documentObject.ActiveWindow.View.Type\ndocumentObject.ActiveWindow.View.Type = WdViewTypeConstant",
    "description": "設定或傳回 Word 文件視窗的檢視模式。",
    "parameters": [
        {"name": "WdViewTypeConstant", "description": "例如 wdNormalView (草稿檢視), wdPrintView (整頁模式/列印版面配置檢視, 預設), wdWebView (Web版面配置檢視), wdOutlineView (大綱檢視), wdReadingView (閱讀版面配置檢視, Word 2013+)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' MsgBox \"目前檢視模式: \" & wdDoc.ActiveWindow.View.Type\n' ' Change to Outline View\n' wdDoc.ActiveWindow.View.Type = wdOutlineView ' wdOutlineView = 2\n' MsgBox \"已切換到大綱檢視。\"\n' Application.Wait Now + TimeValue(\"00:00:02\")\n' ' Change back to Print View\n' wdDoc.ActiveWindow.View.Type = wdPrintView ' wdPrintView = 3\n' MsgBox \"已還原到整頁模式。\"", "explanation": "獲取並顯示目前 Word 文件的檢視模式，然後將其切換到大綱檢視，再切換回整頁模式 (列印版面配置檢視)。"}
    ],
    "keywords": ["word view type", "wdprintview", "wdoutlineview", "change document view word", "Word檢視模式"]
},
// Outlook
{
    "name": "MailItem.BillingInformation Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.BillingInformation [= String]",
    "description": "設定或傳回一個字串，表示與 Outlook 項目相關聯的帳單資訊。此欄位通常用於追蹤或分類與特定專案、客戶或帳單代碼相關的郵件。",
    "parameters": [{"name": "String", "description": "帳單資訊文字。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.CreateItem(olMailItem)\n' olMail.Subject = \"專案X的進度更新\"\n' olMail.BillingInformation = \"ProjectX-Phase2;ClientABC;Dept123\"\n' olMail.Display\n' MsgBox \"郵件的帳單資訊已設定為: \" & olMail.BillingInformation", "explanation": "建立一封新郵件，並為其設定帳單資訊欄位，可用於後續的篩選或報告。"}
    ],
    "keywords": ["outlook billinginformation", "track email billing code", "郵件帳單資訊"]
},
{
    "name": "NameSpace.CurrentUser Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set currentUserRecipient = olNamespace.CurrentUser",
    "description": "傳回一個 Recipient 物件，代表目前登入的 MAPI 使用者。",
    "parameters": [],
    "examples": [
        {"code": "Dim olNS As Object, currentUser As Object ' Outlook.Recipient\nSet olNS = Application.GetNamespace(\"MAPI\")\nSet currentUser = olNS.CurrentUser\nIf Not currentUser Is Nothing And currentUser.Resolved Then\n  MsgBox \"目前登入的Outlook使用者: \" & currentUser.Name & vbCrLf & _\n         \"電子郵件地址: \" & currentUser.AddressEntry.Address ' Or .Address for primary SMTP\nElse\n  MsgBox \"無法獲取目前使用者資訊。\"\nEnd If", "explanation": "獲取目前登入 Outlook 的使用者，並顯示其顯示名稱和電子郵件地址。"}
    ],
    "keywords": ["outlook currentuser", "get logged in user outlook", "mapi current user", "目前Outlook使用者"]
},
// PowerPoint
{
    "name": "SlideRange.Count Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "numberOfSlides = slideRangeObject.Count",
    "description": "傳回 SlideRange 物件中包含的投影片數量。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\nDim sldRange As Object ' PowerPoint.SlideRange\n' Set pptPres = ActivePresentation\n' If pptPres.Slides.Count >= 3 Then\n'   Set sldRange = pptPres.Slides.Range(Array(1, 3)) ' Create a range of slide 1 and 3\n'   MsgBox \"選取的投影片範圍包含 \" & sldRange.Count & \" 張投影片。\"\n' Else\n'   MsgBox \"簡報投影片少於3張，無法建立範例範圍。\"\n' End If", "explanation": "如果簡報至少有3張投影片，則建立一個包含第1張和第3張投影片的 SlideRange，並顯示該範圍中的投影片數量。"}
    ],
    "keywords": ["powerpoint sliderange count", "count slides in range", "投影片範圍計數"]
},
{
    "name": "Slide.Layout (vs .CustomLayout)",
    "category": "PowerPoint 簡報製作",
    "description": "Slide.Layout 屬性設定或傳回投影片的標準版面配置 (PpSlideLayout 常數)。Slide.CustomLayout 屬性設定或傳回套用於投影片的自訂版面配置 (CustomLayout 物件，來自母片)。當您套用一個 CustomLayout 時，Layout 屬性通常會自動更新為對應的基礎標準版面配置 (例如，如果自訂版面基於「標題與內容」，則 Layout 可能變為 ppLayoutObject)。優先考慮使用 CustomLayout 來套用來自設計母片的特定版面，以保持一致性。",
    "parameters": [],
    "examples": [
        {"code": "Dim sld As Object ' PowerPoint.Slide\n' Set sld = ActivePresentation.Slides(1)\n' Debug.Print \"初始版面 (Layout): \" & sld.Layout\n' If Not sld.CustomLayout Is Nothing Then Debug.Print \"初始自訂版面: \" & sld.CustomLayout.Name\n'\n' ' Apply a standard layout\n' sld.Layout = ppLayoutTitleOnly ' 標題版面 (2)\n' Debug.Print \"套用ppLayoutTitleOnly後 - Layout: \" & sld.Layout & \", CustomLayout: \" & sld.CustomLayout.Name\n'\n' ' Apply a custom layout (assuming one named \"MyTwoContent\" exists in the master)\n' On Error Resume Next\n' Dim custLayout As Object ' PowerPoint.CustomLayout\n' Set custLayout = ActivePresentation.SlideMaster.CustomLayouts(\"MyTwoContent\")\n' If Not custLayout Is Nothing Then\n'   sld.CustomLayout = custLayout\n'   Debug.Print \"套用自訂版面 'MyTwoContent' 後 - Layout: \" & sld.Layout & \", CustomLayout: \" & sld.CustomLayout.Name\n' End If\n' On Error GoTo 0", "explanation": "演示 Slide.Layout 和 Slide.CustomLayout 屬性。設定其中一個通常會影響另一個。使用 CustomLayout 通常是為了套用母片中定義的特定版面配置。"}
    ],
    "keywords": ["powerpoint slide layout vs customlayout", "apply slide master layout", "標準版面與自訂版面"]
},
// FSO
{
    "name": "FileSystemObject.Drive.RootFolder Property (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "Set rootFldr = driveObject.RootFolder",
    "description": "傳回一個 Folder 物件，代表指定磁碟機的根資料夾。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, drvC As Object, rootOfC As Object ' Scripting.Folder\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet drvC = fso.GetDrive(\"C\")\nSet rootOfC = drvC.RootFolder\nMsgBox \"磁碟機 C: 的根資料夾路徑是: \" & rootOfC.Path & vbCrLf & _\n       \"根資料夾名稱: \" & rootOfC.Name ' 通常是 \"C:\\\" 或 \"C\"", "explanation": "獲取磁碟機 C: 的 Drive 物件，然後使用其 RootFolder 屬性獲取代表根目錄 (C:\\) 的 Folder 物件。"}
    ],
    "keywords": ["fso drive rootfolder", "get root directory", "磁碟機根目錄"]
},
// String
{
    "name": "StrReverse (Palindrome Check Example)",
    "category": "字串與文本操作",
    "description": "StrReverse 函數可以方便地用於檢查一個字串是否為回文 (即正讀和反讀都相同的字串，忽略大小寫和非字母數字字元)。",
    "syntax": "StrReverse(StringExpression)",
    "parameters": [],
    "examples": [
        {"code": "Function IsPalindrome(ByVal text As String) As Boolean\n  Dim cleanText As String, reversedText As String, char As String\n  Dim i As Long\n  ' Clean the text: remove non-alphanumeric, convert to same case\n  For i = 1 To Len(text)\n    char = Mid(text, i, 1)\n    If (char >= \"A\" And char <= \"Z\") Or (char >= \"a\" And char <= \"z\") Or (char >= \"0\" And char <= \"9\") Then\n      cleanText = cleanText & char\n    End If\n  Next i\n  cleanText = LCase(cleanText)\n  If Len(cleanText) = 0 Then IsPalindrome = True: Exit Function ' Empty string is often considered a palindrome\n  reversedText = StrReverse(cleanText)\n  IsPalindrome = (cleanText = reversedText)\nEnd Function\n\nSub TestPalindrome()\n  Debug.Print \"'Madam, I'm Adam' is palindrome: \" & IsPalindrome(\"Madam, I'm Adam\") ' True\n  Debug.Print \"'Race car' is palindrome: \" & IsPalindrome(\"Race car\")             ' True\n  Debug.Print \"'Hello' is palindrome: \" & IsPalindrome(\"Hello\")                 ' False\nEnd Sub", "explanation": "IsPalindrome 函數首先清理輸入字串，移除所有非字母數字字元並轉換為小寫。然後，它使用 StrReverse 反轉清理後的字串，並比較兩者是否相等以判斷是否為回文。"}
    ],
    "keywords": ["strreverse palindrome", "check palindrome vba", "string reverse example", "回文檢查"]
},
// Math
{
    "name": "WorksheetFunction.StDev_P (Excel - Population Standard Deviation)",
    "category": "數學、日期與時間",
    "syntax": "stdDevPValue = Application.WorksheetFunction.StDev_P(Arg1, [Arg2], ...)",
    "description": "使用 Excel 的 STDEV.P 工作表函數 (Excel 2010+，舊版為 STDEVP)，計算基於整個母體的標準差。",
    "parameters": [{"name": "Arg1, Arg2, ...", "description": "必需/可選。代表整個母體的數值、儲存格範圍或陣列。"}],
    "examples": [
        {"code": "Dim dataPopulation As Variant: dataPopulation = Array(10, 12, 15, 18, 20, 22)\nDim popStdDev As Double\npopStdDev = Application.WorksheetFunction.StDev_P(dataPopulation)\nMsgBox \"母體 {10,12,15,18,20,22} 的標準差 (STDEV.P) 是: \" & Format(popStdDev, \"0.0000\")", "explanation": "計算一個VBA陣列中所有數值作為整個母體的標準差。"}
    ],
    "keywords": ["stdev.p", "population standard deviation", "excel stdevp vba", "母體標準差"]
},
{
    "name": "WorksheetFunction.StDev_S (Excel - Sample Standard Deviation)",
    "category": "數學、日期與時間",
    "syntax": "stdDevSValue = Application.WorksheetFunction.StDev_S(Arg1, [Arg2], ...)",
    "description": "使用 Excel 的 STDEV.S 工作表函數 (Excel 2010+，舊版為 STDEV)，估計基於樣本的標準差。",
    "parameters": [{"name": "Arg1, Arg2, ...", "description": "必需/可選。代表樣本的數值、儲存格範圍或陣列。"}],
    "examples": [
        {"code": "Dim dataSample As Variant: dataSample = Array(65, 70, 75, 80, 85, 90)\nDim sampleStdDev As Double\nsampleStdDev = Application.WorksheetFunction.StDev_S(dataSample)\nMsgBox \"樣本 {65,70,75,80,85,90} 的標準差 (STDEV.S) 是: \" & Format(sampleStdDev, \"0.0000\")", "explanation": "計算一個VBA陣列中數值作為樣本的標準差。"}
    ],
    "keywords": ["stdev.s", "sample standard deviation", "excel stdev vba", "樣本標準差"]
},
// Data Types
{
    "name": "vbVariant Constant (VarType)",
    "category": "資料類型、轉換與驗證",
    "description": "vbVariant 是一個 VbVarType 列舉常數，其值為 12。VarType 函數在檢查未明確鍵入的 Variant 變數 (如果它未包含陣列或 Null) 時，或者如果它包含一個無法歸類為其他特定基本類型的值時，可能會傳回此值。如果 Variant 包含一個陣列，則 VarType 的傳回值是 `vbArray + vbVariant`。",
    "parameters": [],
    "examples": [
        {"code": "Dim myVar As Variant ' Initially vbEmpty\nDim myVarArray As Variant\nmyVar = CreateObject(\"Scripting.FileSystemObject\") ' Becomes vbObject\nDebug.Print \"FSO VarType: \" & VarType(myVar) & \" (vbObject is \" & vbObject & \")\"\nmyVar = Empty ' Reset to vbEmpty\nDebug.Print \"Empty VarType: \" & VarType(myVar) & \" (vbEmpty is \" & vbEmpty & \")\"\n\nmyVarArray = Array(1, \"A\") ' This creates a Variant array, containing Variants\nDebug.Print \"Variant Array VarType: \" & VarType(myVarArray) & \" (vbArray + vbVariant = \" & vbArray + vbVariant & \")\"\n\n' A Variant holding a simple value that IS NOT one of the other specific types might also be just vbVariant,\n' but usually VBA tries to coerce it to a more specific subtype if possible.\n' For example, myVar = \"Hello\" makes VarType(myVar) = vbString (8), not just vbVariant.\n' myVar = 10 makes VarType(myVar) = vbInteger (2).\nMsgBox \"vbVariant (\" & vbVariant & \") 通常表示變數是 Variant 類型，且其內容不是其他基本類型或物件，或者它是一個包含 Variant 元素的陣列。\"", "explanation": "演示不同情況下 Variant 變數的 VarType。直接的 `Dim x As Variant` 初始為 `vbEmpty`。如果它包含一個陣列，則其 VarType 是 `vbArray + vbVariant`。"}
    ],
    "keywords": ["vbvariant", "vartype variant", "variant data type code", "Variant類型代碼"]
},
// Program Flow
{
    "name": "DefType Statements (Precedence over VarType Implicit Default)",
    "category": "程式流程與結構控制",
    "description": "如果一個變數未使用 `As Type` 明確宣告，且模組中存在適用的 `DefType` 語句 (例如 `DefInt I-N`)，則該變數的類型由 `DefType` 決定。如果沒有適用的 `DefType` 且沒有 `Option Explicit`，則變數預設為 Variant。`Option Explicit` 會強制所有變數都必須明確使用 `Dim/Private/Public/Static` 宣告，如果此時 `As Type` 省略，`DefType` 才會生效。",
    "parameters": [],
    "examples": [
        {"code": "' --- Module Level ---\n' ' Option Explicit ' Comment out Option Explicit to see DefType's effect on undeclared vars\n' DefLng L ' Variables starting with L default to Long\n' DefStr S ' Variables starting with S default to String\n'\n' Sub TestDefTypePrecedence()\n'   Dim LoopCounter  ' If Option Explicit is OFF, this becomes Long due to DefLng L\n'   Dim StatusMessage ' If Option Explicit is OFF, this becomes String due to DefStr S\n'   Dim AnotherValue  ' If Option Explicit is OFF and no DefType for A, this is Variant\n'\n'   LoopCounter = 1234567890\n'   StatusMessage = \"Process Complete\"\n'   AnotherValue = Date\n'\n'   Debug.Print \"TypeName(LoopCounter): \" & TypeName(LoopCounter)\n'   Debug.Print \"TypeName(StatusMessage): \" & TypeName(StatusMessage)\n'   Debug.Print \"TypeName(AnotherValue): \" & TypeName(AnotherValue)\n' End Sub", "explanation": "如果註解掉 `Option Explicit`，則 `LoopCounter` 會因 `DefLng L` 而預設為 Long，`StatusMessage` 會因 `DefStr S` 而預設為 String，而 `AnotherValue` (假設沒有 `DefVar A` 或 `DefDate A`) 會預設為 Variant。如果 `Option Explicit` 存在，則所有這些未帶 `As Type` 的 `Dim` 都會導致編譯錯誤。"}
    ],
    "keywords": ["deftype precedence", "implicit typing rules", "variable type default", "DefType優先級"]
},
// External API
{
    "name": "WScript.Shell.Run (Capturing Output - Advanced)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "WScript.Shell 的 Run 方法本身不直接傳回被執行程式的標準輸出 (stdout) 或標準錯誤 (stderr) 到 VBA 變數中。要捕獲輸出，常見的方法是：\n1. 將程式的輸出重定向到一個暫存檔案 (例如 `cmd.exe /c MyCommand > C:\\Temp\\output.txt`)，然後 VBA 再讀取該檔案。\n2. 使用 WScript.Shell 的 Exec 方法，它會傳回一個 WshScriptExec 物件，該物件具有 StdOut 和 StdErr 屬性 (都是 TextStream 物件)，可以從中讀取輸出。Exec 方法通常更適合捕獲輸出。",
    "syntax": "Set execObj = wshShell.Exec(Command)\noutputString = execObj.StdOut.ReadAll()",
    "parameters": [],
    "examples": [
        {"code": "Sub CaptureOutputWithExec()\n    Dim wshShell As Object, oExec As Object\n    Dim commandToRun As String, stdOutput As String, stdError As String\n\n    Set wshShell = CreateObject(\"WScript.Shell\")\n    commandToRun = \"cmd.exe /c ping -n 1 google.com\" ' Example command\n\n    On Error Resume Next\n    Set oExec = wshShell.Exec(commandToRun)\n    If Err.Number <> 0 Then\n        MsgBox \"執行命令失敗: \" & Err.Description\n        Set wshShell = Nothing: Exit Sub\n    End If\n    On Error GoTo 0\n\n    ' Wait for the command to finish (optional, but often needed for output)\n    ' oExec.Status = 0 means running, 1 means finished.\n    Do While oExec.Status = 0\n        Application.Wait Now + TimeValue(\"00:00:00.1\") ' Brief pause\n        DoEvents\n    Loop\n\n    If Not oExec.StdOut.AtEndOfStream Then\n        stdOutput = oExec.StdOut.ReadAll()\n        Debug.Print \"--- 標準輸出 (StdOut) ---\"\n        Debug.Print stdOutput\n    Else\n        Debug.Print \"(StdOut 為空)\"\n    End If\n\n    If Not oExec.StdErr.AtEndOfStream Then\n        stdError = oExec.StdErr.ReadAll()\n        Debug.Print \"--- 標準錯誤 (StdErr) ---\"\n        Debug.Print stdError\n    Else\n        Debug.Print \"(StdErr 為空)\"\n    End If\n\n    MsgBox \"命令已執行。輸出 (如果有) 已列印到立即視窗。\"\n    Set oExec = Nothing: Set wshShell = Nothing\nEnd Sub", "explanation": "使用 WScript.Shell 的 Exec 方法執行 `ping google.com` 命令。然後，它會等待命令完成，並分別讀取其標準輸出 (StdOut) 和標準錯誤 (StdErr) 流的內容，將它們列印到立即視窗。"}
    ],
    "keywords": ["wscript.shell exec", "capture stdout vba", "capture stderr vba", "get command output", "捕獲命令輸出"]
},
{
    "name": "ADODB.Recordset (CursorType adForwardOnly Performance)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "當只需要從頭到尾單向遍歷 Recordset 一次時 (例如，填充列表框或將數據寫入工作表)，使用預設的 `adOpenForwardOnly` (0) 資料指標類型通常能提供最佳效能。因為它對資料提供者的資源要求最低，不需要為向後導航或看到其他使用者變更而維護額外的資料或鎖定。",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object, rs As Object\n' ' Assume conn is an open ADODB.Connection\n' Set rs = CreateObject(\"ADODB.Recordset\")\n' ' Open with forward-only, read-only cursor (fastest for sequential reading)\n' rs.Open \"SELECT ProductName, UnitPrice FROM Products\", conn, 0, 1 ' adOpenForwardOnly, adLockReadOnly\n'\n' If Not rs.EOF Then\n'   Debug.Print \"--- 使用 ForwardOnly 資料指標讀取產品 --- (高效)\"\n'   Do While Not rs.EOF\n'     Debug.Print rs!ProductName & \" - Price: \" & rs!UnitPrice\n'     ' With forward-only, cannot rs.MovePrevious or rs.MoveFirst (after first MoveNext)\n'     ' rs.RecordCount might be -1 until all records are fetched or EOF is hit.\n'     rs.MoveNext\n'   Loop\n' Else\n'   Debug.Print \"資料錄集為空。\"\n' End If\n'\n' If rs.State = 1 Then rs.Close\n' Set rs = Nothing\n' ' If conn.State = 1 Then conn.Close\n' ' Set conn = Nothing\nMsgBox \"(概念性) 演示了 ForwardOnly 資料指標的用法。需有實際資料庫。\"", "explanation": "演示如何使用 `adOpenForwardOnly` 和 `adLockReadOnly` 資料指標類型來開啟 Recordset，以實現高效的順向數據讀取。這種資料指標類型不支持向後移動或某些屬性 (如精確的 RecordCount 直到遍歷結束)。"}
    ],
    "keywords": ["adodb adopenforwardonly", "fast recordset reading", "forward-only cursor", "ado performance", "僅向前資料指標效能"]
},
// --- Excel 核心操作 ---
{
    "name": "ShapeRange.ZOrder (Excel/PowerPoint)",
    "category": "Excel 核心操作",
    "syntax": "shapeRangeObject.ZOrder(ZOrderCmd As MsoZOrderCmd)",
    "description": "變更指定圖案範圍 (ShapeRange) 中圖案的 Z 順序，即它們在堆疊順序中的前後位置。",
    "parameters": [{"name": "ZOrderCmd", "description": "必需。MsoZOrderCmd 常數，例如 msoBringToFront (移到最上層), msoSendToBack (移到最下層), msoBringForward (上移一層), msoSendBackward (下移一層)。"}],
    "examples": [
        {"code": "' In Excel (assuming shpA and shpB are Shape objects, shpA is currently behind shpB)\n' Dim shpA As Shape, shpB As Shape\n' ' Set shpA = ActiveSheet.Shapes(\"ShapeA\")\n' ' Set shpB = ActiveSheet.Shapes(\"ShapeB\")\n'\n' ' Create a ShapeRange containing shpA\n' Dim srA As ShapeRange: Set srA = ActiveSheet.Shapes.Range(Array(shpA.Name))\n' srA.ZOrder msoBringToFront\n' MsgBox \"圖案 'ShapeA' 已被移到堆疊的最上層。\"\n'\n' ' To send shpB backward one level:\n' ' Dim srB As ShapeRange: Set srB = ActiveSheet.Shapes.Range(Array(shpB.Name))\n' ' srB.ZOrder msoSendBackward", "explanation": "假設有名為 \"ShapeA\" 的圖案，此程式碼將其移到工作表上所有其他圖案的最上層。同時概念性地展示了如何將圖案下移一層。此方法也適用於 PowerPoint。"}
    ],
    "keywords": ["shape zorder", "bring to front excel", "send to back powerpoint", "object stacking order", "圖案Z順序", "移至上層/下層", "通用"]
},
{
    "name": "Range.ClearComments (vs .Comment.Delete - Excel Legacy)",
    "category": "Excel 核心操作",
    "description": "`Range.ClearComments` 移除範圍內所有儲存格的舊版註解 (Notes)。如果儲存格有註解，`Range.Comment` 傳回 Comment 物件，其 `.Delete` 方法可以刪除該特定註解。對於新式執行緒註解 (CommentThreaded)，需要使用不同的方法 (`Range.CommentThreaded.Delete` 或遍歷Replies並刪除)。",
    "syntax": "rangeObject.ClearComments ' Clears all legacy comments in range\nrangeObject.Cells(1,1).Comment.Delete ' Deletes legacy comment from specific cell",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").AddComment \"這是舊版註解1。\"\nRange(\"B1\").AddComment \"這是舊版註解2。\"\nRange(\"A1:C5\").ClearComments\nMsgBox \"A1:C5範圍內所有舊版註解已被清除。\"\n\nRange(\"D1\").AddComment \"另一個註解。\"\nIf Not Range(\"D1\").Comment Is Nothing Then\n  Range(\"D1\").Comment.Delete\n  MsgBox \"D1儲存格的註解已透過 .Comment.Delete 刪除。\"\nEnd If", "explanation": "演示如何使用 `ClearComments` 清除一個範圍內所有舊版註解，以及如何使用 `Comment.Delete` 刪除特定儲存格的舊版註解。"}
    ],
    "keywords": ["clearcomments vs comment.delete", "delete legacy comment", "remove cell note", "清除舊註解"]
},
// Word
{
    "name": "Range.Paragraphs(Index).Style (Word)",
    "category": "Word 文件處理",
    "syntax": "rangeObject.Paragraphs(Index).Style = styleNameOrObject",
    "description": "設定或傳回範圍中指定索引的段落的樣式。",
    "parameters": [
        {"name": "Index", "description": "必需。段落在範圍內 Paragraphs 集合中的索引 (1-based)。"},
        {"name": "styleNameOrObject", "description": "樣式的名稱 (字串) 或 Style 物件。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range ' Assume user selected multiple paragraphs\n' If selRange.Paragraphs.Count > 0 Then\n'   selRange.Paragraphs(1).Style = \"標題 2\" ' Apply Heading 2 to the first paragraph in selection\n'   MsgBox \"選取範圍中的第一個段落已套用 '標題 2' 樣式。\"\n' End If", "explanation": "如果使用者選取了文字，則將選取範圍中第一個段落的樣式設定為 \"標題 2\"。"}
    ],
    "keywords": ["word range paragraph style", "set style for specific paragraph", "範圍內段落樣式"]
},
{
    "name": "Document.Fields.Update (Word)",
    "category": "Word 文件處理",
    "syntax": "longUpdatedCount = documentObject.Fields.Update",
    "description": "更新文件中 Fields 集合中的所有功能變數。傳回已更新的功能變數數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim updatedCount As Long\n' Set wdDoc = ActiveDocument\n' If wdDoc.Fields.Count > 0 Then\n'   updatedCount = wdDoc.Fields.Update\n'   MsgBox updatedCount & \" 個功能變數已在文件中更新。\"\n' Else\n'   MsgBox \"文件中沒有功能變數可更新。\"\n' End If", "explanation": "更新活動文件中的所有功能變數 (例如，目錄頁碼、日期功能變數等)，並顯示已更新的功能變數數量。"}
    ],
    "keywords": ["word update all fields", "refresh fields word", "fields.update", "更新所有功能變數"]
},
// Outlook
{
    "name": "MailItem.ClearTaskFlag (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.ClearTaskFlag",
    "description": "清除 MailItem 的任務標記。如果郵件之前被標記為任務 (例如，使用 MarkAsTask)，此方法會移除該標記。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   If olMail.IsMarkedAsTask Then\n'     olMail.ClearTaskFlag\n'     olMail.Save\n'     MsgBox \"郵件 '\" & olMail.Subject & \"' 的任務標記已被清除。\"\n'   Else\n'     MsgBox \"郵件 '\" & olMail.Subject & \"' 沒有任務標記可清除。\"\n'   End If\n' End If", "explanation": "如果選取的郵件已被標記為任務，則清除其任務標記並儲存變更。"}
    ],
    "keywords": ["outlook cleartaskflag", "remove task flag", "unflag email", "清除任務標記"]
},
{
    "name": "ContactItem.FileAs Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "contactItemObject.FileAs [= String]",
    "description": "設定或傳回一個字串，表示連絡人在「檔案存檔方式」欄位中的預設顯示方式 (例如，\"Doe, John\" 或 \"Contoso Ltd (John Doe)\")。Outlook 通常會根據其他欄位自動設定此值，但也可以手動覆寫。",
    "parameters": [{"name": "String", "description": "檔案存檔方式的字串。"}],
    "examples": [
        {"code": "Dim olContact As Object ' Outlook.ContactItem\n' Set olContact = Application.CreateItem(olContactItem)\n' olContact.FirstName = \"Peter\"\n' olContact.LastName = \"Pan\"\n' olContact.CompanyName = \"Neverland Inc.\"\n' ' Outlook will automatically generate a FileAs, e.g., \"Pan, Peter\" or \"Neverland Inc. (Peter Pan)\"\n' Debug.Print \"預設 FileAs: \" & olContact.FileAs\n' olContact.FileAs = \"Pan, Peter (Neverland)\" ' Custom FileAs\n' olContact.Display\n' MsgBox \"連絡人 'Peter Pan' 的 FileAs 屬性已設定。\"", "explanation": "建立一個新連絡人，Outlook 會自動生成其 FileAs 屬性。然後，程式碼將其覆寫為一個自訂的 FileAs 字串。"}
    ],
    "keywords": ["outlook contact fileas", "set contact display name", "連絡人檔案存檔方式"]
},
// PowerPoint
{
    "name": "Slide.SlideShowTransition.Hidden Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideObject.SlideShowTransition.Hidden = MsoTriStateConstant",
    "description": "如果指定的投影片在投影片放映期間被隱藏，則為 True (msoTrue)。讀取/寫入 MsoTriState。",
    "parameters": [{"name": "MsoTriStateConstant", "description": "msoTrue (隱藏), msoFalse (可見)。"}],
    "examples": [
        {"code": "Dim pptSlide As Object\n' Set pptSlide = ActivePresentation.Slides(2) ' Second slide\n' pptSlide.SlideShowTransition.Hidden = msoTrue\n' MsgBox \"第二張投影片已設定為在放映時隱藏。\"", "explanation": "將簡報中的第二張投影片設定為在投影片放映時隱藏。"}
    ],
    "keywords": ["powerpoint hide slide in slideshow", "slideshowtransition hidden", "隱藏投影片放映"]
},
{
    "name": "ShapeRange.Rotation Property (PowerPoint/Excel)",
    "category": "PowerPoint 簡報製作",
    "syntax": "shapeRangeObject.Rotation [= AngleInDegrees]",
    "description": "設定或傳回指定圖案範圍相對於其預設方向的旋轉角度 (以度為單位)。正值表示順時針旋轉。",
    "parameters": [{"name": "AngleInDegrees", "description": "旋轉角度 (Single)。"}],
    "examples": [
        {"code": "Dim shp As Object ' PowerPoint.Shape or Excel.Shape\n' ' In PowerPoint:\n' ' Set shp = ActivePresentation.Slides(1).Shapes(1) ' First shape on first slide\n' ' In Excel:\n' ' Set shp = ActiveSheet.Shapes(1)\n' If Not shp Is Nothing Then\n'   shp.Rotation = 45 ' Rotate 45 degrees clockwise\n'   MsgBox \"圖案 '\" & shp.Name & \"' 已旋轉45度。\"\n' End If", "explanation": "將指定圖案 (Excel或PowerPoint中) 順時針旋轉45度。"}
    ],
    "keywords": ["shape rotation", "rotate object vba", "圖案旋轉", "通用"]
},
// FSO
{
    "name": "TextStream.Close (Importance)",
    "category": "檔案與資料夾管理",
    "description": "使用 FileSystemObject 的 TextStream 物件 (透過 CreateTextFile 或 OpenTextFile 取得) 後，務必呼叫其 Close 方法。對於寫入操作，Close 會確保所有緩衝的數據都寫入到磁碟檔案。對於讀取操作，它會釋放檔案控制代碼。忘記關閉檔案流可能導致數據遺失、檔案鎖定或其他非預期行為。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, ts As Object, filePath As String\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nfilePath = fso.GetSpecialFolder(2).Path & \"\\FSO_Close_Demo.txt\"\n\n' Writing to file\nSet ts = fso.CreateTextFile(filePath, True) ' True to overwrite\nts.WriteLine \"第一行，測試關閉。\"\nts.Write \"第二行的一部分，\"\nts.Write \"第二行的剩餘部分。\"\n' If .Close is not called here, data might not be fully written or file might be locked.\nts.Close ' Crucial for flushing buffer and releasing file\nDebug.Print \"檔案已寫入並關閉。\"\n\n' Reading from file\nSet ts = fso.OpenTextFile(filePath, 1) ' ForReading\nDim content As String\ncontent = ts.ReadAll\nDebug.Print \"檔案內容: \" & content\nts.Close ' Crucial for releasing file handle\nDebug.Print \"檔案已讀取並關閉。\"\n\n' fso.DeleteFile filePath ' Clean up test file\nSet fso = Nothing: Set ts = Nothing", "explanation": "演示在對文字檔案進行寫入和讀取操作後，呼叫 TextStream 物件的 Close 方法的重要性。"}
    ],
    "keywords": ["textstream.close", "fso close file", "release file handle", "flush textstream buffer", "關閉檔案流"]
},
// String
{
    "name": "Like Operator (Pattern List with Hyphen)",
    "category": "字串與文本操作",
    "description": "在 Like 運算子的字元列表 `[charlist]` 中，連字號 (-) 可以用來指定一個字元範圍 (例如 `[A-Z]`, `[0-5]`)。如果要在字元列表中匹配實際的連字號字元，則應將其放在列表的開頭或結尾，或者在不是用於表示範圍的上下文中 (例如 `[+--]` 匹配加號或減號)。",
    "parameters": [],
    "examples": [
        {"code": "Debug.Print \"Part-A\" Like \"Part-[A-Z]\"  ' True (matches Part- followed by an uppercase letter)\nDebug.Print \"Item-3\" Like \"Item#[!0-9]\"   ' False (Item followed by digit, then NOT a digit. Here, '-' is not a digit)\n' Better to be explicit for hyphen:\nDebug.Print \"Item-3\" Like \"Item#[-_0-9]\"  ' True (matches Item, digit, then hyphen or underscore or digit)\nDebug.Print \"Value-\" Like \"Value[-]\"    ' True (matches Value followed by hyphen)\nDebug.Print \"ABC\" Like \"[A-Z-0-9]\" ' This is ambiguous, usually means A to Z, OR hyphen, OR 0 to 9.\n                                 ' Better: \"[A-Z0-9-]\" or \"[-A-Z0-9]\"", "explanation": "演示如何在 Like 運算子的字元列表中使用連字號。當用於表示範圍時 (如 `A-Z`)，它有特殊含義。若要匹配字面上的連字號，最好將其放在列表的開頭或結尾，或確保其上下文不會被解釋為範圍的一部分。"}
    ],
    "keywords": ["like operator hyphen", "pattern matching range", "match literal hyphen", "連字號匹配"]
},
// Excel 核心操作
{
    "name": "Range.Validation.InputTitle / .ErrorTitle (Get/Set)",
    "category": "Excel 核心操作",
    "description": "Validation 物件的 InputTitle 屬性設定或傳回資料驗證輸入訊息的標題。ErrorTitle 屬性設定或傳回資料驗證錯誤訊息的標題。這些標題會顯示在相應的提示框頂部。",
    "syntax": "rangeObject.Validation.InputTitle = \"My Input Prompt Title\"\nrangeObject.Validation.ErrorTitle = \"Data Entry Error\"",
    "parameters": [],
    "examples": [
        {"code": "With Range(\"A1\").Validation\n  .Delete\n  .Add Type:=xlValidateInputOnly ' Just an input message, no validation rule\n  .InputTitle = \"輸入指南\"\n  .InputMessage = \"請在此儲存格輸入客戶的完整法定名稱。\"\n  .ErrorTitle = \"發生錯誤\" ' This won't show unless a validation rule is also added and fails\n  .ErrorMessage = \"請檢查您的輸入。\"\n  .ShowInput = True\n  .ShowError = True\nEnd With\nRange(\"A1\").Select ' Select cell to show input prompt\nMsgBox \"已為A1設定輸入提示標題和訊息。\"", "explanation": "為儲存格A1設定一個僅顯示輸入訊息的「資料驗證」(透過xlValidateInputOnly)，並自訂其輸入訊息的標題和內容。錯誤標題和訊息在此例中不會因輸入而觸發，因為沒有實際的驗證規則。"}
    ],
    "keywords": ["validation inputtitle", "validation errortitle", "data validation prompt title", "資料驗證提示標題"]
},
{
    "name": "Worksheet.Shapes.AddFormControl (Excel Form Controls)",
    "category": "Excel 核心操作",
    "syntax": "Set shpCtrl = worksheetObject.Shapes.AddFormControl(Type As XlFormControl, Left As Single, Top As Single, Width As Single, Height As Single)",
    "description": "在工作表上新增一個表單控制項 (例如，按鈕、核取方塊、選項按鈕、下拉式方塊)。傳回代表該控制項的 Shape 物件。",
    "parameters": [
        {"name": "Type", "description": "必需。XlFormControl 常數，指定要新增的表單控制項類型 (例如 xlButtonControl, xlCheckBox, xlDropDown)。"},
        {"name": "Left, Top, Width, Height", "description": "必需。控制項的位置和大小。"}
    ],
    "examples": [
        {"code": "Dim btn As Shape, chkBox As Shape\nSet btn = ActiveSheet.Shapes.AddFormControl(xlButtonControl, 50, 50, 100, 25)\nbtn.TextFrame.Characters.Text = \"執行巨集\"\nbtn.OnAction = \"MyButtonMacro\" ' Assign a macro to the button\n\nSet chkBox = ActiveSheet.Shapes.AddFormControl(xlCheckBox, 50, 80, 100, 20)\nchkBox.TextFrame.Characters.Text = \"啟用選項\"\n' To link checkbox to a cell: chkBox.ControlFormat.LinkedCell = \"C1\"\nMsgBox \"已在工作表上新增一個按鈕和一個核取方塊表單控制項。\"", "explanation": "在活動工作表上新增一個表單控制項按鈕，設定其顯示文字並指派一個宏。同時新增一個核取方塊。"}
    ],
    "keywords": ["addformcontrol", "excel form controls", "button control vba", "checkbox vba", "新增表單控制項"]
},
{
    "name": "ControlFormat Properties (Excel Form Controls)",
    "category": "Excel 核心操作",
    "description": "透過 Shape 物件的 ControlFormat 屬性，可以存取和修改表單控制項的特定屬性。",
    "syntax": "shapeObject.ControlFormat.LinkedCell = \"A1\"\nshapeObject.ControlFormat.Value = xlOn ' For CheckBox/OptionButton\nshapeObject.ControlFormat.ListFillRange = \"Sheet2!B1:B10\" ' For ListBox/DropDown",
    "parameters": [
        {"name": ".LinkedCell", "description": "將控制項的值連結到指定的儲存格。"},
        {"name": ".Value", "description": "控制項的目前值 (例如，xlOn, xlOff, xlMixed for CheckBox/OptionButton; 數值 for ScrollBar/Spinner)。"},
        {"name": ".ListFillRange", "description": "設定清單方塊或下拉式方塊的項目來源範圍。"},
        {"name": ".AddItem / .RemoveItem / .Clear (ListBox/DropDown)", "description": "動態管理清單項目。"},
        {"name": ".Min / .Max / .SmallChange / .LargeChange (ScrollBar/Spinner)", "description": "設定捲軸或微調按鈕的範圍和步進值。"}
    ],
    "examples": [
        {"code": "Dim dd As Shape ' DropDown form control\nSet dd = ActiveSheet.Shapes.AddFormControl(xlDropDown, 150, 50, 120, 20)\ndd.Name = \"myProductDropDown\"\nWith dd.ControlFormat\n  .AddItem \"產品A\"\n  .AddItem \"產品B\"\n  .AddItem \"產品C\"\n  .ListIndex = 1 ' Select first item\n  .LinkedCell = \"$D$1\" ' Link selected index to D1\n  .DropDownLines = 3 ' Number of lines to show in dropdown\nEnd With\nMsgBox \"已新增下拉式方塊並設定其項目和連結儲存格。D1將顯示選取項目的索引。\"", "explanation": "新增一個下拉式方塊表單控制項，為其新增三個項目，預選第一個，並將其選取的索引連結到D1儲存格。"}
    ],
    "keywords": ["controlformat properties", "excel form control linkedcell", "listfillrange", "表單控制項屬性"]
},
// Word
{
    "name": "Range.Select (Word - To Select Specific Range)",
    "category": "Word 文件處理",
    "description": "Range 物件的 Select 方法用於選取該 Range 物件所代表的文件部分。選取後，Application.Selection 會指向此範圍。",
    "syntax": "wordRangeObject.Select",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object, targetRange As Object ' Word.Range\n' Set wdDoc = ActiveDocument\n' ' Select the second paragraph\n' If wdDoc.Paragraphs.Count >= 2 Then\n'   Set targetRange = wdDoc.Paragraphs(2).Range\n'   targetRange.Select\n'   MsgBox \"文件的第二個段落已被選取。\"\n'   ' Selection.Font.Bold = True ' Now you can operate on Selection\n' End If", "explanation": "如果文件至少有兩個段落，則獲取第二個段落的 Range 物件，然後使用 Select 方法將其選取。"}
    ],
    "keywords": ["word range select", "select specific range word", "選取Word範圍"]
},
{
    "name": "Tables.Item(Index).ConvertToText (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Tables.Item(Index).ConvertToText([Separator], [NestedTables])",
    "description": "將文件中指定索引的表格轉換為文字。與 Table.ConvertToText 類似，但透過 Tables 集合的 Item 方法存取表格。",
    "parameters": [{"name": "Index", "description": "表格在 Tables 集合中的索引 (1-based)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' If wdDoc.Tables.Count > 0 Then\n'   wdDoc.Tables.Item(1).ConvertToText Separator:=wdSeparateByTabs\n'   MsgBox \"第一個表格已轉換為以Tab分隔的文字。\"\n' Else\n'   MsgBox \"文件中沒有表格可轉換。\"\n' End If", "explanation": "將活動文件中的第一個表格轉換為以Tab字元分隔的文字。"}
    ],
    "keywords": ["word tables item converttotext", "convert specific table to text", "依索引轉換表格為文字"]
},
// Outlook
{
    "name": "MailItem.Display (Modal Argument)",
    "category": "Outlook 郵件與項目管理",
    "description": "MailItem.Display([Modal]) 方法可以接受一個可選的 Modal 引數。如果 Modal 設為 True，則郵件視窗會以強制回應模式顯示，VBA 程式碼會暫停執行，直到該視窗被關閉。預設為 False (非強制回應)。",
    "parameters": [{"name": "Modal As Boolean", "description": "True 表示強制回應顯示。"}],
    "examples": [
        {"code": "Dim olMail As Object\nSet olMail = CreateObject(\"Outlook.Application\").CreateItem(0)\nolMail.Subject = \"請檢查此郵件 (強制回應)\"\nolMail.Body = \"您必須先關閉此郵件視窗，VBA才能繼續。\"\nMsgBox \"即將以強制回應模式顯示郵件...\"\nolMail.Display Modal:=True ' Code execution pauses here until mail window is closed\nMsgBox \"郵件視窗已關閉，VBA繼續執行。\"", "explanation": "建立一封新郵件，並以強制回應模式顯示它。VBA 會暫停，直到使用者關閉該郵件視窗。"}
    ],
    "keywords": ["outlook mailitem display modal", "modal email window", "強制回應郵件視窗"]
},
{
    "name": "NameSpace.Stores.Count (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "numberOfStores = olNamespace.Stores.Count",
    "description": "傳回目前 Outlook 設定檔中配置的郵件儲存區 (例如，郵箱、PST檔案) 的數量。",
    "parameters": [],
    "examples": [
        {"code": "Dim olNS As Object\nSet olNS = CreateObject(\"Outlook.Application\").GetNamespace(\"MAPI\")\nMsgBox \"此Outlook設定檔中共有 \" & olNS.Stores.Count & \" 個郵件儲存區。\"", "explanation": "顯示目前 Outlook 設定檔中配置的郵件儲存區總數。"}
    ],
    "keywords": ["outlook stores count", "number of mail stores", "郵件儲存區數量"]
},
// PowerPoint
{
    "name": "Slide.Duplicate (Return Value is SlideRange)",
    "category": "PowerPoint 簡報製作",
    "description": "Slide.Duplicate 方法會建立一個或多個指定投影片的副本，並將這些副本作為一個 SlideRange 物件傳回。即使只複製一張投影片，傳回的也是一個包含該單張投影片的 SlideRange。要存取複製後的單張投影片物件，可以使用 `SlideRange.Item(1)` 或 `SlideRange(1)`。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\nDim originalSlide As Object ' PowerPoint.Slide\nDim duplicatedSlideRange As Object ' PowerPoint.SlideRange\nDim newSingleSlide As Object ' PowerPoint.Slide\n' Set pptPres = ActivePresentation\n' If pptPres.Slides.Count > 0 Then\n'   Set originalSlide = pptPres.Slides(1)\n'   Set duplicatedSlideRange = originalSlide.Duplicate()\n'   If duplicatedSlideRange.Count = 1 Then\n'     Set newSingleSlide = duplicatedSlideRange(1) ' Access the single duplicated slide\n'     newSingleSlide.Shapes.Title.TextFrame.TextRange.Text = \"複製的投影片 - \" & Now\n'     MsgBox \"第一張投影片已複製，副本名稱是 '\" & newSingleSlide.Name & \"'，索引為 \" & newSingleSlide.SlideIndex\n'   End If\n' End If", "explanation": "複製簡報中的第一張投影片。Duplicate 方法傳回一個 SlideRange。透過 `duplicatedSlideRange(1)` 可以獲取到實際複製出來的那張投影片物件，然後修改其標題。"}
    ],
    "keywords": ["powerpoint slide.duplicate sliderange", "access duplicated slide", "複製投影片傳回範圍"]
},
{
    "name": "Shapes.Range(Index).Delete (PowerPoint/Excel)",
    "category": "PowerPoint 簡報製作",
    "syntax": "shapesCollectionOrSlide.Shapes.Range(Index).Delete",
    "description": "選取 Shapes 集合中的一個或一組圖案 (透過 Shapes.Range)，然後使用 Delete 方法將其刪除。",
    "parameters": [{"name": "Index", "description": "要刪除的圖案的名稱或索引號，或包含名稱/索引的陣列。"}],
    "examples": [
        {"code": "' In PowerPoint\n' Dim pptSlide As Object, shpToDelete As Object\n' Set pptSlide = ActivePresentation.Slides(1)\n' ' Add a shape to delete\n' Set shpToDelete = pptSlide.Shapes.AddShape(msoShapeSmileyFace, 10, 10, 50, 50)\n' shpToDelete.Name = \"HappyFace\"\n' Application.Wait Now + TimeValue(\"00:00:01\") ' Pause to see it\n' pptSlide.Shapes.Range(\"HappyFace\").Delete\n' MsgBox \"名為 'HappyFace' 的圖案已被刪除。\"\n'\n' ' In Excel (similar logic for ActiveSheet.Shapes.Range)\n' ' ActiveSheet.Shapes.Range(\"Rectangle 1\").Delete", "explanation": "在 PowerPoint 的第一張投影片上新增一個笑臉圖案，將其命名為 \"HappyFace\"，然後使用 Shapes.Range(\"HappyFace\").Delete 將其刪除。Excel 中的操作類似。"}
    ],
    "keywords": ["shapes.range.delete", "delete shape by name", "remove specific shape", "刪除指定圖案", "通用"]
},
// FSO
{
    "name": "FileSystemObject.GetDrive (Drive Object Properties)",
    "category": "檔案與資料夾管理",
    "description": "fso.GetDrive(DriveSpec) 傳回一個 Drive 物件。Drive 物件具有多個唯讀屬性，提供有關磁碟機的詳細資訊，例如：\n.DriveLetter, .DriveType, .VolumeName, .TotalSize, .FreeSpace, .AvailableSpace, .FileSystem, .SerialNumber, .IsReady, .Path, .RootFolder。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, drv As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nOn Error Resume Next\nSet drv = fso.GetDrive(\"C\") ' Get drive C:\nIf Err.Number = 0 And Not drv Is Nothing Then\n  Debug.Print \"--- 磁碟機 C: 資訊 ---\"\n  Debug.Print \"  代號: \" & drv.DriveLetter\n  Debug.Print \"  類型 (1=Removable, 2=Fixed, 3=Network, 4=CDROM, 5=RAMDisk): \" & drv.DriveType\n  Debug.Print \"  磁碟區名稱: \" & drv.VolumeName\n  Debug.Print \"  總大小 (GB): \" & Format(drv.TotalSize / (1024^3), \"0.00\")\n  Debug.Print \"  可用空間 (GB): \" & Format(drv.FreeSpace / (1024^3), \"0.00\")\n  Debug.Print \"  檔案系統: \" & drv.FileSystem\n  Debug.Print \"  序號: \" & drv.SerialNumber\n  Debug.Print \"  是否就緒: \" & drv.IsReady\nElse\n  Debug.Print \"無法獲取磁碟機 C: 的資訊。錯誤: \" & Err.Description\nEnd If\nOn Error GoTo 0\nSet fso = Nothing: Set drv = Nothing", "explanation": "獲取磁碟機 C: 的 Drive 物件，然後列印其多個屬性，包括磁碟機代號、類型、磁碟區名稱、總大小、可用空間、檔案系統、序號和就緒狀態。"}
    ],
    "keywords": ["fso drive object properties", "get disk info fso", "driveletter", "volumename", "totalsize", "freespace", "磁碟機物件屬性"]
},
// String
{
    "name": "InStrRev (Start Argument Behavior)",
    "category": "字串與文本操作",
    "description": "InStrRev 函數的 Start 引數指定從字串尾部開始反向搜尋的起始位置。如果 Start 被省略或設為 -1 (預設)，則從字串的最後一個字元開始搜尋。如果 Start 是正數，則從字串的第 Start 個字元位置向字串開頭反向搜尋。",
    "syntax": "InStrRev(StringCheck, StringMatch, [Start As Long = -1], [Compare])",
    "parameters": [],
    "examples": [
        {"code": "Dim text As String: text = \"one_two_three_two_four\"\n' Default start (-1): search from end\nDebug.Print \"InStrRev(text, \"\"two\"\"): \" & InStrRev(text, \"two\") ' Output: 15 (finds the second \"two\")\n\n' Start from character 10 (just before the first \"two\") and search backwards\nDebug.Print \"InStrRev(text, \"\"two\"\", 10): \" & InStrRev(text, \"two\", 10) ' Output: 5 (finds the first \"two\")\n\n' Start from character 4 (at the end of \"one_\") and search backwards\nDebug.Print \"InStrRev(text, \"\"one\"\", 4): \" & InStrRev(text, \"one\", 4) ' Output: 1\n\n' Start beyond string length (acts like -1, from end)\nDebug.Print \"InStrRev(text, \"\"two\"\", 100): \" & InStrRev(text, \"two\", 100) ' Output: 15", "explanation": "演示 InStrRev 的 Start 引數如何影響搜尋的起始點。省略 Start 或設為 -1 從字串末尾開始。提供正數 Start 則從該位置向字串開頭搜尋。"}
    ],
    "keywords": ["instrrev start argument", "reverse search from position", "InStrRev起始位置"]
},
// Math
{
    "name": "WorksheetFunction.Rank_Avg (Excel)",
    "category": "數學、日期與時間",
    "syntax": "rankValue = Application.WorksheetFunction.Rank_Avg(Number, Ref As Range, [Order As Long = 0])",
    "description": "使用 Excel 的 RANK.AVG 工作表函數 (Excel 2010 及更新版本)，傳回一個數字在一組數字中的排名。如果多個值具有相同的排名，則傳回這些值的平均排名。",
    "parameters": [
        {"name": "Number", "description": "必需。要找出其排名的數字。"},
        {"name": "Ref", "description": "必需。包含數字列表的儲存格範圍或陣列。"},
        {"name": "Order", "description": "可選。0 (預設) 或非零值。0 表示降冪排名，非零值表示升冪排名。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A5\").Value = Application.Transpose(Array(100, 85, 95, 100, 70))\nDim rankOfA1_Avg As Double, rankOfA4_Avg As Double\n' Rank of A1 (value 100) within A1:A5, descending. Two 100s at rank 1 and 2. Avg rank = (1+2)/2 = 1.5\nrankOfA1_Avg = Application.WorksheetFunction.Rank_Avg(Range(\"A1\").Value, Range(\"A1:A5\"), 0)\nrankOfA4_Avg = Application.WorksheetFunction.Rank_Avg(Range(\"A4\").Value, Range(\"A1:A5\"), 0)\nMsgBox \"儲存格A1 (100) 的平均排名是: \" & rankOfA1_Avg & vbCrLf & _\n       \"儲存格A4 (100) 的平均排名是: \" & rankOfA4_Avg ' Both should be 1.5", "explanation": "演示如何使用 RANK.AVG 函數。對於數據 {100, 85, 95, 100, 70}，兩個100並列第一和第二，因此它們的平均排名都是1.5。"}
    ],
    "keywords": ["rank.avg", "excel rank average", "average rank", "平均排名"]
},
// Data Types
{
    "name": "vbDataObject (VarType - More Context)",
    "category": "資料類型、轉換與驗證",
    "description": "VarType 傳回 vbDataObject (13) 通常指的是「非 OLE 自動化物件」。在 VBA 中，大多數透過 `CreateObject` 或 `New` 關鍵字建立的物件 (如 Excel.Application, Scripting.Dictionary, MSForms.TextBox, 自訂類別實例) 都會被識別為 `vbObject` (9)。vbDataObject 類型更為罕見，可能出現在與特定 API 互動或處理某些非標準的資料結構時，或者在 Visual Basic (非 VBA) 的某些上下文中。對於 Office VBA 開發者而言，vbObject 是更常遇到的物件類型代碼。",
    "parameters": [],
    "examples": [
        {"code": "Dim dataObj As Object\n' Trying to find a common VBA object that returns vbDataObject is difficult.\n' Most COM objects will return vbObject (9).\n' For example, MSForms.DataObject which handles clipboard data, still returns vbObject.\nOn Error Resume Next\nSet dataObj = CreateObject(\"Forms.DataObject.1\")\nIf Err.Number = 0 And Not dataObj Is Nothing Then\n    Debug.Print \"VarType(Forms.DataObject.1) = \" & VarType(dataObj) ' Typically 9 (vbObject)\nElse\n    Debug.Print \"Could not create Forms.DataObject.1\"\nEnd If\nOn Error GoTo 0\nDebug.Print \"vbDataObject constant value: \" & vbDataObject & \". Encountering this VarType is rare in typical Office VBA.\"", "explanation": "再次說明 vbDataObject (13) 在典型 Office VBA 開發中不常見。大多數 VBA 可存取的物件，即使是像 Forms.DataObject 這樣的物件，其 VarType 通常是 vbObject (9)。"}
    ],
    "keywords": ["vbdataobject usage", "vartype non-ole", "data object type", "vbDataObject用途"]
},
// Program Flow
{
    "name": "Declare Statement (Alias for Overloaded Functions - Conceptual)",
    "category": "程式流程與結構控制",
    "description": "如果一個 DLL 函數被重載 (Overloaded)，即 DLL 中存在多個同名但參數列表不同的函數，VBA 的 Declare 語句不能直接處理這種重載。您需要為每個重載版本使用不同的 Alias 名稱來宣告它們，或者如果 DLL 匯出了帶有修飾名稱 (name mangling) 的版本，則 Alias 指向那個特定的修飾名稱。例如，`MyFunc` 可能有 `MyFuncA` (ANSI) 和 `MyFuncW` (Unicode) 版本，或 `MyFunc_int` 和 `MyFunc_string` 版本。",
    "parameters": [],
    "examples": [
        {"code": "' Conceptual: Assume MyDLL.dll has two functions:\n'   int ProcessData_Integer(int val);\n'   int ProcessData_String(char* val);\n' And they are exported with mangled names or distinct names.\n\n' #If VBA7 Then\n'   ' Alias for the integer version\n'   Private Declare PtrSafe Function ProcessInt Lib \"MyDLL.dll\" Alias \"ProcessData_Integer\" (ByVal inputInt As Long) As Long\n'   ' Alias for the string version\n'   Private Declare PtrSafe Function ProcessStr Lib \"MyDLL.dll\" Alias \"ProcessData_String\" (ByVal inputStr As String) As Long\n' #Else\n'   Private Declare Function ProcessInt Lib \"MyDLL.dll\" Alias \"ProcessData_Integer\" (ByVal inputInt As Long) As Long\n'   Private Declare Function ProcessStr Lib \"MyDLL.dll\" Alias \"ProcessData_String\" (ByVal inputStr As String) As Long\n' #End If\n'\n' Sub TestOverloadAlias()\n'   Dim resultInt As Long, resultStr As Long\n'   On Error Resume Next ' If MyDLL.dll is not available\n'   resultInt = ProcessInt(123)\n'   If Err.Number = 0 Then Debug.Print \"ProcessInt(123) = \" & resultInt Else Debug.Print \"Call to ProcessInt failed.\"\n'   Err.Clear\n'   resultStr = ProcessStr(\"Hello\")\n'   If Err.Number = 0 Then Debug.Print \"ProcessStr(\"\"Hello\"\") = \" & resultStr Else Debug.Print \"Call to ProcessStr failed.\"\n'   On Error GoTo 0\n'   MsgBox \"(概念性) 演示了為重載DLL函數使用不同別名。需有實際MyDLL.dll。\"\n' End Sub", "explanation": "概念性地演示如何為 DLL 中可能存在的重載函數 (或具有不同簽名的同名函數的變體) 使用不同的 Alias 名稱在 VBA 中進行宣告。這樣，VBA 程式碼可以根據需要呼叫特定版本的函數。"}
    ],
    "keywords": ["declare overloaded function", "api alias for overload", "dll function overloading vba", "API重載函數別名"]
},
// External API
{
    "name": "WScript.Shell.CurrentDirectory Property",
    "category": "外部互動與API (Web, DB, OS)",
    "syntax": "currentDir = wshShell.CurrentDirectory\nwshShell.CurrentDirectory = newPath",
    "description": "設定或傳回目前作用中處理程序 (執行腳本的處理程序) 的目前工作目錄。這與 VBA 內建的 CurDir 和 ChDir 類似，但作用於 WScript.Shell 物件的上下文。",
    "parameters": [],
    "examples": [
        {"code": "Dim wshShell As Object\nDim initialWshDir As String, newWshDir As String\nSet wshShell = CreateObject(\"WScript.Shell\")\n\ninitialWshDir = wshShell.CurrentDirectory\nDebug.Print \"WScript.Shell 初始目前目錄: \" & initialWshDir\n\nOn Error Resume Next ' Changing directory might fail\nwshShell.CurrentDirectory = \"C:\\Windows\"\nIf Err.Number = 0 Then\n  Debug.Print \"WScript.Shell 目前目錄已更改為: \" & wshShell.CurrentDirectory\nElse\n  Debug.Print \"更改 WScript.Shell 目前目錄失敗: \" & Err.Description\nEnd If\nOn Error GoTo 0\n\n' Change back to original if needed for subsequent operations by wshShell\nwshShell.CurrentDirectory = initialWshDir\nDebug.Print \"WScript.Shell 目前目錄已還原: \" & wshShell.CurrentDirectory\n\nSet wshShell = Nothing", "explanation": "獲取並列印 WScript.Shell 物件的初始目前工作目錄，然後嘗試將其更改為 C:\\Windows，再將其改回。這會影響由該 WScript.Shell 實例執行的後續命令的相對路徑解析。"}
    ],
    "keywords": ["wscript.shell currentdirectory", "change working directory wsh", "WSH目前目錄"]
},
{
    "name": "MSXML2.DOMDocument (IXMLDOMNodeList .length / .item)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "當 `selectNodes` 方法傳回一個 `IXMLDOMNodeList` 物件 (節點列表) 時：\n`.length` 屬性 (Long): 傳回列表中節點的數量。\n`.item(index As Long)` 屬性/方法: 傳回列表中指定索引 (0-based) 處的 `IXMLDOMNode` 物件。",
    "syntax": "Set nodeList = xmlDoc.selectNodes(\"//SomeNode\")\nIf nodeList.length > 0 Then\n  Set firstNode = nodeList.item(0) ' Or nodeList(0)\nEnd If",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object, authors As Object ' IXMLDOMNodeList, authorNode As Object ' IXMLDOMNode\nDim xmlStr As String\nxmlStr = \"<books><book><author>Author1</author><title>T1</title></book>\" & _\n         \"<book><author>Author2</author><title>T2</title></book>\" & _\n         \"<book><author>Author3</author><title>T3</title></book></books>\"\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\nxmlDoc.LoadXML xmlStr\n\nIf xmlDoc.parseError.errorCode = 0 Then\n  Set authors = xmlDoc.selectNodes(\"//book/author\")\n  Debug.Print \"找到的作者數量 (.length): \" & authors.length\n  If authors.length > 0 Then\n    Dim i As Long\n    For i = 0 To authors.length - 1\n      Dim authorNode As Object: Set authorNode = authors.item(i) ' Or authors(i)\n      Debug.Print \"  作者 \" & (i + 1) & \": \" & authorNode.Text\n    Next i\n    Debug.Print \"第一個作者 (透過 .item(0)): \" & authors.item(0).Text\n  End If\nElse\n  Debug.Print \"XML 解析錯誤: \" & xmlDoc.parseError.reason\nEnd If\nSet xmlDoc = Nothing: Set authors = Nothing", "explanation": "載入一個包含多本書籍的XML字串。使用 `selectNodes` 獲取所有作者節點。然後，使用 `.length` 屬性獲取作者節點的數量，並使用 `.item(index)` (或直接 `authors(index)`) 在迴圈中存取每個作者節點的文本。"}
    ],
    "keywords": ["ixmldomnodelist length", "ixmldomnodelist item", "xml node list iteration", "XML節點列表長度與項目"]
},
{
    "name": "ADODB.Recordset (EditMode vs Update Batch/CancelBatch)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "當 Recordset 的 LockType 設為 `adLockBatchOptimistic` (4) 時，對記錄的更改會被快取在本地，直到呼叫 `UpdateBatch` 方法才會將所有掛起的更改一次性提交到資料庫。`CancelBatch` 方法則可以取消所有自上次 `UpdateBatch` 以來或開啟 Recordset 以來的掛起更改。在批次更新模式下，EditMode 屬性的行為可能與單記錄更新模式 (如 adLockOptimistic) 略有不同，因為更改是累積的。",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object, rs As Object\n' ' Assume conn is an open ADODB.Connection\n' Set rs = CreateObject(\"ADODB.Recordset\")\n' rs.CursorLocation = 3 ' adUseClient is often required for batch optimistic\n' rs.Open \"SELECT ProductID, ProductName, UnitPrice FROM Products\", conn, 3, 4, 1 ' adOpenStatic, adLockBatchOptimistic, adCmdText\n'\n' If Not rs.EOF Then\n'   ' Make some changes\n'   rs.Fields(\"UnitPrice\").Value = rs.Fields(\"UnitPrice\").Value * 1.05 ' Increase price of first record by 5%\n'   Debug.Print \"修改後第一筆記錄 EditMode: \" & rs.EditMode ' Might still be 0 or 1 depending on exact provider behavior until UpdateBatch\n'   rs.MoveNext\n'   If Not rs.EOF Then\n'     rs.Fields(\"ProductName\").Value = rs.Fields(\"ProductName\").Value & \" (Updated)\"\n'     Debug.Print \"修改後第二筆記錄 EditMode: \" & rs.EditMode\n'   End If\n'\n'   ' To submit all cached changes:\n'   ' On Error Resume Next\n'   ' rs.UpdateBatch adAffectAll ' adAffectAll affects all records modified\n'   ' If Err.Number = 0 Then\n'   '   MsgBox \"批次更新已提交。\"\n'   ' Else\n'   '   MsgBox \"批次更新失敗: \" & Err.Description\n'   '   rs.CancelBatch adAffectAll ' Rollback cached changes if UpdateBatch failed\n'   ' End If\n'   ' On Error GoTo 0\n'   ' Or to cancel all cached changes:\n'   ' rs.CancelBatch adAffectAll\n'   ' MsgBox \"所有掛起的批次更改已取消。\"\n' End If\n' If rs.State = 1 Then rs.Close\n' Set rs = Nothing\n' ' If conn.State = 1 Then conn.Close\n' ' Set conn = Nothing\nMsgBox \"(概念性) 演示了批次更新相關方法。需有實際可寫資料庫。\"", "explanation": "演示如何以批次樂觀鎖定 (`adLockBatchOptimistic`) 模式開啟 Recordset。對記錄所做的更改會被快取。`UpdateBatch` 方法用於將所有快取的更改提交到資料庫，而 `CancelBatch` 用於撤銷這些快取的更改。"}
    ],
    "keywords": ["adodb recordset updatebatch", "adodb cancelbatch", "batch optimistic locking", "ado batch updates", "批次更新ADO", "取消批次更新"]
},
{
    "name": "WorksheetFunction.IfError (Excel 2007+)",
    "category": "數學、日期與時間",
    "syntax": "result = Application.WorksheetFunction.IfError(Value, Value_if_error)",
    "description": "使用 Excel 的 IFERROR 工作表函數。如果 Value 運算式計算結果為錯誤 (例如 #N/A, #DIV/0!)，則傳回 Value_if_error；否則傳回 Value 運算式的結果。",
    "parameters": [
        {"name": "Value", "description": "必需。要檢查是否有錯誤的運算式或儲存格參照。"},
        {"name": "Value_if_error", "description": "必需。如果 Value 評估為錯誤時要傳回的值。"}
    ],
    "examples": [
        {"code": "Dim num1 As Double: num1 = 10\nDim num2 As Double: num2 = 0\nDim divisionResult As Variant\n' Using IFERROR to handle potential division by zero\ndivisionResult = Application.WorksheetFunction.IfError(num1 / num2, \"除數不能為零\")\nMsgBox \"10 / 0 的結果 (使用IFERROR): \" & divisionResult\n\nDim lookupVal As String: lookupVal = \"Orange\"\nDim lookupRange As Range: Set lookupRange = Range(\"A1:B3\")\n' Range(\"A1:B3\").Value = Application.Transpose(Array(Array(\"Apple\",1),Array(\"Banana\",2),Array(\"Cherry\",3)))\nDim vlookupResult As Variant\nvlookupResult = Application.WorksheetFunction.IfError(Application.WorksheetFunction.VLookup(lookupVal, lookupRange, 2, False), \"未找到產品\")\nMsgBox \"查找 '\" & lookupVal & \"' 的結果 (使用IFERROR): \" & vlookupResult", "explanation": "第一個範例使用 IFERROR 處理潛在的除零錯誤，如果發生錯誤則傳回指定的文字訊息。第二個範例使用 IFERROR 處理 VLOOKUP 可能找不到值的情況，如果 VLOOKUP 產生 #N/A 錯誤，則傳回 \"未找到產品\"。"}
    ],
    "keywords": ["iferror", "excel iferror vba", "handle formula error", "error trapping function", "IFERROR函數"]
},
{
    "name": "Range.Hyperlinks(Index).Delete (Excel - Specific Hyperlink)",
    "category": "Excel 核心操作",
    "description": "刪除範圍中特定索引的超連結。如果一個儲存格包含多個超連結 (不常見，但可能透過VBA建立)，則可以使用索引來指定刪除哪一個。通常一個儲存格只有一個超連結 (Index=1)。",
    "parameters": [{"name": "Index", "description": "必需。超連結在儲存格 Hyperlinks 集合中的索引 (1-based)。"}],
    "examples": [
        {"code": "ActiveSheet.Hyperlinks.Add Anchor:=Range(\"A1\"), Address:=\"http://a.com\", TextToDisplay:=\"Link A\"\n' You can theoretically add multiple hyperlinks to the same cell range via VBA, \n' though UI usually only shows/manages one per cell.\n' ActiveSheet.Hyperlinks.Add Anchor:=Range(\"A1\"), Address:=\"http://b.com\", TextToDisplay:=\"Link B Over A\"\nIf Range(\"A1\").Hyperlinks.Count > 0 Then\n  MsgBox \"A1 中有 \" & Range(\"A1\").Hyperlinks.Count & \" 個超連結。將刪除第一個。\"\n  Range(\"A1\").Hyperlinks(1).Delete\n  MsgBox \"A1 中的第一個超連結已被刪除。剩餘: \" & Range(\"A1\").Hyperlinks.Count\nElse\n  MsgBox \"A1 沒有超連結可刪除。\"\nEnd If", "explanation": "如果A1儲存格有超連結，則刪除其中的第一個超連結。"}
    ],
    "keywords": ["delete specific hyperlink", "remove hyperlink by index", "刪除特定超連結"]
},
{
    "name": "Dialogs(xlDialogSendMail).Show (Excel - Send Mail Dialog)",
    "category": "Excel 核心操作",
    "description": "Application.Dialogs(xlDialogSendMail).Show 方法會開啟一個 Outlook (或其他預設郵件用戶端) 新郵件視窗，並將目前的活動活頁簿 (或選取的工作表，取決於 Excel 如何處理) 作為附件。使用者可以編輯郵件並傳送。如果 Outlook 未設定或發生錯誤，可能失敗。",
    "parameters": [
        {"name": "[Arg1 As String_Recipients]", "description": "可選。預填的收件者郵箱 (To)。"},
        {"name": "[Arg2 As String_Subject]", "description": "可選。預填的郵件主旨。"}
    ],
    "examples": [
        {"code": "Dim recipientEmail As String: recipientEmail = \"test@example.com\"\nDim emailSubject As String: emailSubject = \"請查看附件中的Excel報告 - \" & ActiveWorkbook.Name\nMsgBox \"即將開啟郵件對話框並附加目前活頁簿...\"\nOn Error Resume Next\n' Show method returns True if user sends mail, False if cancels, but behavior can vary.\n' The main action is showing the dialog.\nDim dialogShown As Boolean\ndialogShown = Application.Dialogs(xlDialogSendMail).Show(Arg1:=recipientEmail, Arg2:=emailSubject)\nIf Err.Number = 0 Then\n    If dialogShown Then ' This is not a reliable indicator of mail being sent\n        MsgBox \"郵件對話框已顯示 (並可能已傳送/關閉)。\"\n    Else\n        MsgBox \"郵件對話框已取消。\"\n    End If\nElse\n    MsgBox \"開啟郵件對話框失敗。錯誤: \" & Err.Description & vbCrLf & \"(請確保Outlook已設定)\"\nEnd If\nOn Error GoTo 0", "explanation": "顯示一個 Outlook 新郵件視窗，並將目前活動的 Excel 活頁簿作為附件。同時預先填入指定的收件人和主旨。"}
    ],
    "keywords": ["xldialogsendmail", "excel send workbook as attachment dialog", "郵件對話框附加檔案"]
},
// Word
{
    "name": "Document.TrackMoves Property (Word Track Changes)",
    "category": "Word 文件處理",
    "syntax": "documentObject.TrackMoves = True | False",
    "description": "如果啟用追蹤修訂時，Word 會追蹤移動的文字 (剪下和貼上)，則為 True。讀取/寫入布林值。預設通常為 True。",
    "parameters": [{"name": "True | False", "description": "True 表示追蹤移動。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' wdDoc.TrackRevisions = True ' Ensure track revisions is on\n' wdDoc.TrackMoves = True\n' MsgBox \"文件 '\" & wdDoc.Name & \"' 現在會追蹤文字的移動 (如果追蹤修訂已啟用)。\"", "explanation": "設定活動文件在啟用追蹤修訂時，同時追蹤文字的移動。"}
    ],
    "keywords": ["word track moves", "track changes move text", "追蹤文字移動"]
},
{
    "name": "Range.StoryType Property (Word)",
    "category": "Word 文件處理",
    "syntax": "storyTypeConstant = rangeObject.StoryType",
    "description": "傳回指定範圍所屬的本文類型。唯讀 WdStoryType 常數。",
    "parameters": [
        {"name": "WdStoryType Constants", "description": "例如 wdMainTextStory (1), wdFootnotesStory (2), wdEndnotesStory (3), wdCommentsStory (4), wdTextFrameStory (5), wdEvenPagesHeaderStory (6), wdPrimaryHeaderStory (7), wdEvenPagesFooterStory (8), wdPrimaryFooterStory (9), wdFirstPageHeaderStory (10), wdFirstPageFooterStory (11)。"}
    ],
    "examples": [
        {"code": "Dim selRange As Object ' Word.Range\n' Set selRange = Selection.Range\n' Dim story As String\n' Select Case selRange.StoryType\n'   Case 1: story = \"主要文字\"\n'   Case 7: story = \"主要頁首\"\n'   Case 9: story = \"主要頁尾\"\n'   Case Else: story = \"其他本文 (\" & selRange.StoryType & \")\"\n' End Select\n' MsgBox \"目前選取範圍位於: \" & story", "explanation": "獲取目前選取範圍所在的本文類型 (例如，主要文字區、頁首、頁尾等) 並顯示。"}
    ],
    "keywords": ["word storytype", "range story type", "maintextstory", "headerfooterstory", "本文類型"]
},
// Outlook
{
    "name": "MailItem.MarkAsTask (No Date)",
    "category": "Outlook 郵件與項目管理",
    "description": "使用 `MailItem.MarkAsTask olMarkNoDate` 可以將郵件標記為一個沒有特定到期日的任務。這會將其新增到待辦事項列表中。",
    "parameters": [{"name": "olMarkNoDate (Constant 4)", "description": "將郵件標記為無到期日的任務。"}],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   olMail.MarkAsTask olMarkNoDate\n'   olMail.TaskSubject = \"待辦: \" & olMail.Subject\n'   olMail.Save\n'   MsgBox \"郵件 '\" & olMail.Subject & \"' 已標記為無到期日的待辦任務。\"\n' End If", "explanation": "將選取的郵件標記為一個沒有特定到期日的任務，並自訂其任務主旨。"}
    ],
    "keywords": ["outlook markastask nodate", "flag email no due date", "olmarknodate", "標記為無到期日任務"]
},
{
    "name": "Explorer.CurrentView (Modify and Apply View - Outlook)",
    "category": "Outlook 郵件與項目管理",
    "description": "獲取 Explorer.CurrentView 後，如果它是可修改的檢視類型 (例如 TableView)，可以更改其屬性 (如 SortFields, GroupByFields, ViewFields)，然後必須呼叫該 View 物件的 `.Apply` 方法才能使變更生效並更新顯示。",
    "syntax": "Set oView = olExplorer.CurrentView\n' ... Modify oView properties (e.g., oView.SortFields.Add ...)\noView.Apply",
    "parameters": [],
    "examples": [
        {"code": "Dim olExp As Outlook.Explorer\nDim oView As Outlook.TableView ' Assuming current view is a table view\nDim oSortField As Outlook.OrderField\n\nSet olExp = Application.ActiveExplorer\nIf olExp.CurrentFolder.DefaultItemType = olMailItem Then\n    If olExp.CurrentView.ViewType = olTableView Then\n        Set oView = olExp.CurrentView\n        ' Save current sort order to restore later if needed\n        ' Apply new sort order: by SenderName ascending\n        oView.SortFields.Clear\n        Set oSortField = oView.SortFields.Add(\"urn:schemas:httpmail:sendername\", False) ' False for Ascending\n        oView.Apply ' Apply the changes to the view\n        MsgBox \"郵件檢視已按寄件者名稱升冪排序。\"\n        ' To revert or change again, modify SortFields and call .Apply again\n    Else\n        MsgBox \"目前檢視不是表格檢視。\"\n    End If\nElse\n    MsgBox \"目前資料夾不是郵件資料夾。\"\nEnd If\n\nSet oSortField = Nothing: Set oView = Nothing: Set olExp = Nothing", "explanation": "獲取 Outlook 活動瀏覽器的目前檢視。如果它是表格檢視，則清除現有的排序欄位，然後新增一個按「寄件者名稱」升冪排列的排序條件，最後呼叫 `.Apply` 使變更生效。"}
    ],
    "keywords": ["outlook view apply changes", "tableview.apply", "modify outlook view vba", "套用檢視變更"]
},
// PowerPoint
{
    "name": "SlideRange.NotesPage Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set notesPageShapeRange = slideRangeObject.NotesPage",
    "description": "傳回一個 SlideRange 物件，代表指定投影片範圍中所有投影片的備忘稿頁面。通常，如果 slideRangeObject 只包含一個投影片，則其 NotesPage 屬性指向該單張投影片的備忘稿頁面。",
    "parameters": [],
    "examples": [
        {"code": "Dim sld As Object ' PowerPoint.Slide\nDim notesBody As Object ' PowerPoint.Shape (the notes body placeholder)\n' Set sld = ActivePresentation.Slides(1)\n' ' Access the notes body placeholder on the notes page of the first slide\n' ' The index for notes body placeholder can vary, often 2 if title is 1.\n' On Error Resume Next ' If placeholder doesn't exist or no text\n' Set notesBody = sld.NotesPage.Shapes.Placeholders(2) ' Typically index 2 is the body\n' If Not notesBody Is Nothing And notesBody.HasTextFrame Then\n'   notesBody.TextFrame.TextRange.Text = \"這是為第一張投影片新增的演講者備註。\" & vbCrLf & \"- 重點1\" & vbCrLf & \"- 重點2\"\n'   MsgBox \"已更新第一張投影片的備忘稿。\"\n' Else\n'   MsgBox \"無法找到備忘稿頁面的文字預留位置。\"\n' End If\n' On Error GoTo 0", "explanation": "獲取第一張投影片的備忘稿頁面，並嘗試將文字設定到其主要文字預留位置中 (通常是索引為2的預留位置)。"}
    ],
    "keywords": ["powerpoint sliderange notespage", "access notes page ppt", "edit speaker notes vba", "投影片範圍備忘稿"]
},
{
    "name": "Shapes(Index).ZOrderPosition Property (PowerPoint/Excel - Read-only)",
    "category": "PowerPoint 簡報製作",
    "description": "傳回指定圖案在其 Z 順序 (堆疊順序) 中的位置。傳回值是一個 Long，1 表示在最下層，Shapes.Count 表示在最上層。此屬性是唯讀的；要更改 Z 順序，請使用 ShapeRange.ZOrder 方法。",
    "syntax": "zPosition = shapeObject.ZOrderPosition",
    "parameters": [],
    "examples": [
        {"code": "' In PowerPoint:\n' Dim sld As Object ' PowerPoint.Slide\n' Dim shp As Object ' PowerPoint.Shape\n' Set sld = ActivePresentation.Slides(1)\n' If sld.Shapes.Count > 0 Then\n'   Set shp = sld.Shapes(1) ' Get the first shape added (usually at the bottom of Z-order initially)\n'   MsgBox \"圖案 '\" & shp.Name & \"' 的 Z順序位置是: \" & shp.ZOrderPosition & \" (1 表示最下層)。\"\n'   ' shp.ZOrder msoBringToFront ' Bring it to front\n'   ' MsgBox \"移到最上層後，新的 Z順序位置是: \" & shp.ZOrderPosition\n' End If", "explanation": "如果第一張投影片上有圖案，則獲取第一個圖案的 Z 順序位置。"}
    ],
    "keywords": ["shape zorderposition", "get shape stacking order", "圖案Z順序位置", "通用"]
},
// FSO
{
    "name": "FileSystemObject.File.ShortPath (FSO)",
    "category": "檔案與資料夾管理",
    "syntax": "shortPathString = fileObject.ShortPath",
    "description": "傳回檔案的短路徑名稱 (8.3 格式)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, myFile As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Example with a path that might have a short name variant\n' Dim longFilePath As String: longFilePath = Environ(\"ProgramFiles\") & \"\\Common Files\\Microsoft Shared\\VBA\\VBA7.1\\VBE7.DLL\"\n' If fso.FileExists(longFilePath) Then\n'   Set myFile = fso.GetFile(longFilePath)\n'   MsgBox \"檔案 '\" & myFile.Name & \"' 的短路徑是: \" & myFile.ShortPath\n' Else\n'   MsgBox \"範例檔案路徑未找到: \" & longFilePath\n' End If\n' Set fso = Nothing: Set myFile = Nothing", "explanation": "獲取一個指定檔案 (此處為 VBE7.DLL 的一個可能路徑) 的 8.3 格式短路徑。"}
    ],
    "keywords": ["fso file shortpath", "8.3 file path", "dos file path", "檔案短路徑"]
},
// String
{
    "name": "Option Explicit (Module Declaration Section)",
    "category": "程式流程與結構控制",
    "description": "`Option Explicit` 是一個編譯器指令，應放置在每個 VBA 模組 (標準模組、類別模組、使用者表單模組、文件/工作表模組) 的宣告區 (最頂部，任何 Sub、Function 或 Property 過程之前)。它強制要求模組中的所有變數都必須在使用前透過 `Dim`、`Private`、`Public`、`ReDim` 或 `Static` 等關鍵字進行明確宣告。這有助於捕捉因變數名稱拼寫錯誤而導致的錯誤，並提高程式碼的可讀性和可維護性。在 VBA 編輯器的「工具」>「選項」>「編輯器」標籤頁中，可以勾選「要求變數宣告」選項，這樣在新建模組時會自動加入 `Option Explicit`。",
    "syntax": "Option Explicit",
    "parameters": [],
    "examples": [
        {"code": "' --- At the VERY TOP of a module ---\nOption Explicit\n\nSub MyProcedureWithExplicitVars()\n  Dim myNumber As Integer\n  Dim myText As String\n  ' Dim anotheVar ' This would now cause a compile error \"Variable not defined\"\n  \n  myNumber = 10\n  myText = \"Hello\"\n  ' anothrVar = 5 ' Misspelled variable - would error here if not Dim'd\n  \n  MsgBox myText & \" \" & myNumber\nEnd Sub", "explanation": "演示在模組頂部使用 `Option Explicit`。如果嘗試使用未宣告的變數 (例如 `anotheVar`)，VBA 編譯器會在執行前就標示錯誤。"}
    ],
    "keywords": ["option explicit", "require variable declaration", "explicit variable declaration", "vba best practices", "強制變數宣告"]
},
// Math
{
    "name": "WorksheetFunction.PercentRank_Inc (Excel)",
    "category": "數學、日期與時間",
    "syntax": "percentRank = Application.WorksheetFunction.PercentRank_Inc(ArrayOrRange, X, [Significance As Long])",
    "description": "使用 Excel 的 PERCENTRANK.INC 工作表函數 (Excel 2010+，舊版為 PERCENTRANK)，傳回一個值在資料集中的百分比排名 (0 到 1 之間，包含端點)。",
    "parameters": [
        {"name": "ArrayOrRange", "description": "必需。定義相對位置的數據陣列或儲存格範圍。"},
        {"name": "X", "description": "必需。要找出其百分比排名的值。"},
        {"name": "Significance", "description": "可選。識別要傳回的百分比值有效位數的數字。如果省略，則使用3位小數 (0.xxx)。"}
    ],
    "examples": [
        {"code": "Dim scores As Variant: scores = Array(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)\nDim rankOf50 As Double, rankOf25 As Double\nrankOf50 = Application.WorksheetFunction.PercentRank_Inc(scores, 50)\nrankOf25 = Application.WorksheetFunction.PercentRank_Inc(scores, 25, 4) ' 4 decimal places for significance\nMsgBox \"值 50 的百分比排名是: \" & Format(rankOf50, \"0.000\") & \" (即第 \" & rankOf50 * 100 & \" 百分位)\" & vbCrLf & _\n       \"值 25 的百分比排名 (4位小數) 是: \" & Format(rankOf25, \"0.0000\")", "explanation": "計算值 50 和 25 在一組分數中的百分比排名。百分比排名表示資料集中小於或等於該值的數據所佔的百分比。"}
    ],
    "keywords": ["percentrank.inc", "excel percentrank vba", "percentage rank", "百分比排名"]
},
// Excel 核心操作 - Formula Insertion Examples
{
    "name": "Range.Formula (SUM)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SUM(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 SUM 公式，以計算一組數值的總和。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "要加總的數字、儲存格參照或範圍。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=SUM(A1:B1)\"", "explanation": "儲存格C1將顯示A1和B1儲存格內容的總和。"},
        {"code": "Range(\"D5\").Formula = \"=SUM(A1:A10, C1, 100)\"", "explanation": "儲存格D5將顯示A1到A10範圍的總和，加上C1的值，再加上100。"}
    ],
    "keywords": ["excel formula sum", "insert sum formula", "加總公式", "求和"]
},
{
    "name": "Range.Formula (AVERAGE)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=AVERAGE(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 AVERAGE 公式，以計算一組數值的平均值。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "要計算平均值的數字、儲存格參照或範圍。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=AVERAGE(A1:A10)\"", "explanation": "儲存格C1將顯示A1到A10範圍內數值的平均值。"}
    ],
    "keywords": ["excel formula average", "insert average formula", "平均值公式"]
},
{
    "name": "Range.Formula (COUNT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=COUNT(Value1, [Value2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 COUNT 公式，以計算包含數字的儲存格數量。",
    "parameters": [
        {"name": "Value1, Value2, ...", "description": "要計數其中數字的項目、儲存格參照或範圍。"}
    ],
    "examples": [
        {"code": "Range(\"D1\").Formula = \"=COUNT(A1:C50)\"", "explanation": "儲存格D1將顯示A1到C50範圍內包含數字的儲存格的總數。"}
    ],
    "keywords": ["excel formula count", "insert count formula", "計數數字公式"]
},
{
    "name": "Range.Formula (COUNTA)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=COUNTA(Value1, [Value2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 COUNTA 公式，以計算範圍中不為空的儲存格數量。",
    "parameters": [
        {"name": "Value1, Value2, ...", "description": "要計數其中非空儲存格的項目、儲存格參照或範圍。"}
    ],
    "examples": [
        {"code": "Range(\"E1\").Formula = \"=COUNTA(A1:D100)\"", "explanation": "儲存格E1將顯示A1到D100範圍內所有非空儲存格的總數。"}
    ],
    "keywords": ["excel formula counta", "insert counta formula", "計數非空公式"]
},
{
    "name": "Range.Formula (MAX)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=MAX(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 MAX 公式，以傳回一組數值中的最大值。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "要找出最大值的數字、儲存格參照或範圍。"}
    ],
    "examples": [
        {"code": "Range(\"F1\").Formula = \"=MAX(B1:B50)\"", "explanation": "儲存格F1將顯示B1到B50範圍內的最大數值。"}
    ],
    "keywords": ["excel formula max", "insert max formula", "最大值公式"]
},
{
    "name": "Range.Formula (MIN)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=MIN(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 MIN 公式，以傳回一組數值中的最小值。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "要找出最小值的數字、儲存格參照或範圍。"}
    ],
    "examples": [
        {"code": "Range(\"G1\").Formula = \"=MIN(B1:B50)\"", "explanation": "儲存格G1將顯示B1到B50範圍內的最小數值。"}
    ],
    "keywords": ["excel formula min", "insert min formula", "最小值公式"]
},
{
    "name": "Range.Formula (IF)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=IF(Logical_test, Value_if_true, Value_if_false)\"",
    "description": "在指定儲存格中插入 Excel 的 IF 公式，以根據條件的真假傳回不同的值。",
    "parameters": [
        {"name": "Logical_test", "description": "任何可以評估為 TRUE 或 FALSE 的值或運算式。"},
        {"name": "Value_if_true", "description": "Logical_test 為 TRUE 時傳回的值。"},
        {"name": "Value_if_false", "description": "Logical_test 為 FALSE 時傳回的值。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=IF(A1>10, \"\"高於\"\", \"\"不高於\"\")\"", "explanation": "如果A1儲存格的值大於10，C1顯示\"高於\"，否則顯示\"不高於\"。注意VBA中雙引號的處理。"}
    ],
    "keywords": ["excel formula if", "insert if formula", "條件判斷公式", "IF函數"]
},
{
    "name": "Range.Formula (AND)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=AND(Logical1, [Logical2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 AND 公式。如果所有參數均為 TRUE，則傳回 TRUE；否則傳回 FALSE。",
    "parameters": [
        {"name": "Logical1, Logical2, ...", "description": "1到255個要測試的條件。"}
    ],
    "examples": [
        {"code": "Range(\"D1\").Formula = \"=IF(AND(A1>0, B1<100), \"\"有效\"\", \"\"無效\"\")\"", "explanation": "如果A1大於0且B1小於100，則D1顯示\"有效\"，否則顯示\"無效\"。"}
    ],
    "keywords": ["excel formula and", "insert and formula", "邏輯與公式", "AND函數"]
},
{
    "name": "Range.Formula (OR)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=OR(Logical1, [Logical2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 OR 公式。如果任一參數為 TRUE，則傳回 TRUE；所有參數均為 FALSE 時才傳回 FALSE。",
    "parameters": [
        {"name": "Logical1, Logical2, ...", "description": "1到255個要測試的條件。"}
    ],
    "examples": [
        {"code": "Range(\"E1\").Formula = \"=IF(OR(A1=\"\"Complete\"\", B1=\"\"Pending\"\"), \"\"處理中\"\", \"\"其他狀態\"\")\"", "explanation": "如果A1為\"Complete\"或B1為\"Pending\"，則E1顯示\"處理中\"，否則顯示\"其他狀態\"。"}
    ],
    "keywords": ["excel formula or", "insert or formula", "邏輯或公式", "OR函數"]
},
{
    "name": "Range.Formula (IFERROR)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=IFERROR(Value, Value_if_error)\"",
    "description": "在指定儲存格中插入 Excel 的 IFERROR 公式。如果 Value 運算式計算結果為錯誤，則傳回 Value_if_error；否則傳回 Value 運算式的結果。",
    "parameters": [
        {"name": "Value", "description": "要檢查是否有錯誤的運算式。"},
        {"name": "Value_if_error", "description": "如果 Value 評估為錯誤時要傳回的值。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=IFERROR(A1/B1, \"\"無法計算 (除數可能為0或非數字)\"\")\"", "explanation": "計算A1除以B1。如果發生錯誤（例如B1為0），則C1顯示指定的錯誤訊息，否則顯示計算結果。"}
    ],
    "keywords": ["excel formula iferror", "insert iferror formula", "錯誤處理公式", "IFERROR函數"]
},
{
    "name": "Range.Formula (VLOOKUP)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=VLOOKUP(Lookup_value, Table_array, Col_index_num, [Range_lookup])\"",
    "description": "在指定儲存格中插入 Excel 的 VLOOKUP 公式，用於在表格或範圍的第一欄中垂直尋找值，並傳回同一列中指定欄的值。",
    "parameters": [
        {"name": "Lookup_value", "description": "要在第一欄中尋找的值。"},
        {"name": "Table_array", "description": "包含資料的儲存格範圍。"},
        {"name": "Col_index_num", "description": "Table_array 中要傳回其值的欄號 (1-based)。"},
        {"name": "Range_lookup", "description": "可選。布林值，TRUE (預設) 或省略表示近似符合，FALSE 表示精確符合。"}
    ],
    "examples": [
        {"code": "Range(\"D1\").Formula = \"=VLOOKUP(C1, Sheet2!A1:B100, 2, FALSE)\"", "explanation": "在D1儲存格中，使用C1的值在Sheet2工作表的A1:B100範圍的第一欄中進行精確查找，並傳回該範圍第二欄中對應的值。"}
    ],
    "keywords": ["excel formula vlookup", "insert vlookup formula", "垂直查找公式", "VLOOKUP函數"]
},
{
    "name": "Range.Formula (HLOOKUP)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=HLOOKUP(Lookup_value, Table_array, Row_index_num, [Range_lookup])\"",
    "description": "在指定儲存格中插入 Excel 的 HLOOKUP 公式，用於在表格或範圍的第一列中水平尋找值，並傳回同一欄中指定列的值。",
    "parameters": [
        {"name": "Lookup_value", "description": "要在第一列中尋找的值。"},
        {"name": "Table_array", "description": "包含資料的儲存格範圍。"},
        {"name": "Row_index_num", "description": "Table_array 中要傳回其值的列號 (1-based)。"},
        {"name": "Range_lookup", "description": "可選。布林值。"}
    ],
    "examples": [
        {"code": "Range(\"B2\").Formula = \"=HLOOKUP(A2, Sheet3!A1:E10, 3, FALSE)\"", "explanation": "在B2儲存格中，使用A2的值在Sheet3工作表的A1:E10範圍的第一列中進行精確查找，並傳回該範圍第三列中對應的值。"}
    ],
    "keywords": ["excel formula hlookup", "insert hlookup formula", "水平查找公式", "HLOOKUP函數"]
},
{
    "name": "Range.Formula (INDEX-MATCH)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=INDEX(Array, MATCH(Lookup_value, Lookup_array, [Match_type]))\"",
    "description": "在指定儲存格中插入 Excel 的 INDEX 和 MATCH 組合公式，用於執行更靈活的查找 (例如，向左查找)。",
    "parameters": [
        {"name": "Array (INDEX)", "description": "要從中傳回值的儲存格範圍或陣列。"},
        {"name": "Lookup_value (MATCH)", "description": "要匹配的值。"},
        {"name": "Lookup_array (MATCH)", "description": "包含要匹配的值的範圍。"},
        {"name": "Match_type (MATCH)", "description": "0 (精確符合), 1 (小於), -1 (大於)。"}
    ],
    "examples": [
        {"code": "Range(\"E1\").Formula = \"=INDEX(Sheet2!A1:A50, MATCH(D1, Sheet2!B1:B50, 0))\"", "explanation": "在E1中，使用D1的值在Sheet2的B1:B50中查找其匹配的列號，然後傳回Sheet2的A1:A50中該列號對應的值 (實現了向左查找)。"}
    ],
    "keywords": ["excel formula index match", "insert index match", "靈活查找公式", "INDEX MATCH組合"]
},
{
    "name": "Range.Formula (LEFT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=LEFT(Text, [Num_chars])\"",
    "description": "在指定儲存格中插入 Excel 的 LEFT 公式，以從文字字串的開頭傳回指定數量的字元。",
    "parameters": [
        {"name": "Text", "description": "包含要提取字元的文字字串或儲存格參照。"},
        {"name": "Num_chars", "description": "可選。指定要提取的字元數。預設為1。"}
    ],
    "examples": [
        {"code": "Range(\"B1\").Formula = \"=LEFT(A1, 5)\"", "explanation": "儲存格B1將顯示A1儲存格內容的前5個字元。"}
    ],
    "keywords": ["excel formula left", "insert left formula", "提取左側字串公式", "LEFT函數"]
},
{
    "name": "Range.Formula (RIGHT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=RIGHT(Text, [Num_chars])\"",
    "description": "在指定儲存格中插入 Excel 的 RIGHT 公式，以從文字字串的結尾傳回指定數量的字元。",
    "parameters": [
        {"name": "Text", "description": "文字字串或儲存格參照。"},
        {"name": "Num_chars", "description": "可選。要提取的字元數。預設為1。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=RIGHT(A1, 3)\"", "explanation": "儲存格C1將顯示A1儲存格內容的末尾3個字元。"}
    ],
    "keywords": ["excel formula right", "insert right formula", "提取右側字串公式", "RIGHT函數"]
},
{
    "name": "Range.Formula (MID)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=MID(Text, Start_num, Num_chars)\"",
    "description": "在指定儲存格中插入 Excel 的 MID 公式，以從文字字串的指定起始位置傳回特定數量的字元。",
    "parameters": [
        {"name": "Text", "description": "包含要提取字元的文字字串。"},
        {"name": "Start_num", "description": "提取的起始位置。"},
        {"name": "Num_chars", "description": "要提取的字元數。"}
    ],
    "examples": [
        {"code": "Range(\"D1\").Formula = \"=MID(A1, 7, 5)\"", "explanation": "儲存格D1將顯示從A1儲存格內容的第7個字元開始提取的5個字元。"}
    ],
    "keywords": ["excel formula mid", "insert mid formula", "提取中間字串公式", "MID函數"]
},
{
    "name": "Range.Formula (LEN)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=LEN(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 LEN 公式，以傳回文字字串的長度 (字元數)。",
    "parameters": [
        {"name": "Text", "description": "要計算長度的文字字串或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"E1\").Formula = \"=LEN(A1)\"", "explanation": "儲存格E1將顯示A1儲存格內容的字元長度。"}
    ],
    "keywords": ["excel formula len", "insert len formula", "字串長度公式", "LEN函數"]
},
{
    "name": "Range.Formula (CONCATENATE with &)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=Text1 & Text2 & ...\"",
    "description": "在指定儲存格中插入使用 `&` 運算子連接多個文字字串的公式。",
    "parameters": [
        {"name": "Text1, Text2, ...", "description": "要連接的文字字串、儲存格參照或包含文字的公式。"}
    ],
    "examples": [
        {"code": "Range(\"F1\").Formula = \"=A1 & \"\" \"\" & B1 & \"\" (ID: \"\" & C1 & \"\")\"" , "explanation": "儲存格F1將顯示A1、一個空格、B1、以及括號內含C1值的文字字串的組合。"}
    ],
    "keywords": ["excel formula concatenate", "insert concat formula", "連接字串公式", "&運算子"]
},
{
    "name": "Range.Formula (TEXTJOIN - Excel 2019+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=TEXTJOIN(Delimiter, Ignore_empty, Text1, [Text2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 TEXTJOIN 公式 (Excel 2019 及更新版本，或 Microsoft 365)，用於使用分隔符號連接多個文字字串，並可選擇忽略空字串。",
    "parameters": [
        {"name": "Delimiter", "description": "分隔符號字串。"},
        {"name": "Ignore_empty", "description": "TRUE 表示忽略空儲存格。"},
        {"name": "Text1, Text2, ...", "description": "要連接的文字項目或範圍。"}
    ],
    "examples": [
        {"code": "Range(\"G1\").Formula = \"=TEXTJOIN(\"\", \"\", TRUE, A1:C1)\"", "explanation": "儲存格G1將連接A1到C1範圍內所有非空儲存格的內容，使用逗號和空格作為分隔符號。"}
    ],
    "keywords": ["excel formula textjoin", "insert textjoin formula", "合併字串分隔", "TEXTJOIN函數"]
},
{
    "name": "Range.Formula (FIND)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=FIND(Find_text, Within_text, [Start_num])\"",
    "description": "在指定儲存格中插入 Excel 的 FIND 公式，用於在一個文字字串 (Within_text) 中尋找另一個文字字串 (Find_text) 的起始位置。FIND 區分大小寫。",
    "parameters": [
        {"name": "Find_text", "description": "要尋找的文字。"},
        {"name": "Within_text", "description": "包含要尋找文字的文字。"},
        {"name": "Start_num", "description": "可選。指定搜尋的起始字元位置。"}
    ],
    "examples": [
        {"code": "Range(\"B1\").Formula = \"=FIND(\"\"VBA\"\", A1)\"", "explanation": "儲存格B1將顯示字串\"VBA\"在A1儲存格內容中首次出現的起始位置 (區分大小寫)。如果找不到，會傳回 #VALUE! 錯誤。"}
    ],
    "keywords": ["excel formula find", "insert find formula", "查找字串位置公式", "FIND函數"]
},
{
    "name": "Range.Formula (REPLACE - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=REPLACE(Old_text, Start_num, Num_chars, New_text)\"",
    "description": "在指定儲存格中插入 Excel 的 REPLACE 公式，用於根據指定的字元數取代文字字串的一部分。",
    "parameters": [
        {"name": "Old_text", "description": "要取代其中一部分字元的文字。"},
        {"name": "Start_num", "description": "取代的起始位置。"},
        {"name": "Num_chars", "description": "要取代的字元數。"},
        {"name": "New_text", "description": "要插入的新文字。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=REPLACE(A1, 6, 5, \"\"Excel\"\")\" ' Assume A1 is \"Hello VBA World\"", "explanation": "如果A1是\"Hello VBA World\"，則C1將顯示\"Hello Excel World\" (從第6個字元開始的5個字元\"VBA W\"被\"Excel\"取代)。"}
    ],
    "keywords": ["excel formula replace", "insert replace formula", "取代部分字串公式", "REPLACE函數"]
},
{
    "name": "Range.Formula (TEXT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=TEXT(Value, Format_text)\"",
    "description": "在指定儲存格中插入 Excel 的 TEXT 公式，用於將數值轉換為特定數字格式的文字。",
    "parameters": [
        {"name": "Value", "description": "要轉換的數值或儲存格參照。"},
        {"name": "Format_text", "description": "要套用的數字格式代碼字串。"}
    ],
    "examples": [
        {"code": "Range(\"D1\").Formula = \"=TEXT(A1, \"\"yyyy年m月d日\"\")\" ' Assume A1 contains a date", "explanation": "如果A1包含日期，D1將以\"yyyy年m月d日\"格式顯示該日期作為文字。"}
    ],
    "keywords": ["excel formula text", "insert text formula", "格式化數值為文字", "TEXT函數"]
},
{
    "name": "Range.Formula (TRIM)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=TRIM(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 TRIM 公式，用於移除文字字串中多餘的空格 (保留單字間的單個空格)。",
    "parameters": [
        {"name": "Text", "description": "要移除空格的文字或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"  Extra   Spaces  \"\nRange(\"B1\").Formula = \"=TRIM(A1)\"", "explanation": "儲存格B1將顯示A1內容移除前後和中間多餘空格後的結果 (\"Extra Spaces\")。"}
    ],
    "keywords": ["excel formula trim", "insert trim formula", "移除空格公式", "TRIM函數"]
},
{
    "name": "Range.Formula (UPPER)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=UPPER(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 UPPER 公式，用於將文字字串轉換為全部大寫。",
    "parameters": [
        {"name": "Text", "description": "要轉換的文字或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"lowercase text\"\nRange(\"C1\").Formula = \"=UPPER(A1)\"", "explanation": "儲存格C1將顯示A1內容轉換為大寫的結果 (\"LOWERCASE TEXT\")。"}
    ],
    "keywords": ["excel formula upper", "insert upper formula", "轉大寫公式", "UPPER函數"]
},
{
    "name": "Range.Formula (LOWER)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=LOWER(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 LOWER 公式，用於將文字字串轉換為全部小寫。",
    "parameters": [
        {"name": "Text", "description": "要轉換的文字或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"UPPERCASE TEXT\"\nRange(\"D1\").Formula = \"=LOWER(A1)\"", "explanation": "儲存格D1將顯示A1內容轉換為小寫的結果 (\"uppercase text\")。"}
    ],
    "keywords": ["excel formula lower", "insert lower formula", "轉小寫公式", "LOWER函數"]
},
{
    "name": "Range.Formula (PROPER)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=PROPER(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 PROPER 公式，用於將文字字串中每個單字的首字母轉換為大寫，其餘字母轉為小寫。",
    "parameters": [
        {"name": "Text", "description": "要轉換的文字或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"john doe smith\"\nRange(\"E1\").Formula = \"=PROPER(A1)\"", "explanation": "儲存格E1將顯示A1內容轉換為首字母大寫的結果 (\"John Doe Smith\")。"}
    ],
    "keywords": ["excel formula proper", "insert proper formula", "首字母大寫公式", "PROPER函數"]
},
{
    "name": "Range.Formula (TODAY)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=TODAY()\"",
    "description": "在指定儲存格中插入 Excel 的 TODAY 公式，以傳回目前日期。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=TODAY()\"\nRange(\"A1\").NumberFormat = \"yyyy-mm-dd\"", "explanation": "儲存格A1將顯示目前的日期，並格式化為 yyyy-mm-dd。"}
    ],
    "keywords": ["excel formula today", "insert today formula", "目前日期公式", "TODAY函數"]
},
{
    "name": "Range.Formula (NOW)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=NOW()\"",
    "description": "在指定儲存格中插入 Excel 的 NOW 公式，以傳回目前的日期和時間。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"B1\").Formula = \"=NOW()\"\nRange(\"B1\").NumberFormat = \"yyyy-mm-dd hh:mm:ss\"", "explanation": "儲存格B1將顯示目前的日期和時間。"}
    ],
    "keywords": ["excel formula now", "insert now formula", "目前日期時間公式", "NOW函數"]
},
{
    "name": "Range.Formula (DATE - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DATE(Year, Month, Day)\"",
    "description": "在指定儲存格中插入 Excel 的 DATE 公式，以根據指定的年、月、日傳回日期序列號。",
    "parameters": [
        {"name": "Year", "description": "年份。"},
        {"name": "Month", "description": "月份。"},
        {"name": "Day", "description": "日期。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=DATE(2024, 12, 25)\"", "explanation": "儲存格C1將顯示日期 2024年12月25日。"}
    ],
    "keywords": ["excel formula date", "insert date formula", "建立日期公式", "DATE函數"]
},
{
    "name": "Range.Formula (YEAR - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=YEAR(Serial_number)\"",
    "description": "在指定儲存格中插入 Excel 的 YEAR 公式，以從日期序列號中提取年份。",
    "parameters": [
        {"name": "Serial_number", "description": "包含日期的儲存格或日期值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2025, 5, 20)\nRange(\"D1\").Formula = \"=YEAR(A1)\"", "explanation": "如果A1包含日期 2025/5/20，則D1顯示 2025。"}
    ],
    "keywords": ["excel formula year", "insert year formula", "提取年份公式", "YEAR函數"]
},
{
    "name": "Range.Formula (MONTH - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=MONTH(Serial_number)\"",
    "description": "在指定儲存格中插入 Excel 的 MONTH 公式，以從日期序列號中提取月份。",
    "parameters": [
        {"name": "Serial_number", "description": "包含日期的儲存格或日期值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2025, 5, 20)\nRange(\"E1\").Formula = \"=MONTH(A1)\"", "explanation": "如果A1包含日期 2025/5/20，則E1顯示 5。"}
    ],
    "keywords": ["excel formula month", "insert month formula", "提取月份公式", "MONTH函數"]
},
{
    "name": "Range.Formula (DAY - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DAY(Serial_number)\"",
    "description": "在指定儲存格中插入 Excel 的 DAY 公式，以從日期序列號中提取日期。",
    "parameters": [
        {"name": "Serial_number", "description": "包含日期的儲存格或日期值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2025, 5, 20)\nRange(\"F1\").Formula = \"=DAY(A1)\"", "explanation": "如果A1包含日期 2025/5/20，則F1顯示 20。"}
    ],
    "keywords": ["excel formula day", "insert day formula", "提取日期公式", "DAY函數"]
},
{
    "name": "Range.Formula (NETWORKDAYS)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=NETWORKDAYS(Start_date, End_date, [Holidays])\"",
    "description": "在指定儲存格中插入 Excel 的 NETWORKDAYS 公式，以傳回兩個日期之間完整的工作日數 (不含週末和指定的假日)。",
    "parameters": [
        {"name": "Start_date", "description": "開始日期。"},
        {"name": "End_date", "description": "結束日期。"},
        {"name": "Holidays", "description": "可選。要排除的假日日期範圍或陣列。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2023,10,1)\nRange(\"B1\").Value = DateSerial(2023,10,31)\nRange(\"C1:C2\").Value = Application.Transpose(Array(DateSerial(2023,10,9), DateSerial(2023,10,10))) ' Holidays\nRange(\"G1\").Formula = \"=NETWORKDAYS(A1, B1, C1:C2)\"", "explanation": "計算2023年10月1日到10月31日之間的工作日數，並排除C1:C2中指定的假日。"}
    ],
    "keywords": ["excel formula networkdays", "insert networkdays", "計算工作日公式", "NETWORKDAYS函數"]
},
{
    "name": "Range.Formula (EOMONTH)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=EOMONTH(Start_date, Months)\"",
    "description": "在指定儲存格中插入 Excel 的 EOMONTH 公式，以傳回指定日期之前或之後幾個月的最後一天。",
    "parameters": [
        {"name": "Start_date", "description": "開始日期。"},
        {"name": "Months", "description": "指定月份數。正數表示未來月份，負數表示過去月份，0表示當月。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2023,2,15)\nRange(\"H1\").Formula = \"=EOMONTH(A1, 0)\" ' Last day of Feb 2023\nRange(\"H2\").Formula = \"=EOMONTH(A1, 1)\" ' Last day of Mar 2023", "explanation": "H1顯示2023年2月的最後一天，H2顯示2023年3月的最後一天。"}
    ],
    "keywords": ["excel formula eomonth", "insert eomonth", "月底日期公式", "EOMONTH函數"]
},
{
    "name": "Range.Formula (ROUND)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ROUND(Number, Num_digits)\"",
    "description": "在指定儲存格中插入 Excel 的 ROUND 公式，將數字四捨五入到指定的位數。",
    "parameters": [
        {"name": "Number", "description": "要四捨五入的數字。"},
        {"name": "Num_digits", "description": "要四捨五入到的位數。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 123.456\nRange(\"I1\").Formula = \"=ROUND(A1, 2)\" ' Rounds to 123.46\nRange(\"I2\").Formula = \"=ROUND(A1, 0)\" ' Rounds to 123", "explanation": "I1將A1的值四捨五入到兩位小數，I2將A1的值四捨五入到整數。"}
    ],
    "keywords": ["excel formula round", "insert round formula", "四捨五入公式", "ROUND函數"]
},
{
    "name": "Range.Formula (SUMPRODUCT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SUMPRODUCT(Array1, [Array2], [Array3], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 SUMPRODUCT 公式，將相應陣列或範圍的對應元素相乘，然後傳回這些乘積的總和。",
    "parameters": [
        {"name": "Array1, Array2, ...", "description": "2到255個其元素要相乘然後加總的陣列或範圍。維度必須相同。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A3\").Value = Application.Transpose(Array(1,2,3))\nRange(\"B1:B3\").Value = Application.Transpose(Array(10,20,30))\nRange(\"J1\").Formula = \"=SUMPRODUCT(A1:A3, B1:B3)\"", "explanation": "J1計算 (1*10) + (2*20) + (3*30) = 10 + 40 + 90 = 140。"}
    ],
    "keywords": ["excel formula sumproduct", "insert sumproduct", "乘積和公式", "SUMPRODUCT函數"]
},
{
    "name": "Range.Formula (RANDBETWEEN)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=RANDBETWEEN(Bottom, Top)\"",
    "description": "在指定儲存格中插入 Excel 的 RANDBETWEEN 公式，以傳回介於指定的兩個整數之間的一個隨機整數。",
    "parameters": [
        {"name": "Bottom", "description": "隨機數的下限。"},
        {"name": "Top", "description": "隨機數的上限。"}
    ],
    "examples": [
        {"code": "Range(\"K1\").Formula = \"=RANDBETWEEN(1, 100)\"", "explanation": "K1將顯示一個介於1和100之間的隨機整數。每次重新計算時都會改變。"}
    ],
    "keywords": ["excel formula randbetween", "insert randbetween", "隨機整數公式", "RANDBETWEEN函數"]
},
{
    "name": "Range.Formula (COUNTIF)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=COUNTIF(Range, Criteria)\"",
    "description": "在指定儲存格中插入 Excel 的 COUNTIF 公式，計算範圍中符合指定條件的儲存格數量。",
    "parameters": [
        {"name": "Range", "description": "要計數的儲存格範圍。"},
        {"name": "Criteria", "description": "條件。"}
    ],
    "examples": [
        {"code": "Range(\"L1\").Formula = \"=COUNTIF(A1:A10, \">50\")\"", "explanation": "L1計算A1:A10範圍內值大於50的儲存格數量。"}
    ],
    "keywords": ["excel formula countif", "insert countif", "條件計數公式", "COUNTIF函數"]
},
{
    "name": "Range.Formula (SUMIF)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SUMIF(Range, Criteria, [Sum_range])\"",
    "description": "在指定儲存格中插入 Excel 的 SUMIF 公式，對符合指定條件的儲存格進行加總。",
    "parameters": [
        {"name": "Range", "description": "要評估條件的範圍。"},
        {"name": "Criteria", "description": "條件。"},
        {"name": "Sum_range", "description": "可選。要加總的實際儲存格。"}
    ],
    "examples": [
        {"code": "Range(\"M1\").Formula = \"=SUMIF(A1:A10, \"\"Apple\"\", B1:B10)\"", "explanation": "如果A1:A10中某儲存格為\"Apple\"，則將B1:B10中對應儲存格的值加總到M1。"}
    ],
    "keywords": ["excel formula sumif", "insert sumif", "條件加總公式", "SUMIF函數"]
},
{
    "name": "Range.Formula (AVERAGEIF)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=AVERAGEIF(Range, Criteria, [Average_range])\"",
    "description": "在指定儲存格中插入 Excel 的 AVERAGEIF 公式，計算範圍中符合指定條件的所有儲存格的平均值。",
    "parameters": [
        {"name": "Range", "description": "要評估條件的範圍。"},
        {"name": "Criteria", "description": "條件。"},
        {"name": "Average_range", "description": "可選。要計算平均值的實際儲存格。"}
    ],
    "examples": [
        {"code": "Range(\"N1\").Formula = \"=AVERAGEIF(A1:A10, \">0\")\"", "explanation": "N1計算A1:A10範圍內所有大於0的儲存格的平均值。"}
    ],
    "keywords": ["excel formula averageif", "insert averageif", "條件平均公式", "AVERAGEIF函數"]
},
{
    "name": "Range.Formula (COUNTIFS)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=COUNTIFS(Criteria_range1, Criteria1, [Criteria_range2, Criteria2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 COUNTIFS 公式，計算符合所有指定多個條件的儲存格數量。",
    "parameters": [
        {"name": "Criteria_range1", "description": "第一個條件範圍。"},
        {"name": "Criteria1", "description": "第一個條件。"}
    ],
    "examples": [
        {"code": "Range(\"O1\").Formula = \"=COUNTIFS(A1:A10, \"\">10\"\", B1:B10, \"\"<50\"\")\"", "explanation": "O1計算A1:A10中值大於10且B1:B10中值小於50的列的數量。"}
    ],
    "keywords": ["excel formula countifs", "insert countifs", "多條件計數公式", "COUNTIFS函數"]
},
{
    "name": "Range.Formula (SUMIFS)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SUMIFS(Sum_range, Criteria_range1, Criteria1, [Criteria_range2, Criteria2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 SUMIFS 公式，對符合所有指定多個條件的儲存格進行加總。",
    "parameters": [
        {"name": "Sum_range", "description": "要加總的儲存格範圍。"},
        {"name": "Criteria_range1", "description": "第一個條件範圍。"},
        {"name": "Criteria1", "description": "第一個條件。"}
    ],
    "examples": [
        {"code": "Range(\"P1\").Formula = \"=SUMIFS(C1:C10, A1:A10, \"\"Fruit\"\", B1:B10, \"\">5\"\")\"", "explanation": "如果A列為\"Fruit\"且B列大於5，則加總C列對應的值到P1。"}
    ],
    "keywords": ["excel formula sumifs", "insert sumifs", "多條件加總公式", "SUMIFS函數"]
},
{
    "name": "Range.Formula (AVERAGEIFS)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=AVERAGEIFS(Average_range, Criteria_range1, Criteria1, [Criteria_range2, Criteria2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 AVERAGEIFS 公式，計算符合所有指定多個條件的所有儲存格的平均值。",
    "parameters": [
        {"name": "Average_range", "description": "要計算平均值的儲存格範圍。"},
        {"name": "Criteria_range1", "description": "第一個條件範圍。"},
        {"name": "Criteria1", "description": "第一個條件。"}
    ],
    "examples": [
        {"code": "Range(\"Q1\").Formula = \"=AVERAGEIFS(C1:C10, A1:A10, \"\"North\"\", B1:B10, \"\"Q1\"\")\"", "explanation": "計算C列中，A列為\"North\"且B列為\"Q1\"的對應值的平均值，並放入Q1。"}
    ],
    "keywords": ["excel formula averageifs", "insert averageifs", "多條件平均公式", "AVERAGEIFS函數"]
},
{
    "name": "Range.Formula (LARGE)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=LARGE(Array, K)\"",
    "description": "在指定儲存格中插入 Excel 的 LARGE 公式，傳回資料集中第k個最大值。",
    "parameters": [
        {"name": "Array", "description": "數據陣列或範圍。"},
        {"name": "K", "description": "排位 (例如，1表示最大，2表示第二大)。"}
    ],
    "examples": [
        {"code": "Range(\"R1\").Formula = \"=LARGE(A1:A100, 3)\"", "explanation": "R1將顯示A1:A100範圍中第三大的值。"}
    ],
    "keywords": ["excel formula large", "insert large formula", "第k大值公式", "LARGE函數"]
},
{
    "name": "Range.Formula (SMALL)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SMALL(Array, K)\"",
    "description": "在指定儲存格中插入 Excel 的 SMALL 公式，傳回資料集中第k個最小值。",
    "parameters": [
        {"name": "Array", "description": "數據陣列或範圍。"},
        {"name": "K", "description": "排位 (例如，1表示最小，2表示第二小)。"}
    ],
    "examples": [
        {"code": "Range(\"S1\").Formula = \"=SMALL(A1:A100, 1)\"", "explanation": "S1將顯示A1:A100範圍中最小的值。"}
    ],
    "keywords": ["excel formula small", "insert small formula", "第k小值公式", "SMALL函數"]
},
{
    "name": "Range.Formula (RANK.EQ)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=RANK.EQ(Number, Ref, [Order])\"",
    "description": "在指定儲存格中插入 Excel 的 RANK.EQ 公式，傳回一個數字在一組數字中的排名。如果多個值具有相同的排名，則傳回該組值的最高排名。",
    "parameters": [
        {"name": "Number", "description": "要排名的數字。"},
        {"name": "Ref", "description": "數字列表的範圍或陣列。"},
        {"name": "Order", "description": "0 (降冪) 或 1 (升冪)。"}
    ],
    "examples": [
        {"code": "Range(\"B1\").Formula = \"=RANK.EQ(A1, A$1:A$20, 0)\"", "explanation": "B1將顯示A1在A1:A20範圍內的降冪排名。"}
    ],
    "keywords": ["excel formula rank.eq", "insert rank formula", "排名公式", "RANK.EQ函數"]
},
{
    "name": "Range.Formula (SUBTOTAL)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SUBTOTAL(Function_num, Ref1, [Ref2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 SUBTOTAL 公式，傳回清單或資料庫中的小計。可以指定是否包含隱藏列。",
    "parameters": [
        {"name": "Function_num", "description": "1-11 (包含隱藏值) 或 101-111 (忽略隱藏值) 的數字，指定使用的函數 (例如 9/109=SUM, 1/101=AVERAGE, 2/102=COUNT, 3/103=COUNTA)。"},
        {"name": "Ref1, Ref2, ...", "description": "要進行小計的範圍。"}
    ],
    "examples": [
        {"code": "Range(\"A101\").Formula = \"=SUBTOTAL(9, A1:A100)\"", "explanation": "A101將計算A1:A100範圍的總和，且此總和會根據篩選結果動態變化 (如果使用 Function_num 109，則忽略篩選隱藏的列)。"}
    ],
    "keywords": ["excel formula subtotal", "insert subtotal", "分類匯總公式", "SUBTOTAL函數"]
},
{
    "name": "Range.Formula (IF with ISBLANK)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=IF(ISBLANK(Cell_to_check), Value_if_blank, Value_if_not_blank)\"",
    "description": "在指定儲存格中插入 Excel 的 IF 和 ISBLANK 組合公式，用於檢查某儲存格是否為空，並根據結果傳回不同的值。",
    "parameters": [
        {"name": "Cell_to_check", "description": "要檢查是否為空的儲存格。"},
        {"name": "Value_if_blank", "description": "如果檢查的儲存格為空，則傳回此值。"},
        {"name": "Value_if_not_blank", "description": "如果檢查的儲存格不為空，則傳回此值。"}
    ],
    "examples": [
        {"code": "Range(\"B1\").Formula = \"=IF(ISBLANK(A1), \"\"資料缺失\"\", A1*2)\"", "explanation": "如果A1儲存格為空，B1顯示\"資料缺失\"；否則，B1顯示A1的值乘以2。"}
    ],
    "keywords": ["excel formula if isblank", "check empty cell formula", "ISBLANK公式"]
},
{
    "name": "Range.FormulaR1C1 (SUM Relative)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaR1C1 = \"=SUM(RC[-2]:RC[-1])\"",
    "description": "使用 R1C1 參照樣式在指定儲存格中插入 SUM 公式，對其左側兩個儲存格進行加總。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"C5\").FormulaR1C1 = \"=SUM(RC[-2]:RC[-1])\"", "explanation": "儲存格C5將包含公式 `=SUM(A5:B5)` (以A1樣式表示)。"}
    ],
    "keywords": ["excel r1c1 sum", "relative sum formula r1c1", "R1C1相對加總"]
},
{
    "name": "Range.FormulaR1C1 (IF Relative)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.FormulaR1C1 = \"=IF(RC[-1]>10, \"\"OK\"\", \"\"Review\"\")\"",
    "description": "使用 R1C1 參照樣式在指定儲存格中插入 IF 公式，檢查其左側儲存格的值。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"B2\").FormulaR1C1 = \"=IF(RC[-1]>100, RC[-1]*0.1, RC[-1]*0.05)\"", "explanation": "儲存格B2將根據A2的值計算：如果A2大於100，則為A2的10%；否則為A2的5%。"}
    ],
    "keywords": ["excel r1c1 if", "relative if formula r1c1", "R1C1相對IF"]
},
{
    "name": "Range.Formula (MEDIAN)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=MEDIAN(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 MEDIAN 公式，以傳回一組數值的中位數。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "要計算中位數的數值、儲存格參照或範圍。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A5\").Value = Application.Transpose(Array(10,50,20,40,30))\nRange(\"B1\").Formula = \"=MEDIAN(A1:A5)\"", "explanation": "B1儲存格將顯示A1:A5範圍內數值的中位數 (排序後為10,20,30,40,50，中位數是30)。"}
    ],
    "keywords": ["excel formula median", "insert median formula", "中位數公式", "MEDIAN函數"]
},
{
    "name": "Range.Formula (MODE.SNGL - Excel 2010+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=MODE.SNGL(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 MODE.SNGL 公式，傳回資料集中出現頻率最高的值 (眾數)。如果有多個眾數，傳回第一個。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "要計算眾數的數值、儲存格參照或範圍。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A7\").Value = Application.Transpose(Array(1,2,2,3,4,4,4))\nRange(\"C1\").Formula = \"=MODE.SNGL(A1:A7)\"", "explanation": "C1儲存格將顯示A1:A7範圍內出現次數最多的數字 (此例中為4)。"}
    ],
    "keywords": ["excel formula mode.sngl", "insert mode formula", "眾數公式", "MODE.SNGL函數"]
},
{
    "name": "Range.Formula (DATEDIF - Hidden Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DATEDIF(Start_date, End_date, Unit)\"",
    "description": "在指定儲存格中插入 Excel 的 DATEDIF 公式，用於計算兩個日期之間的年、月或日數。注意：DATEDIF 是一個隱藏函數，在公式自動完成中可能不顯示，但仍然可用。",
    "parameters": [
        {"name": "Start_date", "description": "開始日期。"},
        {"name": "End_date", "description": "結束日期。"},
        {"name": "Unit", "description": "要傳回的時間單位字串 (\"Y\"=年, \"M\"=月, \"D\"=日, \"YM\"=月(忽略年日), \"YD\"=日(忽略年), \"MD\"=日(忽略年月))。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2020, 1, 15)\nRange(\"B1\").Value = DateSerial(2023, 5, 25)\nRange(\"C1\").Formula = \"=DATEDIF(A1, B1, \"\"Y\"\")\" ' Complete years\nRange(\"D1\").Formula = \"=DATEDIF(A1, B1, \"\"M\"\")\" ' Complete months\nRange(\"E1\").Formula = \"=DATEDIF(A1, B1, \"\"D\"\")\" ' Total days", "explanation": "C1計算A1和B1之間相差的完整年數。D1計算完整月數。E1計算總天數。"}
    ],
    "keywords": ["excel formula datedif", "insert datedif", "日期差異計算", "DATEDIF函數"]
},
{
    "name": "Range.Formula (ISBLANK)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ISBLANK(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 ISBLANK 公式，用於檢查指定的儲存格是否為空。如果是，則傳回 TRUE；否則傳回 FALSE。",
    "parameters": [
        {"name": "Value", "description": "要檢查的儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").ClearContents\nRange(\"A2\").Value = \"Not Empty\"\nRange(\"B1\").Formula = \"=ISBLANK(A1)\"\nRange(\"B2\").Formula = \"=ISBLANK(A2)\"", "explanation": "B1將顯示 TRUE (因為A1是空的)。B2將顯示 FALSE (因為A2不是空的)。"}
    ],
    "keywords": ["excel formula isblank", "insert isblank", "檢查空儲存格公式", "ISBLANK函數"]
},
{
    "name": "Range.Formula (ISTEXT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ISTEXT(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 ISTEXT 公式，用於檢查指定的值是否為文字。如果是，則傳回 TRUE；否則傳回 FALSE。",
    "parameters": [
        {"name": "Value", "description": "要檢查的值或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Hello\"\nRange(\"A2\").Value = 123\nRange(\"C1\").Formula = \"=ISTEXT(A1)\"\nRange(\"C2\").Formula = \"=ISTEXT(A2)\"", "explanation": "C1將顯示 TRUE (因為A1是文字)。C2將顯示 FALSE (因為A2是數字)。"}
    ],
    "keywords": ["excel formula istext", "insert istext", "檢查文字公式", "ISTEXT函數"]
},
{
    "name": "Range.Formula (ISNUMBER)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ISNUMBER(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 ISNUMBER 公式，用於檢查指定的值是否為數字。如果是，則傳回 TRUE；否則傳回 FALSE。",
    "parameters": [
        {"name": "Value", "description": "要檢查的值或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 123.45\nRange(\"A2\").Value = \"Excel\"\nRange(\"D1\").Formula = \"=ISNUMBER(A1)\"\nRange(\"D2\").Formula = \"=ISNUMBER(A2)\"", "explanation": "D1將顯示 TRUE (因為A1是數字)。D2將顯示 FALSE (因為A2是文字)。"}
    ],
    "keywords": ["excel formula isnumber", "insert isnumber", "檢查數字公式", "ISNUMBER函數"]
},
{
    "name": "Range.Formula (CONCAT - Excel 2019+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=CONCAT(Text1, [Text2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 CONCAT 公式 (Excel 2019 及更新版本，或 Microsoft 365)，用於連接多個文字字串或範圍中的文字。與舊版 CONCATENATE 函數類似，但可以接受範圍作為參數。",
    "parameters": [
        {"name": "Text1, Text2, ...", "description": "要連接的文字項目或儲存格範圍。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Hello\"\nRange(\"B1\").Value = \"World\"\nRange(\"C1\").Value = \"!\"\nRange(\"F2\").Formula = \"=CONCAT(A1, \"\" \"\", B1, C1)\" ' For earlier Excel, use CONCATENATE or &\n' In Excel 2019+/M365, CONCAT can take a range:\n' Range(\"F3\").Formula = \"=CONCAT(A1:C1)\" ' This would result in \"HelloWorld!\"", "explanation": "F2將顯示 \"Hello World!\"。如果Excel版本支援，F3演示了CONCAT接受範圍參數的功能，會將A1到C1的內容連接起來。"}
    ],
    "keywords": ["excel formula concat", "insert concat formula", "連接字串範圍", "CONCAT函數"]
},
// Excel 核心操作 - Logical Formulas
{
    "name": "Range.Formula (NOT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=NOT(Logical)\"",
    "description": "在指定儲存格中插入 Excel 的 NOT 公式，用於反轉其參數的邏輯值。如果 Logical 為 FALSE，則傳回 TRUE；如果 Logical 為 TRUE，則傳回 FALSE。",
    "parameters": [
        {"name": "Logical", "description": "一個可以評估為 TRUE 或 FALSE 的值或運算式。"}
    ],
    "examples": [
        {"code": "Range(\"B1\").Formula = \"=NOT(A1>10)\"", "explanation": "如果A1的值不大於10，則B1顯示TRUE；否則顯示FALSE。"}
    ],
    "keywords": ["excel formula not", "insert not formula", "邏輯非公式", "NOT函數"]
},
{
    "name": "Range.Formula (IFNA - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=IFNA(Value, Value_if_na)\"",
    "description": "在指定儲存格中插入 Excel 的 IFNA 公式 (Excel 2013+)。如果 Value 運算式計算結果為 #N/A 錯誤，則傳回 Value_if_na；否則傳回 Value 運算式的結果。",
    "parameters": [
        {"name": "Value", "description": "要檢查是否有 #N/A 錯誤的運算式。"},
        {"name": "Value_if_na", "description": "如果 Value 評估為 #N/A 時要傳回的值。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=IFNA(VLOOKUP(A1, Sheet2!A:B, 2, FALSE), \"\"未找到\"\")\"", "explanation": "執行VLOOKUP，如果VLOOKUP的結果是#N/A錯誤，則C1顯示\"未找到\"，否則顯示VLOOKUP的結果。"}
    ],
    "keywords": ["excel formula ifna", "insert ifna formula", "handle na error", "IFNA函數"]
},
{
    "name": "Range.Formula (IFS - Excel 2019+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=IFS(Logical_test1, Value_if_true1, [Logical_test2, Value_if_true2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 IFS 公式 (Excel 2019+)。檢查是否符合一或多個條件，並傳回符合第一個 TRUE 條件的值。IFS 可以取代多個巢狀 IF 語句。",
    "parameters": [
        {"name": "Logical_test1", "description": "第一個要評估的邏輯條件。"},
        {"name": "Value_if_true1", "description": "如果 Logical_test1 為 TRUE 時傳回的值。"},
        {"name": "Logical_test2, Value_if_true2, ...", "description": "可選。後續的條件和值對。"}
    ],
    "examples": [
        {"code": "Range(\"D1\").Formula = \"=IFS(A1>90, \"\"A\"\", A1>75, \"\"B\"\", A1>60, \"\"C\"\", TRUE, \"\"F\"\")\"", "explanation": "根據A1中的分數給出等級：大於90為A，大於75為B，大於60為C，否則為F。"}
    ],
    "keywords": ["excel formula ifs", "insert ifs formula", "multiple if conditions", "IFS函數"]
},
{
    "name": "Range.Formula (SWITCH - Excel 2019+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SWITCH(Expression, Value1, Result1, [Value2, Result2], ..., [Default_or_Value_N, Result_N], [Default])\"",
    "description": "在指定儲存格中插入 Excel 的 SWITCH 公式 (Excel 2019+)。將運算式與一系列值進行比較，並傳回與第一個相符值對應的結果。如果沒有相符項，則可以傳回可選的預設值。",
    "parameters": [
        {"name": "Expression", "description": "要評估的運算式。"},
        {"name": "Value1, Result1", "description": "第一個要與Expression比較的值及其對應的結果。"},
        {"name": "Default (optional)", "description": "如果沒有其他Value匹配Expression，則傳回此值。"}
    ],
    "examples": [
        {"code": "Range(\"E1\").Formula = \"=SWITCH(A1, 1, \"\"星期一\"\", 2, \"\"星期二\"\", 3, \"\"星期三\"\", \"\"其他\"\")\"", "explanation": "如果A1是1，E1顯示\"星期一\"；如果是2，顯示\"星期二\"；如果是3，顯示\"星期三\"；否則顯示\"其他\"。"}
    ],
    "keywords": ["excel formula switch", "insert switch formula", "multi-branch conditional", "SWITCH函數"]
},
{
    "name": "Range.Formula (XOR - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=XOR(Logical1, [Logical2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 XOR 公式 (Excel 2013+)，傳回所有參數的邏輯異或。如果為 TRUE 的參數個數為奇數，則結果為 TRUE；如果為 TRUE 的參數個數為偶數，則結果為 FALSE。",
    "parameters": [
        {"name": "Logical1, Logical2, ...", "description": "1到254個要測試的條件。"}
    ],
    "examples": [
        {"code": "Range(\"F1\").Formula = \"=XOR(A1>10, B1>20)\"", "explanation": "如果A1>10和B1>20中只有一個為真，則F1顯示TRUE；如果兩者都為真或都為假，則顯示FALSE。"}
    ],
    "keywords": ["excel formula xor", "insert xor formula", "logical exclusive or", "XOR函數", "邏輯異或"]
},
// Excel 核心操作 - Text Formulas
{
    "name": "Range.Formula (SUBSTITUTE)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SUBSTITUTE(Text, Old_text, New_text, [Instance_num])\"",
    "description": "在指定儲存格中插入 Excel 的 SUBSTITUTE 公式，用新文字取代文字字串中的舊文字。",
    "parameters": [
        {"name": "Text", "description": "包含要取代字元的文字。"},
        {"name": "Old_text", "description": "要取代的文字。"},
        {"name": "New_text", "description": "要取代 Old_text 的文字。"},
        {"name": "Instance_num", "description": "可選。指定要取代 Old_text 的第幾個實例。如果省略，則取代所有實例。"}
    ],
    "examples": [
        {"code": "Range(\"B1\").Formula = \"=SUBSTITUTE(A1, \"\"2023\"\", \"\"2024\"\")\"", "explanation": "儲存格B1將顯示A1內容中所有\"2023\"被\"2024\"取代後的結果。"},
        {"code": "Range(\"C1\").Formula = \"=SUBSTITUTE(A1, \"\"-\"\", \"\"/\"\", 2)\"", "explanation": "儲存格C1將顯示A1內容中第二個\"-\"被\"/\"取代後的結果。"}
    ],
    "keywords": ["excel formula substitute", "insert substitute formula", "replace text formula", "SUBSTITUTE函數"]
},
{
    "name": "Range.Formula (REPT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=REPT(Text, Number_times)\"",
    "description": "在指定儲存格中插入 Excel 的 REPT 公式，用於將文字重複指定的次數。",
    "parameters": [
        {"name": "Text", "description": "要重複的文字。"},
        {"name": "Number_times", "description": "指定文字重複次數的正數。"}
    ],
    "examples": [
        {"code": "Range(\"D1\").Formula = \"=REPT(\"*\"\", 5)\"", "explanation": "儲存格D1將顯示五個星號 \"*****\"。"},
        {"code": "Range(\"E1\").Formula = \"=REPT(A1, 3)\"", "explanation": "儲存格E1將顯示A1儲存格內容重複三次的結果。"}
    ],
    "keywords": ["excel formula rept", "insert rept formula", "repeat text formula", "REPT函數"]
},
{
    "name": "Range.Formula (EXACT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=EXACT(Text1, Text2)\"",
    "description": "在指定儲存格中插入 Excel 的 EXACT 公式，比較兩個文字字串是否完全相同 (區分大小寫)。如果相同，則傳回 TRUE；否則傳回 FALSE。",
    "parameters": [
        {"name": "Text1", "description": "第一個文字字串。"},
        {"name": "Text2", "description": "第二個文字字串。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=EXACT(A1, B1)\"", "explanation": "儲存格C1將比較A1和B1的內容是否完全相同 (包括大小寫)。"}
    ],
    "keywords": ["excel formula exact", "insert exact formula", "compare strings case sensitive", "EXACT函數"]
},
{
    "name": "Range.Formula (CLEAN)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=CLEAN(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 CLEAN 公式，移除文字中所有不可列印的字元。",
    "parameters": [
        {"name": "Text", "description": "要移除不可列印字元的文字。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Text with \" & Chr(7) & \" bell character.\"\nRange(\"B1\").Formula = \"=CLEAN(A1)\"", "explanation": "儲存格B1將顯示A1內容移除不可列印的響鈴字元(Chr(7))後的結果。"}
    ],
    "keywords": ["excel formula clean", "insert clean formula", "remove nonprinting characters", "CLEAN函數"]
},
{
    "name": "Range.Formula (CHAR - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=CHAR(Number)\"",
    "description": "在指定儲存格中插入 Excel 的 CHAR 公式，根據指定的字元碼傳回對應的字元。",
    "parameters": [
        {"name": "Number", "description": "1到255之間的數字，指定要傳回的字元。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=CHAR(65)\"", "explanation": "儲存格C1將顯示字元 'A' (ASCII碼65)。"}
    ],
    "keywords": ["excel formula char", "insert char formula", "character from code", "CHAR函數"]
},
{
    "name": "Range.Formula (CODE - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=CODE(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 CODE 公式，傳回文字字串中第一個字元的字元碼。",
    "parameters": [
        {"name": "Text", "description": "要獲取其第一個字元代碼的文字。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Apple\"\nRange(\"D1\").Formula = \"=CODE(A1)\"", "explanation": "儲存格D1將顯示字元 'A' 的ASCII碼 (65)。"}
    ],
    "keywords": ["excel formula code", "insert code formula", "get character code", "CODE函數"]
},
{
    "name": "Range.Formula (VALUE - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=VALUE(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 VALUE 公式，將代表數字的文字字串轉換為數字。",
    "parameters": [
        {"name": "Text", "description": "要轉換為數字的文字字串 (例如 \"123.45\" 或儲存格參照)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"'1234.50\" ' Text number\nRange(\"E1\").Formula = \"=VALUE(A1)\"\nRange(\"E1\").NumberFormat = \"0.00\"", "explanation": "如果A1包含文字\"'1234.50\"，E1將其轉換為數字1234.50。"}
    ],
    "keywords": ["excel formula value", "insert value formula", "text to number formula", "VALUE函數"]
},
{
    "name": "Range.Formula (FIXED)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=FIXED(Number, [Decimals As Long = 2], [No_commas As Boolean = FALSE])\"",
    "description": "在指定儲存格中插入 Excel 的 FIXED 公式，將數字四捨五入到指定的小數位數，並以文字格式傳回結果 (可選擇是否包含千位分隔符)。",
    "parameters": [
        {"name": "Number", "description": "要四捨五入並轉換的數字。"},
        {"name": "Decimals", "description": "可選。小數位數。預設為2。"},
        {"name": "No_commas", "description": "可選。TRUE 表示不顯示千位分隔符。預設為FALSE。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 12345.6789\nRange(\"F1\").Formula = \"=FIXED(A1, 2, FALSE)\" ' Results in text \"12,345.68\"\nRange(\"F2\").Formula = \"=FIXED(A1, 0, TRUE)\"  ' Results in text \"12346\"", "explanation": "F1將A1的值格式化為帶逗號且兩位小數的文字。F2格式化為無逗號的整數文字。"}
    ],
    "keywords": ["excel formula fixed", "insert fixed formula", "format number as text", "FIXED函數"]
},
{
    "name": "Range.Formula (DOLLAR)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DOLLAR(Number, [Decimals As Long = 2])\"",
    "description": "在指定儲存格中插入 Excel 的 DOLLAR 公式，將數字轉換為使用貨幣格式的文字，並可指定小數位數。",
    "parameters": [
        {"name": "Number", "description": "要轉換的數字。"},
        {"name": "Decimals", "description": "可選。小數位數。預設為2。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 123.789\nRange(\"G1\").Formula = \"=DOLLAR(A1, 2)\" ' E.g., \"$123.79\"\nRange(\"G2\").Formula = \"=DOLLAR(A1, 0)\" ' E.g., \"$124\"", "explanation": "G1將A1的值格式化為帶貨幣符號且兩位小數的文字。"}
    ],
    "keywords": ["excel formula dollar", "insert dollar formula", "currency format as text", "DOLLAR函數"]
},
{
    "name": "Range.Formula (SEARCH)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SEARCH(Find_text, Within_text, [Start_num])\"",
    "description": "在指定儲存格中插入 Excel 的 SEARCH 公式，用於在一個文字字串中尋找另一個文字字串的起始位置。SEARCH 不區分大小寫。可以使用萬用字元。",
    "parameters": [
        {"name": "Find_text", "description": "要尋找的文字 (可含萬用字元 ?*)。"},
        {"name": "Within_text", "description": "包含要尋找文字的文字。"},
        {"name": "Start_num", "description": "可選。指定搜尋的起始字元位置。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Hello VBA World\"\nRange(\"H1\").Formula = \"=SEARCH(\"\"vba\"\", A1)\"", "explanation": "H1將顯示小寫\"vba\"在A1中首次出現的位置 (因為SEARCH不區分大小寫，所以會找到\"VBA\")。"}
    ],
    "keywords": ["excel formula search", "insert search formula", "find substring case insensitive", "SEARCH函數"]
},
{
    "name": "Range.Formula (T)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=T(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 T 公式。如果 Value 是文字，則傳回 Value。如果 Value 不是文字，則傳回空字串 \"\"。",
    "parameters": [
        {"name": "Value", "description": "要測試的值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Sample Text\"\nRange(\"A2\").Value = 123\nRange(\"I1\").Formula = \"=T(A1)\" ' Returns \"Sample Text\"\nRange(\"I2\").Formula = \"=T(A2)\" ' Returns \"\"", "explanation": "I1顯示A1的文字內容，I2顯示空字串因為A2是數字。"}
    ],
    "keywords": ["excel formula t", "insert t formula", "is text check formula", "T函數"]
},
{
    "name": "Range.Formula (UNICHAR - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=UNICHAR(Number)\"",
    "description": "在指定儲存格中插入 Excel 的 UNICHAR 公式 (Excel 2013+)，傳回由給定 Unicode 數字代碼代表的字元。",
    "parameters": [
        {"name": "Number", "description": "Unicode 字元碼 (十進制)。"}
    ],
    "examples": [
        {"code": "Range(\"J1\").Formula = \"=UNICHAR(8364)\"", "explanation": "J1將顯示歐元符號 € (Unicode 8364)。"}
    ],
    "keywords": ["excel formula unichar", "insert unichar", "unicode character formula", "UNICHAR函數"]
},
{
    "name": "Range.Formula (UNICODE - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=UNICODE(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 UNICODE 公式 (Excel 2013+)，傳回文字中第一個字元的 Unicode (十進制) 字元碼。",
    "parameters": [
        {"name": "Text", "description": "要獲取其第一個字元 Unicode 碼的文字。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"€\"\nRange(\"K1\").Formula = \"=UNICODE(A1)\"", "explanation": "如果A1是歐元符號€，K1將顯示其 Unicode 碼 8364。"}
    ],
    "keywords": ["excel formula unicode", "insert unicode function", "get unicode value", "UNICODE函數"]
},
{
    "name": "Range.Formula (CONCATENATE - Legacy)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=CONCATENATE(Text1, [Text2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 CONCATENATE 公式，用於連接多個文字字串。在新版 Excel 中，通常建議使用 `&` 運算子或 `CONCAT` / `TEXTJOIN` 函數。",
    "parameters": [
        {"name": "Text1, Text2, ...", "description": "要連接的1到255個文字項目。"}
    ],
    "examples": [
        {"code": "Range(\"L1\").Formula = \"=CONCATENATE(A1, \"\" \"\", B1, \"\" from \"\", C1)\"", "explanation": "L1將顯示A1, 空格, B1, \" from \", 和 C1內容的組合。"}
    ],
    "keywords": ["excel formula concatenate legacy", "insert concatenate", "舊版字串連接", "CONCATENATE函數"]
},
// Excel 核心操作 - Date & Time Formulas
{
    "name": "Range.Formula (DATEVALUE - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DATEVALUE(Date_text)\"",
    "description": "在指定儲存格中插入 Excel 的 DATEVALUE 公式，將儲存為文字的日期轉換為 Excel 日期序列號。",
    "parameters": [
        {"name": "Date_text", "description": "代表日期的文字字串。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"'2023/12/31\" ' Text date\nRange(\"B1\").Formula = \"=DATEVALUE(A1)\"\nRange(\"B1\").NumberFormat = \"yyyy-mm-dd\"", "explanation": "如果A1包含文字 \"'2023/12/31\"，B1將其轉換為日期序列號並格式化顯示。"}
    ],
    "keywords": ["excel formula datevalue", "insert datevalue", "text to date formula", "DATEVALUE函數"]
},
{
    "name": "Range.Formula (TIME - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=TIME(Hour, Minute, Second)\"",
    "description": "在指定儲存格中插入 Excel 的 TIME 公式，根據指定的小時、分鐘和秒傳回時間序列號。",
    "parameters": [
        {"name": "Hour", "description": "0到23之間的小時數。"},
        {"name": "Minute", "description": "0到59之間的分鐘數。"},
        {"name": "Second", "description": "0到59之間的秒數。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=TIME(14, 30, 15)\"\nRange(\"C1\").NumberFormat = \"h:mm:ss AM/PM\"", "explanation": "C1將顯示時間下午2點30分15秒。"}
    ],
    "keywords": ["excel formula time", "insert time formula", "create time value", "TIME函數"]
},
{
    "name": "Range.Formula (TIMEVALUE - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=TIMEVALUE(Time_text)\"",
    "description": "在指定儲存格中插入 Excel 的 TIMEVALUE 公式，將儲存為文字的時間轉換為 Excel 時間序列號 (介於0和0.99988426之間的小數)。",
    "parameters": [
        {"name": "Time_text", "description": "代表時間的文字字串。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"'3:45 PM\"\nRange(\"D1\").Formula = \"=TIMEVALUE(A1)\"\nRange(\"D1\").NumberFormat = \"h:mm AM/PM\"", "explanation": "如果A1包含文字 \"'3:45 PM\"，D1將其轉換為時間序列號並格式化顯示。"}
    ],
    "keywords": ["excel formula timevalue", "insert timevalue", "text to time formula", "TIMEVALUE函數"]
},
{
    "name": "Range.Formula (HOUR - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=HOUR(Serial_number)\"",
    "description": "在指定儲存格中插入 Excel 的 HOUR 公式，從時間序列號中提取小時部分 (0到23)。",
    "parameters": [
        {"name": "Serial_number", "description": "包含時間的儲存格或時間值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=NOW()\"\nRange(\"E1\").Formula = \"=HOUR(A1)\"", "explanation": "E1將顯示A1中時間的小時部分。"}
    ],
    "keywords": ["excel formula hour", "insert hour formula", "get hour from time", "HOUR函數"]
},
{
    "name": "Range.Formula (MINUTE - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=MINUTE(Serial_number)\"",
    "description": "在指定儲存格中插入 Excel 的 MINUTE 公式，從時間序列號中提取分鐘部分 (0到59)。",
    "parameters": [
        {"name": "Serial_number", "description": "包含時間的儲存格或時間值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=NOW()\"\nRange(\"F1\").Formula = \"=MINUTE(A1)\"", "explanation": "F1將顯示A1中時間的分鐘部分。"}
    ],
    "keywords": ["excel formula minute", "insert minute formula", "get minute from time", "MINUTE函數"]
},
{
    "name": "Range.Formula (SECOND - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SECOND(Serial_number)\"",
    "description": "在指定儲存格中插入 Excel 的 SECOND 公式，從時間序列號中提取秒部分 (0到59)。",
    "parameters": [
        {"name": "Serial_number", "description": "包含時間的儲存格或時間值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=NOW()\"\nRange(\"G1\").Formula = \"=SECOND(A1)\"", "explanation": "G1將顯示A1中時間的秒部分。"}
    ],
    "keywords": ["excel formula second", "insert second formula", "get second from time", "SECOND函數"]
},
{
    "name": "Range.Formula (WEEKDAY - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=WEEKDAY(Serial_number, [Return_type])\"",
    "description": "在指定儲存格中插入 Excel 的 WEEKDAY 公式，傳回對應於某個日期的星期幾 (數字)。",
    "parameters": [
        {"name": "Serial_number", "description": "日期。"},
        {"name": "Return_type", "description": "可選。決定傳回值類型的數字 (1=週日為1到週六為7；2=週一為1到週日為7；3=週一為0到週日為6)。預設為1。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2023,10,29) ' A Sunday\nRange(\"H1\").Formula = \"=WEEKDAY(A1, 2)\"", "explanation": "H1將顯示A1日期 (2023/10/29) 是星期幾 (使用Return_type 2，週一為1，則週日為7)。"}
    ],
    "keywords": ["excel formula weekday", "insert weekday", "day of week number", "WEEKDAY函數"]
},
{
    "name": "Range.Formula (WEEKNUM - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=WEEKNUM(Serial_number, [Return_type])\"",
    "description": "在指定儲存格中插入 Excel 的 WEEKNUM 公式，傳回特定日期在一年中的第幾週。",
    "parameters": [
        {"name": "Serial_number", "description": "日期。"},
        {"name": "Return_type", "description": "可選。決定一週從哪一天開始的數字 (1=週日開始，2=週一開始)。預設為1。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2024,1,10)\nRange(\"I1\").Formula = \"=WEEKNUM(A1, 2)\"", "explanation": "I1將顯示2024年1月10日是該年的第幾週 (假設週一為每週第一天)。"}
    ],
    "keywords": ["excel formula weeknum", "insert weeknum", "week number of year", "WEEKNUM函數"]
},
{
    "name": "Range.Formula (WORKDAY - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=WORKDAY(Start_date, Days, [Holidays])\"",
    "description": "在指定儲存格中插入 Excel 的 WORKDAY 公式，傳回某個日期 (Start_date) 之前或之後指定工作日數的日期序列號 (排除週末和假日)。",
    "parameters": [
        {"name": "Start_date", "description": "開始日期。"},
        {"name": "Days", "description": "工作日數 (正數為未來，負數為過去)。"},
        {"name": "Holidays", "description": "可選。要排除的假日日期範圍。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2023,10,25)\nRange(\"J1\").Formula = \"=WORKDAY(A1, 5)\" ' 5個工作日後", "explanation": "J1將顯示從2023年10月25日起，5個工作日之後的日期。"}
    ],
    "keywords": ["excel formula workday", "insert workday", "calculate working days", "WORKDAY函數"]
},
{
    "name": "Range.Formula (WORKDAY.INTL - Excel 2010+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=WORKDAY.INTL(Start_date, Days, [Weekend], [Holidays])\"",
    "description": "在指定儲存格中插入 Excel 的 WORKDAY.INTL 公式 (Excel 2010+)，傳回指定工作日數之前或之後的日期，可自訂週末和假日。",
    "parameters": [
        {"name": "Weekend", "description": "可選。指定週末日期的數字或字串 (例如 1=週六日, 11=僅週日)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2023,10,25)\nRange(\"K1\").Formula = \"=WORKDAY.INTL(A1, 5, 11)\" ' 5個工作日後，週末僅週日", "explanation": "K1將計算從A1起5個工作日後的日期，並將週末定義為僅週日。"}
    ],
    "keywords": ["excel formula workday.intl", "custom weekend workday", "WORKDAY.INTL函數"]
},
{
    "name": "Range.Formula (EDATE)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=EDATE(Start_date, Months)\"",
    "description": "在指定儲存格中插入 Excel 的 EDATE 公式，傳回某個日期 (Start_date) 之前或之後指定月份數的日期序列號。",
    "parameters": [
        {"name": "Start_date", "description": "開始日期。"},
        {"name": "Months", "description": "月份數。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2023,1,31)\nRange(\"L1\").Formula = \"=EDATE(A1, 1)\" ' 1個月後 (2023/2/28)\nRange(\"L2\").Formula = \"=EDATE(A1, -3)\" ' 3個月前 (2022/10/31)", "explanation": "L1顯示A1日期的一個月後，L2顯示三個月前。EDATE會自動調整到月底。"}
    ],
    "keywords": ["excel formula edate", "insert edate", "add months to date", "EDATE函數"]
},
{
    "name": "Range.Formula (YEARFRAC)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=YEARFRAC(Start_date, End_date, [Basis])\"",
    "description": "在指定儲存格中插入 Excel 的 YEARFRAC 公式，傳回代表兩個日期之間完整天數的年份分數。",
    "parameters": [
        {"name": "Basis", "description": "可選。日計數基準類型 (0=美國(NASD)30/360, 1=實際/實際, 2=實際/360, 3=實際/365, 4=歐洲30/360)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2023,1,1)\nRange(\"B1\").Value = DateSerial(2023,7,1)\nRange(\"M1\").Formula = \"=YEARFRAC(A1, B1, 1)\"", "explanation": "M1計算2023年1月1日到7月1日之間的年份分數 (使用實際/實際基準)。"}
    ],
    "keywords": ["excel formula yearfrac", "insert yearfrac", "fraction of year", "YEARFRAC函數"]
},
{
    "name": "Range.Formula (DAYS - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DAYS(End_date, Start_date)\"",
    "description": "在指定儲存格中插入 Excel 的 DAYS 公式 (Excel 2013+)，傳回兩個日期之間的天數。",
    "parameters": [
        {"name": "End_date", "description": "結束日期。"},
        {"name": "Start_date", "description": "開始日期。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2023,10,1)\nRange(\"B1\").Value = DateSerial(2023,10,15)\nRange(\"N1\").Formula = \"=DAYS(B1, A1)\"", "explanation": "N1計算B1和A1之間相差的天數 (結果為14)。"}
    ],
    "keywords": ["excel formula days", "insert days", "difference between dates days", "DAYS函數"]
},
{
    "name": "Range.Formula (ISOWEEKNUM - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ISOWEEKNUM(Date)\"",
    "description": "在指定儲存格中插入 Excel 的 ISOWEEKNUM 公式 (Excel 2013+)，傳回給定日期在該年中依照 ISO 8601 標準的週次。",
    "parameters": [
        {"name": "Date", "description": "日期。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = DateSerial(2024,1,3)\nRange(\"O1\").Formula = \"=ISOWEEKNUM(A1)\"", "explanation": "O1將顯示2024年1月3日的ISO週次。"}
    ],
    "keywords": ["excel formula isoweeknum", "insert isoweeknum", "iso week number", "ISOWEEKNUM函數"]
},
// Excel 核心操作 - Lookup & Reference Formulas
{
    "name": "Range.Formula (OFFSET)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=OFFSET(Reference, Rows, Cols, [Height], [Width])\"",
    "description": "在指定儲存格中插入 Excel 的 OFFSET 公式，傳回相對於某個儲存格或儲存格範圍的參照，該參照由指定的列數和欄數偏移。",
    "parameters": [
        {"name": "Reference", "description": "作為偏移基準的儲存格參照。"},
        {"name": "Rows", "description": "向上或向下偏移的列數。"},
        {"name": "Cols", "description": "向左或向右偏移的欄數。"},
        {"name": "Height", "description": "可選。傳回參照的高度 (列數)。"},
        {"name": "Width", "description": "可選。傳回參照的寬度 (欄數)。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=OFFSET(A1, 2, 1)\" ' Returns value of B3", "explanation": "C1將顯示相對於A1向下2列、向右1欄的儲存格 (即B3) 的值。"},
        {"code": "Range(\"D1\").Formula = \"=SUM(OFFSET(A1, 1, 0, 3, 1))\" ' Sums A2:A4", "explanation": "D1將加總從A1向下偏移1列開始，高度為3列，寬度為1欄的範圍 (即A2:A4) 的值。"}
    ],
    "keywords": ["excel formula offset", "insert offset", "relative range reference", "OFFSET函數"]
},
{
    "name": "Range.Formula (INDIRECT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=INDIRECT(Ref_text, [A1_style As Boolean])\"",
    "description": "在指定儲存格中插入 Excel 的 INDIRECT 公式，傳回由文字字串指定的參照。可以使用此函數在公式中建構或更改儲存格參照。",
    "parameters": [
        {"name": "Ref_text", "description": "代表儲存格參照的文字字串 (例如 \"A1\", \"Sheet2!B5\")。"},
        {"name": "A1_style", "description": "可選。TRUE (預設) 表示 Ref_text 是A1樣式，FALSE 表示是R1C1樣式。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"C5\"\nRange(\"B5\").Value = 100\nRange(\"E1\").Formula = \"=INDIRECT(A1)\"", "explanation": "如果A1包含文字\"C5\"，且C5包含值(例如B5=100，則A1應為\"B5\")，E1將顯示儲存格C5的值。此例A1為\"C5\"，B5為100，若要E1顯示100，A1應為\"B5\"。這裡假設A1是\"B5\"。"}
    ],
    "keywords": ["excel formula indirect", "insert indirect", "text to reference", "INDIRECT函數"]
},
{
    "name": "Range.Formula (ADDRESS)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ADDRESS(Row_num, Column_num, [Abs_num], [A1], [Sheet_text])\"",
    "description": "在指定儲存格中插入 Excel 的 ADDRESS 公式，以文字形式建立儲存格位址。",
    "parameters": [
        {"name": "Row_num", "description": "列號。"},
        {"name": "Column_num", "description": "欄號。"},
        {"name": "Abs_num", "description": "可選。參照類型 (1=絕對, 2=列絕對/欄相對, 3=列相對/欄絕對, 4=相對)。"},
        {"name": "A1", "description": "可選。TRUE (A1樣式) 或 FALSE (R1C1樣式)。"},
        {"name": "Sheet_text", "description": "可選。工作表名稱文字。"}
    ],
    "examples": [
        {"code": "Range(\"F1\").Formula = \"=ADDRESS(5, 3, 1, TRUE, \"\"Summary\"\")\"", "explanation": "F1將顯示文字 \"Summary!$C$5\"。"}
    ],
    "keywords": ["excel formula address", "insert address", "create cell reference string", "ADDRESS函數"]
},
{
    "name": "Range.Formula (CHOOSE)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=CHOOSE(Index_num, Value1, [Value2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 CHOOSE 公式，從最多254個值的清單中選擇一個值，基於索引號。",
    "parameters": [
        {"name": "Index_num", "description": "指定要選擇哪個值參數。必須是1到254之間的數字、公式或儲存格參照。"},
        {"name": "Value1, Value2, ...", "description": "值清單。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 2\nRange(\"G1\").Formula = \"=CHOOSE(A1, \"\"蘋果\"\", \"\"香蕉\"\", \"\"櫻桃\"\")\"", "explanation": "如果A1的值是2，G1將顯示\"香蕉\"。"}
    ],
    "keywords": ["excel formula choose", "insert choose", "select from list formula", "CHOOSE函數"]
},
{
    "name": "Range.Formula (ROW - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ROW([Reference])\"",
    "description": "在指定儲存格中插入 Excel 的 ROW 公式，傳回儲存格參照的列號。",
    "parameters": [
        {"name": "Reference", "description": "可選。要獲取其列號的儲存格或範圍。如果省略，則傳回公式所在儲存格的列號。"}
    ],
    "examples": [
        {"code": "Range(\"H1\").Formula = \"=ROW()\" ' Returns row number of H1\nRange(\"H2\").Formula = \"=ROW(C5)\" ' Returns 5", "explanation": "H1顯示其自身的列號，H2顯示儲存格C5的列號 (5)。"}
    ],
    "keywords": ["excel formula row", "insert row function", "get row number formula", "ROW函數"]
},
{
    "name": "Range.Formula (COLUMN - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=COLUMN([Reference])\"",
    "description": "在指定儲存格中插入 Excel 的 COLUMN 公式，傳回儲存格參照的欄號。",
    "parameters": [
        {"name": "Reference", "description": "可選。要獲取其欄號的儲存格或範圍。如果省略，則傳回公式所在儲存格的欄號。"}
    ],
    "examples": [
        {"code": "Range(\"I1\").Formula = \"=COLUMN()\" ' Returns column number of I1\nRange(\"I2\").Formula = \"=COLUMN(D10)\" ' Returns 4 (D is 4th column)", "explanation": "I1顯示其自身的欄號，I2顯示儲存格D10的欄號 (4)。"}
    ],
    "keywords": ["excel formula column", "insert column function", "get column number formula", "COLUMN函數"]
},
{
    "name": "Range.Formula (ROWS - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ROWS(Array)\"",
    "description": "在指定儲存格中插入 Excel 的 ROWS 公式，傳回陣列或儲存格範圍中的列數。",
    "parameters": [
        {"name": "Array", "description": "一個陣列、陣列公式或對儲存格範圍的參照。"}
    ],
    "examples": [
        {"code": "Range(\"J1\").Formula = \"=ROWS(A1:C5)\"", "explanation": "J1將顯示範圍A1:C5的列數 (5)。"}
    ],
    "keywords": ["excel formula rows", "insert rows function", "count rows in range formula", "ROWS函數"]
},
{
    "name": "Range.Formula (COLUMNS - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=COLUMNS(Array)\"",
    "description": "在指定儲存格中插入 Excel 的 COLUMNS 公式，傳回陣列或儲存格範圍中的欄數。",
    "parameters": [
        {"name": "Array", "description": "一個陣列、陣列公式或對儲存格範圍的參照。"}
    ],
    "examples": [
        {"code": "Range(\"K1\").Formula = \"=COLUMNS(A1:D10)\"", "explanation": "K1將顯示範圍A1:D10的欄數 (4)。"}
    ],
    "keywords": ["excel formula columns", "insert columns function", "count columns in range formula", "COLUMNS函數"]
},
{
    "name": "Range.FormulaArray (TRANSPOSE)",
    "category": "Excel 核心操作",
    "syntax": "targetRangeObject.FormulaArray = \"=TRANSPOSE(SourceArrayOrRange)\"",
    "description": "在指定儲存格範圍中插入 Excel 的 TRANSPOSE 陣列公式，用於將垂直範圍轉換為水平範圍，或反之。",
    "parameters": [
        {"name": "SourceArrayOrRange", "description": "要轉置的陣列或儲存格範圍。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A3\").Value = Application.Transpose(Array(\"X\",\"Y\",\"Z\"))\n' Transpose A1:A3 (3 rows, 1 col) to B1:D1 (1 row, 3 cols)\nRange(\"B1:D1\").FormulaArray = \"=TRANSPOSE(A1:A3)\"", "explanation": "先將一個垂直陣列填入A1:A3，然後使用TRANSPOSE陣列公式將其轉置並填入B1:D1。"}
    ],
    "keywords": ["excel formula transpose", "insert transpose array formula", "轉置公式", "TRANSPOSE函數"]
},
{
    "name": "Range.Formula (AREAS)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=AREAS(Reference)\"",
    "description": "在指定儲存格中插入 Excel 的 AREAS 公式，傳回參照中區域的數量。區域是連續的儲存格區塊或單個儲存格。",
    "parameters": [
        {"name": "Reference", "description": "對儲存格或儲存格範圍的參照，可以是非連續的多重選取範圍。"}
    ],
    "examples": [
        {"code": "Range(\"L1\").Formula = \"=AREAS((A1:B2,D4:E5,G1))\"", "explanation": "L1將顯示由三個非連續區域 (A1:B2, D4:E5, G1) 組成的參照中的區域數量 (3)。"}
    ],
    "keywords": ["excel formula areas", "insert areas formula", "count non-contiguous areas", "AREAS函數"]
},
{
    "name": "Range.Formula (GETPIVOTDATA)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=GETPIVOTDATA(Data_field, Pivot_table, [Field1, Item1], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 GETPIVOTDATA 公式，用於從樞紐分析表中提取摘要資料。",
    "parameters": [
        {"name": "Data_field", "description": "包含要擷取資料的資料欄位名稱 (字串)。"},
        {"name": "Pivot_table", "description": "樞紐分析表左上角儲存格的參照。"},
        {"name": "FieldN, ItemN", "description": "指定篩選條件的欄位和項目對。"}
    ],
    "examples": [
        {"code": "Range(\"M1\").Formula = \"=GETPIVOTDATA(\"\"Sales\"\", Sheet2!A3, \"\"Region\"\", \"\"North\"\", \"\"Product\"\", \"\"Apples\"\")\"", "explanation": "M1將嘗試從位於Sheet2!A3的樞紐分析表中，提取\"Sales\"資料欄位下，\"Region\"為\"North\"且\"Product\"為\"Apples\"的值。"}
    ],
    "keywords": ["excel formula getpivotdata", "insert getpivotdata", "從樞紐分析表提取數據", "GETPIVOTDATA函數"]
},
{
    "name": "Range.Formula (LOOKUP - Vector Form)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=LOOKUP(Lookup_value, Lookup_vector, [Result_vector])\"",
    "description": "在指定儲存格中插入 Excel 的 LOOKUP 公式 (向量形式)。在單列或單欄範圍 (Lookup_vector) 中尋找 Lookup_value，並從第二個單列或單欄範圍 (Result_vector) 中的相同位置傳回一個值。Lookup_vector 必須按升冪排列。",
    "parameters": [
        {"name": "Lookup_value", "description": "要尋找的值。"},
        {"name": "Lookup_vector", "description": "只包含一列或一欄的範圍，必須升冪排序。"},
        {"name": "Result_vector", "description": "可選。只包含一列或一欄的範圍，大小與 Lookup_vector 相同。"}
    ],
    "examples": [
        {"code": "' Assume A1:A5 sorted: 10,20,30,40,50. B1:B5: A,B,C,D,E\nRange(\"N1\").Formula = \"=LOOKUP(25, A1:A5, B1:B5)\"", "explanation": "N1將在A1:A5中查找不大於25的最大值 (即20)，並傳回B1:B5中對應位置的值 (即B)。"}
    ],
    "keywords": ["excel formula lookup vector", "insert lookup", "LOOKUP函數向量"]
},
{
    "name": "Range.Formula (XLOOKUP - Microsoft 365)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=XLOOKUP(Lookup_value, Lookup_array, Return_array, [If_not_found], [Match_mode], [Search_mode])\"",
    "description": "在指定儲存格中插入 Excel 的 XLOOKUP 公式 (Microsoft 365)。這是一個更強大和靈活的查找函數，可以取代VLOOKUP, HLOOKUP和INDEX-MATCH的許多用法。",
    "parameters": [
        {"name": "Lookup_value", "description": "要尋找的值。"},
        {"name": "Lookup_array", "description": "要搜尋的陣列或範圍。"},
        {"name": "Return_array", "description": "要從中傳回值的陣列或範圍。"},
        {"name": "If_not_found", "description": "可選。如果未找到符合項，則傳回的值。"},
        {"name": "Match_mode", "description": "可選。0=精確符合(預設), -1=精確或下一個較小項, 1=精確或下一個較大項, 2=萬用字元符合。"},
        {"name": "Search_mode", "description": "可選。1=從頭搜尋(預設), -1=從尾搜尋, 2=二進位搜尋(升冪), -2=二進位搜尋(降冪)。"}
    ],
    "examples": [
        {"code": "Range(\"P1\").Formula = \"=XLOOKUP(O1, Sheet2!A:A, Sheet2!C:C, \"\"Not Found\"\", 0)\"", "explanation": "在P1中，使用O1的值在Sheet2的A欄中進行精確查找，並傳回Sheet2的C欄中對應的值。如果未找到，則顯示\"Not Found\"。"}
    ],
    "keywords": ["excel formula xlookup", "insert xlookup", "XLOOKUP函數", "m365"]
},
{
    "name": "Range.Formula (HYPERLINK)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=HYPERLINK(Link_location, [Friendly_name])\"",
    "description": "在指定儲存格中插入 Excel 的 HYPERLINK 公式，建立一個可點擊的超連結。",
    "parameters": [
        {"name": "Link_location", "description": "連結的路徑或URL。"},
        {"name": "Friendly_name", "description": "可選。儲存格中顯示的文字。如果省略，則顯示Link_location。"}
    ],
    "examples": [
        {"code": "Range(\"Q1\").Formula = \"=HYPERLINK(\"\"http://www.google.com\"\", \"\"Google搜尋\"\")\"", "explanation": "Q1將顯示為可點擊的文字 \"Google搜尋\"，點擊後會打開Google網站。"}
    ],
    "keywords": ["excel formula hyperlink", "insert hyperlink formula", "超連結公式", "HYPERLINK函數"]
},
{
    "name": "Range.Formula (FORMULATEXT - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=FORMULATEXT(Reference)\"",
    "description": "在指定儲存格中插入 Excel 的 FORMULATEXT 公式 (Excel 2013+)，以文字形式傳回另一個儲存格中的公式。",
    "parameters": [
        {"name": "Reference", "description": "對儲存格或儲存格範圍的參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=SUM(B1:B5)\"\nRange(\"R1\").Formula = \"=FORMULATEXT(A1)\"", "explanation": "R1將以文字形式顯示A1儲存格中的公式 (即 \"=SUM(B1:B5)\")。"}
    ],
    "keywords": ["excel formula formulatext", "insert formulatext", "顯示公式文字", "FORMULATEXT函數"]
},
// Excel 核心操作 - Math & Trig Formulas
{
    "name": "Range.Formula (ABS - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ABS(Number)\"",
    "description": "在指定儲存格中插入 Excel 的 ABS 公式，傳回數字的絕對值。",
    "parameters": [
        {"name": "Number", "description": "要求其絕對值的數字。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = -150\nRange(\"B1\").Formula = \"=ABS(A1)\"", "explanation": "B1將顯示A1儲存格中數字的絕對值 (150)。"}
    ],
    "keywords": ["excel formula abs", "insert abs formula", "absolute value formula", "ABS函數"]
},
{
    "name": "Range.Formula (POWER)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=POWER(Number, Power)\"",
    "description": "在指定儲存格中插入 Excel 的 POWER 公式，傳回數字乘冪的結果。",
    "parameters": [
        {"name": "Number", "description": "基數。"},
        {"name": "Power", "description": "指數。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=POWER(5, 3)\"", "explanation": "C1將顯示 5 的 3 次方 (125)。"}
    ],
    "keywords": ["excel formula power", "insert power formula", "exponent formula", "POWER函數", "乘冪"]
},
{
    "name": "Range.Formula (SQRT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=SQRT(Number)\"",
    "description": "在指定儲存格中插入 Excel 的 SQRT 公式，傳回正平方根。",
    "parameters": [
        {"name": "Number", "description": "要求其平方根的數字。必須為正。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 25\nRange(\"D1\").Formula = \"=SQRT(A1)\"", "explanation": "D1將顯示A1儲存格中數字的平方根 (5)。"}
    ],
    "keywords": ["excel formula sqrt", "insert sqrt formula", "square root formula", "SQRT函數", "平方根"]
},
{
    "name": "Range.Formula (PRODUCT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=PRODUCT(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 PRODUCT 公式，將所有指定為參數的數字相乘。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "要相乘的1到255個數字。"}
    ],
    "examples": [
        {"code": "Range(\"E1\").Formula = \"=PRODUCT(A1:A3)\" ' Assumes A1, A2, A3 contain numbers", "explanation": "E1將顯示A1到A3範圍內所有數字的乘積。"},
        {"code": "Range(\"E2\").Formula = \"=PRODUCT(2,3,4)\"", "explanation": "E2將顯示2*3*4的結果 (24)。"}
    ],
    "keywords": ["excel formula product", "insert product formula", "multiply numbers formula", "PRODUCT函數", "乘積"]
},
{
    "name": "Range.Formula (ROUNDUP - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ROUNDUP(Number, Num_digits)\"",
    "description": "在指定儲存格中插入 Excel 的 ROUNDUP 公式，將數字朝遠離零的方向四捨五入。",
    "parameters": [
        {"name": "Number", "description": "要四捨五入的數字。"},
        {"name": "Num_digits", "description": "要四捨五入到的位數。"}
    ],
    "examples": [
        {"code": "Range(\"F1\").Formula = \"=ROUNDUP(12.341, 2)\"", "explanation": "F1將顯示12.35。"}
    ],
    "keywords": ["excel formula roundup", "insert roundup", "無條件進位公式", "ROUNDUP函數"]
},
{
    "name": "Range.Formula (ROUNDDOWN - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ROUNDDOWN(Number, Num_digits)\"",
    "description": "在指定儲存格中插入 Excel 的 ROUNDDOWN 公式，將數字朝向零的方向四捨五入。",
    "parameters": [
        {"name": "Number", "description": "要四捨五入的數字。"},
        {"name": "Num_digits", "description": "要四捨五入到的位數。"}
    ],
    "examples": [
        {"code": "Range(\"G1\").Formula = \"=ROUNDDOWN(56.789, 1)\"", "explanation": "G1將顯示56.7。"}
    ],
    "keywords": ["excel formula rounddown", "insert rounddown", "無條件捨去公式", "ROUNDDOWN函數"]
},
{
    "name": "Range.Formula (CEILING.MATH - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=CEILING.MATH(Number, [Significance], [Mode])\"",
    "description": "在指定儲存格中插入 Excel 的 CEILING.MATH 公式 (Excel 2013+)，將數字向上捨入到最接近的指定基數的倍數。Mode引數控制負數的捨入方向。",
    "parameters": [
        {"name": "Number", "description": "要捨入的數字。"},
        {"name": "Significance", "description": "可選。要捨入到的倍數。預設為1。"},
        {"name": "Mode", "description": "可選。對於負數，控制是朝向零還是遠離零捨入。"}
    ],
    "examples": [
        {"code": "Range(\"H1\").Formula = \"=CEILING.MATH(2.34, 0.5)\"", "explanation": "H1將顯示2.5 (2.34向上捨入到最接近的0.5的倍數)。"}
    ],
    "keywords": ["excel formula ceiling.math", "insert ceiling.math", "向上捨入倍數", "CEILING.MATH函數"]
},
{
    "name": "Range.Formula (FLOOR.MATH - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=FLOOR.MATH(Number, [Significance], [Mode])\"",
    "description": "在指定儲存格中插入 Excel 的 FLOOR.MATH 公式 (Excel 2013+)，將數字向下捨入到最接近的指定基數的倍數。Mode引數控制負數的捨入方向。",
    "parameters": [
        {"name": "Number", "description": "要捨入的數字。"},
        {"name": "Significance", "description": "可選。要捨入到的倍數。預設為1。"}
    ],
    "examples": [
        {"code": "Range(\"I1\").Formula = \"=FLOOR.MATH(7.82, 0.25)\"", "explanation": "I1將顯示7.75 (7.82向下捨入到最接近的0.25的倍數)。"}
    ],
    "keywords": ["excel formula floor.math", "insert floor.math", "向下捨入倍數", "FLOOR.MATH函數"]
},
{
    "name": "Range.Formula (MOD)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=MOD(Number, Divisor)\"",
    "description": "在指定儲存格中插入 Excel 的 MOD 公式，傳回兩數相除後的餘數。",
    "parameters": [
        {"name": "Number", "description": "被除數。"},
        {"name": "Divisor", "description": "除數。"}
    ],
    "examples": [
        {"code": "Range(\"J1\").Formula = \"=MOD(10, 3)\"", "explanation": "J1將顯示1 (10除以3的餘數)。"}
    ],
    "keywords": ["excel formula mod", "insert mod", "餘數公式", "MOD函數"]
},
{
    "name": "Range.Formula (INT - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=INT(Number)\"",
    "description": "在指定儲存格中插入 Excel 的 INT 公式，將數字向下捨入到最接近的整數。",
    "parameters": [
        {"name": "Number", "description": "要向下捨入的實數。"}
    ],
    "examples": [
        {"code": "Range(\"K1\").Formula = \"=INT(8.9)\" ' Returns 8\nRange(\"K2\").Formula = \"=INT(-8.9)\" ' Returns -9", "explanation": "K1顯示8，K2顯示-9。"}
    ],
    "keywords": ["excel formula int", "insert int", "向下取整公式", "INT函數"]
},
{
    "name": "Range.Formula (TRUNC)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=TRUNC(Number, [Num_digits])\"",
    "description": "在指定儲存格中插入 Excel 的 TRUNC 公式，將數字截斷為指定位數的整數或小數。",
    "parameters": [
        {"name": "Number", "description": "要截斷的數字。"},
        {"name": "Num_digits", "description": "可選。指定截斷精確度的小數位數。預設為0。"}
    ],
    "examples": [
        {"code": "Range(\"L1\").Formula = \"=TRUNC(123.456)\" ' Returns 123\nRange(\"L2\").Formula = \"=TRUNC(123.456, 2)\" ' Returns 123.45", "explanation": "L1顯示123 (截斷為整數)。L2顯示123.45 (截斷到兩位小數)。"}
    ],
    "keywords": ["excel formula trunc", "insert trunc", "截斷數字公式", "TRUNC函數"]
},
{
    "name": "Range.Formula (RADIANS)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=RADIANS(Angle)\"",
    "description": "在指定儲存格中插入 Excel 的 RADIANS 公式，將度數轉換為弧度。",
    "parameters": [
        {"name": "Angle", "description": "要轉換為弧度的角度 (以度為單位)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 180\nRange(\"M1\").Formula = \"=RADIANS(A1)\"", "explanation": "M1將顯示180度對應的弧度值 (約3.14159)。"}
    ],
    "keywords": ["excel formula radians", "insert radians", "度轉弧度公式", "RADIANS函數"]
},
{
    "name": "Range.Formula (DEGREES)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DEGREES(Angle)\"",
    "description": "在指定儲存格中插入 Excel 的 DEGREES 公式，將弧度轉換為度數。",
    "parameters": [
        {"name": "Angle", "description": "要轉換為度的角度 (以弧度為單位)。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 3.1415926535\nRange(\"N1\").Formula = \"=DEGREES(A1)\"", "explanation": "N1將顯示約等於Pi弧度對應的度數值 (約180)。"}
    ],
    "keywords": ["excel formula degrees", "insert degrees", "弧度轉度公式", "DEGREES函數"]
},
{
    "name": "Range.Formula (PI - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=PI()\"",
    "description": "在指定儲存格中插入 Excel 的 PI 公式，傳回圓周率 π (約 3.14159265358979)。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"O1\").Formula = \"=PI()*(A1^2)\" ' Calculates area of circle if A1 is radius", "explanation": "如果A1是半徑，O1將計算圓的面積。"}
    ],
    "keywords": ["excel formula pi", "insert pi", "圓周率公式", "PI函數"]
},
{
    "name": "Range.Formula (RAND)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=RAND()\"",
    "description": "在指定儲存格中插入 Excel 的 RAND 公式，傳回一個大於等於0且小於1的均勻分佈隨機實數。每次工作表重新計算時，它都會傳回一個新值。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"P1\").Formula = \"=RAND()\"", "explanation": "P1將顯示一個0到1之間的隨機數。"}
    ],
    "keywords": ["excel formula rand", "insert rand", "隨機數公式", "RAND函數"]
},
{
    "name": "Range.Formula (EVEN - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=EVEN(Number)\"",
    "description": "在指定儲存格中插入 Excel 的 EVEN 公式，將數字向上捨入到最接近的偶數整數。",
    "parameters": [
        {"name": "Number", "description": "要捨入的數字。"}
    ],
    "examples": [
        {"code": "Range(\"Q1\").Formula = \"=EVEN(2.5)\" ' Returns 4\nRange(\"Q2\").Formula = \"=EVEN(3)\"   ' Returns 4\nRange(\"Q3\").Formula = \"=EVEN(-1.5)\" ' Returns -2", "explanation": "演示EVEN函數如何將數字向上捨入到最接近的偶數。"}
    ],
    "keywords": ["excel formula even", "insert even function", "捨入到偶數", "EVEN函數"]
},
{
    "name": "Range.Formula (ODD - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ODD(Number)\"",
    "description": "在指定儲存格中插入 Excel 的 ODD 公式，將數字向上捨入到最接近的奇數整數。",
    "parameters": [
        {"name": "Number", "description": "要捨入的數字。"}
    ],
    "examples": [
        {"code": "Range(\"R1\").Formula = \"=ODD(1.5)\" ' Returns 3\nRange(\"R2\").Formula = \"=ODD(2)\"   ' Returns 3\nRange(\"R3\").Formula = \"=ODD(-2.5)\" ' Returns -3", "explanation": "演示ODD函數如何將數字向上捨入到最接近的奇數。"}
    ],
    "keywords": ["excel formula odd", "insert odd function", "捨入到奇數", "ODD函數"]
},
{
    "name": "Range.Formula (ROMAN)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ROMAN(Number, [Form])\"",
    "description": "在指定儲存格中插入 Excel 的 ROMAN 公式，將阿拉伯數字轉換為羅馬數字文字。",
    "parameters": [
        {"name": "Number", "description": "要轉換的阿拉伯數字。"},
        {"name": "Form", "description": "可選。指定羅馬數字類型的數字 (0=傳統, 1=更簡潔, ..., 4=最簡潔)。"}
    ],
    "examples": [
        {"code": "Range(\"S1\").Formula = \"=ROMAN(2023, 0)\"", "explanation": "S1將顯示2023的傳統羅馬數字表示 (MMXXIII)。"}
    ],
    "keywords": ["excel formula roman", "insert roman", "羅馬數字轉換", "ROMAN函數"]
},
{
    "name": "Range.Formula (ARABIC - Excel 2013+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ARABIC(Text)\"",
    "description": "在指定儲存格中插入 Excel 的 ARABIC 公式 (Excel 2013+)，將羅馬數字文字轉換為阿拉伯數字。",
    "parameters": [
        {"name": "Text", "description": "包含羅馬數字的文字字串。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"MMXXIV\"\nRange(\"T1\").Formula = \"=ARABIC(A1)\"", "explanation": "如果A1是\"MMXXIV\"，T1將顯示2024。"}
    ],
    "keywords": ["excel formula arabic", "insert arabic", "羅馬數字轉阿拉伯", "ARABIC函數"]
},
// Excel 核心操作 - Statistical Formulas
{
    "name": "Range.Formula (STDEV.S - Excel 2010+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=STDEV.S(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 STDEV.S 公式 (Excel 2010+)，估計基於樣本的標準差。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "1到255個代表樣本的數字參數。"}
    ],
    "examples": [
        {"code": "Range(\"B1\").Formula = \"=STDEV.S(A1:A50)\"", "explanation": "B1將計算A1:A50範圍內數據的樣本標準差。"}
    ],
    "keywords": ["excel formula stdev.s", "insert stdev.s", "樣本標準差公式", "STDEV.S函數"]
},
{
    "name": "Range.Formula (STDEV.P - Excel 2010+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=STDEV.P(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 STDEV.P 公式 (Excel 2010+)，計算基於整個母體的標準差。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "1到255個代表母體的數字參數。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Formula = \"=STDEV.P(A1:A100)\"", "explanation": "C1將計算A1:A100範圍內數據的母體標準差。"}
    ],
    "keywords": ["excel formula stdev.p", "insert stdev.p", "母體標準差公式", "STDEV.P函數"]
},
{
    "name": "Range.Formula (VAR.S - Excel 2010+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=VAR.S(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 VAR.S 公式 (Excel 2010+)，估計基於樣本的變異數。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "1到255個代表樣本的數字參數。"}
    ],
    "examples": [
        {"code": "Range(\"D1\").Formula = \"=VAR.S(A1:A30)\"", "explanation": "D1將計算A1:A30範圍內數據的樣本變異數。"}
    ],
    "keywords": ["excel formula var.s", "insert var.s", "樣本變異數公式", "VAR.S函數"]
},
{
    "name": "Range.Formula (VAR.P - Excel 2010+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=VAR.P(Number1, [Number2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 VAR.P 公式 (Excel 2010+)，計算基於整個母體的變異數。",
    "parameters": [
        {"name": "Number1, Number2, ...", "description": "1到255個代表母體的數字參數。"}
    ],
    "examples": [
        {"code": "Range(\"E1\").Formula = \"=VAR.P(A1:A100)\"", "explanation": "E1將計算A1:A100範圍內數據的母體變異數。"}
    ],
    "keywords": ["excel formula var.p", "insert var.p", "母體變異數公式", "VAR.P函數"]
},
{
    "name": "Range.Formula (FREQUENCY)",
    "category": "Excel 核心操作",
    "syntax": "targetRangeObject.FormulaArray = \"=FREQUENCY(Data_array, Bins_array)\"",
    "description": "在指定儲存格範圍中插入 Excel 的 FREQUENCY 陣列公式，計算數值在一個值範圍內的出現頻率，並傳回一個垂直的數字陣列。",
    "parameters": [
        {"name": "Data_array", "description": "要計算頻率的數據集 (儲存格範圍或陣列)。"},
        {"name": "Bins_array", "description": "用於對Data_array中的值進行分組的間隔點 (儲存格範圍或陣列)。"}
    ],
    "examples": [
        {"code": "' Data in A1:A10, Bins in B1:B4\n' Select C1:C5 (one more cell than bins array) before running:\n' Range(\"C1:C5\").FormulaArray = \"=FREQUENCY(A1:A10, B1:B4)\"", "explanation": "如果A1:A10是數據，B1:B4是分組點，則選取C1:C5後輸入此陣列公式，它會計算數據在各分組區間的頻率。"}
    ],
    "keywords": ["excel formula frequency", "insert frequency array", "頻率分佈公式", "FREQUENCY函數"]
},
{
    "name": "Range.Formula (PERCENTILE.INC - Excel 2010+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=PERCENTILE.INC(Array, K)\"",
    "description": "在指定儲存格中插入 Excel 的 PERCENTILE.INC 公式，傳回資料集中第k個百分位數的值 (k介於0和1之間，包含端點)。",
    "parameters": [
        {"name": "Array", "description": "數據陣列或範圍。"},
        {"name": "K", "description": "0到1之間的百分位數值。"}
    ],
    "examples": [
        {"code": "Range(\"F1\").Formula = \"=PERCENTILE.INC(A1:A100, 0.9)\"", "explanation": "F1將顯示A1:A100範圍中第90個百分位數的值。"}
    ],
    "keywords": ["excel formula percentile.inc", "insert percentile", "百分位數公式", "PERCENTILE.INC函數"]
},
{
    "name": "Range.Formula (QUARTILE.INC - Excel 2010+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=QUARTILE.INC(Array, Quart)\"",
    "description": "在指定儲存格中插入 Excel 的 QUARTILE.INC 公式，傳回資料集的四分位數。",
    "parameters": [
        {"name": "Array", "description": "數據陣列或範圍。"},
        {"name": "Quart", "description": "0=最小值, 1=第一四分位數, 2=中位數, 3=第三四分位數, 4=最大值。"}
    ],
    "examples": [
        {"code": "Range(\"G1\").Formula = \"=QUARTILE.INC(A1:A50, 1)\"", "explanation": "G1將顯示A1:A50範圍數據的第一四分位數。"}
    ],
    "keywords": ["excel formula quartile.inc", "insert quartile", "四分位數公式", "QUARTILE.INC函數"]
},
{
    "name": "Range.Formula (COUNTBLANK)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=COUNTBLANK(Range)\"",
    "description": "在指定儲存格中插入 Excel 的 COUNTBLANK 公式，計算指定範圍中空白儲存格的數量。",
    "parameters": [
        {"name": "Range", "description": "要計數其中空白儲存格的範圍。"}
    ],
    "examples": [
        {"code": "Range(\"H1\").Formula = \"=COUNTBLANK(A1:Z100)\"", "explanation": "H1將顯示A1:Z100範圍內所有空白儲存格的總數。"}
    ],
    "keywords": ["excel formula countblank", "insert countblank", "計數空白儲存格公式", "COUNTBLANK函數"]
},
{
    "name": "Range.Formula (CORREL)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=CORREL(Array1, Array2)\"",
    "description": "在指定儲存格中插入 Excel 的 CORREL 公式，傳回兩個數據集之間的相關係數。",
    "parameters": [
        {"name": "Array1", "description": "第一個儲存格範圍或數值陣列。"},
        {"name": "Array2", "description": "第二個儲存格範圍或數值陣列。"}
    ],
    "examples": [
        {"code": "Range(\"I1\").Formula = \"=CORREL(A1:A20, B1:B20)\"", "explanation": "I1將計算A1:A20和B1:B20兩組數據的相關係數。"}
    ],
    "keywords": ["excel formula correl", "insert correl", "相關係數公式", "CORREL函數"]
},
// Excel 核心操作 - Information Formulas
{
    "name": "Range.Formula (ISNA)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ISNA(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 ISNA 公式，檢查值是否為 #N/A 錯誤。如果是，則傳回 TRUE；否則傳回 FALSE。",
    "parameters": [
        {"name": "Value", "description": "要測試的值或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"B1\").Formula = \"=VLOOKUP(A1, C1:D10, 2, FALSE)\"\nRange(\"C1\").Formula = \"=ISNA(B1)\"", "explanation": "如果B1中的VLOOKUP結果為#N/A，則C1顯示TRUE。"}
    ],
    "keywords": ["excel formula isna", "insert isna", "檢查#N/A錯誤", "ISNA函數"]
},
{
    "name": "Range.Formula (ISERROR)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ISERROR(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 ISERROR 公式，檢查值是否為任何錯誤值 (#N/A, #VALUE!, #REF!, #DIV/0!, #NUM!, #NAME?, 或 #NULL!)。如果是，則傳回 TRUE。",
    "parameters": [
        {"name": "Value", "description": "要測試的值或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=1/0\"\nRange(\"D1\").Formula = \"=ISERROR(A1)\"", "explanation": "如果A1包含任何錯誤 (此例為#DIV/0!)，D1顯示TRUE。"}
    ],
    "keywords": ["excel formula iserror", "insert iserror", "檢查任何錯誤", "ISERROR函數"]
},
{
    "name": "Range.Formula (ISERR)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ISERR(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 ISERR 公式，檢查值是否為 #N/A 以外的任何錯誤值。如果是，則傳回 TRUE。",
    "parameters": [
        {"name": "Value", "description": "要測試的值或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=1/0\" ' #DIV/0!\nRange(\"A2\").Formula = \"=NA()\"  ' #N/A\nRange(\"E1\").Formula = \"=ISERR(A1)\" ' TRUE for #DIV/0!\nRange(\"E2\").Formula = \"=ISERR(A2)\" ' FALSE for #N/A", "explanation": "E1顯示TRUE (因為#DIV/0!不是#N/A)。E2顯示FALSE (因為ISERR不認為#N/A是它要找的錯誤)。"}
    ],
    "keywords": ["excel formula iserr", "insert iserr", "檢查非#N/A錯誤", "ISERR函數"]
},
{
    "name": "Range.Formula (ISLOGICAL)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ISLOGICAL(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 ISLOGICAL 公式，檢查值是否為邏輯值 (TRUE 或 FALSE)。如果是，則傳回 TRUE。",
    "parameters": [
        {"name": "Value", "description": "要測試的值或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = True\nRange(\"A2\").Value = \"TRUE\"\nRange(\"F1\").Formula = \"=ISLOGICAL(A1)\" ' TRUE\nRange(\"F2\").Formula = \"=ISLOGICAL(A2)\" ' FALSE (A2 is text)", "explanation": "F1顯示TRUE。F2顯示FALSE，因為A2是文字字串\"TRUE\"而不是布林值TRUE。"}
    ],
    "keywords": ["excel formula islogical", "insert islogical", "檢查邏輯值", "ISLOGICAL函數"]
},
{
    "name": "Range.Formula (ISNONTEXT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ISNONTEXT(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 ISNONTEXT 公式，檢查值是否不是文字 (即數字、日期、邏輯值、錯誤值或空儲存格)。如果是，則傳回 TRUE。",
    "parameters": [
        {"name": "Value", "description": "要測試的值或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = 123\nRange(\"A2\").Value = \"Hello\"\nRange(\"G1\").Formula = \"=ISNONTEXT(A1)\" ' TRUE\nRange(\"G2\").Formula = \"=ISNONTEXT(A2)\" ' FALSE", "explanation": "G1顯示TRUE。G2顯示FALSE。"}
    ],
    "keywords": ["excel formula isnontext", "insert isnontext", "檢查非文字", "ISNONTEXT函數"]
},
{
    "name": "Range.Formula (CELL - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=CELL(Info_type, [Reference])\"",
    "description": "在指定儲存格中插入 Excel 的 CELL 公式，傳回有關儲存格格式、位置或內容的資訊。",
    "parameters": [
        {"name": "Info_type", "description": "字串，指定要傳回的儲存格資訊類型 (例如 \"address\", \"col\", \"row\", \"filename\", \"format\", \"type\")。"},
        {"name": "Reference", "description": "可選。要獲取資訊的儲存格。如果省略，則為公式所在儲存格的資訊。"}
    ],
    "examples": [
        {"code": "Range(\"H1\").Formula = \"=CELL(\"\"address\"\", A1)\"\nRange(\"H2\").Formula = \"=CELL(\"\"row\"\")\"", "explanation": "H1顯示儲存格A1的絕對位址。H2顯示H2儲存格自身的列號。"}
    ],
    "keywords": ["excel formula cell", "insert cell function", "獲取儲存格資訊", "CELL函數"]
},
{
    "name": "Range.Formula (ERROR.TYPE - Excel 2007+)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=ERROR.TYPE(Error_val)\"",
    "description": "在指定儲存格中插入 Excel 的 ERROR.TYPE 公式 (Excel 2007+)，傳回與特定錯誤類型對應的數字。如果 Error_val 不是錯誤，則傳回 #N/A。",
    "parameters": [
        {"name": "Error_val", "description": "要找出其錯誤號碼的錯誤值或儲存格參照。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Formula = \"=1/0\" ' #DIV/0!\nRange(\"A2\").Formula = \"=NA()\"  ' #N/A\nRange(\"I1\").Formula = \"=ERROR.TYPE(A1)\" ' Returns 2 for #DIV/0!\nRange(\"I2\").Formula = \"=ERROR.TYPE(A2)\" ' Returns 7 for #N/A", "explanation": "I1顯示2 (代表#DIV/0!錯誤)。I2顯示7 (代表#N/A錯誤)。"}
    ],
    "keywords": ["excel formula error.type", "insert error.type", "獲取錯誤類型編號", "ERROR.TYPE函數"]
},
{
    "name": "Range.Formula (N - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=N(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 N 公式。如果 Value 是數字，則傳回該數字。如果 Value 是日期，則傳回其序列號。如果 Value 是 TRUE，則傳回 1。如果 Value 是 FALSE，則傳回 0。如果 Value 是錯誤值，則傳回該錯誤值。其他情況傳回 0。",
    "parameters": [
        {"name": "Value", "description": "要轉換的值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Text\"\nRange(\"A2\").Value = 123\nRange(\"A3\").Value = TRUE\nRange(\"J1\").Formula = \"=N(A1)\" ' Returns 0\nRange(\"J2\").Formula = \"=N(A2)\" ' Returns 123\nRange(\"J3\").Formula = \"=N(A3)\" ' Returns 1", "explanation": "演示N函數對不同類型數據的轉換結果。"}
    ],
    "keywords": ["excel formula n", "insert n function", "convert to number if possible", "N函數"]
},
{
    "name": "Range.Formula (TYPE - Excel Function)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=TYPE(Value)\"",
    "description": "在指定儲存格中插入 Excel 的 TYPE 公式，傳回一個數字，代表值的資料類型 (1=數字, 2=文字, 4=邏輯值, 16=錯誤值, 64=陣列)。",
    "parameters": [
        {"name": "Value", "description": "要測試其類型的值。"}
    ],
    "examples": [
        {"code": "Range(\"A1\").Value = \"Hello\"\nRange(\"A2\").Value = 100\nRange(\"A3\").Value = TRUE\nRange(\"K1\").Formula = \"=TYPE(A1)\" ' Returns 2 (Text)\nRange(\"K2\").Formula = \"=TYPE(A2)\" ' Returns 1 (Number)\nRange(\"K3\").Formula = \"=TYPE(A3)\" ' Returns 4 (Logical)", "explanation": "顯示不同資料類型儲存格的TYPE函數結果。"}
    ],
    "keywords": ["excel formula type", "insert type function", "get data type code", "TYPE函數"]
},
// Excel 核心操作 - Financial Formulas (subset)
{
    "name": "Range.Formula (PMT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=PMT(Rate, Nper, Pv, [Fv], [Type])\"",
    "description": "在指定儲存格中插入 Excel 的 PMT 公式，計算年金的定期支付金額。",
    "parameters": [
        {"name": "Rate", "description": "期間利率。"},
        {"name": "Nper", "description": "總支付期數。"},
        {"name": "Pv", "description": "現值 (本金)。"},
        {"name": "Fv", "description": "可選。未來值。"},
        {"name": "Type", "description": "可選。0 (期末支付) 或 1 (期初支付)。"}
    ],
    "examples": [
        {"code": "Range(\"L1\").Formula = \"=PMT(0.05/12, 30*12, 200000)\"", "explanation": "L1計算年利率5%、30年期、貸款20萬的月付款額。"}
    ],
    "keywords": ["excel formula pmt", "insert pmt", "年金支付公式", "PMT函數"]
},
{
    "name": "Range.Formula (FV)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=FV(Rate, Nper, Pmt, [Pv], [Type])\"",
    "description": "在指定儲存格中插入 Excel 的 FV 公式，計算基於固定利率的投資的未來值。",
    "parameters": [
        {"name": "Rate", "description": "期間利率。"},
        {"name": "Nper", "description": "總支付期數。"},
        {"name": "Pmt", "description": "每期支付金額。"},
        {"name": "Pv", "description": "可選。現值。"},
        {"name": "Type", "description": "可選。0或1。"}
    ],
    "examples": [
        {"code": "Range(\"M1\").Formula = \"=FV(0.03/12, 10*12, -100, -1000)\"", "explanation": "M1計算初始存1000，每月存100，共10年，月利率0.03/12的未來值。"}
    ],
    "keywords": ["excel formula fv", "insert fv", "未來值公式", "FV函數"]
},
{
    "name": "Range.Formula (PV)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=PV(Rate, Nper, Pmt, [Fv], [Type])\"",
    "description": "在指定儲存格中插入 Excel 的 PV 公式，計算投資的現值。",
    "parameters": [
        {"name": "Rate", "description": "期間利率。"},
        {"name": "Nper", "description": "總支付期數。"},
        {"name": "Pmt", "description": "每期支付金額。"},
        {"name": "Fv", "description": "可選。未來值。"},
        {"name": "Type", "description": "可選。0或1。"}
    ],
    "examples": [
        {"code": "Range(\"N1\").Formula = \"=PV(0.06/12, 5*12, -200, 0, 0)\"", "explanation": "N1計算5年期、月付200、月利率0.06/12的年金現值。"}
    ],
    "keywords": ["excel formula pv", "insert pv", "現值公式", "PV函數"]
},
{
    "name": "Range.Formula (NPER)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=NPER(Rate, Pmt, Pv, [Fv], [Type])\"",
    "description": "在指定儲存格中插入 Excel 的 NPER 公式，計算投資的期數。",
    "parameters": [
        {"name": "Rate", "description": "期間利率。"},
        {"name": "Pmt", "description": "每期支付金額。"},
        {"name": "Pv", "description": "現值。"}
    ],
    "examples": [
        {"code": "Range(\"O1\").Formula = \"=NPER(0.01, -100, 5000)\"", "explanation": "O1計算利率1%、每期支付-100、現值5000所需的期數。"}
    ],
    "keywords": ["excel formula nper", "insert nper", "期數計算公式", "NPER函數"]
},
{
    "name": "Range.Formula (RATE)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=RATE(Nper, Pmt, Pv, [Fv], [Type], [Guess])\"",
    "description": "在指定儲存格中插入 Excel 的 RATE 公式，計算年金的期間利率。",
    "parameters": [
        {"name": "Nper", "description": "總支付期數。"},
        {"name": "Pmt", "description": "每期支付金額。"},
        {"name": "Pv", "description": "現值。"}
    ],
    "examples": [
        {"code": "Range(\"P1\").Formula = \"=RATE(4*12, -200, 8000)*12\" ' Annual rate", "explanation": "P1計算4年期、月付-200、現值8000的年金的年利率。"}
    ],
    "keywords": ["excel formula rate", "insert rate", "利率計算公式", "RATE函數"]
},
{
    "name": "Range.Formula (NPV)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=NPV(Rate, Value1, [Value2], ...)\"",
    "description": "在指定儲存格中插入 Excel 的 NPV 公式，使用貼現率和一系列未來支付 (負值) 和收入 (正值) 來計算投資的淨現值。",
    "parameters": [
        {"name": "Rate", "description": "期間貼現率。"},
        {"name": "Value1, Value2, ...", "description": "代表支付和收入的1到254個參數。Value1必須在第一個期間結束時發生。"}
    ],
    "examples": [
        {"code": "Range(\"Q1\").Formula = \"=NPV(0.1, -10000, 3000, 4200, 6800)\" ' 10% discount rate", "explanation": "Q1計算初始投資10000，後續三年收入分別為3000, 4200, 6800，貼現率10%的淨現值。"}
    ],
    "keywords": ["excel formula npv", "insert npv", "淨現值公式", "NPV函數"]
},
{
    "name": "Range.Formula (IRR)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=IRR(Values, [Guess])\"",
    "description": "在指定儲存格中插入 Excel 的 IRR 公式，傳回一系列現金流量的內部報酬率。",
    "parameters": [
        {"name": "Values", "description": "包含數字的陣列或儲存格範圍，至少包含一個正值和一個負值。"},
        {"name": "Guess", "description": "可選。對IRR結果的預估值。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A4\").Value = Application.Transpose(Array(-10000, 3000, 4200, 6800))\nRange(\"R1\").Formula = \"=IRR(A1:A4)\"", "explanation": "R1計算A1:A4現金流量的內部報酬率。"}
    ],
    "keywords": ["excel formula irr", "insert irr", "內部報酬率公式", "IRR函數"]
},
{
    "name": "Range.Formula (MIRR)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=MIRR(Values, Finance_rate, Reinvest_rate)\"",
    "description": "在指定儲存格中插入 Excel 的 MIRR 公式，傳回一系列定期現金流量的修正內部報酬率。",
    "parameters": [
        {"name": "Values", "description": "現金流量的範圍或陣列。"},
        {"name": "Finance_rate", "description": "現金流量中資金的利率。"},
        {"name": "Reinvest_rate", "description": "現金流量再投資的利率。"}
    ],
    "examples": [
        {"code": "Range(\"A1:A5\").Value = Application.Transpose(Array(-120000,39000,30000,21000,37000))\nRange(\"S1\").Formula = \"=MIRR(A1:A5, 0.1, 0.12)\"", "explanation": "S1計算A1:A5現金流量的MIRR，融資利率10%，再投資利率12%。"}
    ],
    "keywords": ["excel formula mirr", "insert mirr", "修正內部報酬率", "MIRR函數"]
},
// Excel 核心操作 - Database Functions (Conceptual - less common via direct formula in VBA)
{
    "name": "Range.Formula (DSUM)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DSUM(Database, Field, Criteria)\"",
    "description": "在指定儲存格中插入 Excel 的 DSUM 公式，加總資料庫中符合指定條件的記錄的欄位中的數字。",
    "parameters": [
        {"name": "Database", "description": "構成清單或資料庫的儲存格範圍。"},
        {"name": "Field", "description": "要加總的欄位 (欄標題字串或欄號)。"},
        {"name": "Criteria", "description": "包含指定條件的儲存格範圍。"}
    ],
    "examples": [
        {"code": "' Assume A1:D100 is Database, E1:E2 is Criteria, Field is \"Sales\"\nRange(\"F1\").Formula = \"=DSUM(A1:D100, \"\"Sales\"\", E1:E2)\"", "explanation": "F1將根據E1:E2的條件，對A1:D100資料庫中\"Sales\"欄位的值進行條件加總。"}
    ],
    "keywords": ["excel formula dsum", "insert dsum", "資料庫加總公式", "DSUM函數"]
},
{
    "name": "Range.Formula (DAVERAGE)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DAVERAGE(Database, Field, Criteria)\"",
    "description": "在指定儲存格中插入 Excel 的 DAVERAGE 公式，計算資料庫中符合指定條件的記錄的欄位中數值的平均值。",
    "parameters": [
        {"name": "Database", "description": "儲存格範圍。"},
        {"name": "Field", "description": "要計算平均的欄位。"},
        {"name": "Criteria", "description": "條件範圍。"}
    ],
    "examples": [
        {"code": "Range(\"G1\").Formula = \"=DAVERAGE(A1:D100, 3, E1:E2)\" ' Field 3 (column C)", "explanation": "G1將計算A1:D100資料庫中第3欄符合E1:E2條件的記錄的平均值。"}
    ],
    "keywords": ["excel formula daverage", "insert daverage", "資料庫平均公式", "DAVERAGE函數"]
},
{
    "name": "Range.Formula (DCOUNT)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DCOUNT(Database, [Field], Criteria)\"",
    "description": "在指定儲存格中插入 Excel 的 DCOUNT 公式，計算資料庫中符合指定條件且包含數字的記錄的數量。",
    "parameters": [
        {"name": "Database", "description": "儲存格範圍。"},
        {"name": "Field", "description": "可選。要計數的欄位。如果省略，則計數所有符合條件的記錄。"},
        {"name": "Criteria", "description": "條件範圍。"}
    ],
    "examples": [
        {"code": "Range(\"H1\").Formula = \"=DCOUNT(A1:D100, \"\"Age\"\", E1:E2)\"", "explanation": "H1將計算A1:D100資料庫中\"Age\"欄位包含數字且符合E1:E2條件的記錄數。"}
    ],
    "keywords": ["excel formula dcount", "insert dcount", "資料庫數字計數", "DCOUNT函數"]
},
{
    "name": "Range.Formula (DCOUNTA)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DCOUNTA(Database, [Field], Criteria)\"",
    "description": "在指定儲存格中插入 Excel 的 DCOUNTA 公式，計算資料庫中符合指定條件且不為空的記錄的數量。",
    "parameters": [
        {"name": "Database", "description": "儲存格範圍。"},
        {"name": "Field", "description": "可選。要計數的欄位。"},
        {"name": "Criteria", "description": "條件範圍。"}
    ],
    "examples": [
        {"code": "Range(\"I1\").Formula = \"=DCOUNTA(A1:D100, , E1:E2)\" ' Count all non-blank matching records", "explanation": "I1將計算A1:D100資料庫中所有不為空且符合E1:E2條件的記錄數。"}
    ],
    "keywords": ["excel formula dcounta", "insert dcounta", "資料庫非空計數", "DCOUNTA函數"]
},
{
    "name": "Range.Formula (DMAX)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DMAX(Database, Field, Criteria)\"",
    "description": "在指定儲存格中插入 Excel 的 DMAX 公式，傳回資料庫中符合指定條件的記錄的欄位中的最大值。",
    "parameters": [
        {"name": "Database", "description": "儲存格範圍。"},
        {"name": "Field", "description": "要找出最大值的欄位。"},
        {"name": "Criteria", "description": "條件範圍。"}
    ],
    "examples": [
        {"code": "Range(\"J1\").Formula = \"=DMAX(A1:D100, \"\"Salary\"\", E1:E2)\"", "explanation": "J1將傳回A1:D100資料庫中\"Salary\"欄位符合E1:E2條件的最大值。"}
    ],
    "keywords": ["excel formula dmax", "insert dmax", "資料庫最大值", "DMAX函數"]
},
{
    "name": "Range.Formula (DMIN)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DMIN(Database, Field, Criteria)\"",
    "description": "在指定儲存格中插入 Excel 的 DMIN 公式，傳回資料庫中符合指定條件的記錄的欄位中的最小值。",
    "parameters": [
        {"name": "Database", "description": "儲存格範圍。"},
        {"name": "Field", "description": "要找出最小值的欄位。"},
        {"name": "Criteria", "description": "條件範圍。"}
    ],
    "examples": [
        {"code": "Range(\"K1\").Formula = \"=DMIN(A1:D100, 4, E1:E2)\" ' Field by column index 4 (column D)", "explanation": "K1將傳回A1:D100資料庫中第4欄符合E1:E2條件的最小值。"}
    ],
    "keywords": ["excel formula dmin", "insert dmin", "資料庫最小值", "DMIN函數"]
},
    {
    "name": "Range.Formula (DGET)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DGET(Database, Field, Criteria)\"",
    "description": "在指定儲存格中插入 Excel 的 DGET 公式，從資料庫中提取符合指定條件的單個記錄的欄位值。如果沒有記錄符合條件，傳回 #VALUE!；如果多於一個記錄符合，傳回 #NUM!。",
    "parameters": [
        {"name": "Database", "description": "儲存格範圍。"},
        {"name": "Field", "description": "要提取值的欄位。"},
        {"name": "Criteria", "description": "條件範圍。"}
    ],
    "examples": [
        {"code": "Range(\"L1\").Formula = \"=DGET(A1:D100, \"\"EmployeeName\"\", E1:E2)\" ' E1:E2 must define criteria for a single record", "explanation": "L1將嘗試從A1:D100資料庫中提取符合E1:E2條件的單個記錄的\"EmployeeName\"。"}
    ],
    "keywords": ["excel formula dget", "insert dget", "資料庫提取單值", "DGET函數"]
    },

    {
    "name": "Range.Formula (DATEDIF for Loan Age)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DATEDIF(StartDate_Cell, EndDate_Cell, \"\"Y\"\")\" ' Years\nrangeObject.Formula = \"=DATEDIF(StartDate_Cell, EndDate_Cell, \"\"YM\"\")\" ' Months over years\nrangeObject.Formula = \"=DATEDIF(StartDate_Cell, EndDate_Cell, \"\"MD\"\")\" ' Days over months",
    "description": "在指定儲存格中插入Excel的DATEDIF公式，用於計算貸款已存續年數、月數、天數，常用於貸後管理中計算貸款帳齡或剩餘期限。",
    "parameters": [
        {"name": "StartDate_Cell", "description": "貸款發放日期所在的儲存格。"},
        {"name": "EndDate_Cell", "description": "計算截止日期所在的儲存格 (例如，TODAY() 或報告日期)。"},
        {"name": "Unit", "description": "\"Y\" (年), \"M\" (月), \"D\" (日), \"YM\" (不足一年的月數), \"MD\" (不足一月的日數), \"YD\" (不足一年的日數)。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Value = DateSerial(2020, 1, 15) ' Loan Start Date\nRange(\"D1\").Value = DateSerial(2023, 5, 20) ' Current Date\nRange(\"E1\").Formula = \"=DATEDIF(C1, D1, \"\"Y\"\")\" ' Full years\nRange(\"F1\").Formula = \"=DATEDIF(C1, D1, \"\"YM\"\")\" ' Months after full years\nRange(\"G1\").Formula = \"=DATEDIF(C1, D1, \"\"MD\"\")\" ' Days after full months", "explanation": "E1計算C1和D1之間相差的完整年數。F1計算不足一年的月數。G1計算不足一月的日數。"}
    ],
    "keywords": ["excel formula datedif", "loan age calculation", "remaining term", "datedif", "貸款帳齡", "剩餘期限"]
},
{
    "name": "Range.AutoFilter (Multiple Criteria)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AutoFilter Field:=1, Criteria1:=\"=Value1\", Operator:=xlOr, Criteria2:=\"=Value2\"",
    "description": "對指定欄位套用自動篩選，可以設定多個條件 (例如，等於Value1 或 等於Value2)。",
    "parameters": [
        {"name": "Field", "description": "相對於篩選範圍的欄位索引 (1-based)。"},
        {"name": "Criteria1", "description": "第一個條件。"},
        {"name": "Operator", "description": "xlAnd 或 xlOr，用於組合Criteria1和Criteria2。"},
        {"name": "Criteria2", "description": "第二個條件。"}
    ],
    "examples": [
        {"code": "' Assume A1:C100 is data, with headers in row 1.\n' Filter column B (Field:=2) for \"High Risk\" OR \"Medium Risk\"\nRange(\"A1\").AutoFilter Field:=2, Criteria1:=\"=High Risk\", Operator:=xlOr, Criteria2:=\"=Medium Risk\"", "explanation": "對A1啟動的自動篩選範圍的第二欄進行篩選，顯示值為\"High Risk\"或\"Medium Risk\"的列。"}
    ],
    "keywords": ["excel autofilter multiple criteria", "filter or condition", "autofilter or", "自動篩選多條件"]
},
{
    "name": "ListObject.QueryTable Property (Excel Table from Query)",
    "category": "Excel 核心操作",
    "syntax": "Set qt = listObject.QueryTable",
    "description": "如果 Excel 表格 (ListObject) 是基於查詢 (例如，從外部數據源導入的數據) 建立的，則此屬性傳回與該表格關聯的 QueryTable 物件。QueryTable 物件可用於刷新數據、修改查詢等。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As ListObject, dataQuery As QueryTable\n' Set tbl = ActiveSheet.ListObjects(\"ExternalDataTable\") ' Assume this table was created from a query\n' If Not tbl Is Nothing Then\n'   Set dataQuery = tbl.QueryTable\n'   If Not dataQuery Is Nothing Then\n'     MsgBox \"表格 '\" & tbl.Name & \"' 的數據來源查詢是: \" & dataQuery.CommandText & vbCrLf & _\n'            \"上次刷新時間: \" & dataQuery.ResultRange.Worksheet.Cells(dataQuery.ResultRange.Row, dataQuery.ResultRange.Column).Offset(-1,0).Value ' Heuristic for refresh time often stored above table\n'     ' dataQuery.Refresh BackgroundQuery:=False ' Refresh the data\n'   Else\n'     MsgBox \"表格 '\" & tbl.Name & \"' 不是基於 QueryTable。\"\n'   End If\n' End If", "explanation": "獲取名為 \"ExternalDataTable\" 的 Excel 表格的 QueryTable 物件，並顯示其查詢語句。同時演示了如何刷新該查詢。"}
    ],
    "keywords": ["listobject querytable", "excel table refresh data source", "table from query", "表格查詢物件", "刷新表格數據"]
},
{
    "name": "Range.Consolidate (Using Named Ranges)",
    "category": "Excel 核心操作",
    "syntax": "destinationRange.Consolidate Sources:=Array(\"Sales_BranchA\", \"Sales_BranchB\"), Function:=xlSum",
    "description": "使用已定義的名稱 (Named Ranges) 作為合併數據的來源。",
    "parameters": [
        {"name": "Sources", "description": "包含已命名範圍名稱的字串陣列。"},
        {"name": "Function", "description": "合併函數，如 xlSum, xlAverage。"}
    ],
    "examples": [
        {"code": "' Define named ranges first:\n' ThisWorkbook.Names.Add Name:=\"Sales_BranchA\", RefersTo:=\"=Sheet2!$A$1:$B$5\"\n' ThisWorkbook.Names.Add Name:=\"Sales_BranchB\", RefersTo:=\"=Sheet3!$A$1:$B$5\"\n' ' Consolidate into Sheet1 starting at A1\n' Sheets(\"Sheet1\").Range(\"A1\").Consolidate Sources:=Array(\"Sales_BranchA\", \"Sales_BranchB\"), Function:=xlSum, TopRow:=True, LeftColumn:=True", "explanation": "假設已定義名為 \"Sales_BranchA\" 和 \"Sales_BranchB\" 的範圍，此程式碼將這兩個範圍的數據使用 SUM 函數合併到 Sheet1 的 A1 儲存格開始的區域，並使用來源的頂列和左欄作為標籤。"}
    ],
    "keywords": ["excel consolidate named ranges", "sum data from named ranges", "合併已命名範圍"]
},
// --- Word 文件處理 ---
{
    "name": "MailMerge.Execute (Word Mail Merge)",
    "category": "Word 文件處理",
    "syntax": "documentObject.MailMerge.Execute([Pause As Boolean = False])",
    "description": "執行 Word 的郵件合併作業。documentObject 必須是主郵件合併文件。",
    "parameters": [{"name": "Pause", "description": "可選。True 表示在合併每個記錄後暫停。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document (Main Mail Merge Document)\n' ' Assume wdDoc is the active mail merge main document and data source is configured.\n' Set wdDoc = ActiveDocument\n' If wdDoc.MailMerge.State = wdMainAndDataSource Then ' Check if ready for merge (wdMainAndDataSource = 1)\n'   wdDoc.MailMerge.Destination = wdSendToNewDocument ' Merge to a new document\n'   wdDoc.MailMerge.Execute Pause:=False\n'   MsgBox \"郵件合併已執行到新文件。\"\n'   ' ActiveDocument.PrintOut ' Or print the newly created merged document\n' Else\n'   MsgBox \"文件不是已設定好的郵件合併主文件，或沒有數據源。\"\n' End If", "explanation": "如果活動文件是一個已設定好數據源的郵件合併主文件，則執行郵件合併，將結果輸出到一個新的Word文檔中。"}
    ],
    "keywords": ["word mailmerge execute", "perform mail merge vba", "郵件合併執行"]
},
{
    "name": "ContentControls.Add (Word Content Controls)",
    "category": "Word 文件處理",
    "syntax": "Set cc = documentObject.ContentControls.Add(Type As WdContentControlType, [Range])",
    "description": "在文件中新增一個內容控制項。內容控制項提供結構化的方式來輸入和呈現數據。",
    "parameters": [
        {"name": "Type", "description": "必需。WdContentControlType 常數 (例如 wdContentControlText, wdContentControlDate, wdContentControlDropdownList)。"},
        {"name": "Range", "description": "可選。Range 物件，指定內容控制項插入的位置。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, ccDate As Object ' Word.ContentControl\n' Set wdDoc = ActiveDocument\n' ' Add a date picker content control at the current selection\n' Set ccDate = wdDoc.ContentControls.Add(wdContentControlDate, Selection.Range)\n' With ccDate\n'   .Title = \"簽署日期\"\n'   .Tag = \"ContractSignDate\"\n'   .DateDisplayFormat = \"yyyy年MM月dd日\"\n'   .SetPlaceholderText Text:=\"[點擊選擇日期]\"\n' End With\n' MsgBox \"已新增日期選擇器內容控制項。\"", "explanation": "在目前選取位置新增一個日期選擇器內容控制項，並設定其標題、標籤和日期顯示格式。"}
    ],
    "keywords": ["word content controls add", "insert content control", "structured document tags", "新增內容控制項"]
},
{
    "name": "Document.Protect (AllowOnlyFormFields - Word Form Protection)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Protect(Type As WdProtectionType, [NoReset As Boolean = False], [Password As String])",
    "description": "保護文件。如果 Type 設為 wdAllowOnlyFormFields，則文件被保護，使用者只能在表單欄位 (舊版表單欄位，非內容控制項) 中輸入內容。",
    "parameters": [
        {"name": "Type:=wdAllowOnlyFormFields (Constant 2)", "description": "指定保護類型為僅允許填寫表單欄位。"},
        {"name": "Password", "description": "可選。保護密碼。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' ' Add a legacy form field for testing (e.g., Text Form Field from Developer Tab > Legacy Tools)\n' ' Selection.FormFields.Add Range:=Selection.Range, Type:=wdFieldFormTextInput\n' wdDoc.Protect Type:=wdAllowOnlyFormFields, Password:=\"formpass\"\n' MsgBox \"文件已保護，僅允許在表單欄位中輸入。\"", "explanation": "將活動文件保護起來，使其僅允許使用者在舊版的表單欄位中進行編輯。"}
    ],
    "keywords": ["word protect form fields", "wdallowonlyformfields", "lock document for forms", "保護表單欄位"]
},
{
    "name": "Range.Formula (DATEDIF for Loan Age)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Formula = \"=DATEDIF(StartDate_Cell, EndDate_Cell, \"\"Y\"\")\" ' Years\nrangeObject.Formula = \"=DATEDIF(StartDate_Cell, EndDate_Cell, \"\"YM\"\")\" ' Months over years\nrangeObject.Formula = \"=DATEDIF(StartDate_Cell, EndDate_Cell, \"\"MD\"\")\" ' Days over months",
    "description": "在指定儲存格中插入Excel的DATEDIF公式，用於計算貸款已存續年數、月數、天數，常用於貸後管理中計算貸款帳齡或剩餘期限。",
    "parameters": [
        {"name": "StartDate_Cell", "description": "貸款發放日期所在的儲存格。"},
        {"name": "EndDate_Cell", "description": "計算截止日期所在的儲存格 (例如，TODAY() 或報告日期)。"},
        {"name": "Unit", "description": "\"Y\" (年), \"M\" (月), \"D\" (日), \"YM\" (不足一年的月數), \"MD\" (不足一月的日數), \"YD\" (不足一年的日數)。"}
    ],
    "examples": [
        {"code": "Range(\"C1\").Value = DateSerial(2020, 1, 15) ' Loan Start Date\nRange(\"D1\").Value = DateSerial(2023, 5, 20) ' Current Date\nRange(\"E1\").Formula = \"=DATEDIF(C1, D1, \"\"Y\"\")\" ' Full years\nRange(\"F1\").Formula = \"=DATEDIF(C1, D1, \"\"YM\"\")\" ' Months after full years\nRange(\"G1\").Formula = \"=DATEDIF(C1, D1, \"\"MD\"\")\" ' Days after full months", "explanation": "E1計算C1和D1之間相差的完整年數。F1計算不足一年的月數。G1計算不足一月的日數。"}
    ],
    "keywords": ["excel formula datedif", "loan age calculation", "remaining term", "datedif", "貸款帳齡", "剩餘期限"]
},
{
    "name": "Range.AutoFilter (Multiple Criteria)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.AutoFilter Field:=1, Criteria1:=\"=Value1\", Operator:=xlOr, Criteria2:=\"=Value2\"",
    "description": "對指定欄位套用自動篩選，可以設定多個條件 (例如，等於Value1 或 等於Value2)。",
    "parameters": [
        {"name": "Field", "description": "相對於篩選範圍的欄位索引 (1-based)。"},
        {"name": "Criteria1", "description": "第一個條件。"},
        {"name": "Operator", "description": "xlAnd 或 xlOr，用於組合Criteria1和Criteria2。"},
        {"name": "Criteria2", "description": "第二個條件。"}
    ],
    "examples": [
        {"code": "' Assume A1:C100 is data, with headers in row 1.\n' Filter column B (Field:=2) for \"High Risk\" OR \"Medium Risk\"\nRange(\"A1\").AutoFilter Field:=2, Criteria1:=\"=High Risk\", Operator:=xlOr, Criteria2:=\"=Medium Risk\"", "explanation": "對A1啟動的自動篩選範圍的第二欄進行篩選，顯示值為\"High Risk\"或\"Medium Risk\"的列。"}
    ],
    "keywords": ["excel autofilter multiple criteria", "filter or condition", "autofilter or", "自動篩選多條件"]
},
{
    "name": "ListObject.QueryTable Property (Excel Table from Query)",
    "category": "Excel 核心操作",
    "syntax": "Set qt = listObject.QueryTable",
    "description": "如果 Excel 表格 (ListObject) 是基於查詢 (例如，從外部數據源導入的數據) 建立的，則此屬性傳回與該表格關聯的 QueryTable 物件。QueryTable 物件可用於刷新數據、修改查詢等。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As ListObject, dataQuery As QueryTable\n' Set tbl = ActiveSheet.ListObjects(\"ExternalDataTable\") ' Assume this table was created from a query\n' If Not tbl Is Nothing Then\n'   Set dataQuery = tbl.QueryTable\n'   If Not dataQuery Is Nothing Then\n'     MsgBox \"表格 '\" & tbl.Name & \"' 的數據來源查詢是: \" & dataQuery.CommandText & vbCrLf & _\n'            \"上次刷新時間: \" & dataQuery.ResultRange.Worksheet.Cells(dataQuery.ResultRange.Row, dataQuery.ResultRange.Column).Offset(-1,0).Value ' Heuristic for refresh time often stored above table\n'     ' dataQuery.Refresh BackgroundQuery:=False ' Refresh the data\n'   Else\n'     MsgBox \"表格 '\" & tbl.Name & \"' 不是基於 QueryTable。\"\n'   End If\n' End If", "explanation": "獲取名為 \"ExternalDataTable\" 的 Excel 表格的 QueryTable 物件，並顯示其查詢語句。同時演示了如何刷新該查詢。"}
    ],
    "keywords": ["listobject querytable", "excel table refresh data source", "table from query", "表格查詢物件", "刷新表格數據"]
},
{
    "name": "Range.Consolidate (Using Named Ranges)",
    "category": "Excel 核心操作",
    "syntax": "destinationRange.Consolidate Sources:=Array(\"Sales_BranchA\", \"Sales_BranchB\"), Function:=xlSum",
    "description": "使用已定義的名稱 (Named Ranges) 作為合併數據的來源。",
    "parameters": [
        {"name": "Sources", "description": "包含已命名範圍名稱的字串陣列。"},
        {"name": "Function", "description": "合併函數，如 xlSum, xlAverage。"}
    ],
    "examples": [
        {"code": "' Define named ranges first:\n' ThisWorkbook.Names.Add Name:=\"Sales_BranchA\", RefersTo:=\"=Sheet2!$A$1:$B$5\"\n' ThisWorkbook.Names.Add Name:=\"Sales_BranchB\", RefersTo:=\"=Sheet3!$A$1:$B$5\"\n' ' Consolidate into Sheet1 starting at A1\n' Sheets(\"Sheet1\").Range(\"A1\").Consolidate Sources:=Array(\"Sales_BranchA\", \"Sales_BranchB\"), Function:=xlSum, TopRow:=True, LeftColumn:=True", "explanation": "假設已定義名為 \"Sales_BranchA\" 和 \"Sales_BranchB\" 的範圍，此程式碼將這兩個範圍的數據使用 SUM 函數合併到 Sheet1 的 A1 儲存格開始的區域，並使用來源的頂列和左欄作為標籤。"}
    ],
    "keywords": ["excel consolidate named ranges", "sum data from named ranges", "合併已命名範圍"]
},
// --- Word 文件處理 ---
{
    "name": "MailMerge.Execute (Word Mail Merge)",
    "category": "Word 文件處理",
    "syntax": "documentObject.MailMerge.Execute([Pause As Boolean = False])",
    "description": "執行 Word 的郵件合併作業。documentObject 必須是主郵件合併文件。",
    "parameters": [{"name": "Pause", "description": "可選。True 表示在合併每個記錄後暫停。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document (Main Mail Merge Document)\n' ' Assume wdDoc is the active mail merge main document and data source is configured.\n' Set wdDoc = ActiveDocument\n' If wdDoc.MailMerge.State = wdMainAndDataSource Then ' Check if ready for merge (wdMainAndDataSource = 1)\n'   wdDoc.MailMerge.Destination = wdSendToNewDocument ' Merge to a new document\n'   wdDoc.MailMerge.Execute Pause:=False\n'   MsgBox \"郵件合併已執行到新文件。\"\n'   ' ActiveDocument.PrintOut ' Or print the newly created merged document\n' Else\n'   MsgBox \"文件不是已設定好的郵件合併主文件，或沒有數據源。\"\n' End If", "explanation": "如果活動文件是一個已設定好數據源的郵件合併主文件，則執行郵件合併，將結果輸出到一個新的Word文檔中。"}
    ],
    "keywords": ["word mailmerge execute", "perform mail merge vba", "郵件合併執行"]
},
{
    "name": "ContentControls.Add (Word Content Controls)",
    "category": "Word 文件處理",
    "syntax": "Set cc = documentObject.ContentControls.Add(Type As WdContentControlType, [Range])",
    "description": "在文件中新增一個內容控制項。內容控制項提供結構化的方式來輸入和呈現數據。",
    "parameters": [
        {"name": "Type", "description": "必需。WdContentControlType 常數 (例如 wdContentControlText, wdContentControlDate, wdContentControlDropdownList)。"},
        {"name": "Range", "description": "可選。Range 物件，指定內容控制項插入的位置。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, ccDate As Object ' Word.ContentControl\n' Set wdDoc = ActiveDocument\n' ' Add a date picker content control at the current selection\n' Set ccDate = wdDoc.ContentControls.Add(wdContentControlDate, Selection.Range)\n' With ccDate\n'   .Title = \"簽署日期\"\n'   .Tag = \"ContractSignDate\"\n'   .DateDisplayFormat = \"yyyy年MM月dd日\"\n'   .SetPlaceholderText Text:=\"[點擊選擇日期]\"\n' End With\n' MsgBox \"已新增日期選擇器內容控制項。\"", "explanation": "在目前選取位置新增一個日期選擇器內容控制項，並設定其標題、標籤和日期顯示格式。"}
    ],
    "keywords": ["word content controls add", "insert content control", "structured document tags", "新增內容控制項"]
},
{
    "name": "Document.Protect (AllowOnlyFormFields - Word Form Protection)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Protect(Type As WdProtectionType, [NoReset As Boolean = False], [Password As String])",
    "description": "保護文件。如果 Type 設為 wdAllowOnlyFormFields，則文件被保護，使用者只能在表單欄位 (舊版表單欄位，非內容控制項) 中輸入內容。",
    "parameters": [
        {"name": "Type:=wdAllowOnlyFormFields (Constant 2)", "description": "指定保護類型為僅允許填寫表單欄位。"},
        {"name": "Password", "description": "可選。保護密碼。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' ' Add a legacy form field for testing (e.g., Text Form Field from Developer Tab > Legacy Tools)\n' ' Selection.FormFields.Add Range:=Selection.Range, Type:=wdFieldFormTextInput\n' wdDoc.Protect Type:=wdAllowOnlyFormFields, Password:=\"formpass\"\n' MsgBox \"文件已保護，僅允許在表單欄位中輸入。\"", "explanation": "將活動文件保護起來，使其僅允許使用者在舊版的表單欄位中進行編輯。"}
    ],
    "keywords": ["word protect form fields", "wdallowonlyformfields", "lock document for forms", "保護表單欄位"]
},
// Excel 核心操作 (贷后管理相关)
{
    "name": "Range.AdvancedFilter (Extract Overdue Loans)",
    "category": "Excel 核心操作",
    "syntax": "dataRange.AdvancedFilter Action:=xlFilterCopy, CriteriaRange:=criteriaForOverdue, CopyToRange:=outputRange, Unique:=False",
    "description": "使用进阶筛选功能，从客户贷款主列表中提取所有逾期贷款记录到新的工作表，用于贷后催收或风险拨备分析。",
    "parameters": [
        {"name": "dataRange", "description": "包含所有贷款记录的范围，含表头。"},
        {"name": "criteriaForOverdue", "description": "定义逾期条件的准则范围 (例如，包含“逾期天数”表头和“>0”条件)。"},
        {"name": "outputRange", "description": "用于存放筛选出的逾期贷款记录的目标范围的左上角单元格。"}
    ],
    "examples": [
        {"code": "' 假设贷款数据在 Sheet1!A1:G100，逾期准则在 Sheet1!I1:I2\n' Dim sourceRange As Range, criteriaRange As Range, destinationCell As Range\n' Set sourceRange = Sheets(\"Sheet1\").Range(\"A1:G100\")\n' Set criteriaRange = Sheets(\"Sheet1\").Range(\"I1:I2\")\n' Set destinationCell = Sheets(\"OverdueLoans\").Range(\"A1\") ' 输出到新表\n' sourceRange.AdvancedFilter Action:=xlFilterCopy, CriteriaRange:=criteriaRange, CopyToRange:=destinationCell", "explanation": "将Sheet1中符合逾期条件的贷款记录复制到名为“OverdueLoans”的工作表的A1单元格开始的区域。"}
    ],
    "keywords": ["excel advanced filter", "extract overdue loans", "贷后数据筛选", "逾期贷款提取"]
},
{
    "name": "Worksheet.PivotTables(IndexOrName).PivotCache.Refresh (Specific Cache)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.PivotTables(IndexOrName).PivotCache.Refresh",
    "description": "刷新工作表上特定数据透视表所连接的 PivotCache。用于在贷后监控报告的底层数据源更新后，确保数据透视表显示最新信息。",
    "parameters": [
        {"name": "IndexOrName", "description": "数据透视表的索引号或名称。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable\n' On Error Resume Next ' In case PivotTable doesn't exist\n' Set pt = Sheets(\"RiskDashboard\").PivotTables(\"PortfolioRiskSummary\")\n' If Not pt Is Nothing Then\n'   pt.PivotCache.Refresh\n'   pt.RefreshTable ' It's good practice to refresh the table itself too\n'   MsgBox \"数据透视表 '\" & pt.Name & \"' 的快取已刷新。\"\n' Else\n'   MsgBox \"未找到指定的数据透视表。\"\n' End If\n' On Error GoTo 0", "explanation": "刷新名为“PortfolioRiskSummary”的数据透视表的底层数据快取，然后刷新数据透视表本身。"}
    ],
    "keywords": ["excel pivotcache refresh", "update specific pivottable data", "贷后报告数据刷新", "刷新数据透视表快取"]
},
{
    "name": "Range.Sort (Sort by Multiple Keys - Loan Data)",
    "category": "Excel 核心操作",
    "syntax": "dataRange.Sort Key1:=RangeToSortBy1, Order1:=xlAscending, Key2:=RangeToSortBy2, Order2:=xlDescending, Header:=xlYes",
    "description": "对贷款数据列表进行多重排序，例如，先按“风险评级”（降序），再按“贷款余额”（降序），以突出高风险大额贷款。",
    "parameters": [
        {"name": "Key1", "description": "第一个排序键的范围。"},
        {"name": "Order1", "description": "第一个键的排序顺序。"},
        {"name": "Key2", "description": "第二个排序键的范围。"},
        {"name": "Order2", "description": "第二个键的排序顺序。"},
        {"name": "Header", "description": "xlYes 表示有表头。"}
    ],
    "examples": [
        {"code": "Dim loanDataRange As Range\n' Set loanDataRange = Sheets(\"LoanPortfolio\").Range(\"A1\").CurrentRegion ' Assume data is in a contiguous block\n' ' Sort by RiskRating (Column D, descending) then by LoanBalance (Column E, descending)\n' If Not loanDataRange Is Nothing And loanDataRange.Rows.Count > 1 Then\n'   loanDataRange.Sort Key1:=loanDataRange.Columns(4), Order1:=xlDescending, _\n'                      Key2:=loanDataRange.Columns(5), Order2:=xlDescending, _\n'                      Header:=xlYes, Orientation:=xlSortColumns\n'   MsgBox \"贷款数据已按风险评级（高到低）和贷款余额（高到低）排序。\"\n' End If", "explanation": "对“LoanPortfolio”工作表中的贷款数据，先按第4列（假设为风险评级）降序排列，然后在相同风险评级内按第5列（假设为贷款余额）降序排列。"}
    ],
    "keywords": ["excel sort multiple keys", "sort loan data vba", "贷后数据排序", "多重排序"]
},
{
    "name": "Range.Formula (Calculate Loan-to-Value LTV)",
    "category": "Excel 核心操作",
    "syntax": "ltvCell.Formula = \"=LoanAmount_Cell / CollateralValue_Cell\"",
    "description": "在指定单元格中插入计算贷款价值比 (LTV) 的Excel公式。LTV是贷后监控的关键指标。",
    "parameters": [
        {"name": "LoanAmount_Cell", "description": "包含贷款余额的单元格引用。"},
        {"name": "CollateralValue_Cell", "description": "包含抵押品评估价值的单元格引用。"}
    ],
    "examples": [
        {"code": "' Assume Loan Amount in C2, Collateral Value in D2, LTV to be calculated in E2\nRange(\"E2\").Formula = \"=IF(D2>0, C2/D2, \"\"N/A\"\")\"\nRange(\"E2\").NumberFormat = \"0.00%\"", "explanation": "单元格E2将计算C2（贷款额）除以D2（抵押品价值）的LTV比率，如果抵押品价值为0则显示N/A，并格式化为百分比。"}
    ],
    "keywords": ["excel formula ltv", "loan to value ratio", "贷后指标计算", "LTV计算公式"]
},
{
    "name": "Range.Formula (Calculate Debt Service Coverage Ratio DSCR)",
    "category": "Excel 核心操作",
    "syntax": "dscrCell.Formula = \"=NetOperatingIncome_Cell / TotalDebtService_Cell\"",
    "description": "在指定单元格中插入计算债务偿付覆盖率 (DSCR) 的Excel公式。DSCR是评估客户还款能力的重要指标。",
    "parameters": [
        {"name": "NetOperatingIncome_Cell", "description": "包含净营业收入 (NOI) 或EBITDA的单元格引用。"},
        {"name": "TotalDebtService_Cell", "description": "包含总债务偿付额 (本金+利息) 的单元格引用。"}
    ],
    "examples": [
        {"code": "' Assume NOI/EBITDA in F2, Total Debt Service in G2, DSCR in H2\nRange(\"H2\").Formula = \"=IF(G2<>0, F2/G2, \"\"N/A\"\")\"\nRange(\"H2\").NumberFormat = \"0.00\"", "explanation": "单元格H2将计算F2（净营业收入）除以G2（总债务偿付）的DSCR比率，如果总债务偿付为0则显示N/A，并格式化为两位小数。"}
    ],
    "keywords": ["excel formula dscr", "debt service coverage ratio", "贷后财务比率", "DSCR计算公式"]
},
{
    "name": "Worksheet.Names.Add (Dynamic Named Range for Charts)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Names.Add Name:=\"DynamicChartData\", RefersTo:=\"=OFFSET(Sheet1!$A$1,0,0,COUNTA(Sheet1!$A:$A),COUNTA(Sheet1!$1:$1))\"",
    "description": "创建一个动态的已命名范围，其大小会根据数据量的变化自动调整。这对于作为图表数据源非常有用，确保图表总是反映最新的数据。",
    "parameters": [
        {"name": "Name", "description": "动态范围的名称。"},
        {"name": "RefersTo", "description": "使用OFFSET和COUNTA（或COUNT）函数定义的动态范围公式。"}
    ],
    "examples": [
        {"code": "Dim ws As Worksheet: Set ws = ThisWorkbook.Sheets(\"DataForChart\")\nDim dynamicRangeFormula As String\n' Assumes data starts in A1, headers in row 1 and data in column A determines row count.\n' Adjust COUNTA parts if data structure is different (e.g. for column count).\ndynamicRangeFormula = \"=OFFSET('\" & ws.Name & \"'!$A$1,0,0,COUNTA('\" & ws.Name & \"'!$A:$A),COUNTA('\" & ws.Name & \"'!$1:$1))\"\nOn Error Resume Next ' Delete if it exists\nThisWorkbook.Names(\"ClientPortfolioTrendData\").Delete\nOn Error GoTo 0\nThisWorkbook.Names.Add Name:=\"ClientPortfolioTrendData\", RefersTo:=dynamicRangeFormula\nMsgBox \"动态已命名范围 'ClientPortfolioTrendData' 已创建，可用于图表数据源。\"", "explanation": "创建一个名为 'ClientPortfolioTrendData' 的动态已命名范围，它会自动包含工作表 'DataForChart' 上从A1单元格开始的整个数据区域。此范围随后可以用于创建动态更新的图表。"}
    ],
    "keywords": ["excel dynamic named range", "chart dynamic data source", "offset counta named range", "动态图表数据源", "贷后趋势图"]
},
{
    "name": "Range.Validation (List from Another Sheet's Named Range)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.Add Type:=xlValidateList, Formula1:=\"=MyNamedList\"",
    "description": "为指定单元格添加列表数据验证，其下拉列表的选项来源于另一个工作表（或同一工作表）上的已命名范围。这在贷后管理中可用于规范输入，如风险评级、产品类型等。",
    "parameters": [
        {"name": "Formula1", "description": "指向包含列表项的已命名范围的公式字符串，例如 \"=RiskRatingsList\"。"}
    ],
    "examples": [
        {"code": "' Assume a named range \"ValidRiskLevels\" exists (e.g., on a 'Lookups' sheet)\n' containing values like \"Low\", \"Medium\", \"High\".\n' With Sheets(\"ClientPortfolio\").Range(\"C2:C100\").Validation ' Apply to Risk Rating column\n'   .Delete\n'   .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:=xlBetween, Formula1:=\"=ValidRiskLevels\"\n'   .InputMessage = \"请从列表中选择风险评级。\"\n'   .ShowError = True\n' End With\nMsgBox \"客户组合表中的风险评级列已设置数据验证列表 (源自ValidRiskLevels命名范围)。\"", "explanation": "为“ClientPortfolio”工作表的C2:C100范围（假设为风险评级列）设置数据验证，使其只能从名为“ValidRiskLevels”的已命名范围中选择值。"}
    ],
    "keywords": ["excel data validation list named range", "dropdown from another sheet", "贷后规范输入", "数据验证列表"]
},
{
    "name": "Range.CommentThreaded.Author (Excel Modern Comments)",
    "category": "Excel 核心操作",
    "syntax": "authorObject = commentThreadedObject.Author",
    "description": "传回一个 CommentAuthor 物件，代表执行绪式註解的作者。可以从中获取作者的名称 (`.Name`) 和用户ID (`.UserID`)。",
    "parameters": [],
    "examples": [
        {"code": "Dim cmtTh As CommentThreaded\n' Set cmtTh = Range(\"A1\").CommentThreaded ' Assume A1 has a modern comment\n' If Not cmtTh Is Nothing Then\n'   MsgBox \"A1的主要註解由 '\" & cmtTh.Author.Name & \"' 撰写。\"\n'   If cmtTh.Replies.Count > 0 Then\n'       MsgBox \"第一条回复由 '\" & cmtTh.Replies(1).Author.Name & \"' 撰写。\"\n'   End If\n' End If", "explanation": "如果A1单元格有新式执行绪註解，则显示主要註解及其第一条回复（如果存在）的作者名称。"}
    ],
    "keywords": ["excel modern comment author", "commentthreaded author", "註解作者", "新式註解属性"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.ChangeDataSource (Change PivotTable Source Data)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.ChangeDataSource(Source As Object)",
    "description": "变更指定数据透视表的源数据。Source 可以是一个 Range 对象或一个包含数据源连接信息的字符串 (用于外部数据源)。",
    "parameters": [
        {"name": "Source", "description": "新的数据源。例如，`Sheets(\"NewData\").Range(\"A1:G500\")`。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable\nDim newDataSourceRange As Range\n' Set pt = ActiveSheet.PivotTables(\"ClientSummaryPivot\")\n' Set newDataSourceRange = Sheets(\"UpdatedClientList\").Range(\"A1\").CurrentRegion\n' On Error Resume Next\n' pt.ChangeDataSource Source:=newDataSourceRange\n' If Err.Number = 0 Then\n'   pt.RefreshTable\n'   MsgBox \"数据透视表 '\" & pt.Name & \"' 的源数据已更新为 '\" & newDataSourceRange.Address(External:=True) & \"'。\"\n' Else\n'   MsgBox \"更新数据透视表源数据失败: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "将名为 'ClientSummaryPivot' 的数据透视表的源数据更改为 'UpdatedClientList' 工作表上的新数据区域，然后刷新该数据透视表。"}
    ],
    "keywords": ["excel pivottable changedatasource", "update pivot source data", "变更数据透视表源", "贷后数据更新"]
},
{
    "name": "PivotField.CurrentPageName Property (For Page Fields)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "currentPageString = pagePivotFieldObject.CurrentPageName",
    "description": "传回或设定 PivotTable 页面/筛选栏位中当前显示的项目的名称。如果设置，则该栏位会筛选为该项目。",
    "parameters": [{"name": "pageNameString (to set)", "description": "要显示的项目的名称。"}],
    "examples": [
        {"code": "Dim pt As PivotTable, pfRegion As PivotField\n' Set pt = ActiveSheet.PivotTables(\"RegionalSales\")\n' On Error Resume Next ' In case 'Region' is not a page field or 'North' is not an item\n' Set pfRegion = pt.PageFields(\"Region\")\n' If Not pfRegion Is Nothing Then\n'   pfRegion.CurrentPageName = \"华北地区\" ' Filter for '华北地区'\n'   If Err.Number = 0 Then\n'      MsgBox \"数据透视表已筛选显示区域: \" & pfRegion.CurrentPageName\n'   Else\n'      MsgBox \"无法设置 'Region' 页面筛选为 '华北地区': \" & Err.Description\n'   End If\n' Else\n'   MsgBox \"未找到 'Region' 页面栏位。\"\n' End If\n' On Error GoTo 0", "explanation": "将名为 'RegionalSales' 的数据透视表的 'Region' 页面/筛选栏位的值设置为 '华北地区'，从而筛选数据透视表以仅显示该区域的数据。"}
    ],
    "keywords": ["excel pivotfield currentpagename", "set pivot page filter", "筛选数据透视表页面栏位", "贷后区域分析"]
},
{
    "name": "PivotTable.GrandTotalName Property",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.GrandTotalName [= StringValue]",
    "description": "设定或传回枢纽分析表报表中总计标签的文字字串。预设值是 \"总计\" (或其本地化版本)。",
    "parameters": [{"name": "StringValue", "description": "要显示为总计标签的新文字。"}],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(1)\n' If Not pt Is Nothing Then\n'   pt.GrandTotalName = \"公司合计\"\n'   MsgBox \"数据透视表的总计标签已更改为 '公司合计'。\"\n' End If", "explanation": "将活动工作表上第一个数据透视表的总计标签文字更改为“公司合计”。"}
    ],
    "keywords": ["excel pivottable grandtotalname", "rename pivot grand total", "更改总计标签", "贷后报告总计"]
},
{
    "name": "ListColumn.Range Property (Excel Table Column)",
    "category": "Excel 核心操作",
    "syntax": "Set columnFullRange = listColumnObject.Range",
    "description": "传回一个 Range 物件，代表 Excel 表格 (ListObject) 中特定栏 (ListColumn) 的整个范围，包括该栏的标头、数据区域和总计列（如果可见）。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As ListObject, lc As ListColumn, fullColRng As Range\n' Set tbl = ActiveSheet.ListObjects(\"ClientLoans\")\n' On Error Resume Next\n' Set lc = tbl.ListColumns(\"InterestRate\")\n' If Not lc Is Nothing Then\n'   Set fullColRng = lc.Range\n'   fullColRng.NumberFormat = \"0.00%\"\n'   fullColRng.HorizontalAlignment = xlCenter\n'   MsgBox \"表格栏 'InterestRate' 的整个范围 ('\" & fullColRng.Address & \"') 已格式化。\"\n' Else\n'   MsgBox \"未找到名为 'InterestRate' 的表格栏。\"\n' End If\n' On Error GoTo 0", "explanation": "获取名为 'ClientLoans' 的表格中 'InterestRate' 栏的整个范围（包括表头和可能的总计行），并将其数字格式设为百分比，内容居中对齐。"}
    ],
    "keywords": ["listcolumn.range", "excel table column full range", "表格栏完整范围", "格式化表格栏"]
},
// Word Document Processing
{
    "name": "Document.ContentControls Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set ccCollection = documentObject.ContentControls",
    "description": "传回一个 ContentControls 集合，代表文件中所有的内容控制项。",
    "parameters": [
        {"name": ".Item(IndexOrTitleOrTag)", "description": "方法/属性：通过索引、标题或标签获取单个内容控制项。"},
        {"name": ".Count", "description": "属性：内容控制项的数量。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\nDim cc As Object    ' Word.ContentControl\n' Set wdDoc = ActiveDocument\n' If wdDoc.ContentControls.Count > 0 Then\n'   MsgBox \"此文件包含 \" & wdDoc.ContentControls.Count & \" 个内容控制项。\"\n'   For Each cc In wdDoc.ContentControls\n'     Debug.Print \"控制项标题: \" & cc.Title & \", 标签: \" & cc.Tag & \", 类型: \" & cc.Type\n'     If cc.Type = wdContentControlText Then ' Plain text content control\n'       ' cc.Range.Text = \"[已通过VBA填充 - \" & cc.Title & \"]\"\n'     End If\n'   Next cc\n' Else\n'   MsgBox \"此文件没有内容控制项。\"\n' End If", "explanation": "遍历活动Word文档中的所有内容控制项，并打印其标题、标签和类型。如果内容控制项是纯文本类型，则可以修改其文本。"}
    ],
    "keywords": ["word contentcontrols collection", "iterate content controls", "word structured document tags", "内容控制项集合", "遍历内容控制项"]
},
{
    "name": "ContentControl.Range Property (Word)",
    "category": "Word 文件處理",
    "syntax": "Set contentRange = contentControlObject.Range",
    "description": "传回一个 Range 对象，代表内容控制项的内容（不包括控制项本身的外框或标题）。",
    "parameters": [],
    "examples": [
        {"code": "Dim wdDoc As Object, cc As Object ' Word.ContentControl\n' Set wdDoc = ActiveDocument\n' ' Assume a content control with Tag = \"ClientAddressBlock\" exists\n' On Error Resume Next\n' Set cc = wdDoc.SelectContentControlsByTag(\"ClientAddressBlock\").Item(1)\n' If Not cc Is Nothing Then\n'   cc.Range.Text = \"123 Main Street\" & vbCrLf & \"Anytown, USA 12345\"\n'   cc.Range.Font.Name = \"Arial\"\n'   MsgBox \"已填充并格式化标签为 'ClientAddressBlock' 的内容控制项。\"\n' Else\n'   MsgBox \"未找到标签为 'ClientAddressBlock' 的内容控制项。\"\n' End If\n' On Error GoTo 0", "explanation": "通过标签查找一个内容控制项，然后获取其内部的 Range 对象来设置文本内容和字体。"}
    ],
    "keywords": ["word contentcontrol range", "set content control text", "内容控制项范围", "填充内容控制项"]
},
{
    "name": "Document.Fields(Index).Unlink (Word)",
    "category": "Word 文件處理",
    "syntax": "documentObject.Fields(Index).Unlink",
    "description": "将指定的域 (Field) 对象转换为其最近的结果 (静态文本)。这会移除域的功能，使其不再自动更新。",
    "parameters": [{"name": "Index", "description": "域在 Fields 集合中的索引号 (1-based)。"}],
    "examples": [
        {"code": "Dim wdDoc As Object ' Word.Document\n' Set wdDoc = ActiveDocument\n' ' Unlink all DATE fields in the document to fix their current value\n' Dim fld As Object ' Word.Field\n' Dim i As Long\n' For i = wdDoc.Fields.Count To 1 Step -1 ' Loop backwards when deleting or unlinking\n'   Set fld = wdDoc.Fields(i)\n'   If fld.Type = wdFieldDate Then\n'     fld.Unlink\n'     Debug.Print \"索引为 \" & i & \" 的日期域已解除链接。\"\n'   End If\n' Next i\n' If i < wdDoc.Fields.Count Then MsgBox \"部分或所有日期域已解除链接。\" Else MsgBox \"未找到日期域以解除链接。\"", "explanation": "遍历活动文档中的所有域，如果找到类型为 wdFieldDate (日期域) 的域，则将其解除链接，即将其转换为静态文本。"}
    ],
    "keywords": ["word unlink field", "convert field to text", "remove field code", "解除域链接", "域转文本"]
},
// Outlook 郵件與項目管理
{
    "name": "AppointmentItem.RecurrenceState Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "recurState = appointmentItemObject.RecurrenceState",
    "description": "传回一个 OlRecurrenceState 常数，表示约会项目的周期性状态。",
    "parameters": [
        {"name": "olApptNotRecurring (0)", "description": "不是周期性约会。"},
        {"name": "olApptMaster (1)", "description": "是周期性约会的主项目。"},
        {"name": "olApptOccurrence (2)", "description": "是周期性约会的一个发生实例。"},
        {"name": "olApptException (3)", "description": "是周期性约会的一个例外实例。"}
    ],
    "examples": [
        {"code": "Dim olApt As Object ' Outlook.AppointmentItem\n' ' Set olApt = Application.ActiveExplorer.Selection.Item(1) ' Assuming an appointment is selected\n' If TypeName(olApt) = \"AppointmentItem\" Then\n'   Select Case olApt.RecurrenceState\n'     Case 0: MsgBox \"'\" & olApt.Subject & \"' 是一个非周期性约会。\"\n'     Case 1: MsgBox \"'\" & olApt.Subject & \"' 是周期性约会的主项目。\"\n'     Case 2: MsgBox \"'\" & olApt.Subject & \"' 是周期性约会的一个发生实例。\"\n'     Case 3: MsgBox \"'\" & olApt.Subject & \"' 是周期性约会的一个例外实例。\"\n'   End Select\n' End If", "explanation": "检查选取的 Outlook 约会项目的周期性状态，并显示相应的描述。"}
    ],
    "keywords": ["outlook appointment recurrencestate", "olapptmaster", "olapptoccurrence", "约会周期状态"]
},
{
    "name": "Explorer.ClearSelection Method (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "explorerObject.ClearSelection",
    "description": "取消 Outlook 活动浏览器中的任何选定内容。",
    "parameters": [],
    "examples": [
        {"code": "Dim olExp As Object ' Outlook.Explorer\n' Set olExp = Application.ActiveExplorer\n' If olExp.Selection.Count > 0 Then\n'   MsgBox \"当前选定了 \" & olExp.Selection.Count & \" 个项目。现在将清除选定。\"\n'   olExp.ClearSelection\n'   MsgBox \"选定已清除。现在选定项目数: \" & olExp.Selection.Count\n' Else\n'   MsgBox \"当前没有项目被选定。\"\n' End If", "explanation": "如果 Outlook 活动浏览器中当前有选定的项目，则清除所有选定。"}
    ],
    "keywords": ["outlook clearselection", "deselect items outlook", "取消选定Outlook项目"]
},
// PowerPoint 簡報製作
{
    "name": "Slide.ApplyTheme (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideObject.ApplyTheme(themeFileName As String)",
    "description": "将指定的主题文件 (.thmx) 应用于单个投影片。这会覆盖该投影片从母片继承的主题。",
    "parameters": [
        {"name": "themeFileName", "description": "必需。主题文件的完整路径和文件名。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim themePath As String: themePath = \"C:\\Program Files\\Microsoft Office\\Document Themes 16\\Office Theme.thmx\" ' Example path\n' Set pptSlide = ActivePresentation.Slides(1)\n' On Error Resume Next ' Theme file might not exist\n' If Dir(themePath) <> \"\" Then\n'    pptSlide.ApplyTheme themePath\n'    If Err.Number = 0 Then MsgBox \"已将Office主题应用于第一张投影片。\" Else MsgBox \"应用主题失败: \" & Err.Description\n' Else\n'    MsgBox \"主题文件未找到: \" & themePath\n' End If\n' On Error GoTo 0", "explanation": "尝试将 Office 默认主题文件应用到当前简报的第一张投影片。实际主题文件路径可能因Office版本和安装而异。"}
    ],
    "keywords": ["powerpoint applytheme to slide", "change slide theme", "thmx file", "套用投影片主题"]
},
{
    "name": "Shape.TextFrame2.TextRange.Font (PowerPoint 2007+)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set font2Obj = shapeObject.TextFrame2.TextRange.Font",
    "description": "传回一个 TextRange2.Font 对象，提供对 PowerPoint 图案中文本更丰富的格式化选项 (相较于旧的 TextFrame.TextRange.Font)，例如文字效果、发光、阴影等。在 Office 2007 及更高版本中可用。",
    "parameters": [
        {"name": "Font2 Object Properties", "description": "例如 .Name, .Size, .Fill.ForeColor.RGB (for text color), .Glow.Radius, .Reflection.Type 等。"}
    ],
    "examples": [
        {"code": "Dim shp As Object ' PowerPoint.Shape\nDim tr2Font As Object ' Office.Font2 (from Microsoft Office Object Library)\n' Set shp = ActivePresentation.Slides(1).Shapes.AddTextbox(msoTextOrientationHorizontal, 50, 50, 300, 50)\n' shp.TextFrame2.TextRange.Text = \"高级文本效果\"\n' If Val(Application.Version) >= 12 Then ' Check for Office 2007+\n'   Set tr2Font = shp.TextFrame2.TextRange.Font\n'   With tr2Font\n'     .Size = 24\n'     .Fill.ForeColor.RGB = RGB(200, 50, 50) ' Dark Red text fill\n'     .Glow.Color.RGB = RGB(255, 255, 0)  ' Yellow glow\n'     .Glow.Radius = 8\n'     .Reflection.Type = msoReflectionType1 ' Add a reflection\n'   End With\n'   MsgBox \"已为文本框应用高级字体效果。\"\n' End If", "explanation": "在新创建的文本框中，使用 TextFrame2.TextRange.Font 来访问更高级的文本格式选项，例如设置文本填充色、发光效果和反射效果。"}
    ],
    "keywords": ["powerpoint textframe2 font", "advanced text formatting ppt", "glow effect text", "reflection text", "高级文本格式PPT"]
},
// FileSystemObject
{
    "name": "FileSystemObject.GetDrive (IsReady Property)",
    "category": "檔案與資料夾管理",
    "description": "Drive 物件的 IsReady 屬性 (Boolean) 指示指定的磁碟機是否已就緒可供存取。對於可卸除式磁碟機 (如USB隨身碟、光碟機)，如果沒有插入媒體，IsReady 會傳回 False。",
    "syntax": "isDriveReady = fso.GetDrive(DriveLetter).IsReady",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, cdDrive As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\n' Check a CD/DVD drive, e.g., D: (Change if your CD drive letter is different)\nOn Error Resume Next ' In case drive D: doesn't exist\nSet cdDrive = fso.GetDrive(\"D\")\nIf Err.Number = 0 And Not cdDrive Is Nothing Then\n  If cdDrive.IsReady Then\n    MsgBox \"磁碟機 D: 已就緒 (可能有光碟在裡面)。\"\n  Else\n    MsgBox \"磁碟機 D: 未就緒 (可能沒有光碟或無法存取)。\"\n  End If\nElse\n  MsgBox \"無法存取磁碟機 D: 或該磁碟機不存在。\"\nEnd If\nOn Error GoTo 0\nSet fso = Nothing: Set cdDrive = Nothing", "explanation": "檢查 D: 磁碟機 (通常是光碟機) 是否已就緒。如果裡面沒有光碟，IsReady 通常會是 False。"}
    ],
    "keywords": ["fso drive isready", "check removable drive status", "cd drive ready", "檢查磁碟機是否就緒"]
},
// String Functions
{
    "name": "Replace (Empty String for Replacement)",
    "category": "字串與文本操作",
    "description": "如果 Replace 函數的 `replace` 引數是一個空字串 (vbNullString 或 \"\")，則所有找到的 `find` 子字串都會被移除。",
    "syntax": "Replace(expression, find, \"\")",
    "parameters": [],
    "examples": [
        {"code": "Dim textWithSpaces As String: textWithSpaces = \"Remove   all   extra   spaces.\"\nDim textWithoutSpaces As String\n' Remove all spaces\ntextWithoutSpaces = Replace(textWithSpaces, \" \", \"\")\nDebug.Print \"移除所有空格後: '\" & textWithoutSpaces & \"'\" ' Output: 'Removeallextraspaces.'\n\nDim dataString As String: dataString = \"ProductID;Name;Price\"\nDim cleanedData As String\ncleanedData = Replace(dataString, \";\", \"\") ' Remove all semicolons\nDebug.Print \"移除分號後: '\" & cleanedData & \"'\" ' Output: 'ProductIDNamePrice'", "explanation": "第一個範例移除字串中所有的空格。第二個範例移除所有分號。"}
    ],
    "keywords": ["replace with empty string", "remove substring vba", "delete characters from string", "用空字串取代", "移除子字串"]
},
// Math Functions
{
    "name": "WorksheetFunction.Floor_Math (Excel 2013+)",
    "category": "數學、日期與時間",
    "syntax": "floorValue = Application.WorksheetFunction.Floor_Math(Number, [Significance As Double = 1], [Mode As Double = 0])",
    "description": "使用 Excel 的 FLOOR.MATH 工作表函數 (Excel 2013+)，將數字向下捨入到最接近的指定基數的倍數。Mode 引數控制負數的捨入方向 (0 或省略表示朝向零，非零值表示遠離零)。",
    "parameters": [
        {"name": "Number", "description": "必需。要捨入的數字。"},
        {"name": "Significance", "description": "可選。要捨入到的倍數。預設為1。"},
        {"name": "Mode", "description": "可選。對於負數，0 或省略表示朝向零捨入，任何非零值表示遠離零捨入。"}
    ],
    "examples": [
        {"code": "Debug.Print \"FLOOR.MATH(10.75, 0.5) = \" & Application.WorksheetFunction.Floor_Math(10.75, 0.5) ' Output: 10.5\nDebug.Print \"FLOOR.MATH(1.9, 1) = \" & Application.WorksheetFunction.Floor_Math(1.9)       ' Output: 1\nDebug.Print \"FLOOR.MATH(-2.5, 2, 0) = \" & Application.WorksheetFunction.Floor_Math(-2.5, 2, 0)  ' Output: -2 (towards zero)\nDebug.Print \"FLOOR.MATH(-2.5, 2, 1) = \" & Application.WorksheetFunction.Floor_Math(-2.5, 2, 1)  ' Output: -4 (away from zero)", "explanation": "演示 FLOOR.MATH 函數如何將數字向下捨入到指定基數的倍數，以及 Mode 引數對負數的影響。"}
    ],
    "keywords": ["floor.math", "excel floor function vba", "round down to multiple", "向下捨入到倍數"]
},
// Data Types
{
    "name": "vbError Constant (VarType)",
    "category": "資料類型、轉換與驗證",
    "description": "vbError 是一個 VbVarType 列舉常數，其值為 10。VarType 函數在檢查一個 Variant 變數是否包含由 CVErr 函數建立的錯誤值時，會傳回此值。",
    "parameters": [],
    "examples": [
        {"code": "Dim errVal As Variant\nerrVal = CVErr(xlErrNA) ' Create an #N/A error value\nIf VarType(errVal) = vbError Then\n  Debug.Print \"errVal 的 VarType 是 vbError (\" & vbError & \").\"\n  If CLng(errVal) = xlErrNA Then ' Check specific error code\n    Debug.Print \"  錯誤是 #N/A (代碼: \" & xlErrNA & \")\"\n  End If\nElse\n  Debug.Print \"errVal 的 VarType 不是 vbError: \" & VarType(errVal)\nEnd If", "explanation": "建立一個 #N/A 錯誤值並將其儲存在 Variant 變數中。然後使用 VarType 檢查該變數是否為 vbError 類型，並進一步檢查其具體的錯誤代碼。"}
    ],
    "keywords": ["vberror", "vartype error value", "cverr vartype", "錯誤值類型代碼"]
},
// Program Flow
{
    "name": "Exit Try Statement (Conceptual - Not in VBA)",
    "category": "程式流程與結構控制",
    "description": "VBA 沒有內建的 `Try...Catch...Finally` 結構，因此也沒有 `Exit Try` 語句。錯誤處理在 VBA 中是透過 `On Error GoTo Label`, `On Error Resume Next`, 和 `On Error GoTo 0` 語句，以及 `Err` 物件來管理的。若要在錯誤處理標籤中提前退出且不執行後續的錯誤處理代碼或恢復點，通常會使用 `Exit Sub` 或 `Exit Function` (如果錯誤是不可恢復的)，或者使用 `GoTo` 跳轉到一個共享的清理標籤。",
    "parameters": [],
    "examples": [
        {"code": "Sub ErrorHandlingWithExitSub()\n    On Error GoTo MyHandler\n    Dim result As Double\n    result = 10 / 0 ' This will cause an error\n    MsgBox \"This line will not be reached if error occurs.\"\n    Exit Sub ' Normal exit path\nMyHandler:\n    MsgBox \"錯誤發生: \" & Err.Description\n    ' After handling, you might want to exit the sub completely\n    ' rather than trying to resume or continue if it's a fatal error for this sub.\n    MsgBox \"由於錯誤，將退出此子程序。\"\n    ' No 'Exit Try' but can use 'Exit Sub' here to leave the Sub.\n    Exit Sub ' Exit the Sub entirely after handling.\nEnd Sub", "explanation": "演示一個錯誤處理塊。當錯誤發生時，程式跳轉到 MyHandler。在處理完錯誤後，如果決定不再繼續執行該 Sub 的其餘部分，可以使用 `Exit Sub` 來退出。這與其他語言中的 `finally` 塊之後的正常流程或從 `catch` 塊中提前返回有些類似，但 VBA 的機制不同。"}
    ],
    "keywords": ["vba error handling exit", "exit sub from error handler", "no try catch vba", "VBA錯誤處理退出"]
},
// External API
{
    "name": "WScript.Shell.RegRead (Boolean/Numeric from Registry)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "WScript.Shell 的 RegRead 方法讀取登錄檔值時，會嘗試根據值的類型傳回適當的 VBA 資料類型。例如，REG_DWORD 值會被讀取為 Long。對於類似布林的值 (例如，DWORD 值 0 或 1)，VBA 可以將其解釋為 Boolean。",
    "parameters": [],
    "examples": [
        {"code": "Dim wsh As Object, regBasePath As String\nDim dwordVal As Long, boolValFromDword As Boolean, strVal As String\nSet wsh = CreateObject(\"WScript.Shell\")\nregBasePath = \"HKCU\\Software\\VB and VBA Program Settings\\MyAppVBA\\Settings\\\"\n' Ensure the path ends with a backslash for the key itself\n\n' Write some values for testing\nOn Error Resume Next\nwsh.RegWrite regBasePath & \"EnableFeatureX\", 1, \"REG_DWORD\" ' 1 for True\nwsh.RegWrite regBasePath & \"MaxRetries\", 5, \"REG_DWORD\"\nwsh.RegWrite regBasePath & \"UserName\", \"DefaultUser\", \"REG_SZ\"\nIf Err.Number <> 0 Then Debug.Print \"寫入登錄檔時發生錯誤: \" & Err.Description : Err.Clear\nOn Error GoTo 0\n\n' Read DWORD as Long and then interpret as Boolean\ndwordVal = wsh.RegRead(regBasePath & \"EnableFeatureX\")\nIf IsNumeric(dwordVal) Then boolValFromDword = CBool(dwordVal)\nDebug.Print \"EnableFeatureX (DWORD as Long): \" & dwordVal & \", As Boolean: \" & boolValFromDword\n\n' Read another DWORD\ndwordVal = wsh.RegRead(regBasePath & \"MaxRetries\")\nDebug.Print \"MaxRetries (DWORD): \" & dwordVal\n\n' Read String\nstrVal = wsh.RegRead(regBasePath & \"UserName\")\nDebug.Print \"UserName (String): \" & strVal\n\nSet wsh = Nothing", "explanation": "演示使用 RegWrite 寫入一個 REG_DWORD 值 (例如 1 代表 True)，然後使用 RegRead 將其讀回。VBA 會將 REG_DWORD 讀取為 Long，然後可以使用 CBool 將其轉換為布林值。同時也讀取了一個字串值。"}
    ],
    "keywords": ["regread dword as boolean", "registry numeric value vba", "wsh read boolean registry", "讀取登錄檔數字布林"]
},
{
    "name": "MSXML2.DOMDocument (Load with preserveWhiteSpace=True)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "當 MSXML2.DOMDocument 的 `preserveWhiteSpace` 屬性設為 True 時，XML 解析器會保留元素標籤之間所有形式的空白字元 (空格、定位字元、換行符) 作為 DOM 樹中的文字節點。這在處理需要精確保留原始 XML 格式 (例如，包含預格式化文字或具有特定縮排的 XML) 時非常重要。",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object\nDim xmlFormatted As String\nxmlFormatted = \"<root>\" & vbCrLf & _\n               \"  <item>\" & vbCrLf & _\n               \"    Value 1\" & vbCrLf & _\n               \"  </item>\" & vbCrLf & _\n               \"  <item>Value 2</item>\" & vbCrLf & _\n               \"</root>\"\n\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\nxmlDoc.preserveWhiteSpace = True ' << Preserve whitespace\n\nIf xmlDoc.LoadXML(xmlFormatted) Then\n    Debug.Print \"--- XML with preserveWhiteSpace = True ---\"\n    Debug.Print xmlDoc.XML ' Output will include all original CRLFs and spaces\n    Debug.Print \"根元素的子節點數量 (包括空白文字節點): \" & xmlDoc.documentElement.childNodes.length\n    ' Example: Accessing text node that is just whitespace\n    ' If xmlDoc.documentElement.childNodes(0).nodeType = 3 Then ' NODE_TEXT\n    '   Debug.Print \"第一個子節點 (空白) 的值: '\" & xmlDoc.documentElement.childNodes(0).nodeValue & \"'\"\n    ' End If\nElse\n    Debug.Print \"XML 載入錯誤: \" & xmlDoc.parseError.reason\nEnd If\nSet xmlDoc = Nothing", "explanation": "載入一個包含多個換行符和縮排空格的 XML 字串。由於 `preserveWhiteSpace` 設為 True，當列印 `xmlDoc.XML` 時，這些空白字元會被保留。同時，DOM 樹中的 `childNodes` 集合也會包含代表這些空白的文字節點，導致 `childNodes.length` 可能大於僅計算元素節點時的預期。"}
    ],
    "keywords": ["msxml preserve white space true", "xml formatting preserve", "dom text node whitespace", "保留XML空白節點"]
},
{
    "name": "ADODB.Recordset (AbsolutePage Property)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 AbsolutePage 屬性設定或傳回目前記錄所在的頁碼。一頁是一組記錄，其大小由 PageSize 屬性定義。要使用 AbsolutePage，Recordset 的 CursorLocation 通常需要是 `adUseClient` (3)，並且 CursorType 需要支援書籤 (例如 `adOpenKeyset` 或 `adOpenStatic`)。",
    "syntax": "currentPageNum = rs.AbsolutePage\nrs.AbsolutePage = newPageNum",
    "parameters": [{"name": "rs.PageSize", "description": "屬性：設定或傳回每頁包含的記錄數。"}],
    "examples": [
        {"code": "Dim conn As Object, rs As Object\n' ' Assume conn is an open ADODB.Connection\n' Set rs = CreateObject(\"ADODB.Recordset\")\n' rs.CursorLocation = 3 ' adUseClient\n' rs.PageSize = 10 ' Define each page to have 10 records\n' On Error Resume Next\n' rs.Open \"SELECT OrderID, CustomerID FROM Orders ORDER BY OrderID\", conn, 3, 1 ' adOpenStatic, adLockReadOnly\n' If Err.Number = 0 And Not rs.EOF Then\n'   Debug.Print \"總頁數: \" & rs.PageCount\n'   Debug.Print \"目前頁碼 (初始): \" & rs.AbsolutePage ' Usually 1 or adPosUnknown\n'   If rs.PageCount > 1 Then\n'     rs.AbsolutePage = 2 ' Move to the second page\n'     Debug.Print \"移至第二頁後，目前頁碼: \" & rs.AbsolutePage\n'     Debug.Print \"  第二頁的第一筆記錄 OrderID: \" & rs!OrderID\n'   End If\n'   rs.Close\n' Else\n'   Debug.Print \"開啟資料錄集失敗或為空。錯誤: \" & Err.Description\n' End If\n' On Error GoTo 0\n' ' If conn.State = 1 Then conn.Close\n' ' Set rs = Nothing: Set conn = Nothing\nMsgBox \"(概念性) 演示了 AbsolutePage。需有實際資料庫。\"", "explanation": "演示如何設定 Recordset 的 PageSize，然後使用 AbsolutePage 屬性來獲取目前頁碼或導航到特定頁面。這對於分頁顯示大量數據很有用。"}
    ],
    "keywords": ["adodb absolutepage", "recordset paging", "ado pagecount", "pagesize", "記錄集分頁"]
},
{
    "name": "Command.NamedParameters Property (ADODB.Command)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Command 物件的 NamedParameters 屬性 (布林值) 指示提供者是否應僅評估以名稱傳遞的參數 (True)，還是按其在 Parameters 集合中出現的順序評估參數 (False，預設)。如果設為 True，則在執行命令時，參數值會根據其 Name 屬性與命令文字 (例如 SQL 查詢或預存程序定義) 中的參數名稱進行匹配。如果為 False，則參數按順序匹配。對於使用命名參數的預存程序或查詢，建議將其設為 True 以提高清晰度和可靠性。",
    "syntax": "cmd.NamedParameters = True",
    "parameters": [],
    "examples": [
        {"code": "Dim conn As Object, cmd As Object, param1 As Object, param2 As Object\n' ' Assume conn is an open ADODB.Connection\n' Set cmd = CreateObject(\"ADODB.Command\")\n' Set cmd.ActiveConnection = conn\n' cmd.CommandType = 1 ' adCmdText\n' cmd.CommandText = \"SELECT * FROM Products WHERE CategoryID = ? AND SupplierID = ?\"\n' ' cmd.CommandText = \"SELECT * FROM Products WHERE CategoryID = @CatID AND SupplierID = @SuppID\" ' More typical for named params in SQL Server\n'\n' cmd.NamedParameters = True ' Enable named parameter matching\n'\n' ' Parameters can be added in any order if NamedParameters is True\n' Set param2 = cmd.CreateParameter(\"@SuppID\", adInteger, adParamInput, , 5)\n' cmd.Parameters.Append param2\n' Set param1 = cmd.CreateParameter(\"@CatID\", adInteger, adParamInput, , 1)\n' cmd.Parameters.Append param1\n' ' For '?' placeholders, the order of appending matters even if NamedParameters is True for some providers.\n' ' It's best practice to match placeholder order or use named placeholders in CommandText if provider supports.\n'\n' ' Dim rs As Object\n' ' Set rs = cmd.Execute\n' ' ' ... process rs ...\n' ' If Not rs Is Nothing Then If rs.State = 1 Then rs.Close\n' ' Set rs = Nothing: Set cmd = Nothing: Set param1 = Nothing: Set param2 = Nothing\n' ' If conn.State = 1 Then conn.Close\n' ' Set conn = Nothing\nMsgBox \"(概念性) 演示了 NamedParameters 屬性。實際效果取決於提供者和SQL語法。\"", "explanation": "演示如何將 Command 物件的 NamedParameters 屬性設為 True。當使用命名參數 (例如 SQL Server 中的 `@ParamName`) 時，這允許參數以任何順序附加到 Parameters 集合，只要它們的 Name 屬性與命令文字中的參數名稱匹配。對於使用問號 `?` 作為參數佔位符的 SQL，參數的附加順序通常仍然很重要，即使 NamedParameters 為 True。"}
    ],
    "keywords": ["adodb namedparameters", "ado command named parameters", "sql parameter by name", "命名參數ADO"]
},
{
    "name": "MSXML2.DOMDocument (validate Method - after loading with validation off)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "如果 XML 文件在載入時沒有進行驗證 (`validateOnParse = False`)，或者需要在載入後根據不同的 Schema 進行驗證，可以使用 DOMDocument 物件的 `validate` 方法。此方法會根據先前指派給 `schemas` 屬性的 SchemaCache 來驗證目前 DOM 樹。它會傳回一個 IXMLDOMParseError 物件，可以檢查其 `errorCode` 來判斷驗證是否成功。",
    "syntax": "Set parseErrorObj = xmlDoc.validate()",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object, schemaCache As Object, validationError As Object\nDim xmlContent As String, schemaContent As String\n' Schema and XML from previous example (IXMLDOMDocument Load with Validation)\nschemaContent = \"<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema'>... (schema as before) ...</xs:schema>\"\nxmlContent = \"<note><to>Tove</to><sender>Jani</sender>...</note>\" ' Invalid XML\n\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\nxmlDoc.validateOnParse = False ' << Load WITHOUT validation initially\nxmlDoc.LoadXML xmlContent\nIf xmlDoc.parseError.errorCode <> 0 Then\n    Debug.Print \"XML 載入時發生解析錯誤 (非驗證錯誤): \" & xmlDoc.parseError.reason\n    Exit Sub\nEnd If\n\n' Load schema and assign to document\nSet schemaCache = CreateObject(\"MSXML2.SchemaCache.6.0\")\nschemaCache.Add \"urn:my-schema\", schemaContent\nSet xmlDoc.schemas = schemaCache\n\n' Now, explicitly validate the loaded DOM against the schema\nSet validationError = xmlDoc.validate()\n\nIf validationError.errorCode <> 0 Then\n    Debug.Print \"--- XML 手動驗證失敗 ---\"\n    Debug.Print \"  錯誤碼: \" & validationError.errorCode\n    Debug.Print \"  原因: \" & validationError.reason\n    Debug.Print \"  行: \" & validationError.Line & \", 位置: \" & validationError.linepos\nElse\n    Debug.Print \"XML 已成功通過手動驗證。\"\nEnd If\nSet xmlDoc = Nothing: Set schemaCache = Nothing: Set validationError = Nothing", "explanation": "此範例首先在 `validateOnParse = False` 的情況下載入一個 XML 字串 (即使它可能不符合 Schema，但只要它是格式良好的 XML，就會載入成功)。然後，它將一個 SchemaCache 指派給 DOMDocument 的 `schemas` 屬性，並呼叫 `validate` 方法。`validate` 方法會根據指派的 Schema 驗證已載入的 DOM 樹，並傳回一個 IXMLDOMParseError 物件，可以檢查其 `errorCode` 來判斷驗證結果。"}
    ],
    "keywords": ["msxml domdocument validate method", "xml explicit validation", "validate loaded xml", "手動XML驗證"]
},

{
    "name": "Application.OnTime (Daily Loan Status Report Generation)",
    "category": "Excel 核心操作",
    "syntax": "Application.OnTime TimeValue(\"17:00:00\"), \"GenerateDailyLoanStatusReport\"",
    "description": "使用 Application.OnTime 安排一個VBA宏（例如 GenerateDailyLoanStatusReport）在每個工作日的特定時間（例如下午5點）自動執行。該巨集可以匯總當日的貸款狀態變化、逾期情況、新增風險等，並生成報告或發送通知，是貸後管理日報的有效自動化手段。",
    "parameters": [
        {"name": "TimeValue(\"HH:MM:SS\")", "description": "指定宏應執行的時間。"},
        {"name": "ProcedureName", "description": "要執行的公共Sub過程的名稱。"}
    ],
    "examples": [
        {"code": "Public Sub ScheduleDailyReport()\n    ' Run this once, or in Workbook_Open to schedule for today\n    Dim runTime As Date\n    runTime = Date + TimeValue(\"17:00:00\") ' Today at 5 PM\n    If Weekday(runTime, vbMonday) <= 5 Then ' Only schedule on weekdays\n        Application.OnTime EarliestTime:=runTime, Procedure:=\"GenerateDailyLoanStatusReport\"\n        MsgBox \"每日貸款狀態報告已安排在今天下午5點生成。\"\n    Else\n        MsgBox \"今天是週末，每日報告將不會被安排。\"\n    End If\nEnd Sub\n\nPublic Sub GenerateDailyLoanStatusReport()\n    ' Actual report generation logic here...\n    MsgBox \"正在生成每日貸款狀態報告... (執行於: \" & Now & \")\"\n    ' Example: Consolidate data, check for new overdues, etc.\n    ' ThisWorkbook.Save ' Save the report workbook\n    ' Potentially call another sub to email the report\n    ' To reschedule for next weekday:\n    Dim nextRunTime As Date\n    nextRunTime = Date + 1 + TimeValue(\"17:00:00\") ' Tomorrow 5 PM\n    Do While Weekday(nextRunTime, vbMonday) > 5 ' Skip weekend\n        nextRunTime = nextRunTime + 1\n    Loop\n    Application.OnTime EarliestTime:=nextRunTime, Procedure:=\"GenerateDailyLoanStatusReport\"\n    Debug.Print \"下次每日報告已安排在: \" & nextRunTime\nEnd Sub", "explanation": "ScheduleDailyReport 宏安排 GenerateDailyLoanStatusReport 在當天下午5點執行（如果是工作日）。GenerateDailyLoanStatusReport 內部包含實際生成報告的邏輯，並在結束時重新安排自身在下一個工作日下午5點執行，從而實現每日自動報告。"}
    ],
    "keywords": ["application.ontime", "schedule daily task", "automate daily report", "time-triggered macro", "貸後日報自動化", "定時任務Excel"]
},
{
    "name": "Timer (Measure Loan Data Processing Time)",
    "category": "Excel 核心操作",
    "syntax": "startTime = Timer\n' ... VBA code for processing loan data ...\nduration = Timer - startTime",
    "description": "使用 Timer 函數精確測量一段VBA代碼（例如，處理大量貸款資料、計算風險指標、生成複雜貸後報告）的執行時間，以秒為單位。這有助於識別性能瓶頸並優化貸後管理相關的自動化流程。",
    "parameters": [],
    "examples": [
        {"code": "Sub BenchmarkLoanDataProcessing()\n    Dim sTime As Single, eTime As Single\n    Dim i As Long, tempCalc As Double\n    Dim dataSheet As Worksheet, lastRow As Long\n    ' Set dataSheet = ThisWorkbook.Sheets(\"LoanPortfolio\")\n    ' lastRow = dataSheet.Cells(Rows.Count, \"A\").End(xlUp).Row\n\n    sTime = Timer\n    ' Simulate processing each loan record\n    ' For i = 2 To lastRow ' Assuming header in row 1\n    '   tempCalc = dataSheet.Cells(i, \"LoanAmount_Col\").Value * dataSheet.Cells(i, \"InterestRate_Col\").Value ' Example calculation\n    '   If i Mod 1000 = 0 Then DoEvents ' Yield for very large datasets\n    ' Next i\n    ' For i = 1 To 20000000: Next i ' Placeholder for actual processing\n\n    eTime = Timer\n    MsgBox \"貸款資料處理耗時: \" & Format(eTime - sTime, \"0.000\") & \" 秒。\"", "explanation": "在開始處理貸款資料前記錄 Timer 值，處理完畢後再次記錄，兩者之差即為處理時長。此方法可用於評估貸後管理腳本的效率。"}
    ],
    "keywords": ["timer performance", "benchmark vba code", "loan data processing speed", "貸後處理時間測量", "VBA性能測試"]
},
{
    "name": "DateDiff (Calculate Loan Age in Days/Months/Years)",
    "category": "數學、日期與時間",
    "syntax": "ageInDays = DateDiff(\"d\", LoanOriginationDate, AsOfDate)\nageInMonths = DateDiff(\"m\", LoanOriginationDate, AsOfDate)\nageInYears = DateDiff(\"yyyy\", LoanOriginationDate, AsOfDate)",
    "description": "使用 DateDiff 函數計算貸款自發放日起到指定“截至日期”（通常是當前日期或報告日期）的帳齡，可以按天、月或年計算。這是貸後風險分析和撥備計提的重要參數。",
    "parameters": [
        {"name": "interval (\"d\", \"m\", \"yyyy\")", "description": "時間間隔單位。"},
        {"name": "LoanOriginationDate", "description": "貸款發放日期。"},
        {"name": "AsOfDate", "description": "計算帳齡的截止日期。"}
    ],
    "examples": [
        {"code": "Dim origDate As Date, reportDate As Date\norigDate = DateSerial(2021, 6, 15)\nreportDate = DateSerial(2023, 10, 26)\n\nDebug.Print \"貸款帳齡 (天): \" & DateDiff(\"d\", origDate, reportDate)\nDebug.Print \"貸款帳齡 (完整月數): \" & DateDiff(\"m\", origDate, reportDate)\nDebug.Print \"貸款帳齡 (完整年數): \" & DateDiff(\"yyyy\", origDate, reportDate)", "explanation": "計算從2021年6月15日到2023年10月26日的貸款帳齡，分別以天、完整月數和完整年數顯示。"}
    ],
    "keywords": ["datediff loan age", "calculate loan tenure", "貸後帳齡計算", "貸款存續期"]
},
{
    "name": "DateAdd (Calculate Next Review Date)",
    "category": "數學、日期與時間",
    "syntax": "nextReviewDate = DateAdd(\"m\", ReviewFrequencyMonths, LastReviewDate)",
    "description": "根據上次審查日期和固定的審查頻率（例如，每3個月、6個月或12個月），使用 DateAdd 函數計算下一次貸後審查的計畫日期。",
    "parameters": [
        {"name": "interval (\"m\" for months, \"q\" for quarters, \"yyyy\" for years)", "description": "審查頻率的時間間隔單位。"},
        {"name": "ReviewFrequencyMonths", "description": "審查頻率的月份數 (或其他單位數)。"},
        {"name": "LastReviewDate", "description": "上次審查的完成日期。"}
    ],
    "examples": [
        {"code": "Dim lastReview As Date: lastReview = DateSerial(2023, 7, 15)\nDim quarterlyReviewDue As Date, annualReviewDue As Date\n\nquarterlyReviewDue = DateAdd(\"q\", 1, lastReview) ' Next quarterly review (3 months later)\nannualReviewDue = DateAdd(\"yyyy\", 1, lastReview)    ' Next annual review (1 year later)\n\nMsgBox \"上次審查: \" & Format(lastReview, \"yyyy-mm-dd\") & vbCrLf & _\n       \"下次季度審查: \" & Format(quarterlyReviewDue, \"yyyy-mm-dd\") & vbCrLf & _\n       \"下次年度審查: \" & Format(annualReviewDue, \"yyyy-mm-dd\")", "explanation": "根據2023年7月15日的上次審查日期，計算下一次季度審查（3個月後）和年度審查（1年後）的到期日。"}
    ],
    "keywords": ["dateadd review date", "schedule next loan review", "貸後審查日期計算", "定期審查計畫"]
},
{
    "name": "Format (Timestamp for Loan Action Log)",
    "category": "字串與文本操作",
    "syntax": "logEntry = Format(Now, \"yyyy-mm-dd hh:mm:ss\") & \" - User: \" & Application.UserName & \" - Action: \" & actionDescription",
    "description": "使用 Format(Now, ...) 生成包含日期和精確時間的時間戳記，用於記錄貸後管理操作（例如，風險評級變更、催收電話、檔接收）到Excel日誌表中，確保操作的可追溯性。",
    "parameters": [
        {"name": "Now", "description": "當前的日期和時間。"},
        {"name": "FormatString (\"yyyy-mm-dd hh:mm:ss\")", "description": "期望的時間戳記格式。"}
    ],
    "examples": [
        {"code": "Sub LogLoanCovenantUpdate(loanID As String, covenantName As String, oldValue As String, newValue As String)\n    Dim wsLog As Worksheet, nextLog As Long\n    ' Set wsLog = ThisWorkbook.Sheets(\"CovenantChangeLog\")\n    ' nextLog = wsLog.Cells(Rows.Count, 1).End(xlUp).Row + 1\n    Dim timeStamp As String: timeStamp = Format(Now, \"yyyy-mm-dd hh:nn:ss\")\n    Dim user As String: user = Application.UserName\n    ' wsLog.Cells(nextLog, 1).Value = timeStamp\n    ' wsLog.Cells(nextLog, 2).Value = user\n    ' wsLog.Cells(nextLog, 3).Value = loanID\n    ' wsLog.Cells(nextLog, 4).Value = \"Covenant Update: \" & covenantName\n    ' wsLog.Cells(nextLog, 5).Value = \"Old: \" & oldValue & \", New: \" & newValue\n    Debug.Print timeStamp & \" - User: \" & user & \" - Updated covenant '\" & covenantName & \"' for loan '\" & loanID & \"' from '\" & oldValue & \"' to '\" & newValue & \"'\"", "explanation": "當貸款契約發生變更時，此副程式（概念性）會生成一個包含當前時間戳記、用戶名、貸款ID、契約名稱以及新舊值的日誌條目，並列印到立即視窗（實際應用中會寫入日誌表）。"}
    ],
    "keywords": ["format timestamp vba", "log entry timestamp", "audit trail timestamp", "貸後操作日誌時間戳記", "記錄時間"]
},
{
    "name": "Application.OnTime (Periodic Collateral Revaluation Reminder)",
    "category": "Excel 核心操作",
    "syntax": "Application.OnTime TimeValue(\"09:00:00\"), \"CheckCollateralRevaluationDue\"",
    "description": "使用 Application.OnTime 安排一個宏在每個工作日的特定時間（例如上午9點）運行，該宏檢查抵押品管理表，識別出哪些抵押品即將需要重新評估（例如，根據上次評估日期和評估有效期），並可以生成提醒或報告。",
    "parameters": [],
    "examples": [
        {"code": "Public Sub ScheduleCollateralCheck()\n    ' Run this daily, e.g., from Workbook_Open or a master scheduler\n    Dim checkTime As Date\n    checkTime = Application.WorksheetFunction.WorkDay_Intl(Date, 1, \"0000011\") + TimeValue(\"09:00:00\") ' Next weekday 9 AM\n    Application.OnTime EarliestTime:=checkTime, Procedure:=\"CheckCollateralRevaluationDue\"\n    Debug.Print \"抵押品重估檢查已安排在: \" & checkTime\nEnd Sub\n\nPublic Sub CheckCollateralRevaluationDue()\n    ' Logic to scan collateral log for items due for revaluation\n    ' Example: If LastValuationDate + ValuationValidityPeriodDays < Now + 30 days\n    MsgBox \"正在檢查抵押品重估到期情況... (執行於: \" & Now & \")\"\n    ' ... Generate report or send Outlook reminders to responsible RMs ...\n    Call ScheduleCollateralCheck ' Reschedule for the next weekday\nEnd Sub", "explanation": "ScheduleCollateralCheck 安排 CheckCollateralRevaluationDue 在下一個工作日的上午9點執行。CheckCollateralRevaluationDue 包含檢查邏輯，並重新安排自身，實現定期監控。"}
    ],
    "keywords": ["ontime collateral revaluation", "schedule revaluation check", "貸後抵押品重估提醒", "定時檢查抵押品"]
},
{
    "name": "ADODB.Recordset (Filter by Date Range)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "使用 ADODB Recordset 的 Filter 屬性，可以根據日期範圍篩選記錄，例如，篩選出特定月份或季度內的貸款發放記錄或還款記錄，用於貸後分析報告。日期需要正確格式化以匹配資料庫或 Recordset 的期望。",
    "syntax": "rs.Filter = \"PaymentDate >= #yyyy-mm-dd# AND PaymentDate <= #yyyy-mm-dd#\"",
    "parameters": [{"name": "Date Format in Filter", "description": "日期常數通常用 `#mm/dd/yyyy#` 或 `#yyyy-mm-dd#` (ISO 8601) 格式。使用 Format 函數確保日期格式正確。"}],
    "examples": [
        {"code": "Dim rs As Object ' ADODB.Recordset\nDim startDate As Date, endDate As Date\n' ' Assume rs is an open ADODB.Recordset from 'PaymentHistory' table with client-side cursor\n' ' rs.CursorLocation = adUseClient\n' ' rs.Open \"SELECT * FROM PaymentHistory\", conn, adOpenStatic, adLockReadOnly\n'\n' startDate = DateSerial(2023, 10, 1)\n' endDate = DateSerial(2023, 10, 31)\n'\n' ' Filter for payments made in October 2023\n' ' Using ISO format for dates in filter string is often safer\n' rs.Filter = \"PaymentDate >= #\" & Format(startDate, \"yyyy-mm-dd\") & \"# AND PaymentDate <= #\" & Format(endDate, \"yyyy-mm-dd\") & \"#\"\n'\n' Debug.Print \"--- 十月份的還款記錄 (篩選後) ---\"\n' Do While Not rs.EOF\n'   Debug.Print rs!LoanID & \" - \" & rs!PaymentDate & \" - \" & rs!AmountPaid\n'   rs.MoveNext\n' Loop\n' rs.Filter = \"\" ' Clear filter to see all records again\n' If rs.State = 1 Then rs.Close\nMsgBox \"(概念性) 演示了按日期範圍篩選Recordset。需有實際資料。\"", "explanation": "演示如何為一個已打開的、使用用戶端游標的 ADODB Recordset 設置 Filter 屬性，以篩選出“PaymentDate”在指定日期範圍內的記錄。使用 Format 函數確保日期字串的格式正確。"}
    ],
    "keywords": ["adodb recordset filter date range", "filter by date ado", "貸後資料按日期篩選", "日期範圍篩選"]
},
{
    "name": "ShellExecute (Open Document with Timestamped Backup)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "在貸後管理中，打開客戶關鍵文檔（如合同、財務報表）前，先自動創建一個帶時間戳記的備份副本，然後再用 ShellExecute 打開原始文檔。這確保了原始文檔的快照被保留，防止意外修改。",
    "syntax": "fso.CopyFile SourcePath, BackupPath\nShellExecute 0, \"open\", SourcePath, vbNullString, vbNullString, SW_SHOWNORMAL",
    "parameters": [
        {"name": "SourcePath", "description": "原始文檔的完整路徑。"},
        {"name": "BackupPath", "description": "備份副本的完整路徑，包含時間戳記。"}
    ],
    "examples": [
        {"code": "#If VBA7 Then\n  Private Declare PtrSafe Function ShellExecute Lib \"shell32.dll\" Alias \"ShellExecuteA\" (ByVal hwnd As LongPtr, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As LongPtr\n#Else\n  Private Declare Function ShellExecute Lib \"shell32.dll\" Alias \"ShellExecuteA\" (ByVal hwnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long\n#End If\nConst SW_SHOWNORMAL As Long = 1\n\nSub OpenDocumentWithTimestampedBackup(docPath As String)\n    Dim fso As Object, backupFolder As String, baseName As String, extName As String, timeStamp As String, backupPath As String\n    If Dir(docPath) = \"\" Then MsgBox \"文件未找到: \" & docPath, vbExclamation: Exit Sub\n    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n    backupFolder = fso.GetParentFolderName(docPath) & \"\\_Backups\\\"\n    If Not fso.FolderExists(backupFolder) Then fso.CreateFolder backupFolder\n    baseName = fso.GetBaseName(docPath)\n    extName = fso.GetExtensionName(docPath)\n    timeStamp = Format(Now, \"_yyyymmdd_hhmmss\")\n    backupPath = backupFolder & baseName & timeStamp & \".\" & extName\n    On Error Resume Next\n    fso.CopyFile docPath, backupPath, True ' True to overwrite if backup with same timestamp exists (unlikely)\n    If Err.Number <> 0 Then\n        MsgBox \"創建備份副本失敗: \" & Err.Description, vbCritical\n    Else\n        Debug.Print \"備份已創建: \" & backupPath\n        ShellExecute 0, \"open\", docPath, vbNullString, vbNullString, SW_SHOWNORMAL\n        If Err.LBound(ShellExecute(0, \"open\", docPath, vbNullString, vbNullString, SW_SHOWNORMAL)) > 32 Then\n             MsgBox \"已打開原始文檔: \" & docPath\n        Else\n             MsgBox \"打開原始文檔失敗。\"\n        End If\n    End If\n    On Error GoTo 0\n    Set fso = Nothing\nEnd Sub\n\n' Example Call:\n' Sub TestOpenWithBackup()\n'   OpenDocumentWithTimestampedBackup \"C:\\ClientDocs\\LoanAgreement_ClientA.docx\" ' **替換為實際檔路徑**\n' End Sub", "explanation": "OpenDocumentWithTimestampedBackup 過程接受一個文檔路徑。它首先在該文檔所在目錄的 '_Backups' 子目錄下創建一個帶時間戳記的備份副本，然後使用 ShellExecute 打開原始文檔。"}
    ],
    "keywords": ["shellexecute open with backup", "timestamped backup vba", "貸後文檔版本控制", "自動備份打開"]
},
{
    "name": "UserForm (Track Time Spent on Client Review)",
    "category": "Excel VBA 開發與表單",
    "description": "設計一個UserForm用於貸後客戶審查。當審查人員打開特定客戶的審查表單時，UserForm的Initialize事件記錄開始時間。當審查人員完成審查並點擊“保存/提交”按鈕時，記錄結束時間，計算審查所用時長，並將此資訊（客戶ID、審查日期、開始時間、結束時間、總時長、審查人）記錄到Excel日誌表中。",
    "syntax": "' UserForm code with StartTime and EndTime variables",
    "parameters": [
        {"name": "UserForm_Initialize", "description": "記錄審查開始時間 (使用 Timer 或 Now)。"},
        {"name": "cmdSubmit_Click", "description": "記錄審查結束時間，計算時長，保存資料。"}
    ],
    "examples": [
        {"code": "' --- In UserForm 'ufClientReview' Code Module --- \n' Private reviewStartTime As Single ' Using Timer for duration in seconds\n' Private reviewStartDate As Date   ' Using Now for start timestamp\n'\n' Private Sub UserForm_Initialize()\n'   reviewStartTime = Timer\n'   reviewStartDate = Now\n'   Me.lblStartTime.Caption = \"審查開始於: \" & Format(reviewStartDate, \"yyyy-mm-dd hh:mm:ss\")\n'   ' ... Load client data into form ...\n' End Sub\n'\n' Private Sub cmdSaveReview_Click()\n'   Dim reviewEndTime As Single\n'   Dim durationSeconds As Single, durationFormatted As String\n'   reviewEndTime = Timer\n'   durationSeconds = reviewEndTime - reviewStartTime\n'   durationFormatted = Format(durationSeconds / 86400, \"hh:mm:ss\") ' Convert seconds to time format\n'\n'   Dim clientID As String: clientID = Me.txtClientID.Value ' Assume a ClientID textbox\n'   Dim reviewer As String: reviewer = Application.UserName\n'\n'   ' --- Log to Excel Sheet 'ReviewTimeLog' ---\n'   Dim wsLog As Worksheet, nextLog As Long\n'   Set wsLog = ThisWorkbook.Sheets(\"ReviewTimeLog\") ' A:ClientID, B:Reviewer, C:ReviewDate, D:StartTime, E:EndTime, F:Duration(s), G:Duration(HH:MM:SS)\n'   nextLog = wsLog.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n'   wsLog.Cells(nextLog, \"A\").Value = clientID\n'   wsLog.Cells(nextLog, \"B\").Value = reviewer\n'   wsLog.Cells(nextLog, \"C\").Value = DateValue(reviewStartDate)\n'   wsLog.Cells(nextLog, \"D\").Value = TimeValue(reviewStartDate)\n'   wsLog.Cells(nextLog, \"E\").Value = TimeValue(Now) ' Or TimeValue from a Now variable at this point\n'   wsLog.Cells(nextLog, \"F\").Value = durationSeconds\n'   wsLog.Cells(nextLog, \"G\").Value = durationFormatted\n'\n'   MsgBox \"審查已保存。本次審查耗時: \" & durationFormatted, vbInformation\n'   Unload Me\n' End Sub\n'\n' ' To show the form for a specific client:\n' Sub StartReviewForClient(clientID As String)\n'   ' Load ufClientReview\n'   ' ufClientReview.txtClientID.Value = clientID ' Pass client ID\n'   ' ufClientReview.Show\n' End Sub", "explanation": "在客戶審查UserForm初始化時，記錄開始時間。當使用者點擊“保存審查”按鈕時，記錄結束時間，計算兩者之差得到審查所用時長（以秒為單位，並可格式化為HH:MM:SS），然後將包括時長在內的審查資訊記錄到Excel日誌表中。"}
    ],
    "keywords": ["userform track time spent", "log task duration vba", "貸後審查耗時記錄", "計時表單"]
},
{
    "name": "Application.OnTime (Check for Inactivity and Auto-Save/Close)",
    "category": "Excel 核心操作",
    "description": "在打開包含敏感貸後資料的Excel工作簿時，可以啟動一個Application.OnTime計時器。如果在指定時間內（例如30分鐘）沒有檢測到用戶活動（例如，通過Worksheet_SelectionChange或Worksheet_Change事件重置計時器），則自動保存工作簿並可能關閉它，以增強資料安全性。",
    "syntax": "' See example, involves event handling and OnTime rescheduling.",
    "parameters": [
        {"name": "InactivityTimeout (Seconds)", "description": "定義無操作多少秒後觸發自動保存/關閉。"},
        {"name": "Workbook_Open / Worksheet_Change / Worksheet_SelectionChange Events", "description": "用於啟動和重置不活動計時器。"}
    ],
    "examples": [
        {"code": "' --- In ThisWorkbook Module ---\n' Public LastActivityTime As Date\n' Public Const INACTIVITY_TIMEOUT_MINUTES As Long = 30 ' Minutes\n' Public AutoCloseScheduledTime As Date\n'\n' Private Sub Workbook_Open()\n'   Call ResetInactivityTimer\n' End Sub\n'\n' Private Sub Workbook_SheetChange(ByVal Sh As Object, ByVal Target As Range)\n'   Call ResetInactivityTimer\n' End Sub\n'\n' Private Sub Workbook_SheetSelectionChange(ByVal Sh As Object, ByVal Target As Range)\n'   Call ResetInactivityTimer\n' End Sub\n'\n' Public Sub ResetInactivityTimer()\n'   LastActivityTime = Now\n'   ' Cancel previous OnTime if any (requires storing exact time or using Schedule:=False on the same procedure name)\n'   On Error Resume Next ' If no schedule exists, this is fine\n'   Application.OnTime EarliestTime:=AutoCloseScheduledTime, Procedure:=\"AutoSaveAndCloseDueToInactivity\", Schedule:=False\n'   On Error GoTo 0\n'   AutoCloseScheduledTime = Now + TimeSerial(0, INACTIVITY_TIMEOUT_MINUTES, 0)\n'   Application.OnTime EarliestTime:=AutoCloseScheduledTime, Procedure:=\"AutoSaveAndCloseDueToInactivity\"\n'   Debug.Print \"Inactivity timer reset. Auto-action scheduled for: \" & AutoCloseScheduledTime\n' End Sub\n'\n' Public Sub AutoSaveAndCloseDueToInactivity()\n'   If DateDiff(\"n\", LastActivityTime, Now) >= INACTIVITY_TIMEOUT_MINUTES Then\n'     If ThisWorkbook.Saved = False Then ThisWorkbook.Save\n'     MsgBox \"由於長時間無操作，此工作簿已自動保存並即將關閉。\" & Now, vbInformation + vbSystemModal\n'     ' ThisWorkbook.Close SaveChanges:=False ' Already saved\n'     ' Application.Quit ' If you want to close Excel itself (use with extreme caution)\n'   Else\n'     ' False alarm, activity occurred just before OnTime fired, or timer was reset close to firing.\n'     ' Reschedule based on the actual LastActivityTime.\n'     Call ResetInactivityTimer\n'   End If\n' End Sub", "explanation": "此代碼（主要在ThisWorkbook模組）通過在工作簿打開、工作表內容更改或選區更改時調用`ResetInactivityTimer`來跟蹤用戶活動。`ResetInactivityTimer`會取消先前安排的`AutoSaveAndCloseDueToInactivity`宏，並重新安排它在`INACTIVITY_TIMEOUT_MINUTES`分鐘後執行。如果屆時確實沒有活動，`AutoSaveAndCloseDueToInactivity`會保存工作簿並提示（或執行）關閉。"}
    ],
    "keywords": ["excel auto save close inactivity", "application.ontime inactivity timer", "貸後資料安全", "自動保存關閉"]
},
// Excel 核心操作
{
    "name": "Range.Validation (Custom Formula for Covenant Check)",
    "category": "Excel 核心操作",
    "syntax": "rangeObject.Validation.Add Type:=xlValidateCustom, Formula1:=\"=AND(D5>0.6, E5<1.5)\"",
    "description": "使用自訂公式為儲存格設定數據驗證，用於檢查客戶財務指標是否符合貸款契約條款。例如，檢查DSCR必須大於0.6且負債權益比小於1.5。",
    "parameters": [
        {"name": "Type:=xlValidateCustom", "description": "指定驗證類型為自訂公式。"},
        {"name": "Formula1", "description": "一個計算結果為TRUE或FALSE的Excel公式字串。"}
    ],
    "examples": [
        {"code": "Dim targetCell As Range\nSet targetCell = Sheets(\"CovenantChecks\").Range(\"F5\") ' 儲存格用於輸入DSCR實際值\nWith targetCell.Validation\n  .Delete\n  .Add Type:=xlValidateCustom, AlertStyle:=xlValidAlertStop, _\n       Formula1:=\"=F5>=1.2\" ' DSCR必須大於等於1.2\n  .ErrorMessage = \"DSCR必須大於等於1.2！請檢查客戶財務數據。\"\n  .ErrorTitle = \"契約違反警告\"\nEnd With\nMsgBox \"儲存格 \" & targetCell.Address & \" 已設定DSCR契約驗證。\"", "explanation": "為儲存格F5設定數據驗證，要求其輸入值（客戶的DSCR）必須大於等於1.2，否則顯示錯誤訊息。"}
    ],
    "keywords": ["excel data validation custom formula", "covenant compliance check", "贷後契約檢查", "自訂驗證公式"]
},
{
    "name": "Range.FormatConditions.AddColorScale (Risk Heatmap)",
    "category": "Excel 核心操作",
    "syntax": "Set cs = rangeObject.FormatConditions.AddColorScale(ColorScaleType:=3) ' 3-color scale\ncs.ColorScaleCriteria(1).FormatColor.Color = RGB(255,0,0) ' Min/Lowest\ncs.ColorScaleCriteria(2).Type = xlConditionValuePercentile: cs.ColorScaleCriteria(2).Value = 50\ncs.ColorScaleCriteria(2).FormatColor.Color = RGB(255,255,0) ' Midpoint/Yellow\ncs.ColorScaleCriteria(3).FormatColor.Color = RGB(0,255,0) ' Max/Highest/Green",
    "description": "為一個包含風險評分或逾期天數的儲存格範圍新增色階條件格式，以視覺化方式呈現風險分佈（例如，貸後管理中的風險熱圖）。",
    "parameters": [
        {"name": "ColorScaleType", "description": "色階類型（例如，2色或3色）。"},
        {"name": "ColorScaleCriteria(Index).FormatColor.Color", "description": "設定各臨界點的顏色。"},
        {"name": "ColorScaleCriteria(Index).Type / .Value", "description": "設定各臨界點的類型（數字、百分比、公式等）和值。"}
    ],
    "examples": [
        {"code": "Dim riskScoreRange As Range\n' Set riskScoreRange = Sheets(\"PortfolioOverview\").Range(\"E2:E100\") ' 假設E欄是風險評分\n' riskScoreRange.FormatConditions.Delete ' Clear existing\n' Dim cs As ColorScale\n' Set cs = riskScoreRange.FormatConditions.AddColorScale(ColorScaleType:=3)\n' ' Red (High Risk) for highest values (e.g., 90th percentile)\n' With cs.ColorScaleCriteria(3)\n'   .Type = xlConditionValuePercentile\n'   .Value = 90\n'   .FormatColor.Color = RGB(255, 100, 100) ' Light Red\n' End With\n' ' Yellow for midpoint (e.g., 50th percentile)\n' With cs.ColorScaleCriteria(2)\n'   .Type = xlConditionValuePercentile\n'   .Value = 50\n'   .FormatColor.Color = RGB(255, 255, 150) ' Light Yellow\n' End With\n' ' Green (Low Risk) for lowest values (e.g., 10th percentile)\n' With cs.ColorScaleCriteria(1)\n'   .Type = xlConditionValuePercentile\n'   .Value = 10\n'   .FormatColor.Color = RGB(150, 255, 150) ' Light Green\n' End With\nMsgBox \"(概念性) 已為風險評分範圍設定3色階條件格式。\"", "explanation": "為風險評分範圍設定一個3色階的條件格式：例如，最低的10%分數顯示為淺綠色，中間50%為淺黃色，最高的10%為淺紅色。"}
    ],
    "keywords": ["excel conditional formatting colorscale", "risk heatmap vba", "贷後風險視覺化", "色階條件格式"]
},
{
    "name": "Worksheet.Protect (AllowUsingPivotTables on Protected Sheet)",
    "category": "Excel 核心操作",
    "syntax": "worksheetObject.Protect Password:=\"pass\", AllowUsingPivotTables:=True",
    "description": "保護工作表，但允許使用者在受保護的狀態下與數據透視表進行互動 (例如，刷新、更改欄位、篩選)。這對於發佈包含數據透視表的貸後管理報告，同時保護原始數據或報告結構不被修改很有用。",
    "parameters": [
        {"name": "AllowUsingPivotTables:=True", "description": "允許使用者在受保護的工作表上使用數據透視表功能。"}
    ],
    "examples": [
        {"code": "Dim reportSheet As Worksheet\n' Set reportSheet = ThisWorkbook.Sheets(\"MonthlyRiskReport\")\n' ' Ensure underlying data ranges for PivotTables are unlocked if users need to refresh from them\n' ' (or PivotCache source data is external or on an unprotected sheet)\n' reportSheet.Protect Password:=\"reportUser\", DrawingObjects:=True, Contents:=True, Scenarios:=True, AllowUsingPivotTables:=True\n' MsgBox \"工作表 '\" & reportSheet.Name & \"' 已受保護，但允許使用者操作其中的數據透視表。\"", "explanation": "保護名為 'MonthlyRiskReport' 的工作表，同時允許使用者與該工作表上的任何數據透視表進行互動。"}
    ],
    "keywords": ["excel protect sheet allow pivottable", "worksheet protection pivottable", "贷後報告保護", "保護表使用數據透視表"]
},
{
    "name": "Range.Formula (Calculate Weighted Average Risk Score)",
    "category": "Excel 核心操作",
    "syntax": "resultCell.Formula = \"=SUMPRODUCT(ScoresRange, WeightsRange) / SUM(WeightsRange)\"",
    "description": "在指定儲存格中插入Excel公式，用於計算一組風險因素的加權平均風險評分。貸後管理中常用於綜合評估客戶風險。",
    "parameters": [
        {"name": "ScoresRange", "description": "包含各風險因素得分的儲存格範圍。"},
        {"name": "WeightsRange", "description": "包含對應風險因素權重的儲存格範圍。"}
    ],
    "examples": [
        {"code": "' Assume Risk Scores in A1:A5, corresponding Weights in B1:B5\n' Sheets(\"RiskCalc\").Range(\"A1:A5\").Value = Application.Transpose(Array(70, 85, 60, 90, 75)) ' Scores\n' Sheets(\"RiskCalc\").Range(\"B1:B5\").Value = Application.Transpose(Array(0.3, 0.2, 0.25, 0.15, 0.1)) ' Weights (sum to 1)\n' Sheets(\"RiskCalc\").Range(\"C1\").Formula = \"=SUMPRODUCT(A1:A5, B1:B5)\" ' If weights sum to 1, no need to divide\n' ' If weights don't sum to 1: Sheets(\"RiskCalc\").Range(\"C1\").Formula = \"=SUMPRODUCT(A1:A5, B1:B5)/SUM(B1:B5)\"\nMsgBox \"儲存格C1已設定加權平均風險評分公式。\"", "explanation": "在C1單元格計算A1:A5中各風險評分（以B1:B5中的權重進行加權）的加權平均值。"}
    ],
    "keywords": ["excel formula weighted average", "sumproduct for weighted score", "贷後風險評分", "加權平均計算"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.CalculatedFields.Add (Ratio Calculation)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set cfRatio = pt.CalculatedFields.Add(Name:=\"ProfitMargin\", Formula:=\"=IFERROR(Profit/Sales, 0)\")",
    "description": "在數據透視表中新增一個計算欄位，用於計算比率型指標，例如利潤率 (利潤/銷售額)。使用IFERROR來處理除數可能為零的情況。",
    "parameters": [
        {"name": "Name", "description": "新計算欄位的名稱。"},
        {"name": "Formula", "description": "定義計算的公式，使用單引號括住現有欄位名。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable\n' Set pt = ActiveSheet.PivotTables(\"FinancialSummary\")\n' ' Assume 'Profit' and 'Sales' are existing fields in the PivotTable source data.\n' On Error Resume Next ' In case calculated field already exists\n' Dim cfProfitMargin As PivotField\n' Set cfProfitMargin = pt.CalculatedFields.Add(Name:=\"利潤率\", Formula:=\"=IFERROR(Profit/Sales, 0)\")\n' If Err.Number = 0 Then\n'   cfProfitMargin.Orientation = xlDataField\n'   cfProfitMargin.NumberFormat = \"0.00%\"\n'   MsgBox \"計算欄位 '利潤率' 已新增到數據透視表。\"\n' Else\n'   MsgBox \"新增計算欄位 '利潤率' 失敗: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "在名為“FinancialSummary”的數據透視表中新增一個名為“利潤率”的計算欄位，其公式為 `Profit` 欄位除以 `Sales` 欄位，並使用IFERROR處理可能的除零錯誤。"}
    ],
    "keywords": ["pivottable calculated field ratio", "profit margin pivot", "贷後財務比率分析", "數據透視表計算比率"]
},
{
    "name": "SlicerCache.Slicers(IndexOrName).Caption (Change Slicer Title)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "slicerCacheObject.Slicers(1).Caption = \"按客戶風險等級篩選\"",
    "description": "修改與特定 SlicerCache 關聯的交叉分析篩選器 (Slicer) 的顯示標題。一個 SlicerCache 可以有多個 Slicer 實例。",
    "parameters": [
        {"name": "IndexOrName (Slicers collection)", "description": "交叉分析篩選器的索引 (1-based) 或名稱。"},
        {"name": "NewCaption", "description": "要設定的新標題文字。"}
    ],
    "examples": [
        {"code": "Dim sc As SlicerCache\n' ' Assume a SlicerCache named \"Slicer_RiskRating\" exists\n' On Error Resume Next\n' Set sc = ThisWorkbook.SlicerCaches(\"Slicer_RiskRating\")\n' If Not sc Is Nothing And sc.Slicers.Count > 0 Then\n'   sc.Slicers(1).Caption = \"客戶風險評級篩選器\"\n'   MsgBox \"第一個與 'Slicer_RiskRating' 關聯的交叉分析篩選器標題已更新。\"\n' ElseIf sc Is Nothing Then\n'   MsgBox \"未找到 SlicerCache 'Slicer_RiskRating'。\"\n' Else\n'   MsgBox \"SlicerCache 'Slicer_RiskRating' 沒有關聯的交叉分析篩選器。\"\n' End If\n' On Error GoTo 0", "explanation": "找到名為 \"Slicer_RiskRating\" 的SlicerCache，並將其第一個關聯的交叉分析篩選器的標題更改為“客戶風險評級篩選器”。"}
    ],
    "keywords": ["excel slicer caption vba", "change slicer title", "贷後篩選器自訂", "修改交叉分析篩選器標題"]
},
// Excel VBA 開發與表單
{
    "name": "UserForm (Dynamic Control Creation for Loan Details)",
    "category": "Excel VBA 開發與表單",
    "syntax": "Set newLabel = Me.Controls.Add(\"Forms.Label.1\", \"lblLoanID_1\")\nnewLabel.Caption = \"貸款合同號:\"",
    "description": "在UserForm上動態創建控制項 (例如，標籤和文字方塊) 以顯示從Excel中讀取的客戶多筆貸款的詳細資訊。例如，如果一個客戶有多筆貸款，可以為每筆貸款動態生成一組顯示其詳情的控制項。",
    "parameters": [
        {"name": "Forms.ControlType.1", "description": "要創建的控制項的ProgID (例如，\"Forms.Label.1\", \"Forms.TextBox.1\")。"},
        {"name": "ControlName", "description": "新控制項的唯一名稱。"}
    ],
    "examples": [
        {"code": "' --- In a UserForm's code module, e.g., ufClientDashboard ---\n' Private Sub DisplayClientLoans(clientID As String)\n'   Dim wsLoans As Worksheet, r As Long, lastRow As Long\n'   Dim लोनआईडी As String, loanAmount As Currency\n'   Dim currentTop As Single: currentTop = 10 ' Initial top position for controls\n'   Dim lbl As MSForms.Label, txt As MSForms.TextBox\n'\n'   ' Clear previously added dynamic controls (if any, based on naming convention or tags)\n'   Dim ctrl As MSForms.Control\n'   For Each ctrl In Me.Controls\n'       If Left(ctrl.Name, 7) = \"dynLoan\" Then Me.Controls.Remove ctrl.Name\n'   Next ctrl\n'\n'   Set wsLoans = ThisWorkbook.Sheets(\"LoanDetails\") ' Assume ClientID in Col A, LoanID in B, Amount in C\n'   lastRow = wsLoans.Cells(Rows.Count, \"A\").End(xlUp).Row\n'\n'   For r = 2 To lastRow\n'     If wsLoans.Cells(r, \"A\").Value = clientID Then\n'       लोनआईडी = wsLoans.Cells(r, \"B\").Value\n'       loanAmount = wsLoans.Cells(r, \"C\").Value\n'\n'       ' Add Label for Loan ID\n'       Set lbl = Me.Controls.Add(\"Forms.Label.1\", \"dynLoanIDLbl_\" & लोनआईडी, True)\n'       With lbl: .Caption = \"貸款ID: \" & लोनआईडी: .Left = 10: .Top = currentTop: .Width = 150: End With\n'\n'       ' Add TextBox for Loan Amount (read-only display)\n'       Set txt = Me.Controls.Add(\"Forms.TextBox.1\", \"dynLoanAmtTxt_\" & लोनआईडी, True)\n'       With txt: .Value = Format(loanAmount, \"#,##0.00\"): .Left = 170: .Top = currentTop: .Width = 100: .Locked = True: End With\n'\n'       currentTop = currentTop + 25 ' Increment top for next set of controls\n'     End If\n'   Next r\n'   Me.Height = currentTop + 20 ' Adjust form height\n' End Sub\n'\n' ' Call this from UserForm_Initialize or a button click after selecting a client\n' ' Example: Call DisplayClientLoans(\"CUST001\")", "explanation": "DisplayClientLoans 過程根據傳入的客戶ID，從“LoanDetails”工作表中查找該客戶的所有貸款。對於每筆貸款，它會在UserForm上動態地創建一個標籤來顯示貸款ID，以及一個文字方塊來顯示貸款金額。控制項的位置會動態調整。"}
    ],
    "keywords": ["userform dynamic controls", "vba add controls at runtime", "贷後客戶多貸款顯示", "動態表單生成"]
},
{
    "name": "UserForm (Populate ComboBox with Unique Risk Ratings from Sheet)",
    "category": "Excel VBA 開發與表單",
    "syntax": "For Each cell In sourceRange\n  If Not myDict.Exists(cell.Value) Then myDict.Add cell.Value, 1: Me.ComboBoxRisk.AddItem cell.Value\nNext cell",
    "description": "從包含客戶風險評級的Excel列中提取所有唯一的風險評級值，並用這些值填充UserForm上的ComboBox，供用戶篩選或選擇。",
    "parameters": [
        {"name": "sourceRange", "description": "包含風險評級數據的Excel範圍。"},
        {"name": "myDict (Scripting.Dictionary)", "description": "用於確保只添加唯一值到ComboBox。"}
    ],
    "examples": [
        {"code": "' --- In UserForm_Initialize for e.g., ufRiskFilterForm ---\n' Private Sub UserForm_Initialize()\n'   Dim wsPortfolio As Worksheet, riskRatingCol As Range, cell As Range\n'   Dim uniqueRatings As Object ' Scripting.Dictionary\n'\n'   Set wsPortfolio = ThisWorkbook.Sheets(\"ClientPortfolio\") ' Assume Risk Rating in Column D\n'   If wsPortfolio.Cells(Rows.Count, \"D\").End(xlUp).Row < 2 Then Exit Sub ' No data\n'   Set riskRatingCol = wsPortfolio.Range(\"D2\", wsPortfolio.Cells(Rows.Count, \"D\").End(xlUp))\n'\n'   Set uniqueRatings = CreateObject(\"Scripting.Dictionary\")\n'   uniqueRatings.CompareMode = vbTextCompare ' Case-insensitive for ratings\n'\n'   Me.cboRiskRatingFilter.Clear ' Clear existing items in ComboBox\n'   Me.cboRiskRatingFilter.AddItem \"(所有評級)\" ' Add an 'All' option\n'\n'   For Each cell In riskRatingCol\n'     Dim ratingVal As String: ratingVal = Trim(CStr(cell.Value))\n'     If ratingVal <> \"\" And Not uniqueRatings.Exists(ratingVal) Then\n'       uniqueRatings.Add ratingVal, ratingVal ' Add to dictionary to track uniqueness\n'       Me.cboRiskRatingFilter.AddItem ratingVal ' Add to ComboBox\n'     End If\n'   Next cell\n'   Me.cboRiskRatingFilter.ListIndex = 0 ' Select '(所有評級)' by default\n'   Set uniqueRatings = Nothing: Set wsPortfolio = Nothing: Set riskRatingCol = Nothing\n' End Sub", "explanation": "在UserForm初始化時，此代碼遍歷“ClientPortfolio”工作表中D列（假設為風險評級列）的所有數據，使用Scripting.Dictionary收集所有唯一的風險評級值，然後將這些唯一值添加到名為`cboRiskRatingFilter`的ComboBox中，同時添加一個“(所有評級)”選項。"}
    ],
    "keywords": ["userform combobox unique values", "populate combobox from range distinct", "贷後風險評級篩選", "動態填充下拉框"]
},
// Word 文件處理
{
    "name": "Document.MailMerge.OpenDataSource (Word Mail Merge Setup)",
    "category": "Word 文件處理",
    "syntax": "mainDocument.MailMerge.OpenDataSource Name:=dataSourceFile, [Format], [Connection], [SQLStatement], [SQLStatement1], ...",
    "description": "將數據源附加到指定的Word郵件合併主文件。數據源可以是Excel工作表、Access數據庫、Outlook聯繫人列表等。",
    "parameters": [
        {"name": "Name", "description": "必需。數據源的文件名 (包含路徑)。"},
        {"name": "Connection", "description": "可選。用於連接到SQL數據源的ODBC連接字符串。"},
        {"name": "SQLStatement", "description": "可選。用於查詢數據的SQL語句。"}
    ],
    "examples": [
        {"code": "Dim wdApp As Object, wdMainDoc As Object\nDim excelDataSourcePath As String: excelDataSourcePath = \"C:\\PostLoanData\\ClientContactList.xlsx\"\n' Set wdApp = CreateObject(\"Word.Application\")\n' wdApp.Visible = True\n' Set wdMainDoc = wdApp.Documents.Add ' Or Open an existing mail merge template\n'\n' ' Attach Excel data source\n' If Dir(excelDataSourcePath) <> \"\" Then\n'   wdMainDoc.MailMerge.OpenDataSource Name:=excelDataSourcePath, _\n'                                      Connection:=\"Provider=Microsoft.ACE.OLEDB.12.0;User ID=Admin;Data Source=\" & excelDataSourcePath & \";Mode=Read;Extended Properties=\"\"HDR=YES;IMEX=1;\"\"\", _\n'                                      SQLStatement:=\"SELECT * FROM [Sheet1$]\" ' Assumes data is in Sheet1\n'   If wdMainDoc.MailMerge.State = wdMainAndDataSource Then\n'     MsgBox \"Excel數據源已成功附加到Word郵件合併主文件。\"\n'     ' Now you can insert merge fields and execute the merge\n'   Else\n'     MsgBox \"附加數據源失敗。\"\n'   End If\n' Else\n'   MsgBox \"Excel數據源文件未找到: \" & excelDataSourcePath\n' End If\n' ' wdMainDoc.Close False: wdApp.Quit", "explanation": "創建一個新的Word文檔（或打開一個現有模板），然後使用`OpenDataSource`方法將一個名為“ClientContactList.xlsx”的Excel文件中的Sheet1作為郵件合併的數據源進行連接。"}
    ],
    "keywords": ["word mailmerge opendatasource", "vba connect excel to word mail merge", "贷後通知函數據源", "郵件合併設定"]
},
{
    "name": "ContentControl.Type Property (Word)",
    "category": "Word 文件處理",
    "syntax": "ccType = contentControlObject.Type",
    "description": "傳回一個 WdContentControlType 常數，表示內容控制項的類型 (例如，純文字、日期選取器、下拉式清單、圖片等)。唯讀。",
    "parameters": [],
    "examples": [
        {"code": "Dim cc As Object ' Word.ContentControl\n' ' Assume a content control is selected by the user, or iterate through them\n' Set cc = Selection.ParentContentControl ' If selection is inside a content control\n' If Not cc Is Nothing Then\n'   Select Case cc.Type\n'     Case wdContentControlText: Debug.Print \"類型: 純文字\"\n'     Case wdContentControlDate: Debug.Print \"類型: 日期選取器\"\n'     Case wdContentControlDropdownList: Debug.Print \"類型: 下拉式清單\"\n'     Case wdContentControlPicture: Debug.Print \"類型: 圖片\"\n'     Case Else: Debug.Print \"類型: 其他 (\" & cc.Type & \")\"\n'   End Select\n'   MsgBox \"內容控制項 '\" & cc.Title & \"' 的類型已列印到立即視窗。\"\n' End If", "explanation": "如果使用者選取範圍的父物件是一個內容控制項，則獲取該內容控制項並判斷其類型，然後將類型描述列印到立即視窗。"}
    ],
    "keywords": ["word contentcontrol type", "get content control type", "wdcontentcontroltype", "內容控制項類型"]
},
// Outlook 郵件與項目管理
{
    "name": "MailItem.Save (Save to Drafts)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "mailItemObject.Save",
    "description": "將 Outlook 項目儲存到其目前資料夾中。如果是一個新建立的 MailItem 且尚未傳送或移動，呼叫 Save 通常會將其儲存到預設的「草稿」資料夾。",
    "parameters": [],
    "examples": [
        {"code": "Dim olApp As Object, olDraftMail As Object\nSet olApp = CreateObject(\"Outlook.Application\")\nSet olDraftMail = olApp.CreateItem(olMailItem)\nWith olDraftMail\n  .To = \"internal.review@bank.com\"\n  .Subject = \"草稿 - 貸後檢查點初步想法\"\n  .Body = \"關於客戶XYZ，以下是一些初步的檢查點：\\n1. ...\\n2. ...\"\n  .Save ' Saves the email to the Drafts folder\nEnd With\nMsgBox \"一封包含貸後檢查點的草稿郵件已儲存到您的草稿資料夾。\"", "explanation": "建立一封新的電子郵件，填寫收件人、主旨和內文，然後呼叫 `.Save` 方法。這通常會將該郵件儲存在Outlook的「草稿」資料夾中，供使用者稍後檢閱、修改和傳送。"}
    ],
    "keywords": ["outlook mailitem save drafts", "save email to drafts", "貸後郵件草稿", "儲存到草稿"]
},
{
    "name": "AppointmentItem.ResponseStatus Property (Outlook Meeting)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "responseStatusConst = appointmentItemObject.ResponseStatus",
    "description": "傳回一個 OlResponseStatus 常數，表示與會者對會議邀請的回應狀態。此屬性對會議召集人查看與會者狀態有用。",
    "parameters": [
        {"name": "olResponseNone (0)", "description": "尚未回應。"},
        {"name": "olResponseOrganized (1)", "description": "會議的召集人。"},
        {"name": "olResponseAccepted (3)", "description": "已接受。"},
        {"name": "olResponseDeclined (4)", "description": "已拒絕。"},
        {"name": "olResponseTentative (2)", "description": "暫定接受。"}
    ],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem (a meeting you organized)\nDim recip As Object ' Outlook.Recipient\n' ' Assume olAppt points to a meeting item in your calendar for which you are the organizer\n' If olAppt.MeetingStatus = olMeeting Then ' Check if it's a meeting\n'   If olAppt.Recipients.Count > 0 Then\n'     Debug.Print \"會議 '\" & olAppt.Subject & \"' 的與會者回應狀態:\"\n'     For Each recip In olAppt.Recipients\n'       Debug.Print \"  - \" & recip.Name & \": \" & GetResponseStatusText(recip.MeetingResponseStatus)\n'     Next recip\n'   End If\n' End If\n'\n' Function GetResponseStatusText(status As Long) As String\n'   Select Case status\n'     Case 0: GetResponseStatusText = \"尚未回應\"\n'     Case 1: GetResponseStatusText = \"召集人\"\n'     Case 2: GetResponseStatusText = \"暫定接受\"\n'     Case 3: GetResponseStatusText = \"已接受\"\n'     Case 4: GetResponseStatusText = \"已拒絕\"\n'     Case Else: GetResponseStatusText = \"未知狀態 (\" & status & \")\"\n'   End Select\n' End Function", "explanation": "如果一個約會專案是一個已發送的會議，此代碼會遍歷其所有與會者，並使用每個Recipient物件的 `MeetingResponseStatus` 屬性來獲取並列印他們對會議邀請的回應狀態。"}
    ],
    "keywords": ["outlook meeting responsestatus", "get attendee status", "olresponsestatus", "會議回應狀態", "貸後會議追蹤"]
},
// PowerPoint 簡報製作
{
    "name": "Shapes.AddPlaceholder (PowerPoint - for Custom Layouts)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set phShape = slideOrMasterObject.Shapes.AddPlaceholder(Type As PpPlaceholderType, [Left], [Top], [Width], [Height])",
    "description": "在投影片或投影片母片/版面配置上新增一個預留位置。這在以程式設計方式創建自訂版面配置時非常有用。",
    "parameters": [
        {"name": "Type", "description": "必需。PpPlaceholderType 常數，指定預留位置的類型 (例如，ppPlaceholderTitle, ppPlaceholderBody, ppPlaceholderPicture, ppPlaceholderChart)。"}
    ],
    "examples": [
        {"code": "Dim customLayout As Object ' PowerPoint.CustomLayout\nDim newTitlePH As Object ' PowerPoint.Shape\n' ' Get or create a custom layout from the slide master\n' ' Set customLayout = ActivePresentation.SlideMaster.CustomLayouts.Add(Index:=ActivePresentation.SlideMaster.CustomLayouts.Count + 1, Name:=\"MyNewCustomLayout\")\n' If Not customLayout Is Nothing Then\n'   ' Add a Title placeholder to the custom layout\n'   Set newTitlePH = customLayout.Shapes.AddPlaceholder(Type:=ppPlaceholderTitle, Left:=72, Top:=36, Width:=600, Height:=72)\n'   newTitlePH.Name = \"CustomTitlePlaceholder1\"\n'   newTitlePH.TextFrame.TextRange.Text = \"<輸入自訂標題>\"\n'   MsgBox \"已在自訂版面 '\" & customLayout.Name & \"' 上新增標題預留位置。\"\n' End If", "explanation": "在一個自訂版面配置（假設已獲取或創建 `customLayout` 物件）上新增一個標題類型的預留位置，並設置其位置、大小和預設文字。"}
    ],
    "keywords": ["powerpoint addplaceholder", "custom slide layout vba", "ppplaceholder*", "新增預留位置PPT", "自訂版面設計"]
},
{
    "name": "Slide.Export (with ScaleWidth/Height)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideObject.Export(FileName As String, FilterName As String, [ScaleWidth As Long], [ScaleHeight As Long])",
    "description": "將投影片匯出為圖形檔案，並可以指定匯出圖像的寬度或高度 (以圖元為單位)。如果只指定一個維度，另一個維度會按比例縮放。如果兩者都指定，圖像可能會變形。",
    "parameters": [
        {"name": "ScaleWidth", "description": "可選。匯出圖像的寬度 (圖元)。"},
        {"name": "ScaleHeight", "description": "可選。匯出圖像的高度 (圖元)。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\n' Set pptSlide = ActivePresentation.Slides(1)\n' Dim exportPath As String: exportPath = \"C:\\Exports\\Slide1_Scaled.PNG\"\n' ' Export with a specific width, height will scale proportionally\n' On Error Resume Next\n' pptSlide.Export FileName:=exportPath, FilterName:=\"PNG\", ScaleWidth:=1024\n' If Err.Number = 0 Then\n'   MsgBox \"第一張投影片已匯出為寬度1024圖元的PNG圖片。\"\n' Else\n'   MsgBox \"匯出縮放圖片失敗: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "將簡報的第一張投影片匯出為PNG格式的圖片，並指定其寬度為1024圖元，高度將按原始寬高比自動縮放。"}
    ],
    "keywords": ["powerpoint export slide scaled", "save slide as image size", "匯出縮放投影片圖片", "貸後報告截圖"]
},
// File & Folder Management (FSO)
{
    "name": "FileSystemObject.GetFile (Properties - Name, Path, Size, Type)",
    "category": "檔案與資料夾管理",
    "description": "fso.GetFile(FilePath) 傳回一個 File 物件，該物件包含多個有用的唯讀屬性：\n.Name: 檔案名（不含路徑）\n.Path: 完整路徑（含檔案名）\n.Size: 檔大小（位元組）\n.Type: 檔案類型描述（例如 “文字檔”）\n.DateCreated, .DateLastAccessed, .DateLastModified: 日期時間戳記",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, fileObj As Object\nDim targetFilePath As String: targetFilePath = ThisWorkbook.FullName ' Example: current workbook\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.FileExists(targetFilePath) Then\n    Set fileObj = fso.GetFile(targetFilePath)\n    Debug.Print \"--- 檔案屬性 ('\" & fileObj.Name & \"') ---\"\n    Debug.Print \"  路徑: \" & fileObj.Path\n    Debug.Print \"  大小: \" & fileObj.Size & \" bytes\"\n    Debug.Print \"  類型: \" & fileObj.Type\n    Debug.Print \"  創建日期: \" & fileObj.DateCreated\n    Debug.Print \"  上次修改: \" & fileObj.DateLastModified\nElse\n    Debug.Print \"文件未找到: \" & targetFilePath\nEnd If\nSet fso = Nothing: Set fileObj = Nothing", "explanation": "獲取當前Excel工作簿的 File 物件，並列印其檔案名、完整路徑、大小、類型描述以及創建和修改日期。"}
    ],
    "keywords": ["fso file properties", "get file name path size type", "filesystemobject file info", "貸後文件屬性獲取", "文件中繼資料"]
},
// String & Text Manipulation
{
    "name": "Replace (Nested for Multiple Replacements)",
    "category": "字串與文本操作",
    "syntax": "result = Replace(Replace(OriginalString, Find1, Replace1), Find2, Replace2)",
    "description": "可以通過巢狀呼叫 Replace 函數來實現對同一個字串進行多次不同的替換操作。例如，先將所有逗號替換為空格，然後再將所有分號替換為空格。",
    "parameters": [],
    "examples": [
        {"code": "Dim clientNotes As String: clientNotes = \"客戶ID:C001; 風險等級:高, 逾期天數:15; 備註:需立即跟進.\"\nDim cleanedNotes As String\n' Replace semicolon with a pipe, then comma with a pipe\ncleanedNotes = Replace(clientNotes, \";\", \" | \")\ncleanedNotes = Replace(cleanedNotes, \",\", \" | \")\nDebug.Print \"原始備註: \" & clientNotes\nDebug.Print \"清理後備註: \" & cleanedNotes\n' Output: 客戶ID:C001 |  風險等級:高 |  逾期天數:15 |  備註:需立即跟進.", "explanation": "對包含客戶備註的字串進行兩次替換操作：首先將所有分號替換為“ | ”，然後將所有逗號也替換為“ | ”，以達到統一分隔符號的效果。"}
    ],
    "keywords": ["vba nested replace", "multiple string replacements", "貸後備註清理", "巢狀替換字串"]
},
// Math, Date & Time
{
    "name": "Format (Custom Date/Time Formatting for Reporting)",
    "category": "數學、日期與時間",
    "syntax": "formattedString = Format(DateTimeValue, \"yyyy年m月d日 hh:mm AM/PM\")",
    "description": "使用 Format 函數可以將日期和時間值格式化為貸後管理報告中常用的特定當地語系化字串表示形式，例如中文日期格式或特定的時間格式。",
    "parameters": [
        {"name": "DateTimeValue", "description": "要格式化的日期/時間值。"},
        {"name": "FormatString", "description": "定義輸出格式的字串。"}
    ],
    "examples": [
        {"code": "Dim lastReviewDate As Date: lastReviewDate = #10/25/2023 3:45:00 PM#\nDim reportDateFormat As String, reportTimeFormat As String\nreportDateFormat = Format(lastReviewDate, \"yyyy\"\"年\"\"m\"\"月\"\"d\"\"日\") ' e.g., 2023年10月25日\nreportTimeFormat = Format(lastReviewDate, \"上午/下午 hh\"\"時\"\"mm\"\"分\") ' e.g., 下午 03時45分\nDebug.Print \"上次審查日期 (報告格式): \" & reportDateFormat\nDebug.Print \"審查時間 (報告格式): \" & reportTimeFormat", "explanation": "將一個日期時間值分別格式化為中文長日期格式和中文時間格式，適用於插入到貸後報告中。"}
    ],
    "keywords": ["format date time chinese", "custom date format vba", "貸後報告日期格式", "格式化時間戳記"]
},
// Data Types, Conversion & Validation
{
    "name": "IsDate (Validating Loan Maturity Dates)",
    "category": "資料類型、轉換與驗證",
    "syntax": "If IsDate(cellValue) And CDate(cellValue) >= Date Then ...",
    "description": "在處理從Excel讀取的貸款到期日時，使用 IsDate 檢查儲存格內容是否為有效日期，並可以進一步結合 CDate 轉換後的值與當前日期 (Date) 比較，以判斷貸款是否已到期或即將到期，是貸後管理中常見的驗證步驟。",
    "parameters": [
        {"name": "cellValue", "description": "包含潛在日期值的儲存格的值。"}
    ],
    "examples": [
        {"code": "Dim maturityDateCell As Range\n' Set maturityDateCell = Sheets(\"LoanPortfolio\").Range(\"F10\") ' F10 contains a maturity date\n' If IsDate(maturityDateCell.Value) Then\n'   Dim loanMaturity As Date: loanMaturity = CDate(maturityDateCell.Value)\n'   If loanMaturity < Date Then\n'     MsgBox \"貸款已於 \" & Format(loanMaturity, \"yyyy-mm-dd\") & \" 到期！\"\n'   ElseIf loanMaturity <= Date + 30 Then\n'     MsgBox \"貸款將於 \" & Format(loanMaturity, \"yyyy-mm-dd\") & \" (30天內) 到期，請準備。\"\n'   Else\n'     MsgBox \"貸款到期日 \" & Format(loanMaturity, \"yyyy-mm-dd\") & \" 正常。\"\n'   End If\n' ElseIf Not IsEmpty(maturityDateCell.Value) Then\n'   MsgBox \"儲存格 \" & maturityDateCell.Address & \" 中的到期日格式無效。\"\n' End If", "explanation": "檢查指定儲存格中的貸款到期日是否為有效日期。如果是，則將其與當前日期比較，以判斷貸款是否已到期或即將到期，並給出相應提示。"}
    ],
    "keywords": ["isdate validation", "cdate for comparison", "validate maturity date", "貸後到期日驗證", "檢查日期有效性"]
},
// Program Flow & Structure Control
{
    "name": "Error Handling (Specific Error Number for File Lock)",
    "category": "程式流程與結構控制",
    "syntax": "On Error GoTo FileErrorHandler\n' ... attempt to open/save file ...\nExit Sub\nFileErrorHandler:\n  If Err.Number = 70 Then ' Permission denied (often file lock)\n    MsgBox \"檔可能已被其他程式鎖定或您沒有寫入許可權。請關閉其他程式或檢查許可權後重試。\"\n  Else\n    MsgBox \"處理檔時發生未預期的錯誤: \" & Err.Description\n  End If\nResume Next ' Or Exit Sub",
    "description": "在貸後管理中，批量處理文件（如保存報告、打開客戶文檔）時，文件可能被其他使用者或程式鎖定。通過捕獲特定的錯誤號（例如，錯誤70“許可權不足”，常表示檔鎖定），可以向用戶提供更具體的回饋，而不是通用的錯誤資訊。",
    "parameters": [{"name": "Err.Number = 70", "description": "檢查是否為“許可權不足”錯誤，這通常也包括檔被鎖定的情況。"}],
    "examples": [
        {"code": "Sub SaveReportWithLockCheck(filePath As String)\n    On Error GoTo SaveErrorHandler\n    Dim wb As Workbook: Set wb = ThisWorkbook ' Or ActiveWorkbook\n    wb.SaveAs filePath ' Attempt to save\n    MsgBox \"報告已保存到: \" & filePath\n    Exit Sub\nSaveErrorHandler:\n    If Err.Number = 70 Then ' Permission Denied / File Locked\n        MsgBox \"保存失敗！檔 '\" & filePath & \"' 可能已被鎖定或您沒有寫入許可權。\" & vbCrLf & _\n               \"請關閉可能正在使用此檔的其他應用程式，然後重試。\", vbExclamation, \"檔鎖定錯誤\"\n    ElseIf Err.Number = 1004 Then ' General SaveAs error (e.g. invalid path, invalid char in name)\n        MsgBox \"另存為失敗 (錯誤 1004): \" & Err.Description & vbCrLf & \"請檢查檔案名和路徑。\", vbCritical\n    Else\n        MsgBox \"保存報告時發生未預期的錯誤 \" & Err.Number & \": \" & Err.Description, vbCritical\n    End If\nEnd Sub\n' Example call (ensure path is writable and no file is locked there with same name by another app for success test)\n' Call SaveReportWithLockCheck(\"C:\\Temp\\MyLockedReport.xlsx\")", "explanation": "嘗試保存工作簿。如果保存失敗，錯誤處理常式會特別檢查錯誤號70，如果是，則顯示一個關於檔可能被鎖定的特定消息。"}
    ],
    "keywords": ["vba error handling file lock", "runtime error 70", "saveas error permission denied", "貸後檔保存錯誤處理", "檔鎖定"]
},
// External Interaction
{
    "name": "ADODB.Recordset (Filter with Date and Text Criteria)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "使用 ADODB Recordset 的 Filter 屬性，可以組合多個條件，例如篩選出特定日期之後且客戶名稱包含特定關鍵字的貸款記錄。",
    "syntax": "rs.Filter = \"LoanDate >= #yyyy-mm-dd# AND ClientName LIKE '%keyword%'\"",
    "parameters": [{"name": "Filter String", "description": "包含多個AND/OR條件的篩選字串。"}],
    "examples": [
        {"code": "Dim rs As Object ' ADODB.Recordset\nDim filterDate As Date: filterDate = DateSerial(2023,1,1)\nDim clientKeyword As String: clientKeyword = \"科技\"\n' ' Assume rs is an open ADODB.Recordset with ClientName and LoanOriginationDate fields, client-side cursor\n' rs.Filter = \"LoanOriginationDate >= #\" & Format(filterDate, \"yyyy-mm-dd\") & \"# AND ClientName LIKE '%\" & clientKeyword & \"%M'\"\n' Debug.Print \"--- 2023年後發放給包含'科技'的客戶的貸款 ---\"\n' Do While Not rs.EOF\n'   Debug.Print rs!ClientID & \" - \" & rs!ClientName & \" - \" & rs!LoanOriginationDate\n'   rs.MoveNext\n' Loop\n' rs.Filter = \"\" ' Clear filter\n' If rs.State = 1 Then rs.Close\nMsgBox \"(概念性) 演示了按日期和文本組合條件篩選Recordset。需有實際資料。\"", "explanation": "演示如何篩選一個Recordset，找出所有“LoanOriginationDate”在2023年1月1日之後且“ClientName”包含“科技”的記錄。"}
    ],
    "keywords": ["adodb recordset composite filter", "filter by date and text", "貸後多條件篩選", "組合篩選ADO"]
},
{
    "name": "MSXML2.DOMDocument (SelectSingleNode with Attribute Condition)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "使用 XPath 的謂詞 (predicate) 來選取具有特定屬性值的單個節點。例如，從貸後檢查XML報告中，選取特定ID的風險項。",
    "syntax": "Set node = xmlDoc.selectSingleNode(\"//RiskItem[@ItemID='R005']\")",
    "parameters": [{"name": "XPath with attribute predicate", "description": "例如 `//ElementName[@AttributeName='Value']`。"}],
    "examples": [
        {"code": "Dim xmlDoc As Object, riskNode As Object\nDim xmlStr As String\nxmlStr = \"<PostLoanReview><ClientID>C123</ClientID>\" & _\n         \"<RiskItems>\" & _\n         \"  <RiskItem ItemID='R001'><Description>市場風險</Description><Severity>High</Severity></RiskItem>\" & _\n         \"  <RiskItem ItemID='R005'><Description>操作風險</Description><Severity>Medium</Severity></RiskItem>\" & _\n         \"</RiskItems></PostLoanReview>\"\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\nxmlDoc.LoadXML xmlStr\nIf xmlDoc.parseError.errorCode = 0 Then\n    xmlDoc.setProperty \"SelectionNamespaces\", \"xmlns:df='urn:mydefaultns'\" ' If needed for default namespace\n    Set riskNode = xmlDoc.selectSingleNode(\"//RiskItem[@ItemID='R005']\")\n    If Not riskNode Is Nothing Then\n        MsgBox \"找到ItemID為R005的風險項: \" & riskNode.selectSingleNode(\"Description\").Text & _\n               \", 嚴重性: \" & riskNode.selectSingleNode(\"Severity\").Text\n    Else\n        MsgBox \"未找到ItemID為R005的風險項。\"\n    End If\nElse\n    MsgBox \"XML解析錯誤。\"\nEnd If\nSet xmlDoc = Nothing: Set riskNode = Nothing", "explanation": "載入一個包含風險項的XML。使用XPath `//RiskItem[@ItemID='R005']` 來選取 ItemID 屬性值為 'R005' 的 RiskItem 節點，然後提取其子節點的文本。"}
    ],
    "keywords": ["msxml selectsinglenode attribute", "xpath predicate attribute", "貸後XML報告提取", "按屬性選取節點"]
},
{
    "name": "CreateObject(\"Shell.Application\") .NameSpace Method (Get File Properties)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "使用 Shell.Application 的 NameSpace 方法獲取一個代表特定資料夾的 Shell32.Folder 物件，然後可以使用此 Folder 物件的 GetDetailsOf 方法來讀取檔的擴展屬性（例如，作者、標題、檔版本、創建日期等，這些屬性在檔資源管理器的詳細資訊視圖中可見）。這比 FileSystemObject 提供的屬性更豐富。",
    "syntax": "Set oFolder = oShell.NameSpace(FolderPath)\nSet oFileItem = oFolder.ParseName(FileName)\npropertyValue = oFolder.GetDetailsOf(oFileItem, PropertyIndex)",
    "parameters": [
        {"name": "FolderPath", "description": "資料夾的完整路徑。"},
        {"name": "FileName", "description": "資料夾內的檔案名。"},
        {"name": "PropertyIndex", "description": "一個整數，代表要檢索的屬性。索引號和屬性的對應關係是固定的，但可能因系統語言而異（例如 0=名稱, 1=大小, 2=類型, 9=作者, 10=標題）。"}
    ],
    "examples": [
        {"code": "Sub GetExtendedFileProperties(targetFilePath As String)\n    Dim oShell As Object, oFolder As Object, oFile As Object\n    Dim i As Long, propName As String, propValue As Variant\n    If Dir(targetFilePath) = \"\" Then MsgBox \"文件不存在!\": Exit Sub\n    Set oShell = CreateObject(\"Shell.Application\")\n    Set oFolder = oShell.NameSpace(CreateObject(\"Scripting.FileSystemObject\").GetParentFolderName(targetFilePath))\n    Set oFile = oFolder.ParseName(CreateObject(\"Scripting.FileSystemObject\").GetFileName(targetFilePath))\n    If oFile Is Nothing Then MsgBox \"無法獲取文件項。\": Exit Sub\n    Debug.Print \"--- 文件 '\" & oFile.Name & \"' 的擴展屬性 (前30個) ---\"\n    For i = 0 To 30 ' Try first 30 property indexes\n        propName = oFolder.GetDetailsOf(vbNull, i) ' Get property name header\n        propValue = oFolder.GetDetailsOf(oFile, i)\n        If Trim(propName) <> \"\" And Trim(propValue) <> \"\" Then\n            Debug.Print i & \": \" & propName & \" = \" & propValue\n        End If\n    Next i\n    MsgBox \"檔擴展屬性已嘗試列印到立即視窗。具體屬性索引可能因系統而異。\"\n    Set oShell = Nothing: Set oFolder = Nothing: Set oFile = Nothing\nEnd Sub\n' Example: Call GetExtendedFileProperties(ThisWorkbook.FullName)", "explanation": "GetExtendedFileProperties 過程接受一個檔路徑，然後使用 Shell.Application 物件獲取該檔的擴展屬性。它會嘗試列印前30個屬性的名稱和值。屬性索引對應的具體屬性（如作者、標題）是固定的，但其名稱（由`GetDetailsOf(vbNull, i)`獲取）可能因系統語言而異。"}
    ],
    "keywords": ["shell.application getdetailsof", "vba get extended file properties", "read file metadata", "貸後文檔中繼資料提取", "檔詳細資訊"]
},
// Excel VBA 開發與表單
{
    "name": "UserForm (Event: QueryClose - Prevent Closing)",
    "category": "Excel VBA 開發與表單",
    "syntax": "Private Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)\n  If CloseMode = vbFormControlMenu Then ' User clicked 'X' button\n    If MsgBox(\"確定要放棄未保存的貸後審查資料嗎？\", vbYesNo + vbExclamation, \"關閉確認\") = vbNo Then\n      Cancel = True ' Prevents the form from closing\n    End If\n  End If\nEnd Sub",
    "description": "在 UserForm 的 QueryClose 事件中，可以通過將 Cancel 參數設置為 True 來阻止表單關閉。CloseMode 參數指示關閉操作是如何被觸發的 (例如，vbFormControlMenu 表示用戶點擊了標題列的關閉按鈕 'X')。這可用於在關閉前提示使用者保存貸後資料或進行其他確認。",
    "parameters": [
        {"name": "Cancel As Integer (ByRef)", "description": "設為 True 以取消關閉操作。"},
        {"name": "CloseMode As Integer", "description": "指示關閉原因的常數。"}
    ],
    "examples": [
        {"code": "' (Code above is placed directly in the UserForm's code module)\nSub ShowMyReviewFormModal()\n  ' Dim myForm As New ufClientReview ' Assuming UserForm name is ufClientReview\n  ' myForm.Show vbModal\n  ' ' Code here will execute after the modal form is closed (unless VBA terminated)\n  MsgBox \"(概念性) 如果用戶嘗試用 'X' 關閉上述UserForm，會收到確認提示。\"\nEnd Sub", "explanation": "UserForm_QueryClose 事件程序檢查關閉是否由用戶點擊 'X' 按鈕觸發 (CloseMode = vbFormControlMenu)。如果是，則彈出一個訊息方塊詢問用戶是否確定要關閉。如果用戶選擇“否”，則將 Cancel 設為 True，阻止表單關閉。"}
    ],
    "keywords": ["userform queryclose event", "prevent form closing vba", "confirm close userform", "貸後資料表單關閉確認", "vbFormControlMenu"]
},
{
    "name": "UserForm (Using Frame to Group OptionButtons for Loan Type)",
    "category": "Excel VBA 開發與表單",
    "description": "在UserForm上，將一組相關的 OptionButton（選項按鈕）放置在一個 Frame 控制項內，可以使它們作為一個獨立的選項群組工作。這意味著在同一Frame內的OptionButton中，用戶一次只能選擇一個。例如，用於選擇貸款類型或風險等級。",
    "syntax": "' Design time: Place OptionButtons inside a Frame control on UserForm.",
    "parameters": [{"name": "Frame.Controls", "description": "可以遍歷Frame內的控制項來獲取選中的OptionButton。"}],
    "examples": [
        {"code": "' --- In UserForm 'ufLoanApplication' Code Module ---\n' ' Assume Frame 'frameLoanType' contains OptionButtons: optPersonal, optMortgage, optBusiness\n'\n' Function GetSelectedLoanType() As String\n'   Dim ctrl As MSForms.Control\n'   GetSelectedLoanType = \"(未選擇)\"\n'   For Each ctrl In Me.frameLoanType.Controls\n'     If TypeOf ctrl Is MSForms.OptionButton Then\n'       If ctrl.Value = True Then ' This OptionButton is selected\n'         GetSelectedLoanType = ctrl.Caption ' Or use ctrl.Tag or ctrl.Name\n'         Exit Function\n'       End If\n'     End If\n'   Next ctrl\n' End Function\n'\n' Private Sub cmdSubmitApplication_Click()\n'   Dim selectedType As String\n'   selectedType = GetSelectedLoanType()\n'   MsgBox \"選擇的貸款類型是: \" & selectedType\n'   ' ... further processing ...\n' End Sub", "explanation": "GetSelectedLoanType 函數遍歷名為 'frameLoanType' 的Frame控制項內的所有控制項。如果找到一個被選中的OptionButton，它就返回該OptionButton的Caption作為選擇的貸款類型。cmdSubmitApplication_Click 演示了如何調用此函數。"}
    ],
    "keywords": ["userform optionbutton group frame", "radio button group vba", "貸後貸款類型選擇", "Frame內選項按鈕"]
},
// Excel 核心操作
{
    "name": "Range.Sort (Sort by Loan Delinquency Status)",
    "category": "Excel 核心操作",
    "syntax": "dataRange.Sort Key1:=delinquencyStatusColumn, Order1:=xlDescending, Header:=xlYes",
    "description": "對包含客戶貸款的Excel列表，按“拖欠狀態”或“風險等級”欄位進行排序，以便貸後管理人員優先關注最高風險或已逾期的貸款。",
    "parameters": [
        {"name": "Key1", "description": "包含拖欠狀態或風險等級的欄位範圍。"},
        {"name": "Order1", "description": "xlDescending (降序，例如將“高度逾期”或“高風險”排在最前) 或 xlAscending (升序)。"}
    ],
    "examples": [
        {"code": "Dim portfolioSheet As Worksheet\nSet portfolioSheet = ThisWorkbook.Sheets(\"LoanPortfolio\")\nDim dataToSort As Range\n' 假設數據從A1開始，且包含表頭\nSet dataToSort = portfolioSheet.Range(\"A1\").CurrentRegion \n' 假設“風險等級”在第5欄 (E欄)，希望高風險的排最前面\n' 自訂排序次序可能需要輔助欄或進階排序設定，此處簡化為按字母降序 (假設“高”>“中”>“低”)\nIf dataToSort.Rows.Count > 1 Then\n    dataToSort.Sort Key1:=dataToSort.Columns(5), Order1:=xlDescending, Header:=xlYes\n    MsgBox \"貸款組合已按風險等級 (E欄) 降序排序。\"\nEnd If", "explanation": "對“LoanPortfolio”工作表中的數據區域，按第五欄（假設為風險等級）進行降序排序，將風險較高的項目排在前面，方便貸後檢視。"}
    ],
    "keywords": ["excel sort by risk", "sort delinquency status", "贷後排序", "風險排序"]
},
{
    "name": "Range.Formula (Calculate Days Past Due - DPD)",
    "category": "Excel 核心操作",
    "syntax": "dpdCell.Formula = \"=IF(ActualPaymentDate_Cell > DueDate_Cell, ActualPaymentDate_Cell - DueDate_Cell, IF(AND(ISBLANK(ActualPaymentDate_Cell), TODAY() > DueDate_Cell), TODAY() - DueDate_Cell, 0))\"",
    "description": "在指定儲存格中插入計算逾期天數 (DPD) 的Excel公式。如果實際還款日晚於到期日，則計算差值；如果尚未還款且今天已過到期日，則計算今天與到期日的差值；否則為0。此為貸後監控核心指標。",
    "parameters": [
        {"name": "ActualPaymentDate_Cell", "description": "包含實際還款日期的儲存格參照。"},
        {"name": "DueDate_Cell", "description": "包含應還款日期的儲存格參照。"}
    ],
    "examples": [
        {"code": "' Assume Due Date in C2, Actual Payment Date in D2, DPD in E2\nRange(\"E2\").Formula = \"=IF(ISBLANK(D2), IF(TODAY()>C2, TODAY()-C2, 0), IF(D2>C2, D2-C2, 0))\"\nRange(\"E2\").NumberFormat = \"0\"", "explanation": "儲存格E2根據C2（到期日）和D2（實際還款日）計算逾期天數。如果D2為空且今天已過C2，則計算今天與C2的差額；如果D2晚於C2，則計算D2與C2的差額；否則為0。"}
    ],
    "keywords": ["excel formula dpd", "days past due calculation", "贷後逾期天數", "DPD計算"]
},
{
    "name": "WorksheetFunction.NetworkDays_Intl (Custom Weekend for Loan Servicing)",
    "category": "Excel 核心操作",
    "syntax": "workingDays = Application.WorksheetFunction.NetworkDays_Intl(StartDate, EndDate, WeekendString, [HolidaysRange])",
    "description": "使用Excel的NETWORKDAYS.INTL函數，計算兩個日期之間的完整工作日數，允許自訂週末類型。例如，某些地區的銀行週末可能不是週六日，或在特定項目中工作日定義不同。",
    "parameters": [
        {"name": "StartDate, EndDate", "description": "開始和結束日期。"},
        {"name": "WeekendString", "description": "一個7位數的字串，代表一週中的每一天是否為週末 (1表示週末，0表示工作日)，從週一開始。例如 \"0000011\" 表示週六日為週末，\"1000001\" 表示週日和週一為週末。"},
        {"name": "HolidaysRange", "description": "可選，包含要排除的假日日期範圍。"}
    ],
    "examples": [
        {"code": "Dim startDate As Date: startDate = DateSerial(2023, 10, 1)\nDim endDate As Date: endDate = DateSerial(2023, 10, 31)\nDim holidays As Range: Set holidays = Sheets(\"Calendar\").Range(\"A1:A5\") ' Assume holidays listed here\nDim workDaysCustomWeekend As Long\n' Calculate working days assuming Friday and Saturday are weekends (\"0000110\")\nworkDaysCustomWeekend = Application.WorksheetFunction.NetworkDays_Intl(startDate, endDate, \"0000110\", holidays)\nMsgBox \"在十月份，如果週五週六為週末，則有 \" & workDaysCustomWeekend & \" 個工作日 (已排除指定假日)。\"", "explanation": "計算2023年10月內，在將週五和週六定義為週末的情況下，並排除指定假日列表後的工作日總數。"}
    ],
    "keywords": ["excel networkdays.intl vba", "custom weekend working days", "贷後工作日計算", "自訂週末"]
},
{
    "name": "Workbook.ExportAsFixedFormat (Type:=xlTypePDF, for Loan Statements)",
    "category": "Excel 核心操作",
    "syntax": "workbookObject.ExportAsFixedFormat Type:=xlTypePDF, Filename:=pdfFilePath, [Quality], [IncludeDocProperties], [IgnorePrintAreas]",
    "description": "將整個活頁簿或特定工作表匯出為PDF檔案。在貸後管理中，可用於生成客戶的貸款結單、還款通知書或風險報告的PDF版本。",
    "parameters": [
        {"name": "Type:=xlTypePDF", "description": "指定匯出格式為PDF。"},
        {"name": "Filename", "description": "PDF檔案的完整儲存路徑和名稱。"},
        {"name": "Quality", "description": "可選，xlQualityStandard 或 xlQualityMinimum。"},
        {"name": "IncludeDocProperties", "description": "可選，是否包含文件屬性。"},
        {"name": "IgnorePrintAreas", "description": "可選，True表示忽略列印區域設定，匯出整個工作表/活頁簿。"}
    ],
    "examples": [
        {"code": "Dim clientStatementSheet As Worksheet\nDim pdfOutputName As String\n' Set clientStatementSheet = ThisWorkbook.Sheets(\"Client_C001_Statement\")\n' pdfOutputName = \"C:\\LoanStatements\\Client_C001_Statement_\" & Format(Date, \"yyyymmdd\") & \".pdf\"\n' If Not clientStatementSheet Is Nothing Then\n'   clientStatementSheet.ExportAsFixedFormat Type:=xlTypePDF, Filename:=pdfOutputName, Quality:=xlQualityStandard, OpenAfterPublish:=False\n'   MsgBox \"客戶結單已匯出為PDF: \" & pdfOutputName\n' End If", "explanation": "將名為 'Client_C001_Statement' 的工作表匯出為一個PDF檔案，檔名包含客戶ID和日期。OpenAfterPublish:=False 表示匯出後不自動開啟PDF。"}
    ],
    "keywords": ["excel export to pdf vba", "save as pdf specific sheet", "贷後報告PDF生成", "匯出PDF"]
},
// Excel 資料分析與樞紐
{
    "name": "PivotTable.CalculatedItems.Add (For Covenant Compliance Buckets - OLAP)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "Set ciBucket = olapPivotField.CalculatedItems.Add(Name:=\"Compliant_DSCR\", Formula:=\"IIF([Measures].[DSCR] >= 1.2, [Measures].[LoanBalance], NULL)\")",
    "description": "在基於OLAP數據源的數據透視表中，為某個欄位（例如DSCR）創建計算項目，將客戶按是否符合財務契約（例如DSCR >= 1.2）進行分組，並顯示其對應的貸款餘額或其他度量。",
    "parameters": [
        {"name": "Name", "description": "新計算項目的名稱。"},
        {"name": "Formula", "description": "MDX公式，用於定義計算項目。"}
    ],
    "examples": [
        {"code": "' Assume pt is an OLAP PivotTable and [Measures].[DSCR] and [Measures].[LoanBalance] exist.\n' Dim pt As PivotTable, pfFinancials As PivotField\n' ' Set pt = ActiveSheet.PivotTables(\"OLAP_LoanPortfolio\")\n' ' If pt.PivotCache.OLAP Then\n' '   Set pfFinancials = pt.PivotFields(\"[Client].[Financial Status]\") ' A dummy dimension to add items to\n' '   On Error Resume Next\n' '   pfFinancials.CalculatedItems.Add Name:=\"DSCR Compliant Loans\", _\n' '       Formula:=\"SUM(FILTER([Client].[Client ID].[Client ID].Members, [Measures].[DSCR] >= 1.2), [Measures].[LoanBalance])\"\n' '   If Err.Number = 0 Then MsgBox \"已新增 'DSCR Compliant Loans' 計算項目。\" Else MsgBox \"新增失敗: \" & Err.Description\n' '   On Error GoTo 0\n' ' End If", "explanation": "如果數據透視表基於OLAP，此範例嘗試在一個（假設的）客戶財務狀態維度中新增一個名為“DSCR Compliant Loans”的計算項目，該項目匯總所有DSCR大於等於1.2的客戶的貸款餘額。MDX語法需根據實際Cube結構調整。"}
    ],
    "keywords": ["pivottable olap calculated item", "covenant compliance pivot", "mdx for loan analysis", "贷後OLAP計算項目", "契約達成情況分析"]
},
{
    "name": "SlicerCache.TimelineState.SetFilterDateRange (For Date Slicers/Timelines)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "dateSlicerCache.TimelineState.SetFilterDateRange StartDate, EndDate",
    "description": "設定與日期相關的 SlicerCache（通常由日期交叉分析篩選器或時間表控制項使用）的篩選日期範圍。這允許VBA以程式設計方式控制時間表篩選器。",
    "parameters": [
        {"name": "StartDate", "description": "篩選範圍的開始日期。"},
        {"name": "EndDate", "description": "篩選範圍的結束日期。"}
    ],
    "examples": [
        {"code": "Dim scDate As SlicerCache\nDim reportStartDate As Date, reportEndDate As Date\n' reportStartDate = DateSerial(Year(Now), Month(Now) -1, 1) ' First day of last month\n' reportEndDate = DateSerial(Year(Now), Month(Now), 0)    ' Last day of last month\n'\n' ' Assume a SlicerCache for a date field (e.g., \"Slicer_TransactionDate\") exists\n' On Error Resume Next\n' Set scDate = ThisWorkbook.SlicerCaches(\"Slicer_TransactionDate\")\n' If Not scDate Is Nothing And scDate.SlicerCacheType = xlTimeline Then\n'   scDate.TimelineState.SetFilterDateRange reportStartDate, reportEndDate\n'   MsgBox \"日期交叉分析篩選器已設定為顯示上個月的數據。\"\n' ElseIf scDate Is Nothing Then\n'   MsgBox \"未找到名為 'Slicer_TransactionDate' 的日期 SlicerCache。\"\n' Else\n'   MsgBox \"'Slicer_TransactionDate' 不是一個時間表交叉分析篩選器。\"\n' End If\n' On Error GoTo 0", "explanation": "如果存在一個名為 “Slicer_TransactionDate” 且類型為時間表的 SlicerCache，則此代碼將其篩選範圍設定為上個月的第一天到最後一天。"}
    ],
    "keywords": ["excel slicer timeline vba", "setfilterdaterange", "filter by date slicer code", "贷後報告日期篩選", "時間表控制"]
},
// Excel VBA 開發與表單
{
    "name": "UserForm (Validate Date Input for Loan Review Date)",
    "category": "Excel VBA 開發與表單",
    "syntax": "' In TextBox_Exit event or SubmitButton_Click event\nIf Not IsDate(Me.txtReviewDate.Value) Then ...\nIf CDate(Me.txtReviewDate.Value) < earliestAllowedDate Then ...",
    "description": "在用於輸入貸後審查日期的UserForm文字方塊中，使用VBA進行數據驗證：確保輸入的是有效日期，並且該日期可能需要符合特定業務規則（例如，不能早於上次審查日期，不能是未來過遠的日期）。",
    "parameters": [
        {"name": "TextBox.Value", "description": "文字方塊中輸入的內容。"},
        {"name": "IsDate()", "description": "檢查是否為有效日期格式。"},
        {"name": "CDate()", "description": "將有效日期字串轉換為Date類型以便比較。"}
    ],
    "examples": [
        {"code": "' --- In UserForm 'ufReviewEntry' Code Module ---\n' ' Assume TextBox named txtActualReviewDate\n' Private Sub txtActualReviewDate_Exit(ByVal Cancel As MSForms.ReturnBoolean)\n'   Dim reviewDate As Date\n'   If Trim(Me.txtActualReviewDate.Value) = \"\" Then Exit Sub ' Allow blank if not mandatory yet\n'\n'   If Not IsDate(Me.txtActualReviewDate.Value) Then\n'     MsgBox \"輸入的審查日期格式無效！請使用 yyyy/mm/dd 或系統接受的格式。\", vbExclamation\n'     Cancel = True ' Prevent losing focus\n'     Me.txtActualReviewDate.SelStart = 0\n'     Me.txtActualReviewDate.SelLength = Len(Me.txtActualReviewDate.Text)\n'     Exit Sub\n'   End If\n'\n'   reviewDate = CDate(Me.txtActualReviewDate.Value)\n'   ' Assume loanOriginationDate is available, e.g., from another control or variable\n'   ' Dim loanOriginationDate As Date: loanOriginationDate = CDate(Me.lblOriginationDate.Caption)\n'   ' If reviewDate < loanOriginationDate Then\n'   '   MsgBox \"審查日期不能早於貸款發放日期！\", vbExclamation\n'   '   Cancel = True\n'   ' End If\n'   If reviewDate > Date Then\n'     MsgBox \"審查日期不能是未來日期！\", vbExclamation\n'     Cancel = True\n'   End If\n' End Sub", "explanation": "在名為 `txtActualReviewDate` 的文字方塊的 `Exit` 事件中，檢查輸入值是否為有效日期。如果是，則進一步檢查該日期是否晚於今天（不允許未來日期作為實際審查日）。如果驗證失敗，則顯示錯誤消息並將焦點保留在文字方塊中。"}
    ],
    "keywords": ["userform date validation", "isdate check vba", "validate loan review date", "贷後表單日期驗證", "輸入有效性"]
},
{
    "name": "UserForm (ListBox to Display Client's Overdue Items)",
    "category": "Excel VBA 開發與表單",
    "description": "在選定一個客戶後，UserForm上的ListBox可以動態填充該客戶所有逾期的貸款、待提交的報告或其他貸後管理事項。ListBox可以設定多欄以顯示事項類型、到期日、逾期天數等。",
    "syntax": "Me.ListBoxOverdue.AddItem ItemDescription\nMe.ListBoxOverdue.List(Me.ListBoxOverdue.ListCount - 1, 1) = DueDate\nMe.ListBoxOverdue.List(Me.ListBoxOverdue.ListCount - 1, 2) = DaysPastDue",
    "parameters": [
        {"name": "ListBox.AddItem", "description": "新增一行。"},
        {"name": "ListBox.List(row, col)", "description": "設定指定行和欄的儲存格內容。"}
    ],
    "examples": [
        {"code": "' --- In UserForm module, after selecting a client ---\n' Sub PopulateOverdueItemsListBox(clientID As String)\n'   Dim wsOverdueLog As Worksheet, r As Long, lastRow As Long\n'   Dim itemDesc As String, itemDueDate As Date, dpd As Long\n'\n'   Set wsOverdueLog = ThisWorkbook.Sheets(\"ClientOverdueTracker\") ' Col A=ClientID, B=ItemDesc, C=DueDate, D=Status\n'   Me.lstClientOverdues.Clear\n'   Me.lstClientOverdues.ColumnCount = 3\n'   Me.lstClientOverdues.ColumnWidths = \"150;80;50\" ' Description, Due Date, DPD\n'\n'   lastRow = wsOverdueLog.Cells(Rows.Count, \"A\").End(xlUp).Row\n'   For r = 2 To lastRow\n'     If wsOverdueLog.Cells(r, \"A\").Value = clientID And LCase(wsOverdueLog.Cells(r, \"D\").Value) <> \"completed\" Then\n'       itemDesc = wsOverdueLog.Cells(r, \"B\").Value\n'       itemDueDate = CDate(wsOverdueLog.Cells(r, \"C\").Value)\n'       dpd = Date - itemDueDate ' Calculate DPD\n'       If dpd > 0 Then ' Only show if actually overdue\n'         Me.lstClientOverdues.AddItem itemDesc\n'         Dim newItemIndex As Long: newItemIndex = Me.lstClientOverdues.ListCount - 1\n'         Me.lstClientOverdues.List(newItemIndex, 1) = Format(itemDueDate, \"yyyy-mm-dd\")\n'         Me.lstClientOverdues.List(newItemIndex, 2) = dpd\n'       End If\n'     End If\n'   Next r\n'   If Me.lstClientOverdues.ListCount = 0 Then Me.lstClientOverdues.AddItem \"(此客戶無逾期事項)\"\n' End Sub", "explanation": "PopulateOverdueItemsListBox 過程從 “ClientOverdueTracker” 工作表中查找指定客戶的未完成且已逾期的事項。對於每個逾期事項，它將描述、到期日和逾期天數添加到UserForm上名為 `lstClientOverdues` 的ListBox中。"}
    ],
    "keywords": ["userform listbox populate overdue", "display client overdue items", "贷後逾期事項列表框", "動態列表框內容"]
},
// Word 文件處理
{
    "name": "MailMerge.OpenHeaderSource (Word Mail Merge with Header File)",
    "category": "Word 文件處理",
    "syntax": "mainDocument.MailMerge.OpenHeaderSource Name:=headerSourceFile, [Format], [Connection], [SQLStatement], ...",
    "description": "為Word郵件合併操作附加一個頁首數據源。頁首數據源通常包含將在合併文檔（例如，信函或標籤）的每個頁面或每個部分重複的信息，而主數據源提供每個單獨文檔的變化數據。",
    "parameters": [
        {"name": "Name", "description": "必需。頁首數據源的文件名。"},
        {"name": "SQLStatement", "description": "可選。用於從頁首數據源查詢特定記錄的SQL語句。"}
    ],
    "examples": [
        {"code": "Dim wdMainDoc As Object ' Word.Document (Main Mail Merge Document)\nDim headerFilePath As String: headerFilePath = \"C:\\MailMergeData\\LetterheadInfo.xlsx\"\n' ' Assume wdMainDoc is already open and its MailMerge.MainDocumentType is set (e.g., wdFormLetters)\n' ' And MailMerge.OpenDataSource has already been called for the main data.\n' If Dir(headerFilePath) <> \"\" Then\n'   wdMainDoc.MailMerge.OpenHeaderSource Name:=headerFilePath, _\n'                                         SQLStatement:=\"SELECT * FROM [Sheet1$] WHERE ID='CompanyBranchA'\"\n'   If wdMainDoc.MailMerge.State = wdMainAndSourceAndHeader Then ' State 2\n'     MsgBox \"頁首數據源已成功附加，並篩選了 'CompanyBranchA' 的信息。\"\n'     ' Now, header source fields can be inserted into headers/footers of the main document.\n'   Else\n'     MsgBox \"附加頁首數據源失敗。\"\n'   End If\n' Else\n'   MsgBox \"頁首數據源文件未找到: \" & headerFilePath\n' End If", "explanation": "在一個已設定了主數據源的Word郵件合併主文件中，此代碼嘗試附加一個名為“LetterheadInfo.xlsx”的Excel文件作為頁首數據源，並從中查詢ID為'CompanyBranchA'的記錄。這些數據可用於信頭。"}
    ],
    "keywords": ["word mailmerge openheadersource", "mail merge header data", "贷後通知函信頭", "郵件合併頁首源"]
},
{
    "name": "ContentControl.PlaceholderText Property (Word)",
    "category": "Word 文件處理",
    "syntax": "contentControlObject.SetPlaceholderText [BuildingBlock As Word.BuildingBlock], [Range As Word.Range], [Text As String]",
    "description": "設定內容控制項在為空時顯示的預留位置文字或建置組塊。使用者點擊控制項或輸入內容時，預留位置文字會消失。",
    "parameters": [
        {"name": "Text", "description": "要顯示的預留位置文字字串。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, cc As Object ' Word.ContentControl\n' Set wdDoc = ActiveDocument\n' ' Add a Rich Text content control\n' Set cc = wdDoc.ContentControls.Add(wdContentControlRichText, Selection.Range)\n' cc.Title = \"客戶反饋\"\n' cc.SetPlaceholderText Text:=\"[請在此處輸入客戶對本次貸後服務的反饋意見，不少於50字]\"\n' cc.Range.Select\nMsgBox \"已新增內容控制項並設定其預留位置文字。\"", "explanation": "新增一個RTF內容控制項，並使用 `SetPlaceholderText` 方法設定當該控制項為空時向使用者顯示的提示文字。"}
    ],
    "keywords": ["word contentcontrol placeholdertext", "set placeholder text", "内容控制项预留位置文字", "贷後表單提示"]
},
// Outlook 郵件與項目管理
{
    "name": "MailItem.Actions Collection (Outlook Custom Actions)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set customAction = mailItemObject.Actions.Add()\ncustomAction.Name = \"ForwardToLegalDept\"\ncustomAction.ReplyStyle = olReply\ncustomAction.ResponseStyle = olOpen\ncustomAction.ShowOn = olMenuAndToolbar\ncustomAction.MessageClass = \"IPM.Note.LegalReview\"",
    "description": "允許為Outlook項目（如郵件）定義自訂操作。這些自訂操作可以顯示在項目的“操作”選單或工具欄中。當使用者選擇自訂操作時，可以觸發VBA代碼或Outlook的標準動作。",
    "parameters": [
        {"name": ".Add()", "description": "方法：新增一個新的 Action 物件到 Actions 集合。"},
        {"name": "Action.Name", "description": "操作的顯示名稱。"},
        {"name": "Action.ReplyStyle", "description": "olMeetingReply, olReply, olForward 等，定義操作的基礎類型。"},
        {"name": "Action.ResponseStyle", "description": "olOpen, olSendPrompt, olSend など，定義執行操作時是否開啟新項目。"},
        {"name": "Action.MessageClass", "description": "可選。指定執行操作後建立的項目的訊息類別 (例如，自訂表單)。"}
    ],
    "examples": [
        {"code": "Dim olItem As Object ' Could be MailItem selected by user\nDim newAction As Object ' Outlook.Action\n' ' Assume olItem is the currently selected MailItem\n' ' Set olItem = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olItem) = \"MailItem\" Then\n'   ' Check if action already exists, if so, maybe update or skip\n'   On Error Resume Next\n'   olItem.Actions(\"轉發至貸後風險組\").Delete ' Delete if exists to avoid duplicates\n'   On Error GoTo 0\n'   Set newAction = olItem.Actions.Add\n'   With newAction\n'     .Name = \"轉發至貸後風險組\"\n'     .MessageClass = \"IPM.Note\" ' Standard email forward\n'     .ReplyStyle = olForward ' It's a forward action\n'     .ResponseStyle = olOpen ' Open the forward email for user to edit\n'     .Prefix = \"貸後風險通報:\" ' Prefix for the subject of the forwarded email\n'   End With\n'   olItem.Save ' Save the item to persist the custom action\n'   MsgBox \"已為選取郵件新增自訂操作 '轉發至貸後風險組'。請在郵件的「動作」選單查看。\"\n' End If", "explanation": "如果使用者選取了一封郵件，此代碼會為該郵件新增一個名為「轉發至貸後風險組」的自訂操作。當使用者從該郵件的「動作」選單中選擇此操作時，Outlook會自動建立一個轉寄郵件，主旨帶有“貸後風險通報:”前綴，並打開該轉寄郵件供使用者編輯和發送。"}
    ],
    "keywords": ["outlook custom actions", "mailitem actions add", "automate email workflow", "贷後郵件自訂操作", "郵件流程自動化"]
},
{
    "name": "AppointmentItem.GetOrganizer Method (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "Set organizerRecipient = appointmentItemObject.GetOrganizer()",
    "description": "传回一个 AddressEntry 对象，代表会议约会的召集人。",
    "parameters": [],
    "examples": [
        {"code": "Dim olAppt As Object ' Outlook.AppointmentItem (a meeting item)\nDim organizerEntry As Object ' Outlook.AddressEntry\n' ' Assume olAppt is an existing meeting item in the calendar\n' If olAppt.MeetingStatus = olMeeting Or olAppt.MeetingStatus = olMeetingReceived Then\n'   Set organizerEntry = olAppt.GetOrganizer()\n'   If Not organizerEntry Is Nothing Then\n'     MsgBox \"会议 '\" & olAppt.Subject & \"' 的召集人是: \" & organizerEntry.Name & _\n'            \" (\" & organizerEntry.Address & \")\"\n'   Else\n'     MsgBox \"无法获取会议 '\" & olAppt.Subject & \"' 的召集人信息。\"\n'   End If\n' End If", "explanation": "如果一个约会项目是一个会议（或收到的会议邀请），则此代码获取并显示该会议召集人的姓名和电子邮件地址。"}
    ],
    "keywords": ["outlook appointment organizer", "get meeting organizer", "会议召集人信息", "贷后会议发起人"]
},
// PowerPoint 簡報製作
{
    "name": "Presentation.Merge Method (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "presentationObject.Merge(PathName As String, [SlideIndex As Long = -1])",
    "description": "将另一个简报中的所有或部分投影片合并到目前简报中。合并的投影片会保留其原始格式。",
    "parameters": [
        {"name": "PathName", "description": "必需。要从中合并投影片的简报文件的完整路径。"},
        {"name": "SlideIndex", "description": "可選。一个長整數陣列，指定要合并的来源简报中的投影片索引。如果省略，则合并所有投影片。"}
    ],
    "examples": [
        {"code": "Dim targetPres As Object ' PowerPoint.Presentation\nDim sourcePresPath As String: sourcePresPath = \"C:\\MonthlyReports\\DeptA_Slides.pptx\"\n' Set targetPres = ActivePresentation ' Merge into the currently active presentation\n'\n' If Dir(sourcePresPath) <> \"\" Then\n'   ' Merge all slides from sourcePresPath into targetPres at the end\n'   targetPres.Merge PathName:=sourcePresPath\n'   MsgBox \"已将 '\" & sourcePresPath & \"' 中的所有投影片合并到当前简报末尾。\"\n'\n'   ' Merge specific slides (e.g., 2 and 5) from another source to a specific location\n'   ' Dim sourcePresPath2 As String: sourcePresPath2 = \"C:\\RegionalData\\RegionEast_Report.pptx\"\n'   ' If targetPres.Slides.Count > 0 Then\n'   '   targetPres.Merge PathName:=sourcePresPath2, SlideIndex:=Array(2, 5) ' This SlideIndex refers to position in targetPres, not source.\n'   '   ' To insert at a specific point, you might need to create a temporary presentation, merge into it,\n'   '   ' then copy slides from temp to target at desired index, as Merge often appends.\n'   '   ' A simpler way if just copying slides: sourcePres.Slides.Range(Array(2,5)).Copy -> targetPres.Slides.Paste(Index)\n'   ' MsgBox \"(概念性) 特定投影片合并较为复杂，通常用复制粘贴。\"\n' Else\n'   MsgBox \"源简报文件未找到: \" & sourcePresPath\n' End If", "explanation": "将名为 'DeptA_Slides.pptx' 的简报中的所有投影片合并到当前活动简报的末尾。合并特定投影片或到特定位置通常更推荐使用复制 (`Slides.Range.Copy`) 和粘贴 (`Slides.Paste`) 的方法以获得更精确的控制，因为 `Merge` 方法的行为有时不够直观，特别是其 `SlideIndex` 参数的作用 (它通常指目标简报中插入的位置，而不是源幻灯片的索引)。"}
    ],
    "keywords": ["powerpoint merge presentations", "combine ppt files vba", "合并简报PPT", "贷后报告整合"]
},
{
    "name": "Shape.TextFrame2.TextRange.InsertChartField (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "shapeObject.TextFrame2.TextRange.InsertChartField(ChartFieldType As MsoChartFieldType, [Formula As String = \"\"], [Position As Long = -1])",
    "description": "在图表（或图表的一部分，如标题、坐标轴标题）的文本框中插入一个图表域。例如，可以在图表标题中插入一个域来显示系列名称或值。此功能较高级且不常用。",
    "parameters": [
        {"name": "ChartFieldType", "description": "MsoChartFieldType 常数，指定要插入的域类型。"},
        {"name": "Formula", "description": "可選。域的公式。"},
        {"name": "Position", "description": "可選。插入域的字符位置。"}
    ],
    "examples": [
        {"code": "Dim cht As Object ' PowerPoint.Chart\nDim chtTitle As Object ' PowerPoint.ChartTitle\n' ' Assume a chart exists on the current slide and is selected or referenced by cht\n' ' Set cht = ActiveWindow.Selection.ShapeRange(1).Chart ' If a chart shape is selected\n' If Not cht Is Nothing Then\n'   cht.HasTitle = True\n'   Set chtTitle = cht.ChartTitle\n'   ' Example: Try to insert the chart's name (ProgID) or a category name into title (conceptual)\n'   ' This is a highly specific feature, its exact usage and available ChartFieldTypes need careful checking.\n'   ' On Error Resume Next ' InsertChartField can be tricky\n'   ' chtTitle.TextFrame2.TextRange.InsertChartField ChartFieldType:=msoChartFieldSeriesName ' Example constant\n'   ' If Err.Number = 0 Then MsgBox \"已尝试在图表标题中插入图表域。\" Else MsgBox \"插入图表域失败。\"\n'   ' On Error GoTo 0\n'   MsgBox \"InsertChartField 用于在图表文本中插入动态数据域，用法较复杂。\"\n' End If", "explanation": "概念性地演示如何在图表标题的文本范围中尝试插入一个图表域（例如系列名称）。此功能 `InsertChartField` 的具体应用和可用的 `MsoChartFieldType` 常数需要详细查阅 PowerPoint 对象模型。"}
    ],
    "keywords": ["powerpoint insertchartfield", "dynamic chart text ppt", "贷后图表动态标题", "图表域"]
},
// FileSystemObject
{
    "name": "FileSystemObject.GetStandardStream (StdOut/StdErr Redirection - Conceptual)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "当使用 `WScript.Shell.Exec` 执行外部命令时，可以通过返回的 `WshScriptExec` 对象的 `StdOut` 和 `StdErr` 属性（它们是 TextStream 对象）来读取该命令的标准输出和标准错误流。`FileSystemObject.GetStandardStream` 本身在 Office VBA 中不直接用于捕获 Shell 命令的输出，而是用于 WSH 脚本自身与控制台的交互。",
    "parameters": [],
    "examples": [
        {"code": "' See 'WScript.Shell.Run (Capturing Output - Advanced)' example which uses Exec and then\n' execObj.StdOut.ReadAll() and execObj.StdErr.ReadAll().\n' Those .StdOut and .StdErr are TextStream objects similar to what GetStandardStream would return\n' in a CScript context.\nDim fso As Object, wsh As Object, oExec As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet wsh = CreateObject(\"WScript.Shell\")\n' Set oExec = wsh.Exec(\"cmd /c echo Hello StdOut && echo Hello StdErr >&2\")\n' Dim strOut As String, strErr As String\n' Do While oExec.Status = 0: Loop ' Wait\n' strOut = oExec.StdOut.ReadAll()\n' strErr = oExec.StdErr.ReadAll()\n' Debug.Print \"StdOut: \" & strOut\n' Debug.Print \"StdErr: \" & strErr\nMsgBox \"(概念性) 演示了通过 WshScriptExec 的 StdOut/StdErr 属性 (TextStream) 读取输出。\"", "explanation": "此示例强调，在VBA中捕获外部命令的输出通常通过 `WScript.Shell.Exec` 返回的对象的 `StdOut` 和 `StdErr` (它们是TextStream) 来完成，而不是直接在VBA中使用 `fso.GetStandardStream` 来读取其他进程的流。"}
    ],
    "keywords": ["fso stdout stderr", "capture shell output textstream", "贷后脚本输出捕获", "标准输出流读取"]
},
// String & Text Manipulation
{
    "name": "Replace (Case-Sensitive vs Case-Insensitive Count)",
    "category": "字串與文本操作",
    "description": "Replace 函数的 count 参数指定替换的次数。如果 compare 参数设为 vbTextCompare (不区分大小写)，则替换操作会匹配所有大小写变体，直到达到 count 指定的次数。如果为 vbBinaryCompare (区分大小写)，则只匹配大小写完全一致的实例。",
    "parameters": [],
    "examples": [
        {"code": "Dim text As String: text = \"Report A, report B, REPORT C, report D\"\nDim result1 As String, result2 As String\n' Replace first 2 occurrences of \"report\" (case-insensitive)\nresult1 = Replace(text, \"report\", \"SUMMARY\", , 2, vbTextCompare)\nDebug.Print \"不区分大小写替换前2个: \" & result1 \n' Output: SUMMARY A, SUMMARY B, REPORT C, report D\n\n' Replace first 2 occurrences of \"Report\" (case-sensitive)\nresult2 = Replace(text, \"Report\", \"SUMMARY\", , 2, vbBinaryCompare)\nDebug.Print \"区分大小写替换前2个: \" & result2\n' Output: SUMMARY A, report B, SUMMARY C, report D", "explanation": "演示在进行有限次数替换时，vbTextCompare 和 vbBinaryCompare 的不同效果。不区分大小写时，它会找到并替换任何大小写匹配的“report”直到达到计数。区分大小写时，它只替换精确匹配“Report”的实例。"}
    ],
    "keywords": ["replace count compare", "case sensitive limited replace", "贷后报告文本标准化", "替换指定次数"]
},
// Math, Date & Time
{
    "name": "WorksheetFunction.EDate (Loan Maturity Calculation)",
    "category": "Excel 核心操作",
    "syntax": "maturityDate = Application.WorksheetFunction.EDate(LoanStartDate, LoanTermInMonths)",
    "description": "使用Excel的EDATE函数，根据贷款发放日期和贷款期限（月数），计算贷款的精确到期日。EDATE会自动处理月份天数和闰年。",
    "parameters": [
        {"name": "LoanStartDate", "description": "贷款的起始日期。"},
        {"name": "LoanTermInMonths", "description": "贷款的总期数（以月为单位）。"}
    ],
    "examples": [
        {"code": "Dim startDate As Date: startDate = DateSerial(2023, 1, 31)\nDim termMonths As Long: termMonths = 3\nDim maturity As Date\nmaturity = Application.WorksheetFunction.EDate(startDate, termMonths)\nMsgBox \"从 \" & Format(startDate, \"yyyy-mm-dd\") & \" 开始，为期 \" & termMonths & \" 个月的贷款到期日是: \" & Format(maturity, \"yyyy-mm-dd\")\n' Output: 2023-04-30 (end of April)\n\nDim termMonths2 As Long: termMonths2 = 1\nmaturity = Application.WorksheetFunction.EDate(startDate, termMonths2)\nMsgBox \"从 \" & Format(startDate, \"yyyy-mm-dd\") & \" 开始，为期 \" & termMonths2 & \" 个月的贷款到期日是: \" & Format(maturity, \"yyyy-mm-dd\")\n' Output: 2023-02-28 (end of Feb)", "explanation": "演示如何使用EDATE函数计算贷款到期日。如果起始日在月底，EDATE会确保到期日也是对应月份的月底。"}
    ],
    "keywords": ["excel edate function vba", "calculate maturity date", "贷后到期日计算", "EDATE贷款期限"]
},
// Data Types, Conversion & Validation
{
    "name": "IsObject (With Unset Object Variable)",
    "category": "資料類型、轉換與驗證",
    "description": "如果一个物件变数已被宣告但从未使用 `Set` 语句赋予一个物件参考 (即其值为 `Nothing`)，则 `IsObject` 对此变数仍然会返回 `True`，因为它本身被定义为可以持有物件的变数类型。要检查它是否实际指向一个有效物件，应使用 `If Not myObject Is Nothing Then ...`。",
    "parameters": [],
    "examples": [
        {"code": "Dim objUnset As Object\nDim objSet As Object: Set objSet = CreateObject(\"Scripting.Dictionary\")\nDim wsUnset As Worksheet\n\nDebug.Print \"IsObject(objUnset): \" & IsObject(objUnset) ' True, because objUnset *is* an Object type variable\nDebug.Print \"objUnset Is Nothing: \" & (objUnset Is Nothing) ' True, because it's not set\n\nDebug.Print \"IsObject(objSet): \" & IsObject(objSet) ' True\nDebug.Print \"objSet Is Nothing: \" & (objSet Is Nothing) ' False\n\nDebug.Print \"IsObject(wsUnset): \" & IsObject(wsUnset) ' True (Worksheet is a type of Object)\nDebug.Print \"wsUnset Is Nothing: \" & (wsUnset Is Nothing) ' True", "explanation": "演示即使物件变数未被 `Set` (值为 Nothing)，`IsObject` 对其仍返回 True，因为它本身是物件类型。`Is Nothing` 才是判断其是否实际引用了一个物件实例的正确方法。"}
    ],
    "keywords": ["isobject vs isnothing", "check if object variable is set", "贷後物件初始化检查", "IsObject与IsNothing区别"]
},
// Program Flow & Structure Control
{
    "name": "Application.OnTime (Cancel with Exact Time and Procedure)",
    "category": "程式流程與結構控制",
    "description": "要成功取消一个已使用 `Application.OnTime` 安排的宏，`Schedule:=False` 参数必须与最初安排宏时使用的完全相同的 `EarliestTime` 和 `Procedure` 参数一起调用。如果时间略有不同，或过程名称不匹配，取消将失败。",
    "syntax": "Application.OnTime EarliestTime:=exactScheduledTime, Procedure:=\"MyProcName\", Schedule:=False",
    "parameters": [],
    "examples": [
        {"code": "Public gScheduledTime As Date ' Global variable to store the exact schedule time\nPublic Const MY_PROC_NAME As String = \"MyRecurringTask\"\n\nSub StartMyRecurringProcess()\n    gScheduledTime = Now + TimeValue(\"00:00:05\") ' Schedule for 5 seconds from now\n    Application.OnTime EarliestTime:=gScheduledTime, Procedure:=MY_PROC_NAME\n    MsgBox MY_PROC_NAME & \" 已安排在: \" & Format(gScheduledTime, \"hh:mm:ss\")\nEnd Sub\n\nSub MyRecurringTask()\n    Debug.Print MY_PROC_NAME & \" 执行于 \" & Now\n    ' Reschedule itself (example for a recurring task)\n    ' gScheduledTime = Now + TimeValue(\"00:01:00\") ' Next run in 1 minute\n    ' Application.OnTime EarliestTime:=gScheduledTime, Procedure:=MY_PROC_NAME\nEnd Sub\n\nSub CancelMyProcess()\n    On Error Resume Next ' Suppress error if no such schedule exists\n    Application.OnTime EarliestTime:=gScheduledTime, Procedure:=MY_PROC_NAME, Schedule:=False\n    If Err.Number = 0 Then\n        MsgBox \"尝试取消 '\" & MY_PROC_NAME & \"' 的排程。如果时间和过程名匹配，则已取消。\"\n    Else\n        MsgBox \"取消排程 '\" & MY_PROC_NAME & \"' 失败，可能参数不匹配或未排程。\"\n    End If\n    On Error GoTo 0\nEnd Sub", "explanation": "演示如何使用一个全局变量 `gScheduledTime` 来存储通过 `Application.OnTime` 安排任务的精确时间。然后，在 `CancelMyProcess` 中使用这个存储的精确时间和相同的过程名称来尝试取消该计划任务。"}
    ],
    "keywords": ["application.ontime cancel specific", "stop scheduled macro", "贷後定时任务取消", "精确取消OnTime"]
},
// External Interaction
{
    "name": "WScript.Shell.Exec (Read StdOut Line by Line)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "使用 `WScript.Shell.Exec` 执行外部命令后，可以通过其 `StdOut` (TextStream 对象) 的 `ReadLine` 方法逐行读取标准输出，而不是一次性用 `ReadAll`。这对于处理大量输出或需要在输出到达时立即处理的场景很有用。",
    "syntax": "Set execObj = wshShell.Exec(Command)\nDo While Not execObj.StdOut.AtEndOfStream\n  line = execObj.StdOut.ReadLine()\n  ' Process line\nLoop",
    "parameters": [],
    "examples": [
        {"code": "Sub ReadPingOutputLineByLine()\n    Dim wshShell As Object, oExec As Object\n    Dim commandStr As String, outputLine As String\n    Set wshShell = CreateObject(\"WScript.Shell\")\n    commandStr = \"%COMSPEC% /c ping -n 3 www.google.com\" ' Ping 3 times\n\n    Set oExec = wshShell.Exec(commandStr)\n    Debug.Print \"--- Ping 输出 (逐行) ---\"\n    ' Wait for some output to be available, or for process to finish\n    Do While oExec.Status = 0 Or Not oExec.StdOut.AtEndOfStream Or Not oExec.StdErr.AtEndOfStream\n        If Not oExec.StdOut.AtEndOfStream Then\n            outputLine = oExec.StdOut.ReadLine()\n            Debug.Print \"STDOUT: \" & outputLine\n        End If\n        If Not oExec.StdErr.AtEndOfStream Then\n            outputLine = oExec.StdErr.ReadLine()\n            Debug.Print \"STDERR: \" & outputLine\n        End If\n        If oExec.Status <> 0 And oExec.StdOut.AtEndOfStream And oExec.StdErr.AtEndOfStream Then\n            Exit Do ' Exit if process finished and no more output on both streams\n        End If\n        Application.Wait Now + TimeValue(\"00:00:00.1\") ' Small pause\n        DoEvents\n    Loop\n    MsgBox \"Ping 命令已执行，输出已尝试逐行打印到立即窗口。\"\n    Set oExec = Nothing: Set wshShell = Nothing\nEnd Sub", "explanation": "执行 `ping www.google.com` 命令，并使用一个循环来检查 `StdOut` 和 `StdErr` 是否有新行可读。如果可读，则使用 `ReadLine` 读取并打印。循环会持续到进程结束且两个流都到达末尾。"}
    ],
    "keywords": ["wscript.shell exec readline", "read stdout line by line", "capture command output incrementally", "贷後系统命令逐行输出"]
},
{
    "name": "ADODB.Recordset (Supports Method for Cursor/Lock Types)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 `Supports` 方法可以用来检查当前的 Recordset（基于其 CursorType, LockType 和提供者）是否支持特定的功能，例如向后移动、书签、更新、删除等。它接受一个或多个 CursorOptionEnum 常数。",
    "syntax": "canMovePrevious = rs.Supports(adMovePrevious)\ncanUpdate = rs.Supports(adUpdate)",
    "parameters": [{"name": "CursorOptionEnum Constant", "description": "例如 adMovePrevious, adBookmark, adUpdate, adDelete, adHoldRecords, adResync。"}],
    "examples": [
        {"code": "Dim rs As Object ' ADODB.Recordset\n' ' Assume rs is an open recordset\n' ' Set rs = CreateObject(\"ADODB.Recordset\")\n' ' rs.Open \"SELECT * FROM Customers\", conn, adOpenKeyset, adLockOptimistic\n'\n' If Not rs Is Nothing And rs.State = 1 Then\n'   If rs.Supports(1) Then Debug.Print \"Recordset 支持 adHoldRecords.\" ' 1 = adHoldRecords\n'   If rs.Supports(2) Then Debug.Print \"Recordset 支持 adMovePrevious.\" ' 2 = adMovePrevious\n'   If rs.Supports(4) Then Debug.Print \"Recordset 支持 adUpdate.\" ' 4 = adUpdate\n'   If rs.Supports(8) Then Debug.Print \"Recordset 支持 adBookmark.\" ' 8 = adBookmark\n'   If rs.Supports(16) Then Debug.Print \"Recordset 支持 adApproxPosition.\" ' 16 = adApproxPosition (AbsolutePosition)\n'   ' You can combine flags: If rs.Supports(adUpdate Or adDelete) Then ...\n' Else\n'   Debug.Print \"Recordset 未打开或不支持 Supports 方法。\"\n' End If\n' ' If Not rs Is Nothing Then If rs.State = 1 Then rs.Close\n' ' Set rs = Nothing\nMsgBox \"(概念性) 演示了 Supports 方法。需有实际 Recordset。\"", "explanation": "演示如何使用 Recordset 的 `Supports` 方法来检查其是否支持某些操作，例如向后移动 (`adMovePrevious`) 或更新记录 (`adUpdate`)。这有助于在执行这些操作前确保它们不会导致错误。"}
    ],
    "keywords": ["adodb recordset supports", "cursoroptionenum", "check recordset capabilities", "贷後数据操作能力检查", "Recordset功能检测"]
},
{
    "name": "MSXML2.DOMDocument (getAttribute / setAttribute for XML Nodes)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "对于 IXMLDOMElement 类型的节点，可以使用 `.getAttribute(name)` 方法获取其属性值，使用 `.setAttribute(name, value)` 方法设置或创建属性及其值。",
    "syntax": "attrValue = xmlElement.getAttribute(\"AttributeName\")\nxmlElement.setAttribute \"AttributeName\", \"NewValue\"",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object, bookNode As Object ' IXMLDOMElement\nDim xmlStr As String\nxmlStr = \"<catalog><book id='bk101' genre='Fiction'><title>XML Guide</title></book></catalog>\"\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\nxmlDoc.LoadXML xmlStr\nIf xmlDoc.parseError.errorCode = 0 Then\n    Set bookNode = xmlDoc.selectSingleNode(\"//book[@id='bk101']\")\n    If Not bookNode Is Nothing Then\n        Dim genreAttr As String, langAttr As String\n        genreAttr = bookNode.getAttribute(\"genre\") ' Get existing attribute\n        Debug.Print \"Book bk101 - Genre: \" & genreAttr\n        \n        bookNode.setAttribute \"language\", \"EN\" ' Set (or create) new attribute\n        langAttr = bookNode.getAttribute(\"language\")\n        Debug.Print \"Book bk101 - Language (newly set): \" & langAttr\n        Debug.Print \"Updated XML for book: \" & bookNode.XML\n    End If\nElse\n    Debug.Print \"XML Error: \" & xmlDoc.parseError.reason\nEnd If\nSet xmlDoc = Nothing: Set bookNode = Nothing", "explanation": "载入一个包含带属性的 `book` 元素的XML。它首先使用 `getAttribute` 获取 `genre` 属性的值。然后，使用 `setAttribute` 添加一个新的 `language` 属性并为其赋值，再次用 `getAttribute` 读取新属性，最后打印更新后的 `book` 节点的XML。"}
    ],
    "keywords": ["msxml getattribute", "msxml setattribute", "xml node attribute manipulation", "贷後XML属性读写", "读写XML节点属性"]
},
{
    "name": "Range.Hyperlinks(Index).ScreenTip / .TextToDisplay (Excel)",
    "category": "Excel 核心操作",
    "description": "可以存取和修改现有超链接的 ScreenTip (鼠标悬停时显示的提示) 和 TextToDisplay (单元格中显示的文本) 属性。",
    "syntax": "Range(\"A1\").Hyperlinks(1).ScreenTip = \"New Tooltip Text\"\nRange(\"A1\").Hyperlinks(1).TextToDisplay = \"Click Here for Report\"",
    "parameters": [],
    "examples": [
        {"code": "ActiveSheet.Hyperlinks.Add Anchor:=Range(\"C5\"), Address:=\"http://www.bankwebsite.com\", TextToDisplay:=\"银行网站\"\nIf Range(\"C5\").Hyperlinks.Count > 0 Then\n  With Range(\"C5\").Hyperlinks(1)\n    .ScreenTip = \"点击访问银行官方网站获取最新贷后政策。\"\n    .TextToDisplay = \"银行贷后政策官网\"\n  End With\n  MsgBox \"C5单元格的超链接提示和显示文本已更新。\"\nEnd If", "explanation": "在C5单元格创建一个超链接，然后修改其 ScreenTip (屏幕提示) 和 TextToDisplay (显示文本) 属性。"}
    ],
    "keywords": ["excel hyperlink screentip", "hyperlink texttodisplay", "modify hyperlink properties", "贷後链接提示修改", "更新超链接文本"]
},
{
    "name": "PivotTable.PageFields(IndexOrName).CurrentPage (Set Filter)",
    "category": "Excel 資料分析與樞紐",
    "syntax": "pivotTableObject.PageFields(IndexOrName).CurrentPage = \"ItemNameToFilterBy\"",
    "description": "通过设置 PivotTable 的页面/筛选字段 (PageField) 的 CurrentPage 属性，可以筛选该字段以仅显示特定项目的数据。这会更新数据透视表的显示。",
    "parameters": [
        {"name": "IndexOrName", "description": "页面字段的名称或索引。"},
        {"name": "ItemNameToFilterBy", "description": "要筛选的页面字段中的项目名称。"}
    ],
    "examples": [
        {"code": "Dim pt As PivotTable, pfRegion As PivotField\n' Set pt = ActiveSheet.PivotTables(\"LoanRiskSummary\")\n' On Error Resume Next ' If field or item doesn't exist\n' Set pfRegion = pt.PageFields(\"客户区域\") ' Assume '客户区域' is a Page Field\n' If Not pfRegion Is Nothing Then\n'   pfRegion.CurrentPage = \"华东区\" ' Filter to show only '华东区'\n'   If Err.Number = 0 Then\n'     MsgBox \"数据透视表已按 '客户区域' 筛选为 '华东区'。\"\n'   Else\n'     MsgBox \"设置页面筛选失败 (可能项目 '华东区' 不存在或字段不是页面字段)。 错误: \" & Err.Description\n'   End If\n' Else\n'   MsgBox \"未找到 '客户区域' 页面字段。\"\n' End If\n' On Error GoTo 0", "explanation": "假设活动工作表上有一个名为 'LoanRiskSummary' 的数据透视表，并且它有一个名为 '客户区域' 的页面/筛选字段。此代码尝试将该字段的当前页面设置为 '华东区'，从而筛选数据透视表以仅显示该区域的数据。"}
    ],
    "keywords": ["excel pivottable pagefield filter", "set currentpage pivot filter", "贷後报告按区域筛选", "筛选数据透视表页面"]
},
// Word Document Processing
{
    "name": "ContentControl.Type Property (Word - Check Type before Accessing Specifics)",
    "category": "Word 文件處理",
    "description": "在访问内容控制项的特定属性或方法（例如，DatePicker的.DateDisplayFormat，DropDownList的.DropdownListEntries）之前，应先检查其 .Type 属性，以确保它是期望的控制项类型，从而避免运行时错误。",
    "parameters": [],
    "examples": [
        {"code": "Dim cc As Object ' Word.ContentControl\n' For Each cc In ActiveDocument.ContentControls\n'   Select Case cc.Type\n'     Case wdContentControlDate ' Date Picker\n'       Debug.Print \"日期选择器: \" & cc.Title & \", 当前日期格式: \" & cc.DateDisplayFormat\n'       ' cc.Range.Text = Format(Date, \"yyyy-mm-dd\") ' Set date if needed\n'     Case wdContentControlDropdownList ' Dropdown List\n'       Debug.Print \"下拉列表: \" & cc.Title & \", 有 \" & cc.DropdownListEntries.Count & \" 个选项。\"\n'       If cc.DropdownListEntries.Count > 0 Then cc.Range.Text = cc.DropdownListEntries(1).Text ' Select first item\n'     Case wdContentControlText, wdContentControlRichText ' Text Controls\n'       Debug.Print \"文本控制项: \" & cc.Title & \", 内容: \" & cc.Range.Text\n'     Case Else\n'       Debug.Print \"其他类型控制项: \" & cc.Title & \", 类型ID: \" & cc.Type\n'   End Select\n' Next cc\nMsgBox \"(概念性) 演示了检查内容控制项类型并访问特定属性。\"", "explanation": "遍历活动文档中的所有内容控制项。使用 Select Case 语句根据每个内容控制项的 .Type 属性来执行不同的操作，例如读取日期选择器的日期格式，或获取下拉列表的选项数量。"}
    ],
    "keywords": ["word contentcontrol type check", "access content control properties by type", "贷後合同内容控制项处理", "检查控制项类型"]
},
// Outlook Mail & Item Management
{
    "name": "MailItem.MarkAsTask (Set Reminder and DueDate)",
    "category": "Outlook 郵件與項目管理",
    "description": "将邮件标记为任务时，除了使用 OlMarkInterval 设置提醒类别（如今天、明天），还可以进一步通过 MailItem 的 .TaskSubject, .TaskStartDate, .TaskDueDate, .ReminderSet, .ReminderTime 属性来精确控制生成的任务的细节。",
    "parameters": [],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem\n' ' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   olMail.MarkAsTask olMarkNextWeek ' Mark for follow-up next week\n'   olMail.TaskSubject = \"贷后跟进: \" & olMail.Subject\n'   olMail.TaskStartDate = Date + 7 ' Start task next week\n'   olMail.TaskDueDate = Date + 10 ' Due in 10 days\n'   olMail.ReminderSet = True\n'   olMail.ReminderTime = DateAdd(\"d\", 7, Date) + TimeValue(\"09:00:00\") ' Reminder on start date at 9 AM\n'   olMail.Save\n'   MsgBox \"邮件 '\" & olMail.Subject & \"' 已标记为详细的贷后跟进任务。\"\n' End If", "explanation": "将选定的邮件标记为下周跟进的任务，并自定义任务的主题、开始日期、截止日期以及提醒时间和日期。"}
    ],
    "keywords": ["outlook mailitem markastask details", "set task properties from email", "贷後邮件转任务", "详细任务标记"]
},
{
    "name": "NameSpace.GetDefaultFolder(olFolderSentMail).Items.Restrict (Find Sent Loan Approvals)",
    "category": "Outlook 郵件與項目管理",
    "description": "在“已发送邮件”文件夹中，使用 Restrict 方法根据特定条件（例如，收件人包含特定审批部门，主旨包含“贷款审批通过”和客户ID）查找已发送的贷款审批通知邮件，用于贷后核对或记录。",
    "parameters": [{"name": "Filter (DASL String)", "description": "用于筛选已发送邮件的DASL查询字符串。"}],
    "examples": [
        {"code": "Dim olNS As Object, olSentFolder As Object, filteredSentItems As Object, sentMail As Object\nDim clientIDToSearch As String: clientIDToSearch = \"CUST007\"\nDim approvalKeyword As String: approvalKeyword = \"贷款审批通过\"\nDim approvalDeptEmail As String: approvalDeptEmail = \"credit.approval@bank.com\"\n' Set olNS = Application.GetNamespace(\"MAPI\")\n' Set olSentFolder = olNS.GetDefaultFolder(olFolderSentMail)\n' Dim daslFilter As String\n' ' Filter for emails sent TO approvalDeptEmail (or CC/BCC), with specific subject parts\n' daslFilter = \"@SQL=(\"\"urn:schemas:httpmail:subject\"\" LIKE '%\" & approvalKeyword & \"%\" & _\n'             \" AND \"\"urn:schemas:httpmail:subject\"\" LIKE '%\" & clientIDToSearch & \"%\" & _\n'             \" AND (\"\"urn:schemas:httpmail:to\"\" LIKE '%\" & approvalDeptEmail & \"%\" & _\n'             \" OR \"\"urn:schemas:httpmail:cc\"\" LIKE '%\" & approvalDeptEmail & \"%\" & _\n'             \" OR \"\"urn:schemas:httpmail:bcc\"\" LIKE '%\" & approvalDeptEmail & \"%\"))\"\n' Set filteredSentItems = olSentFolder.Items.Restrict(daslFilter)\n' Debug.Print \"--- 为客户 \" & clientIDToSearch & \" 找到的已发送审批邮件 ---\"\n' For Each sentMail In filteredSentItems\n'   Debug.Print \"主旨: \" & sentMail.Subject & \", 发送时间: \" & sentMail.SentOn\n' Next sentMail\n' If filteredSentItems.Count = 0 Then Debug.Print \"(未找到相关邮件)\"\n' MsgBox \"已在已发送邮件中搜索审批通知。\"", "explanation": "在“已发送邮件”文件夹中，搜索主旨包含“贷款审批通过”和特定客户ID，并且收件人（To, CC,或BCC）包含特定审批部门邮箱的邮件。这有助于贷后团队追踪审批通信。"}
    ],
    "keywords": ["outlook restrict sent items", "find sent emails by criteria", "贷後审批邮件追踪", "搜索已发送邮件"]
},
// PowerPoint 簡報製作
{
    "name": "Shapes.Range(Array).MergeShapes (PowerPoint 2010+)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set mergedShapeResult = slideObject.Shapes.Range(ArrayOfShapeNamesOrIndices).MergeShapes(MergeCmd As MsoMergeCmd, [PrimaryShape As PowerPoint.Shape])",
    "description": "对选定的一个或多个图执行合并操作（例如，联合、组合、拆分、相交、相减）。传回一个 Shape 对象，代表合并操作的结果。",
    "parameters": [
        {"name": "MergeCmd", "description": "MsoMergeCmd 常数，指定合并操作类型 (msoMergeUnion, msoMergeCombine, msoMergeFragment, msoMergeIntersect, msoMergeSubtract)。"},
        {"name": "PrimaryShape", "description": "可選。对于某些合并操作（如相减），指定作为主图的 Shape 对象。"}
    ],
    "examples": [
        {"code": "Dim sld As Object ' PowerPoint.Slide\nDim rect1 As Object, circle1 As Object ' PowerPoint.Shape\nDim merged As Object ' PowerPoint.Shape\n' Set sld = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, ppLayoutBlank)\n' Set rect1 = sld.Shapes.AddShape(msoShapeRectangle, 50, 50, 150, 100)\n' rect1.Name = \"MyRectForMerge\"\n' Set circle1 = sld.Shapes.AddShape(msoShapeOval, 100, 80, 120, 70)\n' circle1.Name = \"MyCircleForMerge\"\n' ' Select both shapes for merging\n' sld.Shapes.Range(Array(\"MyRectForMerge\", \"MyCircleForMerge\")).Select\n' ' Perform a Union merge on the selected shapes\n' Set merged = Selection.ShapeRange.MergeShapes(msoMergeUnion)\n' merged.Fill.ForeColor.RGB = RGB(100, 150, 250) ' Color the new merged shape\n' MsgBox \"已将矩形和椭圆联合成一个新图。\"", "explanation": "在新投影片上创建一个矩形和一个椭圆，然后选中这两个图，并使用 MergeShapes 方法的 `msoMergeUnion` 操作将它们合并成一个新的组合图。"}
    ],
    "keywords": ["powerpoint mergeshapes", "combine shapes ppt vba", "shape union subtract", "合并图PPT", "贷後流程图制作"]
},
{
    "name": "Presentation.EnsureAllMediaUpgraded (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "presentationObject.EnsureAllMediaUpgraded",
    "description": "确保简报中的所有媒体（音频、视频）都已升级到当前PowerPoint版本支持的最佳格式。这对于处理从旧版本Office迁移过来的简报，以确保媒体兼容性和播放性能非常有用。",
    "parameters": [],
    "examples": [
        {"code": "Dim pptPres As Object ' PowerPoint.Presentation\n' Set pptPres = ActivePresentation\n' On Error Resume Next ' This operation might not be needed or might fail in some contexts\n' pptPres.EnsureAllMediaUpgraded\n' If Err.Number = 0 Then\n'   MsgBox \"已尝试确保简报 '\" & pptPres.Name & \"' 中的所有媒体都已升级到最新格式。\"\n' Else\n'   MsgBox \"媒体升级过程中发生错误或此操作不适用: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "尝试升级活动简报中所有媒体对象的格式，以确保它们与当前PowerPoint版本的兼容性和性能最佳。"}
    ],
    "keywords": ["powerpoint ensureallmediaupgraded", "upgrade ppt media format", "贷後培训材料更新", "升级媒体格式PPT"]
},
// FileSystemObject (FSO)
{
    "name": "FileSystemObject.BuildPath (Handling Rooted Second Path)",
    "category": "檔案與資料夾管理",
    "description": "如果 `FileSystemObject.BuildPath(path1, path2)` 中的 `path2` 是一個絕對路徑 (例如，以磁碟機代號開頭 `C:\\...`)，則 `BuildPath` 會直接傳回 `path2`，忽略 `path1`。",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nDim basePath As String: basePath = \"C:\\MyBaseFolder\"\nDim relativeSub As String: relativeSub = \"SubFolder\\File.txt\"\nDim absoluteSub As String: absoluteSub = \"D:\\AnotherPlace\\OtherFile.txt\"\n\nDebug.Print \"BuildPath(base, relative): \" & fso.BuildPath(basePath, relativeSub) \n' Output: C:\\MyBaseFolder\\SubFolder\\File.txt\n\nDebug.Print \"BuildPath(base, absolute): \" & fso.BuildPath(basePath, absoluteSub) \n' Output: D:\\AnotherPlace\\OtherFile.txt (basePath is ignored)\nSet fso = Nothing", "explanation": "演示 BuildPath 方法在第二个参数是相对路径和绝对路径时的不同行为。如果第二个参数是绝对路径，则第一个参数被忽略。"}
    ],
    "keywords": ["fso buildpath absolute path", "path concatenation rules", "贷後文档路径组合", "BuildPath绝对路径"]
},
// String & Text Manipulation
{
    "name": "StrConv (vbUnicode and vbFromUnicode)",
    "category": "字串與文本操作",
    "description": "vbUnicode: 将字符串转换为Unicode格式 (主要用于与期望Unicode字节数组的API函数交互，或者当字符串可能包含需要特定Unicode处理的字符时)。\nvbFromUnicode: 将Unicode字节数组转换回VBA字符串。这通常与API函数返回Unicode字节数组的场景相关。在VBA内部，字符串已经是Unicode (UTF-16 LE)，所以这些转换更多是关于与其他系统或API的字节级表示的交互。",
    "parameters": [],
    "examples": [
        {"code": "Dim originalString As String: originalString = \"Hello 世界\"\nDim unicodeBytes() As Byte, convertedBackString As String\n\n' Convert VBA's internal Unicode string to a Byte array representation of Unicode (UTF-16LE)\n' Note: StrConv(str, vbUnicode) actually returns a String that *can be assigned* to a Byte array.\n' The byte array will contain the UTF-16LE bytes of the string.\nDim tempUnicodeStr As String\n' tempUnicodeStr = StrConv(originalString, vbUnicode) ' This step is often misunderstood.\n' Assigning a string to byte array directly does the conversion to ANSI typically.\n' For true byte representation of UTF-16:\nDim n As Long\nIf Len(originalString) > 0 Then\n    ReDim unicodeBytes(LenB(originalString) - 1)\n    For n = 0 To UBound(unicodeBytes)\n        unicodeBytes(n) = AscB(MidB(StrConv(originalString, vbUnicode), n + 1, 1))\n    Next n\n    ' This is more direct to get byte array of VBA's internal string:\n    ' unicodeBytes = StrConv(originalString, vbUnicode)\n    ' ^This is wrong: StrConv to vbUnicode, then assign to Byte array makes an ANSI representation of the Unicode code points if done directly.\n    ' Correct way to get byte representation of internal UTF-16:\n    Dim sTemp As String: sTemp = originalString\n    unicodeBytes = sTemp ' This assigns UTF-16LE bytes to the array.\n\n    Debug.Print \"原始字串: \" & originalString\n    Debug.Print \"转换后的Unicode字节数组长度: \" & UBound(unicodeBytes) + 1\n\n    ' Convert byte array (assumed to be UTF-16LE) back to VBA string\n    convertedBackString = StrConv(unicodeBytes, vbFromUnicode)\n    Debug.Print \"从Unicode字节数组转回的字串: \" & convertedBackString\nElse\n    Debug.Print \"原始字串为空。\"\nEnd If", "explanation": "演示如何将VBA内部的Unicode字符串转换为其字节数组表示（UTF-16LE，这是VBA字符串的内部格式），然后再使用`StrConv`的`vbFromUnicode`将其转换回VBA字符串。注意：直接使用 `StrConv(string, vbUnicode)` 返回的是一个可以被赋给字节数组的字符串，其字节内容是UTF-16LE。"}
    ],
    "keywords": ["strconv vbunicode", "strconv vbfromunicode", "string to unicode bytes", "unicode byte array to string", "贷後国际化文本处理", "Unicode转换"]
},
// Math, Date & Time
{
    "name": "WorksheetFunction.Days (Excel 2013+ - Calculate Loan Duration)",
    "category": "Excel 核心操作",
    "syntax": "durationInDays = Application.WorksheetFunction.Days(EndDate, StartDate)",
    "description": "使用Excel的DAYS函数 (Excel 2013+)，计算两个日期之间的天数。这对于精确计算贷款的实际存续天数很有用，尤其在需要按日计息或分析时。",
    "parameters": [
        {"name": "EndDate", "description": "结束日期。"},
        {"name": "StartDate", "description": "开始日期。"}
    ],
    "examples": [
        {"code": "Dim loanStartDate As Date: loanStartDate = DateSerial(2023, 1, 10)\nDim loanMaturityDate As Date: loanMaturityDate = DateSerial(2023, 4, 15)\nDim loanActualDays As Long\nOn Error Resume Next ' DAYS function might not be available in very old Excel versions\nloanActualDays = Application.WorksheetFunction.Days(loanMaturityDate, loanStartDate)\nIf Err.Number = 0 Then\n  MsgBox \"从 \" & Format(loanStartDate, \"yyyy-mm-dd\") & \" 到 \" & Format(loanMaturityDate, \"yyyy-mm-dd\") & \" 的贷款实际天数是: \" & loanActualDays & \" 天。\"\nElse\n  MsgBox \"无法使用DAYS函数 (可能Excel版本过旧)。\"\nEnd If\nOn Error GoTo 0", "explanation": "计算从2023年1月10日到2023年4月15日之间的总天数。"}
    ],
    "keywords": ["excel days function vba", "calculate days between dates", "贷後贷款实际天数", "DAYS函数计算"]
},
// Data Types, Conversion & Validation
{
    "name": "Val (Handling Non-Numeric Prefix/Suffix in Loan IDs)",
    "category": "資料類型、轉換與驗證",
    "syntax": "numericPartOfID = Val(LoanIDString)",
    "description": "在处理可能包含字母前缀或后缀的贷款合同号或客户ID（例如 \"LN00123\", \"CUST456AB\"）时，Val 函数可以从字符串的开头提取数字部分，直到遇到非数字字符。这有助于从混合字符串中分离出数字ID用于排序或查找。",
    "parameters": [
        {"name": "LoanIDString", "description": "包含字母和数字的贷款ID字符串。"}
    ],
    "examples": [
        {"code": "Dim contractNo1 As String: contractNo1 = \"LN00789X\"\nDim contractNo2 As String: contractNo2 = \"CUST-001-A\"\nDim contractNo3 As String: contractNo3 = \"987654\"\nDim numPart1 As Long, numPart2 As Long, numPart3 As Long\n\nnumPart1 = Val(contractNo1) ' Extracts leading numbers, so 0 if starts with LN\n' Correct approach for 'LN00789X' would be Mid(contractNo1, 3) then Val()\n' numPart1 = Val(Mid(contractNo1,3)) ' If prefix is always 2 chars\nDebug.Print \"Val(\"\"\" & contractNo1 & \"\"\") (after stripping prefix 'LN'): \" & Val(Replace(contractNo1,\"LN\",\"\")) ' Output depends on stripping\n\nnumPart2 = Val(contractNo2) ' Extracts leading numbers, so 0 if starts with CUST-\nDebug.Print \"Val(\"\"\" & contractNo2 & \"\"\") (after stripping prefix 'CUST-'): \" & Val(Mid(contractNo2,6)) ' Output: 1\n\nnumPart3 = Val(contractNo3)\nDebug.Print \"Val(\"\"\" & contractNo3 & \"\"\") = \" & numPart3 ' Output: 987654\n\nDim complexID As String: complexID = \"ACC456-Branch02\"\nDebug.Print \"Val(\"\"\" & complexID & \"\"\") = \" & Val(complexID) ' Output: 0\nDebug.Print \"Numeric part from '\" & complexID & \"' (after stripping ACC): \" & Val(Mid(complexID,4)) ' Output: 456", "explanation": "演示了Val函数在提取字符串中前导数字时的行为。如果字符串以非数字字符开头，Val返回0。对于“LN00789X”这类ID，需要先移除前缀“LN”，然后再用Val转换数字部分。对于“ACC456-Branch02”，Val(Mid(complexID,4)) 可以提取出456。"}
    ],
    "keywords": ["val function for mixed string", "extract number from loan id", "贷後ID数字提取", "Val解析ID"]
},
// Program Flow & Structure Control
{
    "name": "Looping Through Controls on a UserForm's MultiPage Page",
    "category": "Excel VBA 開發與表單",
    "syntax": "For Each ctrl In Me.MultiPage1.Pages(PageIndex).Controls\n  ' Process ctrl\nNext ctrl",
    "description": "遍歷UserForm上MultiPage控件的特定页面 (Page) 上的所有控件。这对于在贷后管理表单的不同部分（例如，客户基本信息页、财务数据页、风险评估页）统一处理数据或验证输入很有用。",
    "parameters": [
        {"name": "MultiPage1", "description": "MultiPage控件的名称。"},
        {"name": "PageIndex", "description": "要遍历其控件的页面的索引 (0-based)。"}
    ],
    "examples": [
        {"code": "' --- In UserForm 'ufLoanReview' Code Module ---\n' ' Assume MultiPage1 exists, and Page 0 has TextBoxes: txtIncome, txtAssets\n' Private Sub cmdValidatePage1_Click()\n'   Dim ctrl As MSForms.Control\n'   Dim pageToValidate As MSForms.Page\n'   Set pageToValidate = Me.MultiPage1.Pages(0) ' Validate first page\n'   Dim hasError As Boolean: hasError = False\n'\n'   For Each ctrl In pageToValidate.Controls\n'     If TypeOf ctrl Is MSForms.TextBox Then\n'       Dim txtBox As MSForms.TextBox: Set txtBox = ctrl\n'       If Trim(txtBox.Value) = \"\" Then\n'         MsgBox \"页面 '\" & pageToValidate.Caption & \"' 上的欄位 '\" & txtBox.Name & \"' 不能为空！\", vbExclamation\n'         txtBox.SetFocus\n'         hasError = True\n'         Exit For\n'       End If\n'       If Not IsNumeric(txtBox.Value) And (txtBox.Name = \"txtIncome\" Or txtBox.Name = \"txtAssets\") Then\n'           MsgBox \"欄位 '\" & txtBox.Name & \"' 必須为数字！\", vbExclamation\n'           txtBox.SetFocus\n'           hasError = True\n'           Exit For\n'       End If\n'     End If\n'   Next ctrl\n'   If Not hasError Then MsgBox \"页面 '\" & pageToValidate.Caption & \"' 的基本验证通过。\"\n' End Sub", "explanation": "cmdValidatePage1_Click 过程遍历MultiPage1控件的第一个页面 (索引0) 上的所有控件。如果控件是TextBox，它会检查其是否为空或（对于特定命名的文本框）是否为数字。"}
    ],
    "keywords": ["userform multipage controls loop", "iterate controls on page", "贷後多页表单验证", "遍历MultiPage页面控件"]
},
// External Interaction (Web, DB, OS)
{
    "name": "ADODB.Recordset (Clone Method for Multiple Pointers)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 `Clone` 方法创建一个与原始 Recordset 具有相同书签的重复 Recordset 对象。这意味着两个 Recordset 最初指向同一条记录，但可以独立移动它们的记录指针。这在需要同时维护对同一数据集的不同视图或位置时非常有用，例如，在一个循环中查找主记录，在另一个（克隆的）Recordset 中查找其关联记录。两个 Recordset 共享相同的底层数据，对一个 Recordset 中数据的更改（如果可更新）会反映在另一个中。",
    "syntax": "Set rsClone = rsOriginal.Clone([LockType As LockTypeEnum = adLockUnspecified])",
    "parameters": [{"name": "LockType", "description": "可選。指定克隆 Recordset 的鎖定類型。預設為 adLockUnspecified (通常繼承原始的)。"}],
    "examples": [
        {"code": "Dim conn As Object, rsMain As Object, rsDetail As Object\n' ' Assume conn is an open ADODB.Connection to a database with Orders and OrderDetails tables\n' Set rsMain = CreateObject(\"ADODB.Recordset\")\n' rsMain.CursorLocation = 3 ' adUseClient for Clone to work reliably with some providers\n' rsMain.Open \"SELECT OrderID, CustomerID, OrderDate FROM Orders WHERE CustomerID = 'ALFKI'\", conn, 3, 1 ' adOpenStatic, adLockReadOnly\n'\n' If Not rsMain.EOF Then\n'   Debug.Print \"--- 主訂單 (來自 rsMain) ---\"\n'   Do While Not rsMain.EOF\n'     Dim currentOrderID As Variant: currentOrderID = rsMain!OrderID\n'     Debug.Print \"OrderID: \" & currentOrderID & \", Date: \" & rsMain!OrderDate\n'\n'     ' Clone the main recordset to find details for the current order\n'     ' Or better, open a new recordset for details to avoid issues with complex main recordsets.\n'     ' This clone example is more for showing independent navigation on same *initial* dataset.\n'     ' For master-detail, usually a separate parameterized query for details is better.\n'     ' Set rsDetail = CreateObject(\"ADODB.Recordset\")\n'     ' rsDetail.Open \"SELECT ProductName, Quantity FROM [Order Details] WHERE OrderID = \" & currentOrderID, conn, 0, 1\n'     ' While Not rsDetail.EOF\n'     '    Debug.Print \"    Detail: \" & rsDetail!ProductName & \" - Qty: \" & rsDetail!Quantity\n'     '    rsDetail.MoveNext\n'     ' Wend\n'     ' rsDetail.Close\n'     rsMain.MoveNext\n'   Loop\n' Else\n'   Debug.Print \"未找到客戶ALFKI的訂單。\"\n' End If\n' If rsMain.State = 1 Then rsMain.Close\n' Set rsMain = Nothing: Set rsDetail = Nothing\n' ' If conn.State = 1 Then conn.Close: Set conn = Nothing\nMsgBox \"(概念性) 演示了Recordset.Clone，但對於主從關係，通常使用參數化查詢更佳。\"", "explanation": "此範例概念性地說明了 `Clone` 方法。在實際的主從報表或資料處理中，更常見的做法是為詳細資料部分執行一個新的、基於主記錄ID的參數化查詢，而不是克隆主記錄集來尋找詳細資料。Clone 更適用於當您需要對完全相同的結果集進行多次獨立遍歷或定位時。"}
    ],
    "keywords": ["adodb recordset clone", "duplicate recordset pointer", "贷後主從數據處理", "克隆記錄集"]
},
{
    "name": "MSXML2.DOMDocument (Iterate ChildNodes and Attributes)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "遍歷 XML 节点的 `childNodes` 集合以访问其所有子节点，并可以访问每个元素子节点的 `attributes` 集合以获取其属性。",
    "syntax": "For Each child In parentNode.childNodes\n  If child.nodeType = 1 Then ' NODE_ELEMENT\n    For Each attr In child.attributes\n      ' Process attribute (attr.name, attr.value)\n    Next attr\n  End If\nNext child",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object, rootElem As Object, elem As Object, attr As Object\nDim xmlString As String\nxmlString = \"<LoanApplication ClientID='C001' Status='Pending'>\" & _\n            \"  <Applicant Name='John Doe' Age='35'/>\" & _\n            \"  <LoanDetails Amount='50000' TermMonths='60' Purpose='Vehicle'/>\" & _\n            \"  <Collateral Type='Property' Value='75000'/>\" & _\n            \"</LoanApplication>\"\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False\nxmlDoc.LoadXML xmlString\nIf xmlDoc.parseError.errorCode = 0 Then\n    Set rootElem = xmlDoc.documentElement ' LoanApplication\n    Debug.Print \"根節點: \" & rootElem.nodeName\n    For Each elem In rootElem.childNodes ' Applicant, LoanDetails, Collateral\n        If elem.nodeType = 1 Then ' If it's an Element node (NODE_ELEMENT = 1)\n            Debug.Print \"  子元素: \" & elem.nodeName\n            If elem.hasAttributes Then\n                For Each attr In elem.Attributes\n                    Debug.Print \"    屬性: \" & attr.Name & \" = '\" & attr.Value & \"'\"\n                Next attr\n            End If\n        End If\n    Next elem\nElse\n    Debug.Print \"XML解析錯誤: \" & xmlDoc.parseError.reason\nEnd If\nSet xmlDoc = Nothing: Set rootElem = Nothing: Set elem = Nothing: Set attr = Nothing", "explanation": "载入一个包含贷款申请信息的XML字符串。然后，它遍历根元素（`LoanApplication`）的所有子元素（`Applicant`, `LoanDetails`, `Collateral`）。对于每个子元素，它会打印其名称，并进一步遍历和打印该元素的所有属性及其值。"}
    ],
    "keywords": ["msxml iterate childnodes attributes", "xml dom traversal", "read xml attributes vba", "贷後XML数据解析", "遍历XML节点属性"]
},
{
    "name": "Range.ClearContents (vs .Clear vs .ClearFormats vs .ClearComments)",
    "category": "Excel 核心操作",
    "description": "Range物件的清除方法：\n.ClearContents: 仅清除儲存格的内容 (值和公式)，保留格式和註解。\n.ClearFormats: 仅清除儲存格的格式，保留内容和註解。\n.ClearComments: (Excel 2016 及更早版本主要指旧版註解/附註) 清除儲存格的註解/附註，保留内容和格式。\n.ClearHyperlinks: 移除超連結，但保留儲存格显示的文字和格式。\n.Clear: 清除儲存格的所有内容、格式和註解 (等同于在UI中选择“全部清除”)。",
    "parameters": [],
    "examples": [
        {"code": "Range(\"A1\").Value = \"=1+1\": Range(\"A1\").Font.Bold = True: Range(\"A1\").AddComment \"Test\"\n' Range(\"B1\").Value = \"Data\": Range(\"B1\").ClearContents ' B1 becomes empty, format remains\n' Range(\"C1\").Value = \"Format\": Range(\"C1\").Interior.Color=vbYellow: Range(\"C1\").ClearFormats ' C1 text remains, yellow gone\n' Range(\"D1\").Value = \"Comment\": Range(\"D1\").AddComment \"Temp\": Range(\"D1\").ClearComments ' D1 text remains, comment gone\n' Range(\"E1\").Value = \"All Gone\": Range(\"E1\").Font.Italic=True: Range(\"E1\").Clear ' E1 empty, no italic\nMsgBox \"(概念性) 演示了不同的Range.Clear*方法。请取消註解并分别测试。\"", "explanation": "概念性地展示了 `ClearContents`, `ClearFormats`, `ClearComments`, 和 `Clear` 之间的区别。实际测试时，可以取消註解各行并观察效果。"}
    ],
    "keywords": ["range clear methods", "clearcontents vs clearformats", "excel clear cell parts", "清除儲存格不同部分"]
},
{
    "name": "Worksheet.PageSetup (Margins, Orientation, PaperSize for Loan Docs)",
    "category": "Excel 核心操作",
    "syntax": "With worksheetObject.PageSetup\n  .LeftMargin = Application.InchesToPoints(0.75)\n  .Orientation = xlLandscape\n  .PaperSize = xlPaperA4\nEnd With",
    "description": "使用 PageSetup 物件設定工作表的列印頁面屬性，如邊界、頁面方向 (纵向/横向)、纸张大小。这在自动生成标准格式的贷后报告（例如，要打印的客户对账单、风险摘要）时非常重要。",
    "parameters": [
        {"name": ".LeftMargin, .RightMargin, .TopMargin, .BottomMargin", "description": "设定页边距 (以点为单位)。"},
        {"name": ".HeaderMargin, .FooterMargin", "description": "设定页首/页脚边距。"},
        {"name": ".Orientation", "description": "XlPageOrientation 常数 (xlPortrait, xlLandscape)。"},
        {"name": ".PaperSize", "description": "XlPaperSize 常数 (例如 xlPaperA4, xlPaperLetter)。"},
        {"name": ".Zoom", "description": "缩放比例 (百分比) 或 False (表示使用 FitToPagesTall/Wide)。"},
        {"name": ".FitToPagesTall / .FitToPagesWide", "description": "将打印输出缩放到指定的页高/页宽。"}
    ],
    "examples": [
        {"code": "Dim wsReport As Worksheet\n' Set wsReport = ThisWorkbook.Sheets(\"LoanSummaryReport\")\n' With wsReport.PageSetup\n'   .Orientation = xlLandscape ' 横向\n'   .PaperSize = xlPaperA4      ' A4纸\n'   .LeftMargin = Application.InchesToPoints(0.5)\n'   .RightMargin = Application.InchesToPoints(0.5)\n'   .TopMargin = Application.InchesToPoints(0.75)\n'   .BottomMargin = Application.InchesToPoints(0.75)\n'   .HeaderMargin = Application.InchesToPoints(0.3)\n'   .FooterMargin = Application.InchesToPoints(0.3)\n'   .CenterHorizontally = True\n'   .CenterVertically = False\n'   .PrintGridlines = False\n'   .PrintHeadings = False ' 不打印行号列标\n'   .PrintArea = \"A1:H50\" ' 设置打印区域\n' End With\n' MsgBox \"工作表 '\" & wsReport.Name & \"' 的页面设置已更新，适合打印贷后摘要。\"", "explanation": "为名为 'LoanSummaryReport' 的工作表设置页面为横向A4纸，调整页边距，设定打印时水平居中，不打印网格线和行列标题，并指定了打印区域。"}
    ],
    "keywords": ["excel pagesetup vba", "set print margins orientation", "fit to page", "贷後报告打印设置", "页面布局"]
},
{
    "name": "ListObject.AutoFilter.ApplyFilter (Excel Table Filter by Code)",
    "category": "Excel 核心操作",
    "syntax": "listObject.AutoFilter.ApplyFilter",
    "description": "在清除了 ListObject 的 AutoFilter 上的任何现有筛选后，重新应用所有列筛选器。如果之前没有对 ListObject.Range 使用 AutoFilter 方法来建立筛选器，或者 AutoFilter 对象本身没有设置任何筛选条件，则此方法可能效果不明显或出错。通常在以编程方式修改了多个 ListColumn 的筛选条件后，用于一次性应用所有这些更改。",
    "parameters": [],
    "examples": [
        {"code": "Dim tbl As ListObject\nDim lcRisk As ListColumn, lcStatus As ListColumn\n' Set tbl = ActiveSheet.ListObjects(\"ClientPortfolioTable\")\n' If Not tbl Is Nothing Then\n'   ' Clear any existing table filters first\n'   If tbl.AutoFilter.FilterMode Then tbl.AutoFilter.ShowAllData\n'\n'   ' Set criteria for multiple columns (conceptual, actual setting is via Range.AutoFilter on table's range)\n'   ' This example assumes filters were *already defined* or being set on the Range, then ApplyFilter refreshes.\n'   ' More typically, you'd apply filters to the table's .Range object directly:\n'   ' tbl.Range.AutoFilter Field:=tbl.ListColumns(\"RiskRating\").Index, Criteria1:=\"High\"\n'   ' tbl.Range.AutoFilter Field:=tbl.ListColumns(\"LoanStatus\").Index, Criteria1:=\"Active\"\n'   ' After setting individual column filters on tbl.Range, ApplyFilter might be used,\n'   ' but often the direct .Range.AutoFilter calls are sufficient to apply.\n'\n'   ' If you've programmatically built up a filter on the AutoFilter object of the ListObject itself:\n'   ' (This is less common than filtering the .Range)\n'   ' With tbl.AutoFilter.Filters\n'   '    .Item(tbl.ListColumns(\"RiskRating\").Index).Criteria1 = \"High\"\n'   '    .Item(tbl.ListColumns(\"LoanStatus\").Index).Criteria1 = \"Active\"\n'   ' End With\n'   ' tbl.AutoFilter.ApplyFilter ' Apply the filter defined on the AutoFilter object\n'\n'   MsgBox \"(概念性) ApplyFilter用于应用在ListObject.AutoFilter对象上定义的筛选。更常用的是对Table.Range进行AutoFilter。\"\n' End If", "explanation": "ListObject.AutoFilter.ApplyFilter 用于应用已在 ListObject 的 AutoFilter 对象上定义的筛选条件。更常见的是直接对表格的数据范围 (`ListObject.Range`) 使用 `.AutoFilter` 方法来指定和应用筛选条件。如果筛选器已设置，`ApplyFilter` 可以用来刷新或重新应用它们。"}
    ],
    "keywords": ["excel listobject autofilter applyfilter", "filter excel table vba", "贷後表格筛选应用", "程序化筛选表格"]
},
// Word 文件處理
{
    "name": "Document.MailMerge.Fields.Add (Add MergeField to Word Doc)",
    "category": "Word 文件處理",
    "syntax": "Set mf = mainDocument.MailMerge.Fields.Add(Range:=selectionRange, Name:=\"DataSourceFieldName\")",
    "description": "在Word邮件合并主文档的指定范围插入一个MERGEFIELD域。Name 参数对应于附加的数据源中的字段（列）名。",
    "parameters": [
        {"name": "Range", "description": "要插入合并域的Word文档中的Range对象。"},
        {"name": "Name", "description": "数据源中的字段（列）名称。"}
    ],
    "examples": [
        {"code": "Dim wdMainDoc As Object ' Word.Document (Mail Merge Main Document)\nDim selRange As Object ' Word.Range\n' ' Assume wdMainDoc is the active main document with a data source attached.\n' Set wdMainDoc = ActiveDocument\n' Set selRange = Selection.Range ' User selects where to insert the merge field\n'\n' If wdMainDoc.MailMerge.State = wdMainAndDataSource Or wdMainDoc.MailMerge.State = wdMainAndSourceAndHeader Then\n'   Dim mergeFieldName As String: mergeFieldName = \"Client_Name\" ' Must match a field name in data source\n'   On Error Resume Next\n'   Dim newMergeField As Object ' Word.MailMergeField\n'   Set newMergeField = wdMainDoc.MailMerge.Fields.Add(Range:=selRange, Name:=mergeFieldName)\n'   If Err.Number = 0 And Not newMergeField Is Nothing Then\n'     MsgBox \"邮件合并域 '\" & mergeFieldName & \"' 已插入到选定位置。\"\n'     ' newMergeField.Code.Text will be like \" MERGEFIELD Client_Name \"\n'   Else\n'     MsgBox \"插入合并域 '\" & mergeFieldName & \"' 失败。请确保数据源已连接且字段名正确。错误: \" & Err.Description\n'   End If\n'   On Error GoTo 0\n' Else\n'   MsgBox \"请先为文件附加邮件合并数据源。\"\n' End If", "explanation": "如果活动文档已连接了邮件合并数据源，则在用户当前选择的位置插入一个名为“Client_Name”的合并域（假设“Client_Name”是数据源中的一个有效列名）。"}
    ],
    "keywords": ["word mailmerge add field", "insert mergefield vba", "贷後通知函合并域", "邮件合并字段插入"]
},
{
    "name": "ContentControl.Delete (Word Content Control)",
    "category": "Word 文件處理",
    "syntax": "contentControlObject.Delete([DeleteContents As Boolean = False])",
    "description": "从文档中删除指定的内容控制项。可以选择是否同时删除控制项的内。",
    "parameters": [
        {"name": "DeleteContents", "description": "可選。True 表示同时删除内容控制项的内。False (预设) 表示只删除控制项本身，保留其内容在文档中。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, ccToDelete As Object ' Word.ContentControl\n' Set wdDoc = ActiveDocument\n' ' Assume a content control with Tag = \"ObsoleteSection\" exists\n' On Error Resume Next\n' Set ccToDelete = wdDoc.SelectContentControlsByTag(\"ObsoleteSection\").Item(1)\n' If Not ccToDelete Is Nothing Then\n'   If MsgBox(\"是否要删除内容控制项 '\" & ccToDelete.Title & \"' 及其内容？\", vbYesNo) = vbYes Then\n'     ccToDelete.Delete DeleteContents:=True\n'   Else\n'     ccToDelete.Delete DeleteContents:=False\n'   End If\n'   MsgBox \"内容控制项已处理。\"\n' Else\n'   MsgBox \"未找到标签为 'ObsoleteSection' 的内容控制项。\"\n' End If\n' On Error GoTo 0", "explanation": "通过标签查找一个内容控制项。如果找到，则根据用户选择删除该内容控制项（及其内容或仅控制项本身）。"}
    ],
    "keywords": ["word contentcontrol delete", "remove content control", "删除内容控制项", "贷後合同模板清理"]
},
// Outlook 郵件與項目管理
{
    "name": "MailItem.PropertyAccessor.GetProperty (Read X-Headers)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "xHeaderValue = mailItem.PropertyAccessor.GetProperty(\"http://schemas.microsoft.com/mapi/string/{00020386-0000-0000-C000-000000000046}/X-CustomHeaderName\")",
    "description": "使用 PropertyAccessor 的 GetProperty 方法，配合正确的MAPI命名空间URI，可以读取邮件的X-Headers（自定义邮件头）。这对于分析来自特定系统（如CRM、风险系统）的邮件，这些系统可能在邮件头中嵌入了用于追踪或分类的自定义信息，非常有用。",
    "parameters": [
        {"name": "SchemaName for X-Header", "description": "通常格式为 `http://schemas.microsoft.com/mapi/string/{00020386-0000-0000-C000-000000000046}/X-Header-Name`，其中 `X-Header-Name` 是实际的自定义头名称。"}
    ],
    "examples": [
        {"code": "Dim olMail As Object ' Outlook.MailItem, assume selected\nDim pa As Object     ' Outlook.PropertyAccessor\nDim riskSystemID As String, clientSegment As String\n' ' Set olMail = Application.ActiveExplorer.Selection.Item(1)\n' If TypeName(olMail) = \"MailItem\" Then\n'   Set pa = olMail.PropertyAccessor\n'   On Error Resume Next ' Header might not exist\n'   riskSystemID = pa.GetProperty(\"http://schemas.microsoft.com/mapi/string/{00020386-0000-0000-C000-000000000046}/X-RiskSystem-AlertID\")\n'   clientSegment = pa.GetProperty(\"http://schemas.microsoft.com/mapi/string/{00020386-0000-0000-C000-000000000046}/X-Client-Segment\")\n'   If Err.Number = 0 Then\n'     Debug.Print \"邮件 '\" & olMail.Subject & \"' 的自定义头信息:\"\n'     If riskSystemID <> \"\" Then Debug.Print \"  X-RiskSystem-AlertID: \" & riskSystemID\n'     If clientSegment <> \"\" Then Debug.Print \"  X-Client-Segment: \" & clientSegment\n'   Else\n'     Debug.Print \"读取邮件 '\" & olMail.Subject & \"' 的自定义头失败或部分失败。\"\n'   End If\n'   On Error GoTo 0\n' Else\n'   MsgBox \"请选择一封邮件。\"\n' End If\n' Set pa = Nothing: Set olMail = Nothing", "explanation": "如果选中的是一封邮件，此代码尝试使用 PropertyAccessor 读取两个自定义的X-Header：“X-RiskSystem-AlertID” 和 “X-Client-Segment”。这些信息可以用于贷后系统对邮件的自动分类或数据关联。"}
    ],
    "keywords": ["outlook propertyaccessor x-header", "read custom email headers vba", "贷後邮件自定义头读取", "MAPI X-Header"]
},
{
    "name": "ContactItem.AddPicture (Outlook Contact Photo)",
    "category": "Outlook 郵件與項目管理",
    "syntax": "contactItemObject.AddPicture(Path As String)",
    "description": "将指定的图片文件作为联系人的照片添加到 Outlook 联系人项目中。如果联系人已有照片，则此方法会替换现有照片。",
    "parameters": [
        {"name": "Path", "description": "必需。图片文件的完整路径 (例如 .jpg, .png, .gif, .bmp)。"}
    ],
    "examples": [
        {"code": "Dim olContact As Object ' Outlook.ContactItem\nDim photoPath As String: photoPath = \"C:\\ClientPhotos\\JohnDoe.jpg\" ' **替换为实际图片路径**\n' ' Assume olContact is an existing ContactItem for John Doe\n' ' Set olContact = Application.GetNamespace(\"MAPI\").GetDefaultFolder(olFolderContacts).Items(\"Doe, John\")\n' If Not olContact Is Nothing Then\n'   If Dir(photoPath) <> \"\" Then\n'     On Error Resume Next\n'     olContact.AddPicture photoPath\n'     If Err.Number = 0 Then\n'       olContact.Save\n'       MsgBox \"已为联系人 '\" & olContact.FullName & \"' 添加/更新照片。\"\n'     Else\n'       MsgBox \"添加照片失败: \" & Err.Description\n'     End If\n'     On Error GoTo 0\n'   Else\n'     MsgBox \"照片文件未找到: \" & photoPath\n'   End If\n' Else\n'   MsgBox \"未找到指定的联系人。\"\n' End If", "explanation": "如果联系人“Doe, John”存在，并且指定的照片文件也存在，则此代码将该照片添加为联系人的头像照片，并保存联系人。"}
    ],
    "keywords": ["outlook contact addpicture", "set contact photo vba", "贷後客户照片管理", "联系人头像"]
},
// PowerPoint 簡報製作
{
    "name": "Slide.ApplyThemeColorScheme (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "slideObject.ApplyThemeColorScheme(themeColorSchemeName As String)",
    "description": "将指定的主题颜色方案应用于单个投影片。主题颜色方案是简报主题的一部分，定义了一组协调的颜色。",
    "parameters": [
        {"name": "themeColorSchemeName", "description": "必需。主题颜色方案的名称 (例如，在“设计”选项卡 -> “变体” -> “颜色”中看到的方案名称)。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object ' PowerPoint.Slide\nDim targetColorScheme As String\n' Set pptSlide = ActivePresentation.Slides(1)\n' ' List available color schemes for the current design (conceptual)\n' ' Dim des As Design: Set des = pptSlide.Design\n' ' For Each cs In des.Theme.ThemeColorSchemes: Debug.Print cs.Name: Next cs\n'\n' targetColorScheme = \"Office\" ' Default Office color scheme, or another specific name\n' On Error Resume Next ' Scheme name might be incorrect or not available\n' pptSlide.ApplyThemeColorScheme targetColorScheme\n' If Err.Number = 0 Then\n'   MsgBox \"已将主题颜色方案 '\" & targetColorScheme & \"' 应用于第一张投影片。\"\n' Else\n'   MsgBox \"应用颜色方案 '\" & targetColorScheme & \"' 失败: \" & Err.Description\n' End If\n' On Error GoTo 0", "explanation": "尝试将名为“Office”的主题颜色方案（通常是默认方案）应用于当前简报的第一张投影片。"}
    ],
    "keywords": ["powerpoint applythemecolorscheme", "change slide color scheme", "贷後报告PPT配色", "应用主题颜色方案"]
},
{
    "name": "Shape.AnimationSettings Property (PowerPoint - Legacy Animation)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set animSettings = shapeObject.AnimationSettings",
    "description": "传回一个 AnimationSettings 对象，代表指定图的旧版动画效果设置。对于较新版本PowerPoint (2007+)，推荐使用 Slide.TimeLine 对象来处理更高级的动画。",
    "parameters": [
        {"name": ".EntryEffect", "description": "PpEntryEffect 常数，设置进入动画效果。"},
        {"name": ".AdvanceMode", "description": "ppAdvanceOnClick 或 ppAdvanceOnTime。"},
        {"name": ".AdvanceTime", "description": "如果 AdvanceMode 是 ppAdvanceOnTime，则为自动切换的时间 (秒)。"},
        {"name": ".TextLevelEffect", "description": "PpTextLevelEffect，文本动画方式 (例如，按段落)。"}
    ],
    "examples": [
        {"code": "Dim shp As Object ' PowerPoint.Shape (e.g., a text box)\nDim anim As Object ' PowerPoint.AnimationSettings\n' Set shp = ActivePresentation.Slides(1).Shapes.AddTextbox(msoTextOrientationHorizontal, 50, 100, 400, 50)\n' shp.TextFrame.TextRange.Text = \"旧版动画效果演示\"\n' Set anim = shp.AnimationSettings\n' With anim\n'   .EntryEffect = ppEffectFlyFromLeft ' 5 = 飞入，从左侧\n'   .AdvanceMode = ppAdvanceOnClick\n'   .Animate = msoTrue ' Activate the animation setting\n'   ' For text within shape:\n'   .AnimateTextInReverse = False\n'   .TextLevelEffect = ppAnimateByFirstLevel\n' End With\n' MsgBox \"已为文本框设置旧版飞入动画效果。\"", "explanation": "为一个新创建的文本框设置旧版的“从左侧飞入”进入动画效果，并设定为单击时播放。"}
    ],
    "keywords": ["powerpoint animationsettings", "legacy animation ppt", "ppentryeffect", "贷後演示旧动画", "旧版动画设置"]
},
// FileSystemObject (FSO)
{
    "name": "FileSystemObject.GetFolder (Recursive Folder Size)",
    "category": "檔案與資料夾管理",
    "description": "Folder 对象的 .Size 属性会递归地计算该文件夹内所有文件和所有子文件夹（及其内容）的总大小（以字节为单位）。这对于评估客户提交的资料包或项目文件夹的总磁盘占用非常有用。",
    "syntax": "totalSizeBytes = fso.GetFolder(FolderPath).Size",
    "parameters": [],
    "examples": [
        {"code": "Dim fso As Object, targetFolder As Object\nDim folderPathToCheck As String: folderPathToCheck = \"C:\\ClientSubmissions\\ClientA_Q3_2023\"\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nIf fso.FolderExists(folderPathToCheck) Then\n    Set targetFolder = fso.GetFolder(folderPathToCheck)\n    Dim sizeMB As Double\n    sizeMB = targetFolder.Size / (1024 * 1024)\n    MsgBox \"资料夹 '\" & targetFolder.Name & \"' 的总大小是: \" & Format(sizeMB, \"0.00\") & \" MB。\"\nElse\n    MsgBox \"资料夹未找到: \" & folderPathToCheck\nEnd If\nSet fso = Nothing: Set targetFolder = Nothing", "explanation": "获取指定客户资料文件夹的 Folder 对象，然后使用其 .Size 属性来计算该文件夹及其所有子文件夹和文件的总大小，并将结果转换为MB显示。"}
    ],
    "keywords": ["fso folder size recursive", "get directory size", "贷後资料文件夹大小", "递归计算文件夹大小"]
},
// String & Text Manipulation
{
    "name": "Split (Using Limit Argument for Max Array Elements)",
    "category": "字串與文本操作",
    "description": "Split 函数的 `limit` 参数（可选）指定要返回的子字符串的最大数量。如果 `limit` 大于实际能分割出的子字符串数量，则返回所有子字符串。如果 `limit` 小于实际数量，则数组的最后一个元素将包含原始字符串中所有剩余未分割的部分。",
    "syntax": "Split(expression, [delimiter], [limit], [compare])",
    "parameters": [{"name": "limit", "description": "要返回的子字符串的最大数量。-1 (默认)表示返回所有。"}],
    "examples": [
        {"code": "Dim textToSplit As String: textToSplit = \"RiskTypeA;SeverityHigh;ActionRequired;DueDate2023-12-31\"\nDim partsLimited As Variant\n' Split into a maximum of 3 parts\npartsLimited = Split(textToSplit, \";\", 3)\nDebug.Print \"分割为最多3部分:\"\nDim i As Long\nFor i = LBound(partsLimited) To UBound(partsLimited)\n  Debug.Print \"  Part \" & i & \": \" & partsLimited(i)\nNext i\n' Output will be:\n'   Part 0: RiskTypeA\n'   Part 1: SeverityHigh\n'   Part 2: ActionRequired;DueDate2023-12-31 (remaining part)", "explanation": "使用 Split 函数将分号分隔的字符串分割成最多3个部分。结果数组的最后一个元素 (partsLimited(2)) 将包含从第三个分隔符开始的所有剩余文本。"}
    ],
    "keywords": ["split function limit argument", "max array elements from split", "贷後风险备注解析", "分割指定数量"]
},
// Math, Date & Time
{
    "name": "WorksheetFunction.WorkDay (Exclude Weekend and Holidays for SLAs)",
    "category": "Excel 核心操作",
    "syntax": "targetDate = Application.WorksheetFunction.WorkDay(StartDate, NumDays, [HolidaysRange])",
    "description": "使用Excel的WORKDAY函数，计算从某个开始日期算起，经过指定数量的工作日（自动排除周末）并排除指定假日列表后的日期。这在贷后管理中用于计算服务水平协议(SLA)的到期日或跟进任务的截止工作日非常有用。",
    "parameters": [
        {"name": "StartDate", "description": "开始日期。"},
        {"name": "NumDays", "description": "要增加的工作日数 (正数表示未来，负数表示过去)。"},
        {"name": "HolidaysRange", "description": "可选。包含要排除的假日日期列表的范围。"}
    ],
    "examples": [
        {"code": "Dim issueReportedDate As Date: issueReportedDate = DateSerial(2023, 10, 25) ' Wednesday\nDim slaDays As Long: slaDays = 3 ' SLA is 3 working days\nDim companyHolidays As Range\n' Assume Sheets(\"CompanyCalendar\").Range(\"A1:A10\") lists company holidays\n' Set companyHolidays = Sheets(\"CompanyCalendar\").Range(\"A1:A10\")\nDim resolutionDueDate As Date\n' resolutionDueDate = Application.WorksheetFunction.WorkDay(issueReportedDate, slaDays, companyHolidays)\n' For this example, assume no holidays provided for simplicity for execution\nresolutionDueDate = Application.WorksheetFunction.WorkDay(issueReportedDate, slaDays)\nMsgBox \"问题报告于: \" & Format(issueReportedDate, \"yyyy-mm-dd (dddd)\") & vbCrLf & _\n       \"按 \" & slaDays & \" 个工作日SLA，预计解决到期日: \" & Format(resolutionDueDate, \"yyyy-mm-dd (dddd)\")", "explanation": "如果客户问题在2023年10月25日（周三）报告，SLA要求3个工作日内解决，则此代码计算出解决方案的到期日（不考虑假日的情况下，应为2023年10月30日，周一）。"}
    ],
    "keywords": ["excel workday function vba", "calculate sla due date", "贷後SLA到期日计算", "工作日计算"]
},
// Data Types, Conversion & Validation
{
    "name": "CStr (Converting Error Values to String)",
    "category": "資料類型、轉換與驗證",
    "description": "当 CStr 函数的参数是一个包含错误值的 Variant (例如，由 CVErr 创建，或公式计算结果为 #N/A, #DIV/0! 等)，CStr 会将该错误值转换为其对应的错误代码字符串 (例如，“错误 2042”对应 #N/A)。",
    "parameters": [],
    "examples": [
        {"code": "Dim errValNA As Variant, errValDiv0 As Variant\nerrValNA = CVErr(xlErrNA)       ' #N/A (Error 2042)\nerrValDiv0 = CVErr(xlErrDiv0)   ' #DIV/0! (Error 2007)\n\nDim strFromNA As String, strFromDiv0 As String\nstrFromNA = CStr(errValNA)\nstrFromDiv0 = CStr(errValDiv0)\n\nDebug.Print \"CVErr(xlErrNA) as String: \" & strFromNA      ' Output: 错误 2042\nDebug.Print \"CVErr(xlErrDiv0) as String: \" & strFromDiv0    ' Output: 错误 2007\n\n' Using in a cell formula that results in error\nRange(\"A1\").Formula = \"=NA()\"\nDim cellErrorStr As String\ncellErrorStr = CStr(Range(\"A1\").Value)\nDebug.Print \"Range(\"\"A1\"\") (#N/A) as String: \" & cellErrorStr ' Output: 错误 2042", "explanation": "演示 CStr 如何将 CVErr 创建的错误值以及单元格中的公式错误值转换为包含错误代码的字符串。"}
    ],
    "keywords": ["cstr error value", "convert error to string", "vba error code string", "错误值转字串"]
},
// Program Flow & Structure Control
{
    "name": "UserForm (ComboBox .MatchEntry Property for Auto-Completion)",
    "category": "Excel VBA 開發與表單",
    "description": "ComboBox 控件的 .MatchEntry 属性确定当用户在文本框部分键入字符时，控件如何尝试匹配列表中的条目。\n`fmMatchEntryFirstLetter` (0): 查找以键入字符开头的第一个条目。\n`fmMatchEntryComplete` (1 - 默认): 查找与已键入的所有字符完全匹配的第一个条目。\n`fmMatchEntryNone` (2): 不执行匹配。",
    "syntax": "Me.ComboBoxClient.MatchEntry = fmMatchEntryFirstLetter",
    "parameters": [{"name": "fmMatchEntryConstant", "description": "例如 fmMatchEntryFirstLetter, fmMatchEntryComplete。"}],
    "examples": [
        {"code": "' --- In UserForm 'ufClientSearch' Code Module ---\n' Private Sub UserForm_Initialize()\n'   With Me.cboClientName ' ComboBox for client names\n'     .AddItem \"Apple Inc.\"\n'     .AddItem \"Amazon Services Inc.\"\n'     .AddItem \"Alphabet Inc.\"\n'     .AddItem \"Microsoft Corporation\"\n'     .AddItem \"Meta Platforms Inc.\"\n'\n'     .MatchEntry = 0 ' fmMatchEntryFirstLetter\n'     ' When user types 'A', it will jump to 'Apple Inc.' or 'Amazon' or 'Alphabet'\n'     ' depending on which is first in list that matches.\n'     ' If it were fmMatchEntryComplete, typing 'Ap' would go to 'Apple Inc.'\n'   End With\n' End Sub\n'\n' Private Sub cboClientName_KeyDown(ByVal KeyCode As MSForms.ReturnInteger, ByVal Shift As Integer)\n'   ' Optional: Could further refine behavior on KeyDown if needed\n'   If Me.cboClientName.MatchFound Then\n'     Debug.Print \"Match Found: \" & Me.cboClientName.Text\n'   End If\n' End Sub", "explanation": "在 UserForm 初始化时，为一个名为 `cboClientName` 的 ComboBox 填充客户名称，并将其 `MatchEntry` 属性设置为 `fmMatchEntryFirstLetter`。这意味着当用户开始键入时，ComboBox 会尝试匹配列表中以该字符开头的第一个条目。"}
    ],
    "keywords": ["userform combobox matchentry", "combobox autocomplete behavior", "贷後客户选择框", "下拉框自动匹配"]
},
// External Interaction (Web, DB, OS)
{
    "name": "ADODB.Recordset (Find Method for Searching Records)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "ADODB Recordset 的 `Find` 方法用于在 Recordset 中搜索符合指定条件的记录。它需要一个筛选字符串，语法类似于 SQL WHERE 子句的条件部分。Find 方法从当前行或指定的起始位置开始搜索。要使用 Find，Recordset 的 CursorType 通常需要支持向后移动或书签 (例如 `adOpenKeyset` 或 `adOpenStatic`)。",
    "syntax": "rs.Find(Criteria As String, [SkipRows As Long = 0], [SearchDirection As SearchDirectionEnum = adSearchForward], [Start As Variant])",
    "parameters": [
        {"name": "Criteria", "description": "必需。筛选字符串，例如 \"LastName = 'Smith' AND FirstName = 'John'\" 或 \"Amount > 1000\"。"},
        {"name": "SkipRows", "description": "可選。从当前行或Start书签开始搜索前要跳过的行数。"},
        {"name": "SearchDirection", "description": "可選。adSearchForward (預設) 或 adSearchBackward。"},
        {"name": "Start", "description": "可選。一个书签，指定搜索的起始位置。"}
    ],
    "examples": [
        {"code": "Dim conn As Object, rs As Object\nDim criteria As String\n' ' Assume conn is an open ADODB.Connection\n' Set rs = CreateObject(\"ADODB.Recordset\")\n' rs.CursorLocation = 3 ' adUseClient\n' rs.CursorType = 3     ' adOpenStatic\n' rs.LockType = 1       ' adLockReadOnly\n' rs.Open \"SELECT ClientID, ClientName, RiskRating, LoanBalance FROM ClientPortfolio\", conn\n'\n' If Not rs.EOF Then\n'   criteria = \"RiskRating = 'High' AND LoanBalance > 500000\"\n'   rs.Find criteria\n'   If Not rs.EOF Then ' Found a match\n'     Debug.Print \"--- 找到符合条件的第一笔高风险大额贷款 ---\"\n'     Debug.Print \"ClientID: \" & rs!ClientID & \", Name: \" & rs!ClientName & \", Balance: \" & rs!LoanBalance\n'     ' Find next one\n'     rs.Find criteria, SkipRows:=1 ' Skip current found record and find next\n'     If Not rs.EOF Then\n'       Debug.Print \"--- 找到符合条件的下一笔高风险大额贷款 ---\"\n'       Debug.Print \"ClientID: \" & rs!ClientID & \", Name: \" & rs!ClientName\n'     Else\n'       Debug.Print \"(没有更多符合条件的记录)\"\n'     End If\n'   Else\n'     Debug.Print \"未找到符合条件 (RiskRating='High' AND LoanBalance>500000) 的贷款。\"\n'   End If\n' End If\n' If rs.State = 1 Then rs.Close\n' Set rs = Nothing\n' ' If conn.State = 1 Then conn.Close: Set conn = Nothing\nMsgBox \"(概念性) 演示了Recordset.Find。需有实际数据。\"", "explanation": "演示如何使用 Recordset 的 `Find` 方法。首先，打开一个包含客户组合数据的 Recordset。然后，定义一个筛选条件（例如，风险评级为'High'且贷款余额大于500,000）。第一次调用 `Find` 查找第一个匹配的记录。如果找到，则第二次调用 `Find` 时使用 `SkipRows:=1` 来查找下一个匹配的记录。"}
    ],
    "keywords": ["adodb recordset find", "search recordset vba", "ado find criteria", "贷後高风险客户筛选", "在Recordset中查找"]
},
{
    "name": "MSXML2.DOMDocument (TransformNodeToObject Method - XSLT to DOM)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "IXMLDOMNode 的 `transformNodeToObject` 方法使用 XSLT 样式表转换 XML 节点，并将结果输出到一个新的 DOMDocument 对象 (或一个流对象)。这与 `transformNode` (输出为字符串) 不同，它直接生成一个 DOM 对象，便于进一步的程序化处理。",
    "syntax": "xmlNodeOrDoc.transformNodeToObject(stylesheetNodeOrDoc As Object, outputObject As Object)",
    "parameters": [
        {"name": "stylesheetNodeOrDoc", "description": "必需。包含XSLT样式表的 IXMLDOMNode。"},
        {"name": "outputObject", "description": "必需。将接收转换结果的物件 (例如，一个新的 DOMDocument 实例)。"}
    ],
    "examples": [
        {"code": "Dim xmlData As Object, xslt As Object, resultDom As Object\nDim xmlStr As String, xsltStr As String\n\nxmlStr = \"<clients><client id='c1'><name>Client A</name><status>Active</status></client>\" & _\n         \"<client id='c2'><name>Client B</name><status>Inactive</status></client></clients>\"\n' XSLT to select only active clients and wrap them in a new root\nxsltStr = \"<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>\" & _\n          \"<xsl:template match='/'>\" & _\n          \"  <active_clients><xsl:apply-templates select='clients/client[status=\"\"Active\"\"]'/></active_clients>\" & _\n          \"</xsl:template>\" & _\n          \"<xsl:template match='client'><client_summary id='{@id}'><name><xsl:value-of select='name'/></name></client_summary></xsl:template>\" & _\n          \"</xsl:stylesheet>\"\n\nSet xmlData = CreateObject(\"MSXML2.DOMDocument.6.0\")\nSet xslt = CreateObject(\"MSXML2.DOMDocument.6.0\")\nSet resultDom = CreateObject(\"MSXML2.DOMDocument.6.0\") ' Target DOM for output\nxmlData.async = False: xslt.async = False: resultDom.async = False\n\nxmlData.LoadXML xmlStr\nxslt.LoadXML xsltStr\n\nIf xmlData.parseError.errorCode = 0 And xslt.parseError.errorCode = 0 Then\n    xmlData.transformNodeToObject xslt, resultDom\n    If resultDom.parseError.errorCode = 0 And Not resultDom.documentElement Is Nothing Then\n        Debug.Print \"--- XSLT 转换结果 (DOM) ---\"\n        Debug.Print resultDom.XML\n        ' Now resultDom can be further processed as a DOMDocument\n    Else\n        Debug.Print \"TransformNodeToObject 失败或结果为空。错误: \" & resultDom.parseError.reason\n    End If\nElse\n    Debug.Print \"XML 或 XSLT 载入错误。\"\nEnd If\nSet xmlData = Nothing: Set xslt = Nothing: Set resultDom = Nothing", "explanation": "载入 XML 数据和 XSLT 样式表。XSLT 的目的是筛选出状态为 \"Active\" 的客户，并为他们创建一个新的 `<active_clients>` 结构。`transformNodeToObject` 方法执行转换，并将结果直接填充到 `resultDom` 这个新的 DOMDocument 对象中。然后打印出这个新生成的 DOM 的 XML 内容。"}
    ],
    "keywords": ["msxml transformnodetoobject", "xslt to dom vba", "xml transformation result dom", "贷後客户筛选XML", "XSLT输出DOM"]
},
// --- Excel 核心操作 (贷后管理场景) ---
{
    "name": "Workbook.Queries.Add (Power Query from Excel Table for Loan Analysis)",
    "category": "Excel 核心操作",
    "syntax": "Set newPQ = workbookObject.Queries.Add(Name As String, Formula As String, [Description As String])",
    "description": "在Excel中通过VBA添加一个新的Power Query查询，该查询可以基于工作簿内的现有Excel表格（ListObject）或其他数据源。这允许在贷后管理中创建可重用的数据转换和分析步骤。Formula参数使用M语言。",
    "parameters": [
        {"name": "Name", "description": "新Power Query的名称。"},
        {"name": "Formula", "description": "定义查询的M语言公式字符串。"},
        {"name": "Description", "description": "可选，查询的描述。"}
    ],
    "examples": [
        {"code": "Sub CreatePowerQueryFromLoanTable()\n    Dim wb As Workbook: Set wb = ThisWorkbook\n    Dim loanTable As ListObject\n    Dim pqName As String: pqName = \"PQ_ActiveHighRiskLoans\"\n    Dim mFormula As String\n\n    ' Assume a table named \"LoanPortfolioTable\" exists on sheet \"PortfolioData\"\n    On Error Resume Next\n    Set loanTable = wb.Sheets(\"PortfolioData\").ListObjects(\"LoanPortfolioTable\")\n    If loanTable Is Nothing Then\n        MsgBox \"未找到名为 'LoanPortfolioTable' 的Excel表格。\", vbExclamation\n        Exit Sub\n    End If\n    On Error GoTo 0\n\n    ' M formula to get data from the Excel table and filter for Active, High Risk loans\n    mFormula = \"let\" & vbCrLf & _\n               \"    Source = Excel.CurrentWorkbook(){[Name=\"\"\" & loanTable.Name & \"\"\"]}[Content],\" & vbCrLf & _\n               \"    #\"\"筛选的行\"\" = Table.SelectRows(Source, each ([RiskRating] = \"\"High\"\" and [Status] = \"\"Active\"\"))\" & vbCrLf & _\n               \"in\" & vbCrLf & _\n               \"    #\"\"筛选的行\"\"\"\n\n    ' Delete existing query with same name to avoid error\n    On Error Resume Next\n    wb.Queries(pqName).Delete\n    On Error GoTo 0\n\n    Dim newQuery As WorkbookQuery\n    Set newQuery = wb.Queries.Add(Name:=pqName, Formula:=mFormula, Description:=\"筛选活动的高风险贷款\")\n    ' Optionally, load the query to a new sheet\n    ' With ActiveSheet.ListObjects.Add(SourceType:=xlSrcQuery, Source:=newQuery.Name, Destination:=Range(\"A1\"))\n    '   .Name = \"HighRiskLoanOutputTable\"\n    '   .QueryTable.Refresh BackgroundQuery:=False\n    ' End With\n    MsgBox \"Power Query '\" & pqName & \"' 已创建，用于筛选高风险活动贷款。您可以从“查询和连接”窗格管理它或将其加载到工作表。\"\n    Set newQuery = Nothing: Set loanTable = Nothing\nEnd Sub", "explanation": "此宏在当前工作簿中创建一个名为“PQ_ActiveHighRiskLoans”的新Power Query查询。该查询的M语言公式 (`mFormula`) 从一个名为“LoanPortfolioTable”的现有Excel表格中获取数据，并筛选出“RiskRating”为“High”且“Status”为“Active”的行。创建查询后，可以手动或通过VBA将其结果加载到工作表中。"}
    ],
    "keywords": ["excel power query vba add", "create m query vba", "贷後高风险筛选PQ", "自动化PowerQuery"]
},
{
    "name": "Range.Validation (List with Dynamic Named Range for Covenant Types)",
    "category": "Excel 核心操作",
    "description": "为贷后管理中的“契约类型”输入单元格设置数据验证，使其下拉列表来源于一个动态已命名范围。这个动态范围可以指向一个包含所有有效契约类型的列表，当契约类型库更新时，下拉列表也能自动更新。",
    "syntax": "rangeObject.Validation.Add Type:=xlValidateList, Formula1:=\"=DynamicCovenantTypes\"",
    "parameters": [{"name": "DynamicCovenantTypes", "description": "一个动态已命名范围的名称，该范围引用包含契约类型的列表。"}],
    "examples": [
        {"code": "' First, create a dynamic named range, e.g., \"CovenantTypeList\"\n' Define Name in Excel: Name: CovenantTypeList\n'                       RefersTo: =OFFSET(Lookups!$A$1,0,0,COUNTA(Lookups!$A:$A),1)\n' (Assuming covenant types are in column A of 'Lookups' sheet, starting A1)\n\nSub SetupCovenantTypeDropdown(targetCell As Range)\n    With targetCell.Validation\n        .Delete\n        .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, _\n             Operator:=xlBetween, Formula1:=\"=CovenantTypeList\"\n        .IgnoreBlank = True\n        .InCellDropdown = True\n        .InputTitle = \"选择契约类型\"\n        .InputMessage = \"请从下拉列表中选择一个有效的贷款契约类型。\"\n        .ErrorTitle = \"无效类型\"\n        .ErrorMessage = \"选择的契约类型无效。\"\n    End With\n    MsgBox \"单元格 \" & targetCell.Address & \" 已设置动态契约类型下拉列表。\"\nEnd Sub\n\n' Example Call: Call SetupCovenantTypeDropdown(Sheets(\"LoanDetails\").Range(\"E5\"))", "explanation": "假设在Excel中已定义了一个名为“CovenantTypeList”的动态命名范围（例如，使用OFFSET和COUNTA使其引用“Lookups”工作表A列中的所有契约类型）。此VBA过程 `SetupCovenantTypeDropdown` 将指定的目标单元格的数据验证设置为一个列表，其来源是这个动态命名范围。"}
    ],
    "keywords": ["excel dynamic dropdown validation", "list validation dynamic range", "贷後契约类型规范输入", "动态数据验证列表"]
},
// Word 文件處理
{
    "name": "Document.MailMerge.CreateHeaderSource (Word Mail Merge)",
    "category": "Word 文件處理",
    "description": "创建一个新的Word文档作为邮件合并的页首数据源。页首数据源包含将在每个合并文档（例如信函）的页首或页脚重复的信息，如公司地址、日期等。创建后，可以将数据填入此页首源文档。",
    "syntax": "mainDocument.MailMerge.CreateHeaderSource(Name:=headerFilePath, [PasswordDocument], [WritePasswordDocument], [HeaderRecord])",
    "parameters": [
        {"name": "Name", "description": "必需。新页首数据源文件的完整路径和名称。"},
        {"name": "HeaderRecord", "description": "可選。一个字符串，包含页首数据源第一行（字段名）的制表符或逗号分隔的值。"}
    ],
    "examples": [
        {"code": "Dim wdMainDoc As Object ' Word.Document (Main Mail Merge Document)\nDim headerDataPath As String: headerDataPath = \"C:\\MailMergeData\\SharedLetterhead.docx\"\n' ' Assume wdMainDoc is the active mail merge main document.\n' ' Create a new header source file with some default fields\n' On Error Resume Next ' Delete if exists for test re-run\n' Kill headerDataPath\n' On Error GoTo 0\n' wdMainDoc.MailMerge.CreateHeaderSource Name:=headerDataPath, _\n'                                    HeaderRecord:=\"CompanyName\" & vbTab & \"CompanyAddress\" & vbTab & \"ReportDate\"\n' ' Now, open headerDataPath, fill in the data for the single record, save and close it.\n' ' Then, use wdMainDoc.MailMerge.OpenHeaderSource Name:=headerDataPath to link it.\n' If Dir(headerDataPath) <> \"\" Then\n'   MsgBox \"页首数据源文件模板 '\" & headerDataPath & \"' 已创建。请填入数据后使用OpenHeaderSource附加。\"\n' Else\n'   MsgBox \"创建页首数据源文件失败。\"\n' End If", "explanation": "为当前邮件合并主文档创建一个名为“SharedLetterhead.docx”的页首数据源文件，并定义其表头字段。创建后，需要另外打开此文件填入具体的信头数据，然后再将其附加到主文档。"}
    ],
    "keywords": ["word mailmerge createheadersource", "mail merge letterhead data", "贷後通知函信头数据创建", "邮件合并页首创建"]
},
{
    "name": "ContentControl.BuildingBlockType / .BuildingBlockCategory (Word)",
    "category": "Word 文件處理",
    "description": "对于类型为 `wdContentControlBuildingBlockGallery` 或 `wdContentControlDocPartGallery` 的内容控制项，这两个属性用于指定在库中显示的构建块的类型和类别。",
    "syntax": "ccGallery.BuildingBlockType = WdBuildingBlockTypesConstant\nccGallery.BuildingBlockCategory = \"CategoryName\"",
    "parameters": [
        {"name": "BuildingBlockType", "description": "WdBuildingBlockTypes 常数，例如 wdTypeCoverPage, wdTypeQuickParts, wdTypeCustomHeaders。"},
        {"name": "BuildingBlockCategory", "description": "构建块的类别名称 (字符串)。"}
    ],
    "examples": [
        {"code": "Dim wdDoc As Object, ccCustomGallery As Object ' Word.ContentControl\n' Set wdDoc = ActiveDocument\n' ' Add a Building Block Gallery Content Control for custom Quick Parts\n' Set ccCustomGallery = wdDoc.ContentControls.Add(wdContentControlBuildingBlockGallery, Selection.Range)\n' With ccCustomGallery\n'   .Title = \"选择自定义条款\"\n'   .BuildingBlockType = wdTypeQuickParts ' Show Quick Parts\n'   .BuildingBlockCategory = \"贷后常用条款\" ' Filter by this category (must exist in Building Blocks Organizer)\n'   .SetPlaceholderText Text:=\"[从贷后条款库中选择]\"\n' End With\n' MsgBox \"已新增一个用于显示 '贷后常用条款' 类别下快速部件的构建块库内容控制项。\"", "explanation": "新增一个构建块库内容控制项，并将其配置为显示“快速部件”类型中类别为“贷后常用条款”的构建块。这些构建块需要预先在Word的构建块管理器中定义和分类。"}
    ],
    "keywords": ["word contentcontrol buildingblockgallery", "wdtypequickparts", "贷後条款选择控制项", "构建块库"]
},
// Outlook 郵件與項目管理
{
    "name": "MailItem.VotingResponse (Process Voting Results)",
    "category": "Outlook 郵件與項目管理",
    "description": "当收到对带有投票按钮的邮件的回覆时，`VotingResponse` 属性包含收件者的投票选择（例如，“是”，“否”，“同意”等）。VBA可以处理这些回覆，将投票结果汇总到Excel或数据库中，用于贷后决策或意见收集。",
    "parameters": [],
    "examples": [
        {"code": "' Assume this code runs when processing replies to a voting email.\n' Dim olReplyMail As Outlook.MailItem\n' Dim wsVotingResults As Worksheet ' Excel sheet to log results\n' Dim nextResultRow As Long\n' ' Set wsVotingResults = ThisWorkbook.Sheets(\"VotingLog\")\n' ' nextResultRow = wsVotingResults.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n'\n' ' If TypeName(olReplyMail) = \"MailItem\" And olReplyMail.VotingResponse <> \"\" Then\n' '   wsVotingResults.Cells(nextResultRow, \"A\").Value = olReplyMail.SenderEmailAddress\n' '   wsVotingResults.Cells(nextResultRow, \"B\").Value = olReplyMail.VotingResponse\n' '   wsVotingResults.Cells(nextResultRow, \"C\").Value = olReplyMail.ReceivedTime\n' '   ' Extract original subject or tracking ID if needed to link to original poll\n' '   Dim originalSubject As String\n' '   If Left(olReplyMail.Subject, 4) = \"RE: \" Or Left(olReplyMail.Subject, 4) = \"答覆: \" Then\n' '       originalSubject = Trim(Mid(olReplyMail.Subject, InStr(olReplyMail.Subject, \":\") + 1))\n' '   Else\n' '       originalSubject = olReplyMail.Subject ' Or from ConversationTopic\n' '   End If\n' '   wsVotingResults.Cells(nextResultRow, \"D\").Value = originalSubject\n' '   wsVotingResults.Cells(nextResultRow, \"E\").Value = olReplyMail.ConversationID\n' '   Debug.Print \"投票结果已记录: \" & olReplyMail.SenderEmailAddress & \" 投了 '\" & olReplyMail.VotingResponse & \"'\"\n' '   olReplyMail.UnRead = False\n' '   ' olReplyMail.Move ... ' Move processed voting reply\n' ' End If", "explanation": "此概念性代码演示了在处理Outlook邮件时，如果邮件的 `VotingResponse` 属性不为空，则表明这是一封投票回覆。代码会提取发件人、投票选项和接收时间，并将其记录到Excel的“VotingLog”工作表中。"}
    ],
    "keywords": ["outlook process voting responses", "log email votes to excel", "贷後意见投票收集", "处理投票回覆"]
},
{
    "name": "ContactItem.BusinessCardLayoutXml Property (Outlook)",
    "category": "Outlook 郵件與項目管理",
    "description": "设定或传回一个 XML 字符串，代表 Outlook 联络人电子名片 (EBC) 的版面配置。允许以程序设计方式自定义电子名片的外观和包含的字段。操作此 XML 需要了解其特定架构。",
    "parameters": [{"name": "XMLString", "description": "符合电子名片版面配置架构的XML字符串。"}],
    "examples": [
        {"code": "Dim olContact As Object ' Outlook.ContactItem\nDim ebcXml As String\n' ' Set olContact = Application.CreateItem(olContactItem)\n' ' olContact.FullName = \"John Doe - VIP Client\"\n' ' olContact.Email1Address = \"j.doe@vipclient.com\"\n' ' olContact.CompanyName = \"VIP Industries\"\n' ' ' Example of a very simple EBC XML to just show name and company\n' ' ebcXml = \"<bc:layout xmlns:bc='<y_bin_338>http://schemas.microsoft.com/office/outlook/12/electronicbusinesscards'>\" & _\n' '            \"<bc:group><bc:item prop='FullName'/><bc:item prop='CompanyName'/></bc:group></bc:layout>\"\n' ' On Error Resume Next ' Setting EBC XML can be complex\n' ' olContact.BusinessCardLayoutXml = ebcXml\n' ' If Err.Number = 0 Then\n' '   olContact.Display\n' '   MsgBox \"联络人 '\" & olContact.FullName & \"' 的电子名片版面配置已尝试设定。\"\n' ' Else\n' '   MsgBox \"设定电子名片版面配置失败: \" & Err.Description\n' ' End If\n' ' On Error GoTo 0\nMsgBox \"(概念性) BusinessCardLayoutXml 用于自定义电子名片。需了解其XML结构。\"", "explanation": "概念性地演示如何获取一个联络人项目，并为其 `BusinessCardLayoutXml` 属性赋予一个XML字符串，以自定义该联络人在电子名片视图中的显示方式。实际的XML结构较为复杂。"}
    ],
    "keywords": ["outlook contact businesscardlayoutxml", "customize electronic business card", "贷後重要客户名片", "自定义电子名片"]
},
// PowerPoint 簡報製作
{
    "name": "Shapes.AddMediaObjectFromEmbedTag (PowerPoint 2013+)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set mediaShape = slideObject.Shapes.AddMediaObjectFromEmbedTag(EmbedTag As String, [Left], [Top], [Width], [Height])",
    "description": "根据视频网站（如YouTube, Vimeo）提供的嵌入代码 (HTML embed tag) 在投影片上新增一个在线视频。需要 Office 2013 或更高版本，并且计算机需要能够访问互联网。",
    "parameters": [
        {"name": "EmbedTag", "description": "必需。包含视频嵌入代码的字符串 (通常是 `<iframe ...>...</iframe>`)。"}
    ],
    "examples": [
        {"code": "Dim pptSlide As Object, onlineVideoShp As Object ' PowerPoint.Shape\nDim videoEmbedCode As String\n' ' Set pptSlide = ActivePresentation.Slides.Add(ActivePresentation.Slides.Count + 1, ppLayoutBlank)\n' ' Example YouTube embed code (replace with a real one)\n' ' videoEmbedCode = \"<iframe width='\"\"560\"\"' height='\"\"315\"\"' src='\"\"https://www.youtube.com/embed/VIDEO_ID_HERE\"\"' frameborder='\"\"0\"\"' allowfullscreen></iframe>\"\n' ' On Error Resume Next ' Requires internet access and valid embed code\n' ' Set onlineVideoShp = pptSlide.Shapes.AddMediaObjectFromEmbedTag(EmbedTag:=videoEmbedCode, Left:=50, Top:=50, Width:=560, Height:=315)\n' ' If Not onlineVideoShp Is Nothing And Err.Number = 0 Then\n' '   MsgBox \"在线视频已尝试嵌入到新投影片。\"\n' ' Else\n' '   MsgBox \"嵌入在线视频失败 (可能版本不支持、代码无效或无网络): \" & Err.Description\n' ' End If\n' ' On Error GoTo 0\nMsgBox \"(概念性) AddMediaObjectFromEmbedTag 用于嵌入在线视频。需 PowerPoint 2013+。\"", "explanation": "在新投影片上尝试根据提供的HTML嵌入代码（例如来自YouTube）嵌入一个在线视频，并设置其位置和大小。"}
    ],
    "keywords": ["powerpoint addmediaobjectfromembedtag", "embed online video ppt", "贷後培训视频嵌入", "插入在线视频PPT"]
},
{
    "name": "Slide.Hyperlinks Property (PowerPoint)",
    "category": "PowerPoint 簡報製作",
    "syntax": "Set hlinks = slideObject.Hyperlinks",
    "description": "传回一个 Hyperlinks 集合，代表指定投影片上的所有超链接 (通常是附加到图或文本上的)。",
    "parameters": [
        {"name": "Hyperlinks.Count", "description": "集合中超链接的数量。"},
        {"name": "Hyperlinks.Item(Index)", "description": "获取特定超链接。"},
        {"name": "Hyperlinks.Add(ShapeObject, Address, [SubAddress], [ScreenTip], [TextToDisplay])", "description": "方法（用于Shape）：为图添加超链接。"}
    ],
    "examples": [
        {"code": "Dim sld As Object ' PowerPoint.Slide\nDim hlink As Object ' PowerPoint.Hyperlink\n' Set sld = ActivePresentation.Slides(1)\n' ' First, add a shape and a hyperlink to it for testing\n' Dim shpWithLink As Object\n' ' Set shpWithLink = sld.Shapes.AddLabel(msoTextOrientationHorizontal, 50, 250, 200, 20)\n' ' shpWithLink.TextFrame.TextRange.Text = \"银行贷后政策主页\"\n' ' shpWithLink.ActionSettings(ppMouseClick).Hyperlink.Address = \"http://www.bank.com/postloanpolicy\"\n'\n' If sld.Hyperlinks.Count > 0 Then\n'   MsgBox \"第一张投影片上有 \" & sld.Hyperlinks.Count & \" 个超链接。\"\n'   For Each hlink In sld.Hyperlinks\n'     Debug.Print \"超链接地址: \" & hlink.Address & \", 子地址: \" & hlink.SubAddress & \", 屏幕提示: \" & hlink.ScreenTip\n'     ' To follow a link from a shape's ActionSetting:\n'     ' If hlink.Parent Is shpWithLink Then shpWithLink.ActionSettings(ppMouseClick).Hyperlink.Follow\n'   Next hlink\n' Else\n'   MsgBox \"第一张投影片上没有超链接。\"\n' End If", "explanation": "首先（在注释中）为第一张投影片上的一个图（例如一个标签）添加一个超链接。然后，代码遍历该投影片上的所有超链接对象，并打印它们的地址、子地址和屏幕提示。注意，为图的文本框中的特定文本部分添加超链接（`TextRange.ActionSettings`）与整个图的超链接（`Shape.ActionSettings` 或通过`Slide.Hyperlinks`集合访问）是不同的。`Slide.Hyperlinks`通常指向附加到图上的超链接。"}
    ],
    "keywords": ["powerpoint slide hyperlinks", "list hyperlinks on slide", "贷後资料链接PPT", "投影片超链接集合"]
},
// FileSystemObject (FSO)
{
    "name": "FileSystemObject.GetStandardStream (StdErr Example - Conceptual)",
    "category": "檔案與資料夾管理",
    "description": "GetStandardStream(StdErr) 获取标准错误流。与 StdIn 和 StdOut 类似，在 Office VBA 中直接使用较少，更多用于 WSH/CScript 环境或通过 `WScript.Shell.Exec` 捕获外部命令的错误输出。",
    "parameters": [{"name": "StdErr (Constant 2)", "description": "指定标准错误流。"}],
    "examples": [
        {"code": "' See 'WScript.Shell.Run (Capturing Output - Advanced)' which uses Exec\n' and can read execObj.StdErr.ReadAll() or .ReadLine().\nDim fso As Object, wsh As Object, oExec As Object\nSet fso = CreateObject(\"Scripting.FileSystemObject\")\nSet wsh = CreateObject(\"WScript.Shell\")\n' Command that generates an error: e.g., trying to access a non-existent file with 'type'\n' Set oExec = wsh.Exec(\"cmd /c type NonExistentFile123.txt\")\n' Dim errorOutput As String\n' Do While oExec.Status = 0: Loop ' Wait\n' If Not oExec.StdErr.AtEndOfStream Then errorOutput = oExec.StdErr.ReadAll()\n' If errorOutput <> \"\" Then Debug.Print \"StdErr: \" & errorOutput Else Debug.Print \"(StdErr was empty or command succeeded)\"\nMsgBox \"(概念性) 演示了通过 WshScriptExec 的 StdErr 属性读取错误输出。\"", "explanation": "强调在VBA中，捕获外部命令的标准错误输出通常通过 `WScript.Shell.Exec` 返回的对象的 `StdErr` 属性 (TextStream) 来完成。"}
    ],
    "keywords": ["fso stderr", "capture command error stream", "standard error vba", "贷後脚本错误捕获", "标准错误流"]
},
// String & Text Manipulation
{
    "name": "InStrRev (Return 0 if Not Found)",
    "category": "字串與文本操作",
    "description": "如果 InStrRev 函数在 StringCheck 中找不到 StringMatch (或者如果 StringCheck 为空，或者 StringMatch 为空但 Start 不是0)，它会返回 0。",
    "parameters": [],
    "examples": [
        {"code": "Dim mainText As String: mainText = \"Monthly Financial Report - Q3\"\nDim searchFor As String: searchFor = \"Annual\"\nDim position As Long\nposition = InStrRev(mainText, searchFor, -1, vbTextCompare)\nIf position = 0 Then\n  Debug.Print \"在 '\" & mainText & \"' 中未找到子字串 '\" & searchFor & \"'。\"\nElse\n  Debug.Print \"'\" & searchFor & \"' 最后出现在位置: \" & position\nEnd If\n\nDim emptyText As String: emptyText = \"\"\nDebug.Print \"InStrRev(\"\"\"\", \"\"A\"\"): \" & InStrRev(emptyText, \"A\") ' Output: 0", "explanation": "演示当 InStrRev 找不到指定的子字符串时，它会返回0。同时也显示了当被搜索字符串为空时的情况。"}
    ],
    "keywords": ["instrrev not found", "reverse search returns zero", "贷後报告名称检查", "反向查找失败"]
},
// Math, Date & Time
{
    "name": "WorksheetFunction.Floor_Precise (Excel 2010+)",
    "category": "數學、日期與時間",
    "syntax": "floorValue = Application.WorksheetFunction.Floor_Precise(Number, [Significance As Double = 1])",
    "description": "使用Excel的FLOOR.PRECISE函数 (Excel 2010+)，将数字向下舍入到最接近的指定基数的倍数。与FLOOR.MATH不同，它对负数的舍入行为始终是“趋向负无穷大”（即向下舍入）。如果Significance为负，则对于正数Number返回#NUM!，对于负数Number则朝向零舍入。",
    "parameters": [
        {"name": "Number", "description": "必需。要舍入的数值。"},
        {"name": "Significance", "description": "可選。舍入的基数。如果省略，则假定为1。其符号被忽略。"}
    ],
    "examples": [
        {"code": "Debug.Print \"FLOOR.PRECISE(12.8, 1) = \" & Application.WorksheetFunction.Floor_Precise(12.8, 1) ' Output: 12\nDebug.Print \"FLOOR.PRECISE(12.8, 0.5) = \" & Application.WorksheetFunction.Floor_Precise(12.8, 0.5) ' Output: 12.5\nDebug.Print \"FLOOR.PRECISE(-5.7, 2) = \" & Application.WorksheetFunction.Floor_Precise(-5.7, 2)  ' Output: -6 (rounds towards negative infinity)\nDebug.Print \"FLOOR.PRECISE(-5.7, -2) = \" & Application.WorksheetFunction.Floor_Precise(-5.7, -2) ' Output: -6 (sign of significance is ignored for direction itself, but can error for positive numbers)", "explanation": "演示FLOOR.PRECISE函数如何将数字向下舍入到指定基数的倍数，特别是对于负数，它总是向负无穷大方向舍入。"}
    ],
    "keywords": ["excel floor.precise vba", "round down precise multiple", "贷後计算舍入", "FLOOR.PRECISE函数"]
},
// Data Types, Conversion & Validation
{
    "name": "VarType (Return Value for User-Defined Type - UDT)",
    "category": "資料類型、轉換與驗證",
    "description": "对于使用 `Type...End Type` 定义的用户自定义类型 (UDT) 的变量，VarType 函数会返回 `vbUserDefinedType` (常数值 36)。",
    "parameters": [],
    "examples": [
        {"code": "Private Type LoanRecord\n  LoanID As String\n  Amount As Currency\n  IssueDate As Date\nEnd Type\n\nSub CheckUDTVarType()\n  Dim myLoan As LoanRecord\n  myLoan.LoanID = \"LN001\"\n  myLoan.Amount = 50000\n  myLoan.IssueDate = Date\n\n  If VarType(myLoan) = vbUserDefinedType Then\n    Debug.Print \"myLoan 的 VarType 是 vbUserDefinedType (\" & vbUserDefinedType & \").\"\n  Else\n    Debug.Print \"myLoan 的 VarType 不是 vbUserDefinedType: \" & VarType(myLoan)\n  End If\nEnd Sub", "explanation": "定义一个名为 `LoanRecord` 的用户自定义类型，然后声明该类型的一个变量 `myLoan`。VarType(myLoan) 会返回 `vbUserDefinedType` (36)。"}
    ],
    "keywords": ["vartype user defined type", "vbuserdefinedtype", "udt data type code", "贷後UDT类型检查", "用户定义类型代码"]
},
// Program Flow & Structure Control
{
    "name": "Declare Sub/Function (Parameter As Any)",
    "category": "程式流程與結構控制",
    "description": "在 Declare 语句中，可以将 API 函数的参数声明为 `As Any`。这允许在调用 API 时传递不同数据类型的参数给该位置，VBA 不会进行类型检查。这在 API 函数根据其他参数的值接受不同类型数据时非常有用，但也非常危险，因为类型不匹配可能导致程序崩溃。通常与 `ByVal` 结合使用，传递实际的值或指针 (如果传递的是对象或字符串，ByVal As Any 会传递其地址)。",
    "parameters": [],
    "examples": [
        {"code": "' Example: SendMessage API can take various types for lParam depending on the message (wMsg).\n' #If VBA7 Then\n'   Private Declare PtrSafe Function SendMessage Lib \"user32\" Alias \"SendMessageA\" (\n'     ByVal hwnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, lParam As Any) As LongPtr\n' #Else\n'   Private Declare Function SendMessage Lib \"user32\" Alias \"SendMessageA\" (\n'     ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long\n' #End If\n' Const WM_SETTEXT As Long = &HC\n'\n' Sub SendTextToNotepad(notepadHwnd As LongPtr, textToSend As String)\n'   If notepadHwnd = 0 Then Exit Sub\n'   ' When lParam is a string for WM_SETTEXT, it's passed ByVal.\n'   ' If lParam As Any is used, and you pass a string, VBA passes a pointer to it.\n'   ' To be explicit, usually it's declared ByVal lParam As String for WM_SETTEXT.\n'   ' This example shows 'As Any' for lParam, and ByVal is used in the call for the string.\n'   SendMessage notepadHwnd, WM_SETTEXT, 0, ByVal textToSend ' Pass string ByVal with As Any\n'   MsgBox \"已尝试向Notepad发送文本 (使用 lParam As Any 和 ByVal String)。\"\n' End Sub\n'\n' ' To test: (Need to get notepadHwnd first)\n' ' Dim npHwnd As LongPtr: npHwnd = FindWindow(\"Notepad\", vbNullString)\n' ' Call SendTextToNotepad(npHwnd, \"Hello from VBA via SendMessage As Any!\")", "explanation": "演示 SendMessage API 的 Declare 语句，其中 `lParam` 被声明为 `As Any`。在调用时，当为 `WM_SETTEXT` 消息传递字符串给 `lParam` 时，使用 `ByVal textToSend`。这告诉VBA将字符串的指针按值传递。`As Any` 提供了灵活性，但也增加了类型错误的风险。"}
    ],
    "keywords": ["declare parameter as any", "api as any argument", "flexible api parameter", "API参数As Any"]
},
// External Interaction (Web, DB, OS)
{
    "name": "WScript.Shell RegRead (Handling Non-Existent Value Error)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "如果 WScript.Shell 的 RegRead 方法尝试读取一个不存在的登录檔值 (而不是机码的预设值)，它会触发一个执行阶段错误 (通常是错误号为 -2147024894，表示“系统找不到指定的文件”，或者其他与登录檔相关的错误)。需要使用 `On Error Resume Next` 来处理这种情况。",
    "parameters": [],
    "examples": [
        {"code": "Dim wshShell As Object, regKeyPath As String, regValueName As String, retrievedValue As Variant\nSet wshShell = CreateObject(\"WScript.Shell\")\nregKeyPath = \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\\"\nregValueName = \"HideFileExt_NonExistent\" ' A value that likely does not exist\n\nOn Error Resume Next ' Trap error if value doesn't exist\nretrievedValue = wshShell.RegRead(regKeyPath & regValueName)\nIf Err.Number <> 0 Then\n  Debug.Print \"读取登录檔值 '\" & regKeyPath & regValueName & \"' 失败。\"\n  Debug.Print \"  错误号: \" & Err.Number & \" (十六进制: \" & Hex(Err.Number) & \")\"\n  Debug.Print \"  错误描述: \" & Err.Description\n  retrievedValue = \"[值未找到或读取错误]\"\n  Err.Clear\nElse\n  Debug.Print \"登录檔值 '\" & regValueName & \"' = \" & retrievedValue\nEnd If\nOn Error GoTo 0\nMsgBox \"尝试读取一个可能不存在的登录檔值。结果: \" & retrievedValue\nSet wshShell = Nothing", "explanation": "尝试读取一个可能不存在的登录檔值 `HideFileExt_NonExistent`。如果该值不存在，`RegRead` 会产生错误。`On Error Resume Next` 用于捕获此错误，并打印错误信息。"}
    ],
    "keywords": ["regread error handling", "registry value not found", "wsh read non-existent registry", "读取不存在的登录檔值"]
},
{
    "name": "ADODB.Recordset (Clone with adLockReadOnly)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "当使用 ADODB Recordset 的 `Clone` 方法创建副本时，可以指定克隆副本的锁定类型。如果原始 Recordset 是可更新的，但您希望克隆的副本是只读的以防止意外修改，可以将 LockType 参数设为 `adLockReadOnly` (1)。",
    "syntax": "Set rsReadOnlyClone = rsOriginal.Clone(adLockReadOnly)",
    "parameters": [],
    "examples": [
        {"code": "Dim rsMain As Object, rsCloneRO As Object\n' ' Assume rsMain is an open, updatable ADODB.Recordset (e.g., adOpenKeyset, adLockOptimistic)\n' ' rsMain.CursorLocation = adUseClient\n' ' rsMain.Open \"SELECT * FROM Products\", conn, adOpenKeyset, adLockOptimistic\n'\n' If Not rsMain Is Nothing And rsMain.State = 1 Then\n'   Set rsCloneRO = rsMain.Clone(adLockReadOnly) ' Create a read-only clone\n'   If Not rsCloneRO.EOF Then\n'     Debug.Print \"克隆 (只读) Recordset 中的第一条产品: \" & rsCloneRO!ProductName\n'     ' Attempting to update rsCloneRO would fail or be ignored because it's read-only\n'     On Error Resume Next\n'     rsCloneRO.Fields(\"UnitPrice\").Value = rsCloneRO.Fields(\"UnitPrice\").Value + 1\n'     If Err.Number <> 0 Then\n'       Debug.Print \"  尝试更新只读克隆失败 (预期中)。错误: \" & Err.Description\n'     Else\n'       Debug.Print \"  只读克隆意外地允许更新 (不应发生)。\"\n'     End If\n'     On Error GoTo 0\n'   End If\n'   If rsCloneRO.State = 1 Then rsCloneRO.Close\n'   Set rsCloneRO = Nothing\n' End If\n' ' ... close rsMain and conn ...\nMsgBox \"(概念性) 演示了创建只读克隆Recordset。需有实际数据。\"", "explanation": "假设 `rsMain` 是一个可更新的 Recordset。`rsMain.Clone(adLockReadOnly)` 会创建一个指向相同数据但本身是只读的 Recordset 副本 (`rsCloneRO`)。对 `rsCloneRO` 进行更新操作将会失败。"}
    ],
    "keywords": ["adodb recordset clone readonly", "adlockreadonly clone", "贷後数据只读副本", "克隆只读记录集"]
},
{
    "name": "MSXML2.DOMDocument (Load External XML with Error Handling)",
    "category": "外部互動與API (Web, DB, OS)",
    "description": "从外部文件或URL加载XML到MSXML2.DOMDocument时，应检查 `Load` 方法的返回值以及 `parseError.errorCode`。`Load` 方法本身会返回一个布尔值指示加载是否“开始”成功（对于同步加载，也表示完成）。如果XML格式错误或文件不存在/不可访问，`parseError.errorCode` 将非零。",
    "parameters": [],
    "examples": [
        {"code": "Dim xmlDoc As Object\nDim xmlFilePath As String: xmlFilePath = \"C:\\Path\\To\\NonExistentOrMalformed.xml\"\nSet xmlDoc = CreateObject(\"MSXML2.DOMDocument.6.0\")\nxmlDoc.async = False ' Crucial for VBA to wait for Load to complete\n\nIf Not xmlDoc.Load(xmlFilePath) Then ' Load returned False (e.g., file not found, access denied)\n    MsgBox \"DOMDocument.Load 方法传回 False。\" & vbCrLf & _\n           \"Parse Error Code: \" & xmlDoc.parseError.errorCode & vbCrLf & _\n           \"Reason: \" & xmlDoc.parseError.reason\nElseIf xmlDoc.parseError.errorCode <> 0 Then ' Load returned True, but XML content had errors\n    MsgBox \"XML 内容解析错误!\" & vbCrLf & _\n           \"Error Code: \" & xmlDoc.parseError.errorCode & vbCrLf & _\n           \"Reason: \" & xmlDoc.parseError.reason & vbCrLf & _\n           \"Line: \" & xmlDoc.parseError.Line & \", Pos: \" & xmlDoc.parseError.linepos\nElse\n    MsgBox \"XML 文件 '\" & xmlFilePath & \"' 已成功载入并解析。根元素: \" & xmlDoc.documentElement.nodeName\nEnd If\nSet xmlDoc = Nothing", "explanation": "演示在尝试从文件加载XML时，如何检查 `Load` 方法的布尔返回值以及 `parseError.errorCode`。如果 `Load` 返回 False，通常意味着文件级别的问题（找不到、无法访问）。如果 `Load` 返回 True 但 `parseError.errorCode` 非零，则意味着文件已打开但其XML内容格式不正确。"}
    ],
    "keywords": ["msxml load error handling", "xml file parse error", "check load success dom", "贷後XML文件载入错误处理", "检查XML载入状态"]
},
{
    "name": "全自動化貸後契約遵循監控、違約通知及跟進任務創建系統",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: An Excel workbook acts as the central repository for loan covenant details and client financial data. VBA automates the entire process of: 1. Periodically checking financial data against covenants. 2. Identifying breaches or near-breaches. 3. Generating a formal breach notification letter in Word. 4. Emailing this letter and a summary to the Relationship Manager (RM) and Risk Officer via Outlook. 5. Creating a follow-up task in Outlook for the RM.",
    "description": "此全自動化系統旨在主動監控客戶的財務契約遵守情況，並在發生違約或接近違約時，自動化通知和任務指派流程。流程包括：1. **Excel數據中心**：a. “LoanCovenants”表：LoanID, ClientID, CovenantType (例如，“DSCR最低值”，“LTV上限”，“淨資產下限”)，CovenantThreshold (契約規定值)，WarningBuffer (例如，0.1 表示10%的預警緩衝區)。b. “ClientFinancials_Periodic”表：ClientID, ReportPeriod, MetricName (例如，“EBITDA”，“總債務”，“房地產估值”，“淨資產”)，MetricValue。c. “RM_Assignments”表：ClientID, RM_Name, RM_Email, RiskOfficer_Email。d. “BreachLog”表：記錄所有已識別的違約和預警事件。2. **VBA自動化引擎 (可設定時執行，例如每日夜間)**：a. **數據提取與計算**：對於“LoanCovenants”表中的每筆有效貸款，從“ClientFinancials_Periodic”表中獲取其最新報告期的相關財務指標，並計算實際的契約比率 (例如，DSCR = EBITDA / 總債務償付)。b. **契約比對與狀態更新**：  i. 將計算出的實際比率與`CovenantThreshold`進行比較。  ii. 如果實際值未達到契約要求，則標記為“違約 (Breach)”。  iii. 如果實際值在`CovenantThreshold`的`WarningBuffer`範圍內 (例如，DSCR略高於最低要求但低於“安全”水準)，則標記為“預警 (Warning)”。  iv. 在“LoanCovenants”表或一個單獨的“CovenantStatus”表中更新每個契約的當前狀態和檢查日期。c. **生成Word違約/預警通知函**：  i. 如果檢測到“違約”或嚴重“預警”：    - VBA啟動Word，打開一個預設的“契約通知函範本.dotx”。    - 範本中包含預留位置，如[ClientName], [LoanID], [CovenantDescription], [RequiredValue], [ActualValue], [BreachDate], [RMName]。    - VBA將從Excel中提取的相關資訊填充到Word範本的預留位置中。    - 將生成的通知函以特定命名規則 (例如，`BreachNotice_ClientID_LoanID_Date.docx`) 保存到指定檔夾，並可選擇同時另存為PDF。d. **Outlook郵件通知**：  i. 創建一個新的Outlook郵件項目。  ii. 收件人：從“RM_Assignments”表中獲取對應的RM_Email。  iii. 抄送人：RiskOfficer_Email。  iv. 主旨：“緊急：客戶 [ClientName] ([ClientID]) 發生財務契約 [違約/預警] - 貸款 [LoanID]”。  v. 郵件正文：簡要說明情況，引用契約條款和實際值，並附上生成的Word/PDF通知函。vi. 直接發送郵件。e. **Outlook任務創建**：  i. 為負責的RM創建一個新的Outlook任務。  ii. 主旨：“跟進客戶 [ClientName] 的 [CovenantType] [違約/預警]”。  iii. 截止日期：例如，3個工作日後。  iv. 提醒：設定提前1天提醒。  v. 正文：包含客戶ID、貸款ID、違約詳情和指向已保存通知函的路徑。  vi. 將任務指派給RM (或保存在RM的任務列表中)。f. **記錄日誌**：所有生成的通知函、郵件和任務的發送/創建狀態都記錄到“BreachLog”表中。此系統的目標是實現貸後契約監控的閉環管理，從自動檢測、標準化通知到任務化跟進。",
    "parameters": [
        {"name": "Excel Data Sheets", "description": "包含契約、財務數據、RM分配和日誌的工作表。"},
        {"name": "Word Notification Letter Template Path", "description": "Word格式的違約/預警通知函範本檔路徑。"},
        {"name": "Output Folder for Generated Letters", "description": "保存生成的Word/PDF通知函的檔夾。"},
        {"name": "VBA Engine Scheduling (e.g., OnTime)", "description": "用於定期觸發整個監控和通知流程的機制。"},
        {"name": "Email Content Templates and Task Parameters", "description": "Outlook郵件和任務的標準化內容和設定。"}
    ],
    "examples": [
        {"code": "' --- Main Sub to orchestrate the process (Conceptual) ---\nPublic Sub AutomatedCovenantMonitoringAndNotification()\n    ' Dim wb As Workbook: Set wb = ThisWorkbook ' Or specific workbook\n    ' Dim wsCov As Worksheet: Set wsCov = wb.Sheets(\"LoanCovenants\")\n    ' Dim wsFins As Worksheet: Set wsFins = wb.Sheets(\"ClientFinancials_Periodic\")\n    ' Dim wsRMAssign As Worksheet: Set wsRMAssign = wb.Sheets(\"RM_Assignments\")\n    ' Dim wsBreachLog As Worksheet: Set wsBreachLog = wb.Sheets(\"BreachLog\")\n    ' Dim olApp As Object, wdApp As Object ' For Outlook and Word\n    ' Dim lastCovRow As Long, i As Long, nextLogRow As Long\n\n    ' On Error GoTo GlobalErrorHandler\n    ' ' Initialize Outlook and Word Applications (get or create)\n    ' ' ... (Code for GetObject/CreateObject for olApp and wdApp) ...\n\n    ' lastCovRow = wsCov.Cells(Rows.Count, \"A\").End(xlUp).Row\n    ' nextLogRow = wsBreachLog.Cells(Rows.Count, \"A\").End(xlUp).Row + 1\n\n    ' For i = 2 To lastCovRow ' Loop through each covenant entry\n    '   Dim clientID As String: clientID = wsCov.Cells(i, \"ClientID_Col\").Value\n    '   Dim loanID As String: loanID = wsCov.Cells(i, \"LoanID_Col\").Value\n    '   Dim covenantType As String: covenantType = wsCov.Cells(i, \"CovenantType_Col\").Value\n    '   Dim covenantThreshold As Double: covenantThreshold = wsCov.Cells(i, \"CovenantThreshold_Col\").Value\n    '   Dim warningBuffer As Double: warningBuffer = wsCov.Cells(i, \"WarningBuffer_Col\").Value\n    '   Dim actualMetricValue As Double\n    '   Dim isBreach As Boolean: isBreach = False\n    '   Dim isWarning As Boolean: isWarning = False\n    '   Dim rmEmail As String, riskOfficerEmail As String, clientName As String\n\n    '   ' 1. Get latest financial metric for this client and covenant type\n    '   actualMetricValue = GetLatestClientMetric(clientID, covenantType, wsFins) ' Custom function\n\n    '   ' 2. Compare and determine status (simplified logic)\n    '   ' Example for a DSCR (must be >= threshold)\n    '   If covenantType = \"DSCR最低值\" Then\n    '      If actualMetricValue < covenantThreshold Then isBreach = True\n    '      If Not isBreach And actualMetricValue < (covenantThreshold * (1 + warningBuffer)) Then isWarning = True\n    '   End If\n    '   ' ... (Add logic for other covenant types like LTV (must be <= threshold), etc.) ...\n\n    '   If isBreach Or isWarning Then\n    '     ' Get RM and Risk Officer emails\n    '     GetContactEmails clientID, wsRMAssign, clientName, rmEmail, riskOfficerEmail ' Custom function\n    '     Dim statusText As String: statusText = IIf(isBreach, \"違約\", \"預警\")\n\n    '     ' 3. Generate Word Notification Letter\n    '     Dim letterPath As String\n    '     letterPath = GenerateBreachLetter_Word(wdApp, clientName, loanID, covenantType, covenantThreshold, actualMetricValue, statusText) ' Custom function\n\n    '     If letterPath <> \"\" Then\n    '       ' 4. Send Outlook Email Notification\n    '       Call SendBreachNotificationEmail(olApp, rmEmail, riskOfficerEmail, clientName, clientID, loanID, covenantType, statusText, letterPath)\n    '       ' 5. Create Outlook Task for RM\n    '       Call CreateFollowUpTask_Outlook(olApp, rmEmail, clientName, clientID, loanID, covenantType, statusText)\n    '       ' 6. Log to BreachLog\n    '       wsBreachLog.Cells(nextLogRow, 1).Value = Now\n    '       wsBreachLog.Cells(nextLogRow, 2).Value = clientID\n    '       wsBreachLog.Cells(nextLogRow, 3).Value = loanID\n    '       wsBreachLog.Cells(nextLogRow, 4).Value = covenantType\n    '       wsBreachLog.Cells(nextLogRow, 5).Value = statusText\n    '       wsBreachLog.Cells(nextLogRow, 6).Value = actualMetricValue\n    '       wsBreachLog.Cells(nextLogRow, 7).Value = \"通知已發送，任務已創建\"\n    '       nextLogRow = nextLogRow + 1\n    '     End If\n    '   End If\n    ' Next i\n    ' wsBreachLog.Columns.AutoFit\n    ' ThisWorkbook.Save\n    ' MsgBox \"貸後契約遵循監控、通知及任務創建流程已執行完畢。\"\n' GlobalErrorHandler:\n    ' ' ... Error handling for the entire process ...\n' ' Cleanup: Set olApp = Nothing: Set wdApp = Nothing, etc.\nMsgBox \"(概念性) 全自動化貸後契約監控流程。實際執行需要多個輔助函數和詳細的錯誤處理。\"", "explanation": "此概念性VBA宏 `AutomatedCovenantMonitoringAndNotification` 描述了一個完整的貸後契約監控自動化流程。它會遍歷Excel中記錄的貸款契約，從客戶財務數據表中獲取最新指標，進行比對以判斷是否違約或達到預警。如果觸發條件，它會調用其他（假設的）輔助函數來：1. `GetLatestClientMetric`: 獲取客戶最新的相關財務指標。2. `GetContactEmails`: 獲取客戶經理和風險官員的郵箱。3. `GenerateBreachLetter_Word`: 使用Word範本生成正式的違約/預警通知函，並返回文件路徑。4. `SendBreachNotificationEmail`: 創建並發送Outlook郵件，附上生成的通知函。5. `CreateFollowUpTask_Outlook`: 為客戶經理創建一個Outlook跟進任務。6. 最後，將事件記錄到Excel的“BreachLog”表中。"}
    ],
    "keywords": ["vba automated covenant monitoring", "excel word outlook integration post-loan", "generate breach notification letter vba", "outlook task creation from excel", "貸後契約自動監控", "違約通知自動化", "Excel Word Outlook整合貸後"]
},
{
    "name": "貸後管理儀表板數據源自動聚合與PowerPoint報告摘要生成",
    "category": "綜合應用案例與技巧",
    "syntax": "Scenario: Multiple Excel files or database tables contain disparate post-loan management data (e.g., client risk ratings, overdue loan details, collateral information, RM follow-up logs). VBA first uses Power Query (managed via VBA or pre-built) or ADODB to consolidate these data sources into a central Excel 'DashboardData' sheet. Then, it extracts key summary statistics and charts from this sheet (or from PivotTables based on it) and automatically populates a standardized PowerPoint presentation template to create a periodic 'Post-Loan Portfolio Health Report'.",
    "description": "此全自動化流程旨在從多個數據源收集貸後管理數據，在Excel中進行聚合，然後將關鍵摘要和圖表自動填充到PowerPoint報告範本中。1. **數據聚合 (Excel Power Query 或 ADODB)**：a. VBA觸發預先建立的Power Query查詢，或執行ADODB腳本，從多個源（例如，核心系統導出的CSV檔、信貸系統數據庫表、RM日誌Excel表）提取和轉換數據。b. 所有清洗和整合後的數據被加載到一個主Excel工作簿中的“DashboardData”工作表中。此表包含如ClientID, LoanID, RiskRating, DPD, CollateralCoverageRatio, LastContactDate, OpenActionItems等欄位。2. **Excel摘要分析與圖表生成**：a. 在Excel中，基於“DashboardData”工作表，可以預先建立或由VBA動態創建數據透視表和數據透視圖，以匯總關鍵貸後指標 (例如，按風險等級劃分的貸款分佈、逾期貸款總額趨勢、抵押品覆蓋率不足的貸款數量、RM跟進活動的完成率)。3. **PowerPoint報告範本準備**：a. 創建一個PowerPoint範本 (.potx)，其中包含預設的投影片版面配置、公司Logo、以及用於填充數據和圖表的佔位符。預留位置可以是特定的圖形名稱 (例如，“txtOverallRiskScore”, “chtDelinquencyTrend”, “tblTopOverdues”) 或通過其在投影片上的索引/類型來識別。4. **VBA填充PowerPoint報告**：a. VBA啟動PowerPoint應用程式，並基於範本創建一個新簡報。b. **填充文本數據**：從Excel的“DashboardData”表或基於它的數據透視表中提取關鍵的摘要數字或文本（例如，總體組合風險評分、逾期貸款總額、本期重點關注客戶列表），並將這些數據填入PowerPoint範本中對應的文字方塊或表格佔位元符中。c. **複製Excel圖表到PowerPoint**：  i. 遍歷Excel中預定義的貸後管理圖表 (例如，數據透視圖)。  ii. 使用 `Chart.ChartArea.Copy` 將Excel圖表複製為圖片。  iii. 在PowerPoint的目標投影片上，定位到圖表佔位符（或指定位置），然後使用 `Slide.Shapes.PasteSpecial(DataType:=ppPasteEnhancedMetafile)` 或 `ppPasteBitmap` 將圖表粘貼進去。可以調整粘貼後圖形的大小和位置。d. **填充表格數據 (可選)**：如果PowerPoint範本中有表格需要填充詳細數據，VBA可以從Excel讀取數據，然後逐行逐格地填充到PowerPoint表格中。5. **保存並分發PowerPoint報告**：a. 將填充好的PowerPoint簡報以特定命名規則（例如，`PostLoanHealthReport_YYYYMM.pptx`）保存。b. (可選) 通過Outlook將生成的PPT報告作為附件發送給預定義的管理層郵件列表。此系統實現了從數據聚合到最終報告呈現的完全自動化，大大提高了貸後管理報告的生成效率和一致性。",
    "parameters": [
        {"name": "Data Source Connection Strings / Power Query Names", "description": "用於從各個系統提取數據的連接資訊或已定義的Power Query查詢名稱。"},
        {"name": "Excel Master Data Consolidation Sheet", "description": "存放從所有源聚合後的貸後管理數據。"},
        {"name": "Excel Summary PivotTables and Charts", "description": "基於聚合數據創建的，用於提取摘要和圖表的數據透視表/圖。"},
        {"name": "PowerPoint Report Template Path", "description": "標準貸後組合健康報告的PPT範本檔路徑。"},
        {"name": "PowerPoint Placeholder Names/Identifiers", "description": "PPT範本中用於填充文本、圖表、表格的佔位元符的名稱或識別方式。"},
        {"name": "Output Folder for Generated PPT Reports", "description": "保存生成的PPT報告的檔夾。"},
        {"name": "Email Distribution List (Optional)", "description": "用於自動分發報告的收件人列表。"}
    ],
    "examples": [
        {"code": "' --- Main Orchestration Sub (Conceptual) ---\nPublic Sub CreateAndDistributePortfolioHealthPPT()\n    ' Dim excelApp As Object: Set excelApp = Application ' Assuming running from Excel\n    ' Dim pptApp As Object, pptPres As Object, pptSld As Object\n    ' Dim dataSheet As Worksheet, pivotSheet As Worksheet\n    ' Dim chartObj As ChartObject, tblObj As ListObject\n    ' Dim reportDateSuffix As String: reportDateSuffix = Format(Date, \"yyyyMM\")\n\n    On Error GoTo GlobalErrorHandler\n    ' excelApp.ScreenUpdating = False\n\n    ' --- 1. Refresh/Aggregate Data in Excel (Conceptual) ---\n    ' Call RefreshAllPowerQueries ' Custom Sub to refresh PQs that bring in data\n    ' Call ConsolidateDataFromSourcesToDashboardDataSheet ' Custom Sub using ADO or PQ to populate \"DashboardData\"\n    ' Set dataSheet = ThisWorkbook.Sheets(\"DashboardData\")\n    ' ' Refresh PivotTables based on DashboardData\n    ' ' For Each pt In ThisWorkbook.Sheets(\"PivotSummaries\").PivotTables: pt.RefreshTable: Next pt\n\n    ' --- 2. Initialize PowerPoint and Open Template ---\n    ' ' ... (Code for GetObject/CreateObject for pptApp) ...\n    ' ' pptApp.Visible = msoTrue\n    ' ' Set pptPres = pptApp.Presentations.Open(\"C:\\Templates\\PostLoanReportTemplate.potx\", WithWindow:=msoTrue)\n\n    ' --- 3. Populate PowerPoint Slides ---\n    ' ' Example: Populate Title Slide (Slide 1)\n    ' ' Set pptSld = pptPres.Slides(1)\n    ' ' pptSld.Shapes.Title.TextFrame.TextRange.Text = \"貸後資產組合健康報告 - \" & reportDateSuffix\n    ' ' pptSld.Shapes.Placeholders(2).TextFrame.TextRange.Text = \"生成日期: \" & Format(Date, \"yyyy年m月d日\") ' Subtitle placeholder\n\n    ' ' Example: Populate Summary Statistics (Slide 2, Shape \"txtKeyMetrics\")\n    ' ' Set pptSld = pptPres.Slides(2)\n    ' ' Dim totalExposure As Currency: totalExposure = ThisWorkbook.Sheets(\"PivotSummaries\").Range(\"TotalExposureCell\").Value\n    ' ' Dim overdueRate As Double: overdueRate = ThisWorkbook.Sheets(\"PivotSummaries\").Range(\"OverallOverdueRateCell\").Value\n    ' ' On Error Resume Next\n    ' ' pptSld.Shapes(\"txtKeyMetrics\").TextFrame.TextRange.Text = \"總體風險敞口: \" & Format(totalExposure, \"#,##0\") & vbCrLf & _\n    ' '                                                       \"總體逾期率: \" & Format(overdueRate, \"0.00%\")\n    ' ' On Error GoTo GlobalErrorHandler\n\n    ' ' Example: Copy Excel Chart (e.g., from \"PivotSummaries\" sheet, chart named \"RiskDistributionChart\")\n    ' ' Set pptSld = pptPres.Slides(3)\n    ' ' On Error Resume Next\n    ' ' Set chartObj = ThisWorkbook.Sheets(\"PivotSummaries\").ChartObjects(\"RiskDistributionChart\")\n    ' ' If Not chartObj Is Nothing Then\n    ' '   chartObj.Chart.ChartArea.Copy\n    ' '   pptSld.Shapes.PasteSpecial DataType:=2 ' ppPasteEnhancedMetafile or ppPasteBitmap (0)\n    ' '   ' Adjust pasted chart position and size on pptSld.Shapes(pptSld.Shapes.Count)\n    ' ' Else\n    ' '   Debug.Print \"Excel 圖表 'RiskDistributionChart' 未找到。\"\n    ' ' End If\n    ' ' On Error GoTo GlobalErrorHandler\n\n    ' ' Example: Copy Excel Table (e.g., a ListObject named \"Top10OverdueTable\")\n    ' ' Set pptSld = pptPres.Slides(4)\n    ' ' On Error Resume Next\n    ' ' Set tblObj = ThisWorkbook.Sheets(\"DetailedReports\").ListObjects(\"Top10OverdueTable\")\n    ' ' If Not tblObj Is Nothing Then\n    ' '   tblObj.Range.Copy\n    ' '   pptSld.Shapes.PasteSpecial DataType:=10, Link:=msoFalse ' ppPasteOLEObject or other table paste options\n    ' ' Else\n    ' '   Debug.Print \"Excel 表格 'Top10OverdueTable' 未找到。\"\n    ' ' End If\n    ' ' On Error GoTo GlobalErrorHandler\n\n    ' --- 4. Save PowerPoint Presentation ---\n    ' ' Dim pptSavePath As String: pptSavePath = \"C:\\GeneratedReports\\PostLoanHealthReport_\" & reportDateSuffix & \".pptx\"\n    ' ' pptPres.SaveAs pptSavePath\n    ' ' MsgBox \"PowerPoint 報告已生成並保存於: \" & pptSavePath\n\n    ' --- 5. (Optional) Email the Report ---\n    ' ' Call SendReportByEmail_Outlook(pptApp, pptSavePath, \"management@bank.com\", \"月度貸後組合健康報告 - \" & reportDateSuffix)\n\n' GlobalErrorHandler:\n'   ' excelApp.ScreenUpdating = True\n'   ' ' ... Error handling for the entire process ...\n' ' Cleanup: Set objects to Nothing, close PPT if opened by script, etc.\nMsgBox \"(概念性) 貸後管理儀錶板資料聚合與PowerPoint報告摘要生成流程。實際執行需要詳細的Excel資料準備、PowerPoint範本設計以及各步驟的VBA實現。\"", "explanation": "此概念性VBA宏 `CreateAndDistributePortfolioHealthPPT` 描述了一個自動從多個資料來源聚合貸後資料到Excel主資料表，然後刷新或創建基於此資料的Excel樞紐分析表和圖表。接著，它會啟動PowerPoint，打開一個報告範本，並將Excel中的摘要資料、圖表（複製為圖片）和表格（可作為OLE物件或圖片粘貼）填充到PowerPoint範本的相應預留位置中。最後，生成的PowerPoint報告會被保存，並可選擇通過Outlook郵件分發。"}
    ],
    "keywords": ["vba excel powerpoint reporting automation", "automate dashboard to ppt", "post-loan portfolio report generation", "excel data consolidation to powerpoint", "貸後管理PPT報告自動化", "Excel資料聚合到PPT", "自動化儀錶板報告"]
},

];

        // --- 新增代碼開始 ---
        // 清理 description 字段中的 Markdown 加粗 (**)
        vbaCommands.forEach(command => {
            if (command.description && typeof command.description === 'string') {
                command.description = command.description.replace(/\*\*/g, '');
            }
            // 例如，清理 examples[].explanation:
            if (command.examples && Array.isArray(command.examples)) {
                command.examples.forEach(example => {
                    if (example.explanation && typeof example.explanation === 'string') {
                        example.explanation = example.explanation.replace(/\*\*/g, '');
                    }
                });
            }
        });
        // --- 新增代碼結束 ---

        // 初始化 Fuse.js
        const fuse = new Fuse(vbaCommands, {
            keys: ['name', 'description', 'keywords', 'category'],
            threshold: 0.25, // 降低門檻以便更容易匹配非精確詞
            includeScore: true,
            includeMatches: true,
        });

        const mainQueryInterfaceDiv = document.getElementById('mainQueryInterface');
        const searchResultsContainer = document.getElementById('searchResultsContainer');
        const resultsDiv = document.getElementById('results');
        const detailsDiv = document.getElementById('details');
        const directoryDiv = document.getElementById('directory');
        const commandStatsDiv = document.getElementById('commandStats');
        const searchBox = document.getElementById('searchBox');
        const contentPageDivs = document.querySelectorAll('.content-page');


        function displayCommandStats() {
            commandStatsDiv.textContent = `現已記錄 ${vbaCommands.length} 個 VBA 指令的說明。`;
        }

        function toggleCategoryContent(headerElement) {
            const contentUl = headerElement.nextElementSibling;
            const toggleIcon = headerElement.querySelector('.toggle-icon');
            if (contentUl) {
                if (contentUl.style.display === 'none' || contentUl.style.display === '') {
                    contentUl.style.display = 'block';
                    if (toggleIcon) toggleIcon.textContent = '[-]';
                } else {
                    contentUl.style.display = 'none';
                    if (toggleIcon) toggleIcon.textContent = '[+]';
                }
            }
        }

        function displayDirectory() {
            const categories = {};
            vbaCommands.forEach(cmd => {
                if (!cmd.category) cmd.category = "未分類";
                if (!categories[cmd.category]) {
                    categories[cmd.category] = [];
                }
                categories[cmd.category].push(cmd);
            });

             const categoryOrder = [
                "Excel 核心操作", "Excel 資料分析與樞紐", "Excel VBA 開發與表單",
                "Word 文件處理", "Outlook 郵件與項目管理", "PowerPoint 簡報製作",
                "檔案與資料夾管理", "字串與文本操作", "陣列、集合與字典",
                "數學、日期與時間", "資料類型、轉換與驗證", "程式流程與結構控制",
                "錯誤處理與調試", "外部互動與API (Web, DB, OS)", "綜合應用案例與技巧"
            ];

            const sortedCategories = Object.keys(categories).sort((a, b) => {
                let indexA = categoryOrder.indexOf(a);
                let indexB = categoryOrder.indexOf(b);
                if (indexA === -1) indexA = categoryOrder.length;
                if (indexB === -1) indexB = categoryOrder.length;
                if (indexA !== indexB) return indexA - indexB;
                return a.localeCompare(b);
            });

            let directoryHtml = '';
            sortedCategories.forEach(categoryName => {
                directoryHtml += `<div class="directory-category">
                                    <h3 onclick="toggleCategoryContent(this)">
                                        ${escapeHtml(categoryName)} (${categories[categoryName].length})
                                        <span class="toggle-icon">[+]</span>
                                    </h3>
                                    <ul style="display:none;">`;
                categories[categoryName].sort((a, b) => a.name.localeCompare(b.name)).forEach(cmd => {
                    directoryHtml += `<li>
                                        <div class="directory-item" onclick="showDetails('${escapeHtml(cmd.name)}')">
                                            <span class="directory-item-name-main">${escapeHtml(cmd.name)}</span>
                                            <span class="directory-item-description">${escapeHtml(cmd.description)}</span>
                                        </div>
                                      </li>`;
                });
                directoryHtml += `</ul></div>`;
            });
            directoryDiv.innerHTML = directoryHtml;
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') {
                return String(unsafe);
            }
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function applyHighlights(text, query) {
            if (!text || !query) {
                return escapeHtml(text);
            }
            const escapedQuery = escapeRegExp(query);
            const stringText = String(text);
            const regex = new RegExp(`\\b(${escapedQuery})\\b`, 'gi');
            return escapeHtml(stringText).replace(regex, (match) => {
                return `<span class="highlight">${match}</span>`;
            });
        }

        function performSearch(query) {
            showMainQueryInterface(); // Ensure main query UI is visible
            detailsDiv.style.display = 'none';
            detailsDiv.innerHTML = '';
            directoryDiv.style.display = 'none'; // Hide directory when searching

            const fuseResults = fuse.search(query);

            if (fuseResults.length === 0) {
                resultsDiv.innerHTML = '<p>找不到相關指令，請嘗試其他關鍵詞。</p>';
            } else {
                resultsDiv.innerHTML = fuseResults.map(result => {
                    const commandItem = result.item;
                    let highlightedName = applyHighlights(commandItem.name, query);
                    let highlightedDescription = applyHighlights(commandItem.description, query);
                    let keywordsDisplay = '';
                    if (commandItem.keywords && commandItem.keywords.length > 0) {
                        keywordsDisplay = ` (關鍵詞: ${commandItem.keywords.map(kw => applyHighlights(kw, query)).join(', ')})`;
                    }
                    return `
                        <div class="result-item" onclick="showDetails('${escapeHtml(commandItem.name)}')">
                            <strong>${highlightedName}</strong> (${escapeHtml(commandItem.category || '未分類')}) - ${highlightedDescription}
                            <small style='color: #777;'>${keywordsDisplay}</small>
                        </div>`;
                }).join('');
            }
            searchResultsContainer.style.display = 'block';
        }

        function handleSearch() {
            const query = searchBox.value.trim();
            if (query === '') {
                showMainQueryInterface(); // Show directory
                resultsDiv.innerHTML = '';
                detailsDiv.style.display = 'none';
                searchResultsContainer.style.display = 'none';
            } else {
                performSearch(query);
            }
        }

        function closeDetailsView() {
            detailsDiv.style.display = 'none';
            detailsDiv.innerHTML = '';
            if (searchBox.value.trim() === '') {
                 showMainQueryInterface();
                 resultsDiv.innerHTML = '';
                 searchResultsContainer.style.display = 'none';
            }
            // If there were search results, they remain visible.
        }

        function showDetails(commandName) {
            const command = vbaCommands.find(cmd => cmd.name === commandName);
            if (command) {
                let paramsHtml = '';
                if (command.parameters && command.parameters.length > 0) {
                    paramsHtml = `<p><strong>參數：</strong></p><ul>${command.parameters.map(param => `<li><strong>${escapeHtml(param.name)}</strong>: ${escapeHtml(param.description)}</li>`).join('')}</ul>`;
                }
                let examplesHtml = '';
                if (command.examples && command.examples.length > 0) {
                    examplesHtml = `<p><strong>範例：</strong></p>${command.examples.map(example => `<pre>${escapeHtml(example.code)}</pre><p class="example-explanation">${escapeHtml(example.explanation)}</p>`).join('')}`;
                }
                let keywordsHtml = '';
                if (command.keywords && command.keywords.length > 0) {
                    keywordsHtml = `<p><strong>關鍵詞：</strong> ${command.keywords.map(escapeHtml).join(', ')}</p>`;
                }
                detailsDiv.innerHTML = `
                    <span class="close-details-btn" onclick="closeDetailsView()" title="關閉說明">×</span>
                    <h2>${escapeHtml(command.name)}</h2>
                    <p><strong>分類：</strong> ${escapeHtml(command.category || '未分類')}</p>
                    <p><strong>語法：</strong></p><pre>${escapeHtml(command.syntax)}</pre>
                    <p><strong>說明：</strong> ${escapeHtml(command.description)}</p>
                    ${paramsHtml}${examplesHtml}${keywordsHtml}`;
                detailsDiv.style.display = 'block';
                searchResultsContainer.style.display = 'block'; // Ensure search results container is visible for details
                detailsDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function showMainQueryInterface() {
            contentPageDivs.forEach(page => page.style.display = 'none');
            mainQueryInterfaceDiv.style.display = 'block';
            if (searchBox.value.trim() === '' && detailsDiv.style.display === 'none') {
                directoryDiv.style.display = 'block';
                searchResultsContainer.style.display = 'none';
            } else if (searchBox.value.trim() !== '') {
                directoryDiv.style.display = 'none';
                searchResultsContainer.style.display = 'block';
            }
            window.scrollTo(0, 0);
        }

        function showContentPage(pageIdToShow) {
            mainQueryInterfaceDiv.style.display = 'none';
            contentPageDivs.forEach(page => page.style.display = 'none');
            const pageToShow = document.getElementById(pageIdToShow);
            if (pageToShow) {
                pageToShow.style.display = 'block';
                window.scrollTo(0, 0);
            }
        }

        window.onload = () => {
            displayCommandStats();
            displayDirectory();
            showMainQueryInterface(); // Initial display state

            searchBox.addEventListener('keydown', function(event) {
                if (event.key === "Escape") {
                    searchBox.value = "";
                    handleSearch(); // This will call showMainQueryInterface
                }
            });
        };
    </script>
        <footer>
            <p>Designed by Nathan Yuen. All Rights Reserved.</p>
        </footer>
</body>
</html>
